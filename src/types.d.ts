/**
 * The namespace for anything to do with PDF actions and action dispatch.
 * Actions can be defined by providing a JavaScript object that has the desired properties, and a name property defining the action subtype it represents. See documentation for specific action types for allowable properties.
 * @namespace Actions
 */
declare namespace Actions {
  class Action {
    constructor(options: any);
    /**
     * Called when the action is triggered.
     * @method Actions.Action#onTriggered
     * @param {(Annotations.Forms.Field|CoreControls.DocumentViewer)} owner The dispatcher to which this action is attached
     * @param {object} event The PDFJS event to use when executing the action
     * @param {CoreControls.DocumentViewer} documentViewer The DocumentViewer to use as context for the action execution
     */
    onTriggered(
      owner: Annotations.Forms.Field | CoreControls.DocumentViewer,
      event: any,
      documentViewer: CoreControls.DocumentViewer,
    ): void;
    /**
     * Get the action's name.
     */
    name: string;
  }
  class Dest {
    constructor(options: any);
    /**
     * Gets and sets the 1-based page number to go to.
     */
    page: number;
    /**
     * Gets the fit style (One of XYZ, FitBH, FitH, FitBV, FitV, FitR, FitB, Fit)
     */
    fit: string;
    /**
     * Gets the top of the destination rectangle
     */
    top: number | undefined;
    /**
     * Gets the left hand side of the destination rectangle
     */
    left: number | undefined;
    /**
     * Gets the bottom of the destination rectangle
     */
    bottom: number | undefined;
    /**
     * Gets the right hand side of the destination rectangle
     */
    right: number | undefined;
    /**
     * Gets the zoom at which to view the destination
     */
    zoom: number | undefined;
    /**
     * Gets the name of the destination
     */
    name: string | undefined;
  }
  /**
   * Creates a dispatcher.
   * A mixin that enables many different classes to construct and dispatch PDF Actions.
   * @name Actions.Dispatcher
   * @mixin
   */
  interface Dispatcher {}
  class GoTo extends Actions.Action {
    constructor(options: any);
    /**
     * Called when the action is triggered.
     * @method Actions.Action#onTriggered
     * @param {(Annotations.Forms.Field|CoreControls.DocumentViewer)} owner The dispatcher to which this action is attached
     * @param {object} event The PDFJS event to use when executing the action
     * @param {CoreControls.DocumentViewer} documentViewer The DocumentViewer to use as context for the action execution
     */
    onTriggered(
      owner: Annotations.Forms.Field | CoreControls.DocumentViewer,
      event: any,
      documentViewer: CoreControls.DocumentViewer,
    ): void;
    /**
     * Gets the destination object.
     */
    dest: Actions.Dest;
  }
  class GoToR extends Actions.Action {
    constructor(options: any);
    /**
     * Called when the action is triggered.
     * @method Actions.Action#onTriggered
     * @param {(Annotations.Forms.Field|CoreControls.DocumentViewer)} owner The dispatcher to which this action is attached
     * @param {object} event The PDFJS event to use when executing the action
     * @param {CoreControls.DocumentViewer} documentViewer The DocumentViewer to use as context for the action execution
     */
    onTriggered(
      owner: Annotations.Forms.Field | CoreControls.DocumentViewer,
      event: any,
      documentViewer: CoreControls.DocumentViewer,
    ): void;
    /**
     * Gets the destination object.
     */
    dest: Actions.Dest;
    /**
     * Gets the original filename of the remote document.
     */
    filename: string;
    /**
     * Gets whether the document should be opened in a new window or not.
     */
    newWindow: boolean;
  }
  /**
   * Creates a hide action.
   * @class Show or hide a list of fields.
   * @name Hide
   * @memberof Actions
   * @augments Actions.Action
   * @param {?object} options A map of properties to set on the Action
   * @property {Array<string>} fields The names of the fields on which the action should operate
   * @property {boolean} hide If true, hide the fields in fields, otherwise show them
   */
  class Hide extends Actions.Action {
    constructor(options: any);
    /**
     * Called when the action is triggered.
     * @method Actions.Action#onTriggered
     * @param {(Annotations.Forms.Field|CoreControls.DocumentViewer)} owner The dispatcher to which this action is attached
     * @param {object} event The PDFJS event to use when executing the action
     * @param {CoreControls.DocumentViewer} documentViewer The DocumentViewer to use as context for the action execution
     */
    onTriggered(
      owner: Annotations.Forms.Field | CoreControls.DocumentViewer,
      event: any,
      documentViewer: CoreControls.DocumentViewer,
    ): void;
    /**
     * The names of the fields on which the action should operate
     */
    fields: string[];
    /**
     * If true, hide the fields in fields, otherwise show them
     */
    hide: boolean;
  }
  class JavaScript extends Actions.Action {
    constructor(options: any);
    /**
     * Called when the action is triggered.
     * @method Actions.Action#onTriggered
     * @param {(Annotations.Forms.Field|CoreControls.DocumentViewer)} owner The dispatcher to which this action is attached
     * @param {object} event The PDFJS event to use when executing the action
     * @param {CoreControls.DocumentViewer} documentViewer The DocumentViewer to use as context for the action execution
     */
    onTriggered(
      owner: Annotations.Forms.Field | CoreControls.DocumentViewer,
      event: any,
      documentViewer: CoreControls.DocumentViewer,
    ): void;
    /**
     * The JavaScript string to execute when the action is triggered
     */
    javascript: string;
  }
  class Named extends Actions.Action {
    constructor(options: any);
    /**
     * Called when the action is triggered.
     * @method Actions.Action#onTriggered
     * @param {(Annotations.Forms.Field|CoreControls.DocumentViewer)} owner The dispatcher to which this action is attached
     * @param {object} event The PDFJS event to use when executing the action
     * @param {CoreControls.DocumentViewer} documentViewer The DocumentViewer to use as context for the action execution
     */
    onTriggered(
      owner: Annotations.Forms.Field | CoreControls.DocumentViewer,
      event: any,
      documentViewer: CoreControls.DocumentViewer,
    ): void;
    /**
     * The name of the action to perform.
     */
    action: string;
  }
  class ResetForm extends Actions.Action {
    constructor(options: any);
    /**
     * Called when the action is triggered.
     * @method Actions.Action#onTriggered
     * @param {(Annotations.Forms.Field|CoreControls.DocumentViewer)} owner The dispatcher to which this action is attached
     * @param {object} event The PDFJS event to use when executing the action
     * @param {CoreControls.DocumentViewer} documentViewer The DocumentViewer to use as context for the action execution
     */
    onTriggered(
      owner: Annotations.Forms.Field | CoreControls.DocumentViewer,
      event: any,
      documentViewer: CoreControls.DocumentViewer,
    ): void;
    /**
     * The names of the fields on which the action should operate
     */
    fields: string[];
    /**
     * Whether the action should reset only the fields specified in fields, or all the fields except those.
     */
    exclude: boolean;
  }
  class URI extends Actions.Action {
    constructor(options: any);
    /**
     * Called when the action is triggered.
     * @method Actions.Action#onTriggered
     * @param {(Annotations.Forms.Field|CoreControls.DocumentViewer)} owner The dispatcher to which this action is attached
     * @param {object} event The PDFJS event to use when executing the action
     * @param {CoreControls.DocumentViewer} documentViewer The DocumentViewer to use as context for the action execution
     */
    onTriggered(
      owner: Annotations.Forms.Field | CoreControls.DocumentViewer,
      event: any,
      documentViewer: CoreControls.DocumentViewer,
    ): void;
    /**
     * The URI to launch when the action is triggered
     */
    uri: string;
  }
}

/**
 * Creates a submit-form action.
 * @class Submit the form, via various possible protocols, and including/excluding different fields.
 * @name SubmitForm
 * @augments Actions.Action
 * @param {?object} options A map of properties to set on the Action
 * @property {string} url The URL to submit the form to
 * @property {Array<string>} fields A list of the names of the fields to operate on
 * @property {string} format The format in which to submit the fields (one of fdf, html, xfdf)
 * @property {boolean} includeEmpty Whether to include empty fields
 * @property {Annotations.WidgetFlags} flags A flags object exposing all flags on the action
 * @property {string} method The HTTP method to submit with (either POST or GET)
 * @property {boolean} exclude Whether to include or exclude the fields named in fields
 */
declare class SubmitForm extends Actions.Action {
  constructor(options: any);
  /**
   * Called when the action is triggered.
   * @method Actions.Action#onTriggered
   * @param {(Annotations.Forms.Field|CoreControls.DocumentViewer)} owner The dispatcher to which this action is attached
   * @param {object} event The PDFJS event to use when executing the action
   * @param {CoreControls.DocumentViewer} documentViewer The DocumentViewer to use as context for the action execution
   */
  onTriggered(
    owner: Annotations.Forms.Field | CoreControls.DocumentViewer,
    event: any,
    documentViewer: CoreControls.DocumentViewer,
  ): void;
  /**
   * The URL to submit the form to
   */
  url: string;
  /**
   * A list of the names of the fields to operate on
   */
  fields: string[];
  /**
   * The format in which to submit the fields (one of fdf, html, xfdf)
   */
  format: string;
  /**
   * Whether to include empty fields
   */
  includeEmpty: boolean;
  /**
   * A flags object exposing all flags on the action
   */
  flags: Annotations.WidgetFlags;
  /**
   * The HTTP method to submit with (either POST or GET)
   */
  method: string;
  /**
   * Whether to include or exclude the fields named in fields
   */
  exclude: boolean;
}

/**
 * The namespace for anything to do with PDF annotations.
 * @namespace Annotations
 */
declare namespace Annotations {
  namespace Forms {
    /**
     * @class Contains functions for changing the default behavior of embedded PDF JavaScript
     * @name Annotations.Forms.EmbeddedJS
     */
    class EmbeddedJS {
      /**
       * Hook into the existing embedded JS functions and update their implementations
       * @method Annotations.Forms.EmbeddedJS#update
       * @param {function} callback Function that is called with the embedded global object
       */
      update(callback: (...params: any[]) => any): void;
      /**
       * Gets the keypress value of the active field after applying the latest keystroke
       * @method Annotations.Forms.EmbeddedJS#getFinalKeypressValue
       * @param {object} globalEvent The global event object in the embedded JS context
       * @return {string} The current keypress value of the active field
       */
      getFinalKeypressValue(globalEvent: any): string;
    }
    /**
     * Represents a tree of PDF Forms fields. @see Annotations.Forms.Field
     * Allows adding, getting and visiting fields.
     * @class Annotations.Forms.FieldManager
     * @param {CoreControls.AnnotationManager} annotationManager
     */
    class FieldManager {
      constructor(annotationManager: CoreControls.AnnotationManager);
      /**
       * Set the calculation order - use this if you need changes in one field to trigger calculation events on other fields.
       * If the name of field that is changed is before the name of another field, that other field is recalculated.
       * If the name of the field that has changed is not in the array, all the fields named by the arrya are recalculated in order.
       * @method Annotations.Forms.FieldManager#setCalculationOrder
       * @param {Array<string>} order An array of field names.
       */
      setCalculationOrder(order: string[]): void;
      /**
       * Gets the calculation order. @see Annotations.Forms.FieldManager.setCalculationOrder
       * @method Annotations.Forms.FieldManager#getCalculationOrder
       * @returns {Array<string>}  An array of field names.
       */
      getCalculationOrder(): string[];
      /**
       * Gets a field whose full name matches the one that is given. If No field matches, and the last part of the field name is a number, returns that index of the field's widget array.
       * @method Annotations.Forms.FieldManager#getField
       * @param {string} name The full name of the field to search for.
       * @returns {?(Annotations.Forms.Field|Annotations.WidgetAnnotation)} The field or widget, or null if no field matches.
       */
      getField(name: string): Annotations.Forms.Field | Annotations.WidgetAnnotation;
      /**
       * Adds the given field object to the field tree, either replacing or merging with any existing field.
       * Note: if the field is merged, it is the equivalent of performing Annotations.Forms.Field.set on the existing field, followed by setting all the field's widgets' fields to the original field.
       * @method Annotations.Forms.FieldManager#addField
       * @param {(Annotations.Forms.Field|object)} field The field or field-like object to add.
       * @param {boolean} [update=false]
       * @returns {Annotations.Forms.Field} The field that was inserted into the field tree (may not be the field originally provided).
       */
      addField(field: Annotations.Forms.Field | any, update?: boolean): Annotations.Forms.Field;
      /**
       * Equivalent to the given field's value changing, if it was at position index in the calculation order.
       * @method Annotations.Forms.FieldManager#calculate
       * @param {?Annotations.Forms.Field} field The field to set as source for the calculation event. May be null.
       * @param {number} [index=0] The index at which to start running the calculation order.
       */
      calculate(field: Annotations.Forms.Field, index?: number): void;
      /**
       * Listener for field value changes.
       * @method Annotations.Forms.FieldManager#fieldChanged
       * @param {Annotations.Forms.Field} field The field whose value changed.
       */
      fieldChanged(field: Annotations.Forms.Field): void;
      /**
             * Calls the specified callback for each of the root fields in the document.
             *
             * If there is a tree of form fields, then this will only iterate over root fields. Please use {@link Annotations.Forms.Field.children} and a tree traversal algorithm to traverse the fields. If you know the name of your field, you can use {@link Annotations.Forms.FieldManager.getField}.
             * @method Annotations.Forms.FieldManager#forEachField
             * @param {function} callback The function that will be called for each field. The callback is passed the field object.
             * @example
             * var stack = [];
                     fieldManager.forEachField(function(field) {
                     stack.push(field); // Push root fields
                   });
                     while (stack.length > 0) {
                     var current = stack.pop();
                     if (current.isTerminal()) {
                       // Work with terminal/leaf fields
                     }
                     else {
                       // Traverse children
                       stack = stack.concat(current.children);
                     }
                   }
             */
      forEachField(callback: (...params: any[]) => any): void;
      /**
       * Updates the function to be used for handling alert messages for field validation.
       * @method Annotations.Forms.FieldManager#setAlertHandler
       * @param {function} handler The function that will handle alert messages. It will be called with a string representing the alert message.
       */
      setAlertHandler(handler: (...params: any[]) => any): void;
    }
    interface Field extends Actions.Dispatcher {}
    /**
     * Represents a PDF Form field.
     * @class Annotations.Forms.Field
     * @memberof Annotations.Forms
     *
     * @mixes Actions.Dispatcher
     *
     * @listens Annotations.Forms.Field#calculate
     * @listens Annotations.Forms.Field#commit
     *
     * @param {string} name The field's full name.
     * @param {Annotations.Forms.Field|object} [options] The options with which to construct the field. If options is a Field, the constructor returns the existing object.
     * @param {string} [options.type] The field's type. One of ('Tx', 'Btn', 'Ch' or 'Sig').
     * @param {Array<Annotations.Forms.Field>} [options.children] The field's children.
     * @param {Array<Annotations.WidgetAnnotation>} [options.widgets] The field's child widgets.
     * @param {Annotations.Forms.FieldManager} [options.fieldManager] The field's field manager.
     * @param {Annotations.Font} [options.font] The font that is used by the field.
     * @param {number} [options.maxLen] The field's maximum length. -1 means infinite.
     * @param {string} [options.tooltipName] The text to be displayed when hovering over the field and the userName property is not defined.
     *
     * @property {string} type Returns the field's type. One of ('Tx', 'Btn', 'Ch' or 'Sig')
     * @property {Array<Annotations.Forms.Field>} [children=[]] The field's children
     * @property {Array<Annotations.WidgetAnnotation>} [widgets=[]] The field's child widgets
     * @property {object<string, Array<Actions.Action>>} [actions={}] Gets the field's actions.
     * @property {number|string} [defaultValue=null] The field's default value
     * @property {number|string} [exportValue=null] The field's export value. Defaults to the field's value if not set.
     * @property {Annotations.WidgetFlags} [flags=new Annotations.WidgetFlags()] The field's flags object
     * @property {Annotations.Font} [font=new Annotations.Font()] Returns the field's associated font object
     * @property {boolean} [IsModified=false] Is field is modified?
     * @property {number} [maxLen=-1] The field's maximum length. -1 means infinite.
     * @property {string} name The full name of the field.
     * @property {Array<object>} [options=[]] The field's options (or permanently null if the field type does not support options).
     * @property {string} [quadding='Left-justified'] Returns the field's quadding. (One of 'Left-justified', 'Right-justified', 'Centered')
     * @property {number|string} [value=null] The field's value.
     * @property {string} userName The text to be displayed when hovering over the field.
     * @property {string} tooltipName The text to be displayed when hovering over the field and the userName property is not defined.
     */
    class Field implements Actions.Dispatcher {
      constructor(
        name: string,
        options?: {
          type?: string;
          children?: Annotations.Forms.Field[];
          widgets?: Annotations.WidgetAnnotation[];
          fieldManager?: Annotations.Forms.FieldManager;
          font?: Annotations.Font;
          maxLen?: number;
          tooltipName?: string;
        },
      );
      /**
       * Set all field properties form the given object.
       * @method Annotations.Forms.Field#set
       * @param {(Annotations.Forms.Field|object)} options The object to set properties from.
       */
      set(options: Annotations.Forms.Field | any): void;
      /**
       * Sets the field's type. Tries to retain as much type-specific information as possible across type changes.
       * @method Annotations.Forms.Field#setType
       * @param {string} type The new field type, one of Tx, Ch, Btn or Sig.
       */
      setType(type: string): void;
      /**
       * Sets the visibility of all child widgets
       * @method Annotations.Forms.Field#setVisible
       * @param {boolean} visible Should the field be visible?
       */
      setVisible(visible: boolean): void;
      /**
       * Checks whether the current field is a terminal/leaf node (no children).
       * @method Annotations.Forms.Field#isTerminal
       * @returns {boolean} Whether this field is terminal/leaf node
       */
      isTerminal(): boolean;
      /**
       * Sets the field's value, following any type-specific constraints, and updating all widgets.
       * @method Annotations.Forms.Field#setValue
       * @fires Annotations.Forms.Field#change
       * @param {?(string|number)} value The value to set.
       * @param widget
       */
      setValue(value: string | number, widget: any): void;
      /**
       * Commits the new value to the field (triggers Validate action, and updates all widgets)
       * @method Annotations.Forms.Field#commit
       * @param {*} event Ignored.
       * @param {?(string|number)} value The new value.
       * @param widget
       */
      commit(event: any, value: string | number, widget: any): void;
      /**
       * Returns the field's type. One of ('Tx', 'Btn', 'Ch' or 'Sig')
       */
      type: string;
      /**
       * The field's children
       */
      children?: Annotations.Forms.Field[];
      /**
       * The field's child widgets
       */
      widgets?: Annotations.WidgetAnnotation[];
      /**
       * Gets the field's actions.
       */
      actions?: {
        [key: string]: Actions.Action[];
      };
      /**
       * The field's default value
       */
      defaultValue?: number | string;
      /**
       * The field's export value. Defaults to the field's value if not set.
       */
      exportValue?: number | string;
      /**
       * The field's flags object
       */
      flags?: Annotations.WidgetFlags;
      /**
       * Returns the field's associated font object
       */
      font?: Annotations.Font;
      /**
       * Is field is modified?
       */
      IsModified?: boolean;
      /**
       * The field's maximum length. -1 means infinite.
       */
      maxLen?: number;
      /**
       * The full name of the field.
       */
      name: string;
      /**
       * The field's options (or permanently null if the field type does not support options).
       */
      options?: object[];
      /**
       * Returns the field's quadding. (One of 'Left-justified', 'Right-justified', 'Centered')
       */
      quadding?: string;
      /**
       * The field's value.
       */
      value?: number | string;
      /**
       * The text to be displayed when hovering over the field.
       */
      userName: string;
      /**
       * The text to be displayed when hovering over the field and the userName property is not defined.
       */
      tooltipName: string;
    }
  }
  /**
   * The base class for all annotations
   * @class Represents an annotation.
   * @name Annotation
   * @memberof Annotations
   * @property {string} Author The author of the annotation.
   * @property {object} CustomData Gets or sets custom data on the annotation.
   * @property {Date} DateModified Gets or sets the date that the annotation was last modified.
   * @property {string} elementName Gets or sets the name of the annotation element in XFDF.
   * @property {number} Height Gets or sets the height of the annotation
   * @property {boolean} Hidden Gets or sets whether the annotation is hidden.
   * @property {boolean} Invisible Gets or sets whether the annotation is invisible, only if it is an unknown annotation type. Generally for hiding annotations you should use "Hidden"
   * @property {boolean} Printable Gets or sets whether the annotation should be displayed when printing the page.
   * @property {boolean} ReadOnly Gets or sets whether the annotation is readonly or not. If it's readonly it can't be edited or deleted.
   * @property {boolean} Locked Gets or sets whether the annotation is locked or not. If it's locked it can't be edited or deleted, but the note can be edited.
   * @property {boolean} LockedContents Gets or sets whether the annotation contents are locked or not. If the contents are locked then note can't be edited but the annotation can be edited or deleted.
   * @property {string} Id A unique identifier for the annotation. Corresponds to the name attribute in XFDF.
   * @property {boolean} IsAdded Gets or sets whether the annotation has been added since the last time the AnnotCommand was retrieved.
   * @property {boolean} IsDeleted Gets or sets whether the annotation has been deleted since the last time the AnnotCommand was retrieved.
   * @property {boolean} IsModified Gets or sets whether the annotation has been modified since the last time the AnnotCommand was retrieved.
   * @property {boolean} Listable Gets or sets whether the annotation should be listed in annotation lists.
   * @property {boolean} NoMove Gets or sets whether or not the annotation can be moved
   * @property {boolean} NoResize Gets or sets if this annotation can be resized by the user.
   * @property {boolean} NoRotate Gets or sets if this annotation can be rotated.
   * @property {boolean} NoZoom Gets or sets if this annotation scales with the page.
   * @property {boolean} NoView Gets or sets whether the annotation is visible on the screen. Differs from Hidden in that it can still be printed if the print flag is set.
   * @property {boolean} ToggleNoView Gets or sets whether the ToggleNoView flag is set on the annotation.
   * @property {number} PageNumber Gets or sets the page number of a document that the annotation appears on.
   * @property {string} Subject Represents the subject of the annotation. Default is the annotation's type.
   * @property {number} Width Gets or sets the width of the annotation
   * @property {number} X Gets or sets the annotation's x-axis position.
   * @property {number} Y Gets or sets the annotation's y-axis position.
   * @property {number} Rotation Gets or sets the annotation's clockwise rotation in degrees. Valid values are 0, 90, 180 and 270. Only applies to Stamp, FreeText and Caret annotations.
   * @property {boolean} MaintainAspectRatio Gets or sets if the annotation maintains aspect ratio when being resized.
   * @property {boolean} isClickableOutsideRect Gets or sets whether any parts of the annotation drawn outside of the rect are clickable.
   * @property {string} ToolName The name of the tool that is used to create this annotation.
   */
  class Annotation {
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
    /**
     * The author of the annotation.
     */
    Author: string;
    /**
     * Gets or sets custom data on the annotation.
     */
    CustomData: any;
    /**
     * Gets or sets the date that the annotation was last modified.
     */
    DateModified: Date;
    /**
     * Gets or sets the name of the annotation element in XFDF.
     */
    elementName: string;
    /**
     * Gets or sets the height of the annotation
     */
    Height: number;
    /**
     * Gets or sets whether the annotation is hidden.
     */
    Hidden: boolean;
    /**
     * Gets or sets whether the annotation is invisible, only if it is an unknown annotation type. Generally for hiding annotations you should use "Hidden"
     */
    Invisible: boolean;
    /**
     * Gets or sets whether the annotation should be displayed when printing the page.
     */
    Printable: boolean;
    /**
     * Gets or sets whether the annotation is readonly or not. If it's readonly it can't be edited or deleted.
     */
    ReadOnly: boolean;
    /**
     * Gets or sets whether the annotation is locked or not. If it's locked it can't be edited or deleted, but the note can be edited.
     */
    Locked: boolean;
    /**
     * Gets or sets whether the annotation contents are locked or not. If the contents are locked then note can't be edited but the annotation can be edited or deleted.
     */
    LockedContents: boolean;
    /**
     * A unique identifier for the annotation. Corresponds to the name attribute in XFDF.
     */
    Id: string;
    /**
     * Gets or sets whether the annotation has been added since the last time the AnnotCommand was retrieved.
     */
    IsAdded: boolean;
    /**
     * Gets or sets whether the annotation has been deleted since the last time the AnnotCommand was retrieved.
     */
    IsDeleted: boolean;
    /**
     * Gets or sets whether the annotation has been modified since the last time the AnnotCommand was retrieved.
     */
    IsModified: boolean;
    /**
     * Gets or sets whether the annotation should be listed in annotation lists.
     */
    Listable: boolean;
    /**
     * Gets or sets whether or not the annotation can be moved
     */
    NoMove: boolean;
    /**
     * Gets or sets if this annotation can be resized by the user.
     */
    NoResize: boolean;
    /**
     * Gets or sets if this annotation can be rotated.
     */
    NoRotate: boolean;
    /**
     * Gets or sets if this annotation scales with the page.
     */
    NoZoom: boolean;
    /**
     * Gets or sets whether the annotation is visible on the screen. Differs from Hidden in that it can still be printed if the print flag is set.
     */
    NoView: boolean;
    /**
     * Gets or sets whether the ToggleNoView flag is set on the annotation.
     */
    ToggleNoView: boolean;
    /**
     * Gets or sets the page number of a document that the annotation appears on.
     */
    PageNumber: number;
    /**
     * Represents the subject of the annotation. Default is the annotation's type.
     */
    Subject: string;
    /**
     * Gets or sets the width of the annotation
     */
    Width: number;
    /**
     * Gets or sets the annotation's x-axis position.
     */
    X: number;
    /**
     * Gets or sets the annotation's y-axis position.
     */
    Y: number;
    /**
     * Gets or sets the annotation's clockwise rotation in degrees. Valid values are 0, 90, 180 and 270. Only applies to Stamp, FreeText and Caret annotations.
     */
    Rotation: number;
    /**
     * Gets or sets if the annotation maintains aspect ratio when being resized.
     */
    MaintainAspectRatio: boolean;
    /**
     * Gets or sets whether any parts of the annotation drawn outside of the rect are clickable.
     */
    isClickableOutsideRect: boolean;
    /**
     * The name of the tool that is used to create this annotation.
     */
    ToolName: string;
  }
  /**
   * Creates a new instance of Border.
   * @class Represents a class that contains border information for an annotation.
   * @name Annotations.Border
   * @param {object} options The initialization options, an object with properties color, width, style, cornerRadius
   * @property {Annotations.Color} color The color of the border
   * @property {number} width The width of the border
   * @property {string} style The style of the border (possible types include: solid, bevelled, inset)
   * @property {number} cornerRadius The corner radius size
   */
  class Border {
    constructor(options: any);
    /**
     * The color of the border
     */
    color: Annotations.Color;
    /**
     * The width of the border
     */
    width: number;
    /**
     * The style of the border (possible types include: solid, bevelled, inset)
     */
    style: string;
    /**
     * The corner radius size
     */
    cornerRadius: number;
  }
  /**
   * Creates a new instance of Color.
   * @class Represents a class that contains a color's RGB and alpha value.
   * @name Annotations.Color
   * @param {number} r the R (red) value (0-255)
   * @param {number} g the G (green) value (0-255)
   * @param {number} b the B (blue) value (0-255)
   * @param {number} a the A (alpha) value (0-1.0)
   * @property {number} R the R (red) value (0-255)
   * @property {number} G the G (green) value (0-255)
   * @property {number} B the B (blue) value (0-255)
   * @property {number} A the A (alpha) value (0-1.0)
   */
  class Color {
    constructor(r: number, g: number, b: number, a: number);
    /**
     * Outputs the current color as a CSS3 RGB color string.
     * @method Annotations.Color#toString
     * @example ex. "rgb(0,0,0)" or "rgba(0,255,0,0.5)"
     * @returns {string} The CSS3 RGB color string.
     * @override
     */
    toString(): string;
    /**
     * Returns the color as a hex string e.g. #FFFFFF
     * @method Annotations.Color#toHexString
     * @returns {string} The hex color string.
     */
    toHexString(): string;
    /**
     * the R (red) value (0-255)
     */
    R: number;
    /**
     * the G (green) value (0-255)
     */
    G: number;
    /**
     * the B (blue) value (0-255)
     */
    B: number;
    /**
     * the A (alpha) value (0-1.0)
     */
    A: number;
  }
  /**
   * Creates a new box control handle
   * @class A control handle based on the bounding box of the annotation used for resizing.
   * @name Annotations.BoxControlHandle
   * @extends Annotations.ControlHandle
   * @param {number} width the width of the handle
   * @param {number} height the height of the handle
   * @param {number} horizontalAlignment the horizontal position of the handle
   * @param {number} verticalAlignment the veritical position of the handle
   */
  class BoxControlHandle extends Annotations.ControlHandle {
    constructor(width: number, height: number, horizontalAlignment: number, verticalAlignment: number);
    /**
     * Defines the width of all control handles. Default is 8.
     * @name Annotations.ControlHandle#handleWidth
     */
    handleWidth: any;
    /**
     * Defines the height of all control handles. Default is 8.
     * @name Annotations.ControlHandle#handleHeight
     */
    handleHeight: any;
    /**
     * Defines a padding for selection accuracy. Default is 1.
     * Increase this value to make selection more forgiving.
     * @name Annotations.ControlHandle#selectionAccuracyPadding
     */
    selectionAccuracyPadding: any;
    /**
     * Determines if the provided point is a hit on the control handle.
     * See {@link Annotations.SelectionAlgorithm} for usuable selection algorithms.
     * @method Annotations.ControlHandle#testSelection
     * @param {Annotations.Annotation} annotation the annotation
     * @param {Annotations.Rect} selectionBox the selection rect
     * @param {number} zoom the current zoom level of the document
     * @param {number} x the x-coordinate of the point to test, in page coordinates
     * @param {number} y the y-coordinate of the point to test, in page coordinates
     * @returns {boolean} true if the provided point is a hit
     */
    testSelection(
      annotation: Annotations.Annotation,
      selectionBox: Annotations.Rect,
      zoom: number,
      x: number,
      y: number,
    ): boolean;
    /**
     * Draws the control handle's appearance on the provided canvas context
     * @method Annotations.ControlHandle#draw
     * @param {CanvasRenderingContext2D} ctx the annotation canvas context
     * @param {Annotations.Annotation} annotation the annotation to modify
     * @param {Annotations.Rect} selectionBox the selection rect
     * @param {number} zoom the current zoom level of the document
     */
    draw(
      ctx: CanvasRenderingContext2D,
      annotation: Annotations.Annotation,
      selectionBox: Annotations.Rect,
      zoom: number,
    ): void;
  }
  /**
   * Creates a callout control handle.
   * @class A control handle for the callout {@link Annotations.FreeTextAnnotation} annotation. The annotation must implement the getPath() method.
   * @name Annotations.CalloutControlHandle
   * @extends Annotations.ControlHandle
   * @param {number} x the x coordinate of the point
   * @param {number} y the y coordinate of the point
   * @param {number} width the width of the handle
   * @param {number} height the height of the handle
   * @param {number} pathIndex the index of the point in the path array
   */
  class CalloutControlHandle extends Annotations.ControlHandle {
    constructor(x: number, y: number, width: number, height: number, pathIndex: number);
    /**
     * Defines the width of all control handles. Default is 8.
     * @name Annotations.ControlHandle#handleWidth
     */
    handleWidth: any;
    /**
     * Defines the height of all control handles. Default is 8.
     * @name Annotations.ControlHandle#handleHeight
     */
    handleHeight: any;
    /**
     * Defines a padding for selection accuracy. Default is 1.
     * Increase this value to make selection more forgiving.
     * @name Annotations.ControlHandle#selectionAccuracyPadding
     */
    selectionAccuracyPadding: any;
    /**
     * Determines if the provided point is a hit on the control handle.
     * See {@link Annotations.SelectionAlgorithm} for usuable selection algorithms.
     * @method Annotations.ControlHandle#testSelection
     * @param {Annotations.Annotation} annotation the annotation
     * @param {Annotations.Rect} selectionBox the selection rect
     * @param {number} zoom the current zoom level of the document
     * @param {number} x the x-coordinate of the point to test, in page coordinates
     * @param {number} y the y-coordinate of the point to test, in page coordinates
     * @returns {boolean} true if the provided point is a hit
     */
    testSelection(
      annotation: Annotations.Annotation,
      selectionBox: Annotations.Rect,
      zoom: number,
      x: number,
      y: number,
    ): boolean;
    /**
     * Draws the control handle's appearance on the provided canvas context
     * @method Annotations.ControlHandle#draw
     * @param {CanvasRenderingContext2D} ctx the annotation canvas context
     * @param {Annotations.Annotation} annotation the annotation to modify
     * @param {Annotations.Rect} selectionBox the selection rect
     * @param {number} zoom the current zoom level of the document
     */
    draw(
      ctx: CanvasRenderingContext2D,
      annotation: Annotations.Annotation,
      selectionBox: Annotations.Rect,
      zoom: number,
    ): void;
  }
  /**
   * Creates a new ControlHandle with the specified dimensions.
   * @class Represents a base class for control handles for selected annotations that can be moved.
   * Control handles are typically used to resize an annotation or other operations that modify the annotation.
   * @name Annotations.ControlHandle
   * @param {number} x the x-coordinate of the upper-left point
   * @param {number} y the y-coordinate of the upper-left point
   * @param {number} width the width of the control handle
   * @param {number} height the width of the control handle
   */
  class ControlHandle {
    constructor(x: number, y: number, width: number, height: number);
    /**
     * Defines the width of all control handles. Default is 8.
     * @name Annotations.ControlHandle#handleWidth
     */
    handleWidth: any;
    /**
     * Defines the height of all control handles. Default is 8.
     * @name Annotations.ControlHandle#handleHeight
     */
    handleHeight: any;
    /**
     * Defines a padding for selection accuracy. Default is 1.
     * Increase this value to make selection more forgiving.
     * @name Annotations.ControlHandle#selectionAccuracyPadding
     */
    selectionAccuracyPadding: any;
    /**
     * Determines if the provided point is a hit on the control handle.
     * See {@link Annotations.SelectionAlgorithm} for usuable selection algorithms.
     * @method Annotations.ControlHandle#testSelection
     * @param {Annotations.Annotation} annotation the annotation
     * @param {Annotations.Rect} selectionBox the selection rect
     * @param {number} zoom the current zoom level of the document
     * @param {number} x the x-coordinate of the point to test, in page coordinates
     * @param {number} y the y-coordinate of the point to test, in page coordinates
     * @returns {boolean} true if the provided point is a hit
     */
    testSelection(
      annotation: Annotations.Annotation,
      selectionBox: Annotations.Rect,
      zoom: number,
      x: number,
      y: number,
    ): boolean;
    /**
     * Draws the control handle's appearance on the provided canvas context
     * @method Annotations.ControlHandle#draw
     * @param {CanvasRenderingContext2D} ctx the annotation canvas context
     * @param {Annotations.Annotation} annotation the annotation to modify
     * @param {Annotations.Rect} selectionBox the selection rect
     * @param {number} zoom the current zoom level of the document
     */
    draw(
      ctx: CanvasRenderingContext2D,
      annotation: Annotations.Annotation,
      selectionBox: Annotations.Rect,
      zoom: number,
    ): void;
  }
  /**
   * Creates a line control handle.
   * @class A control handle for the {@link Annotations.LineAnnotation}.
   * @name Annotations.LineControlHandle
   * @extends Annotations.ControlHandle
   * @param {number} x the x coordinate of the point
   * @param {number} y the y coordinate of the point
   * @param {number} width the width of the handle
   * @param {number} height the height of the handle
   * @param {boolean} isEnd true if the handle is for the start point, false if the handle is for the end point
   */
  class LineControlHandle extends Annotations.ControlHandle {
    constructor(x: number, y: number, width: number, height: number, isEnd: boolean);
    /**
     * Defines the width of all control handles. Default is 8.
     * @name Annotations.ControlHandle#handleWidth
     */
    handleWidth: any;
    /**
     * Defines the height of all control handles. Default is 8.
     * @name Annotations.ControlHandle#handleHeight
     */
    handleHeight: any;
    /**
     * Defines a padding for selection accuracy. Default is 1.
     * Increase this value to make selection more forgiving.
     * @name Annotations.ControlHandle#selectionAccuracyPadding
     */
    selectionAccuracyPadding: any;
    /**
     * Determines if the provided point is a hit on the control handle.
     * See {@link Annotations.SelectionAlgorithm} for usuable selection algorithms.
     * @method Annotations.ControlHandle#testSelection
     * @param {Annotations.Annotation} annotation the annotation
     * @param {Annotations.Rect} selectionBox the selection rect
     * @param {number} zoom the current zoom level of the document
     * @param {number} x the x-coordinate of the point to test, in page coordinates
     * @param {number} y the y-coordinate of the point to test, in page coordinates
     * @returns {boolean} true if the provided point is a hit
     */
    testSelection(
      annotation: Annotations.Annotation,
      selectionBox: Annotations.Rect,
      zoom: number,
      x: number,
      y: number,
    ): boolean;
    /**
     * Draws the control handle's appearance on the provided canvas context
     * @method Annotations.ControlHandle#draw
     * @param {CanvasRenderingContext2D} ctx the annotation canvas context
     * @param {Annotations.Annotation} annotation the annotation to modify
     * @param {Annotations.Rect} selectionBox the selection rect
     * @param {number} zoom the current zoom level of the document
     */
    draw(
      ctx: CanvasRenderingContext2D,
      annotation: Annotations.Annotation,
      selectionBox: Annotations.Rect,
      zoom: number,
    ): void;
  }
  /**
   * Creates a path control handle.
   * @class A control handle that manipulates path-based annotations ({@link Annotations.IPathAnnotation}) by moving the points in the path. The annotation must implement the getPath() method.
   * @name Annotations.PathControlHandle
   * @extends Annotations.ControlHandle
   * @param {number} x the x coordinate of the point
   * @param {number} y the y coordinate of the point
   * @param {number} width the width of the handle
   * @param {number} height the height of the handle
   * @param {number} pathIndex the index of the point in the path array
   */
  class PathControlHandle extends Annotations.ControlHandle {
    constructor(x: number, y: number, width: number, height: number, pathIndex: number);
    /**
     * Defines the width of all control handles. Default is 8.
     * @name Annotations.ControlHandle#handleWidth
     */
    handleWidth: any;
    /**
     * Defines the height of all control handles. Default is 8.
     * @name Annotations.ControlHandle#handleHeight
     */
    handleHeight: any;
    /**
     * Defines a padding for selection accuracy. Default is 1.
     * Increase this value to make selection more forgiving.
     * @name Annotations.ControlHandle#selectionAccuracyPadding
     */
    selectionAccuracyPadding: any;
    /**
     * Determines if the provided point is a hit on the control handle.
     * See {@link Annotations.SelectionAlgorithm} for usuable selection algorithms.
     * @method Annotations.ControlHandle#testSelection
     * @param {Annotations.Annotation} annotation the annotation
     * @param {Annotations.Rect} selectionBox the selection rect
     * @param {number} zoom the current zoom level of the document
     * @param {number} x the x-coordinate of the point to test, in page coordinates
     * @param {number} y the y-coordinate of the point to test, in page coordinates
     * @returns {boolean} true if the provided point is a hit
     */
    testSelection(
      annotation: Annotations.Annotation,
      selectionBox: Annotations.Rect,
      zoom: number,
      x: number,
      y: number,
    ): boolean;
    /**
     * Draws the control handle's appearance on the provided canvas context
     * @method Annotations.ControlHandle#draw
     * @param {CanvasRenderingContext2D} ctx the annotation canvas context
     * @param {Annotations.Annotation} annotation the annotation to modify
     * @param {Annotations.Rect} selectionBox the selection rect
     * @param {number} zoom the current zoom level of the document
     */
    draw(
      ctx: CanvasRenderingContext2D,
      annotation: Annotations.Annotation,
      selectionBox: Annotations.Rect,
      zoom: number,
    ): void;
  }
  /**
   * Creates a polygon control handle.
   * @class A control handle that manipulates path-based annotations ({@link Annotations.IPathAnnotation}) by moving the points in the path. The annotation must implement the getPath() method.
   * @name Annotations.PolygonControlHandle
   * @extends Annotations.PathControlHandle
   * @param {number} x the x coordinate of the point
   * @param {number} y the y coordinate of the point
   * @param {number} width the width of the handle
   * @param {number} height the height of the handle
   * @param {number} pathIndex the index of the point in the path array
   */
  class PolygonControlHandle extends Annotations.PathControlHandle {
    constructor(x: number, y: number, width: number, height: number, pathIndex: number);
    /**
     * Defines the width of all control handles. Default is 8.
     * @name Annotations.ControlHandle#handleWidth
     */
    handleWidth: any;
    /**
     * Defines the height of all control handles. Default is 8.
     * @name Annotations.ControlHandle#handleHeight
     */
    handleHeight: any;
    /**
     * Defines a padding for selection accuracy. Default is 1.
     * Increase this value to make selection more forgiving.
     * @name Annotations.ControlHandle#selectionAccuracyPadding
     */
    selectionAccuracyPadding: any;
    /**
     * Determines if the provided point is a hit on the control handle.
     * See {@link Annotations.SelectionAlgorithm} for usuable selection algorithms.
     * @method Annotations.ControlHandle#testSelection
     * @param {Annotations.Annotation} annotation the annotation
     * @param {Annotations.Rect} selectionBox the selection rect
     * @param {number} zoom the current zoom level of the document
     * @param {number} x the x-coordinate of the point to test, in page coordinates
     * @param {number} y the y-coordinate of the point to test, in page coordinates
     * @returns {boolean} true if the provided point is a hit
     */
    testSelection(
      annotation: Annotations.Annotation,
      selectionBox: Annotations.Rect,
      zoom: number,
      x: number,
      y: number,
    ): boolean;
    /**
     * Draws the control handle's appearance on the provided canvas context
     * @method Annotations.ControlHandle#draw
     * @param {CanvasRenderingContext2D} ctx the annotation canvas context
     * @param {Annotations.Annotation} annotation the annotation to modify
     * @param {Annotations.Rect} selectionBox the selection rect
     * @param {number} zoom the current zoom level of the document
     */
    draw(
      ctx: CanvasRenderingContext2D,
      annotation: Annotations.Annotation,
      selectionBox: Annotations.Rect,
      zoom: number,
    ): void;
  }
  /**
   * @class Contains the tools to create and manipulate form field data
   * @name Annotations.Forms
   * @property {function} getUsableInputWidth A function to set the allowable width for fields with "scroll long text" disabled.
   * It takes the width of the field and it should return a number which is the new allowable width
   */
  class Forms {
    /**
     * A function to set the allowable width for fields with "scroll long text" disabled.
     * It takes the width of the field and it should return a number which is the new allowable width
     */
    getUsableInputWidth: (...params: any[]) => any;
  }
  /**
   * A class representing a PDF font.
   * @class Annotations.Font
   *
   * @param {object} [params] An object containing parameters to be initialised on the font.
   * @property {string} name The font's name
   * @property {number} [size=0] The font's size
   * @property {string} [type='Type1'] The font's type (One of CIDType0, CIDType2, MMType1, TrueType, Type0, Type1, Type3)
   * @property {(Annotations.Color|array|object)} [strokeColor=new Annotations.Color([0,0,0])] The font's stroke color
   * @property {(Annotations.Color|array|object)} [fillColor=new Annotations.Color([0,0,0])] The font's fill color
   * @property {number} calculatedSize The calculated size of the font if size is 0
   */
  class Font {
    constructor(params?: any);
    /**
     * Set all properties on Font using a Font or a Font-like object.
     * @method Annotations.Font#set
     * @param {(Annotations.Font|object)} options The options to set on the Font
     */
    set(options: Annotations.Font | any): void;
    /**
     * Is the font solid black?
     * @method Annotations.Font#isBlack
     * @returns {boolean} Whether the font is solid black
     */
    isBlack(): boolean;
    /**
     * Convert the font to a CSS object like one would pass to jQuery.css().
     * @method Annotations.Font#toCSS
     * @param {number} zoom
     * @returns {object} An object appropriate to pass to jQuery.css()
     */
    toCSS(zoom: number): any;
    /**
     * The font's name
     */
    name: string;
    /**
     * The font's size
     */
    size?: number;
    /**
     * The font's type (One of CIDType0, CIDType2, MMType1, TrueType, Type0, Type1, Type3)
     */
    type?: string;
    /**
     * The font's stroke color
     */
    strokeColor?: Annotations.Color | any[] | any;
    /**
     * The font's fill color
     */
    fillColor?: Annotations.Color | any[] | any;
    /**
     * The calculated size of the font if size is 0
     */
    calculatedSize: number;
  }
  interface HTMLAnnotation extends Actions.Dispatcher {}
  /**
   * An common base class annotation that displays its contents using HTML5 instead of via Canvas.
   * @params {object} options A map of parameters to set on the new HTMLAnnotation.
   * @class Annotations.HTMLAnnotation
   * @augments Annotations.Annotation
   * @mixes Actions.Dispatcher
   * @property {{x1: number, y1: number, x2: number, y2: number}} rect The annotation's rectangle
   * @property {?Element} element Gets the annotation's outer display element, if it exists
   * @property {?Element} innerElement Gets the annotation's inner UI element, if it exists
   * @property {boolean} [hidden=false] Gets and sets whether the annotation is hidden
   * @property {(Annotations.Color|object|Array<any>)} [color=new Annotations.Color()] Gets and sets the annotation's color (any type that can be used to construct Annotations.Color)
   * @property {(Annotations.Border|object)} [border=new Annotations.Border()] Gets and sets the annotation's border (is a border, or a map of border properties)
   * @property {(Annotations.Color|object|Array<any>)} [backgroundColor=new Annotations.Color()] Gets and sets the annotation's background color
   * @property {{string, Array<Actions.Action>}} [actions={}] Gets the actions attached to this annotation as an object with triggers as keys and arrays of actions as values
   * @property {number} [rotation=0] Gets and sets the annotation's rotation (must be one of 0, 90, 180, 270)
   */
  class HTMLAnnotation extends Annotations.Annotation implements Actions.Dispatcher {
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
    /**
     * The annotation's rectangle
     */
    rect: any;
    /**
     * Gets the annotation's outer display element, if it exists
     */
    element: Element;
    /**
     * Gets the annotation's inner UI element, if it exists
     */
    innerElement: Element;
    /**
     * Gets and sets whether the annotation is hidden
     */
    hidden?: boolean;
    /**
     * Gets and sets the annotation's color (any type that can be used to construct Annotations.Color)
     */
    color?: Annotations.Color | any | any[];
    /**
     * Gets and sets the annotation's border (is a border, or a map of border properties)
     */
    border?: Annotations.Border | any;
    /**
     * Gets and sets the annotation's background color
     */
    backgroundColor?: Annotations.Color | any | any[];
    /**
     * Gets the actions attached to this annotation as an object with triggers as keys and arrays of actions as values
     */
    actions?: any;
    /**
     * Gets and sets the annotation's rotation (must be one of 0, 90, 180, 270)
     */
    rotation?: number;
  }
  /**
   * Represents a PDF Link annotation with associated actions.
   * @class Annotations.Link
   * @extends Annotations.HTMLAnnotation
   * @param {object} options A map of properties to set on the new Link
   */
  class Link extends Annotations.HTMLAnnotation {
    constructor(options: any);
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Creates a new Point with an x and y coordinate.
   * @class A utility class that represents a point with an x and y coordinate.
   * @memberof Annotations
   * @param {number} x the x-coordinate
   * @param {number} y the y-coordinate
   * @property {number} x the x-coordinate
   * @property {number} y the y-coordinate
   */
  class Point {
    constructor(x: number, y: number);
    /**
     * the x-coordinate
     */
    x: number;
    /**
     * the y-coordinate
     */
    y: number;
  }
  /**
   * Create a new Quad with the x and y coordinates of the the four points of a quadrilateral.
   * @class Represents a utility class used to manipulate quadrilateral objects.
   * @example
   *  (x4,y4)---(x3,y3)
   *     |        |
   *  (x1,y1)---(x2,y2)
   * @memberof Annotations
   * @param {number} x1 the x coordinate of the lower-left point
   * @param {number} y1 the y coordinate of the lower-left point
   * @param {number} x2 the x coordinate of the lower-right point
   * @param {number} y2 the y coordinate of the lower-right point
   * @param {number} x3 the x coordinate of the upper-right point
   * @param {number} y3 the y coordinate of the upper-right point
   * @param {number} x4 the x coordinate of the upper-left point
   * @param {number} y4 the y coordinate of the upper-left point
   * @property {number} x1 the x coordinate of the lower-left point
   * @property {number} y1 the y coordinate of the lower-left point
   * @property {number} x2 the x coordinate of the lower-right point
   * @property {number} y2 the y coordinate of the lower-right point
   * @property {number} x3 the x coordinate of the upper-right point
   * @property {number} y3 the y coordinate of the upper-right point
   * @property {number} x4 the x coordinate of the upper-left point
   * @property {number} y4 the y coordinate of the upper-left point
   */
  class Quad {
    constructor(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number);
    /**
     * the x coordinate of the lower-left point
     */
    x1: number;
    /**
     * the y coordinate of the lower-left point
     */
    y1: number;
    /**
     * the x coordinate of the lower-right point
     */
    x2: number;
    /**
     * the y coordinate of the lower-right point
     */
    y2: number;
    /**
     * the x coordinate of the upper-right point
     */
    x3: number;
    /**
     * the y coordinate of the upper-right point
     */
    y3: number;
    /**
     * the x coordinate of the upper-left point
     */
    x4: number;
    /**
     * the y coordinate of the upper-left point
     */
    y4: number;
  }
  /**
   * Create a new Rect with the x and y coordinates of the upper-left and lower right points.
   * @class Represents a utility class used to manipulate rectangle objects.
   * @example
   *  (x1,y1)------|
   *     |        |
   *     |------(x2,y2)
   * @memberof Annotations
   * @param {number} x1 the x coordinate of the upper-left point
   * @param {number} y1 the y coordinate of the upper-left point
   * @param {number} x2 the x coordinate of the lower-right point
   * @param {number} y2 the y coordinate of the lower-right point
   * @property {number} x1 the x coordinate of the upper-left point
   * @property {number} y1 the y coordinate of the upper-left point
   * @property {number} x2 the x coordinate of the lower-right point
   * @property {number} y2 the y coordinate of the lower-right point
   */
  class Rect {
    constructor(x1: number, y1: number, x2: number, y2: number);
    /**
     * Gets the width of the rect
     * @method Annotations.Rect#getWidth
     * @returns {number} The width of the rect
     */
    getWidth(): number;
    /**
     * Gets the height of the rect
     * @method Annotations.Rect#getHeight
     * @returns {number} The height of the rect
     */
    getHeight(): number;
    /**
     * Translates the rect
     * @method Annotations.Rect#translate
     * @param {number} x The amount to translate in the x direction
     * @param {number} y The amount to translate in the y direction
     */
    translate(x: number, y: number): void;
    /**
     * Best fit this rect into another larger rect
     * @method Annotations.Rect#fitTo
     * @param {Annotations.Rect} rect
     */
    fitTo(rect: Annotations.Rect): void;
    /**
     * Normalizes the rect to ensure point (x1, y1) is the upper left point and width and height are non-negative.
     * @method Annotations.Rect#normalize
     */
    normalize(): void;
    /**
     * Normalizes the rect to ensure point (x1, y1) is the bottom left point as expected by xfdf output
     * @method Annotations.Rect#exportNormalize
     */
    exportNormalize(): void;
    /**
     * the x coordinate of the upper-left point
     */
    x1: number;
    /**
     * the y coordinate of the upper-left point
     */
    y1: number;
    /**
     * the x coordinate of the lower-right point
     */
    x2: number;
    /**
     * the y coordinate of the lower-right point
     */
    y2: number;
  }
  /**
   * Creates a box selection model.
   * @class A selection model based on the annotation's bounding box. This is used for most generic annotations.
   * @name Annotations.BoxSelectionModel
   * @extends Annotations.SelectionModel
   * @param {Annotations.Annotation} annotation The annotation
   * @param {boolean} canModify Indicates if the annotation can be modified
   */
  class BoxSelectionModel extends Annotations.SelectionModel {
    constructor(annotation: Annotations.Annotation, canModify: boolean);
    /**
     * Defines thickness of the annotation selection outline. Default is 2.
     * @name Annotations.SelectionModel#selectionOutlineThickness
     */
    selectionOutlineThickness: any;
    /**
     * Defines a padding for selection accuracy. Default is 2.
     * Increase this value to make selection more forgiving.
     * @name Annotations.SelectionModel#selectionAccuracyPadding
     */
    selectionAccuracyPadding: any;
    /**
     * Defines the default color for the annotation selection outline.
     * @name Annotations.SelectionModel#defaultSelectionOutlineColor
     */
    defaultSelectionOutlineColor: any;
    /**
     * Defines the default color for the annotation selection outline when the user is not permitted to make modifications.
     * @name Annotations.SelectionModel#defaultNoPermissionSelectionOutlineColor
     */
    defaultNoPermissionSelectionOutlineColor: any;
    /**
     * Defines the dash size for the selection outline. Default is 4;
     * @name Annotations.SelectionModel#selectionOutlineDashSize
     */
    selectionOutlineDashSize: any;
    /**
     * Determines if the provided point is a hit on the selected annotationhandle.
     * * See {@link Annotations.SelectionAlgorithm} for usuable selection algorithms.
     * @method Annotations.SelectionModel#testSelection
     * @param {Annotations.Annotation} annotation the annotation
     * @param {number} x the x-coordinate of the point to test, in page coordinates
     * @param {number} y the y-coordinate of the point to test, in page coordinates
     * @param {object} pageMatrix the page matrix of the page the annotation is on
     * @param {number} zoom the zoom level of the page the annotation is on
     * @param {CoreControls.PageRotation} rotation the rotation of the page the annotation is on
     * @returns {boolean} true if the provided point is a hit
     */
    testSelection(
      annotation: Annotations.Annotation,
      x: number,
      y: number,
      pageMatrix: any,
      zoom: number,
      rotation: CoreControls.PageRotation,
    ): boolean;
    /**
     * Hit detection for each control handle.
     * @method Annotations.SelectionModel#testControlHandles
     * @param {Annotations.Annotation} annotation
     * @param {number} zoom
     * @param {number} x
     * @param {number} y
     * @returns {Annotations.ControlHandle} the control handle that was hit
     */
    testControlHandles(
      annotation: Annotations.Annotation,
      zoom: number,
      x: number,
      y: number,
    ): Annotations.ControlHandle;
    /**
     * Returns the ControlHandle objects associated with this selection model.
     * @method Annotations.SelectionModel#getControlHandles
     * @returns {Array<Annotations.ControlHandle>} an array of ControlHandleObject
     */
    getControlHandles(): Annotations.ControlHandle[];
    /**
     * Gets the dimensions {x, y, width, height} of the selection bounding box.
     * It may be different from the annotation's bounding box.
     * e.g. The selection bounding box may have a padding.
     * @method Annotations.SelectionModel#getDimensions
     * @param {Annotations.Annotation} annotation
     * @returns {Annotations.Rect}
     */
    getDimensions(annotation: Annotations.Annotation): Annotations.Rect;
    /**
     * Indicates that the associated annotation is able to be modified
     * @method Annotations.SelectionModel#canModify
     * @returns {boolean}
     */
    canModify(): boolean;
    /**
     * Indicates that the associated annotation is already selected.
     * This can be useful to implement different selection behaviors when an annotation is selected.
     * @method Annotations.SelectionModel#isSelected
     * @returns {boolean}
     */
    isSelected(): boolean;
    /**
     * Draws the selection outline of the annotation.
     * By default, a rectangle is drawn based on the annotations x, y, width and height.
     * @method Annotations.SelectionModel#drawSelectionOutline
     * @param {CanvasRenderingContext2D} ctx
     * @param {Annotations.Annotation} annotation
     * @param {number} zoom
     */
    drawSelectionOutline(ctx: CanvasRenderingContext2D, annotation: Annotations.Annotation, zoom: number): void;
  }
  /**
   * Creates a callout selection model.
   * @class A selection model for FreeTextAnnotation callouts.
   * @name Annotations.CalloutSelectionModel
   * @param {Annotations.Annotation} annotation the annotation
   * @param {boolean} canModify indicates if the annotation can be modified
   */
  class CalloutSelectionModel {
    constructor(annotation: Annotations.Annotation, canModify: boolean);
  }
  /**
   * Creates a free text selection model.
   * @class A selection model based on the annotation's bounding box. This is used for free text annotations.
   * @name Annotations.FreeTextSelectionModel
   * @extends Annotations.BoxSelectionModel
   * @param {Annotations.Annotation} annotation the annotation
   * @param {boolean} canModify indicates if the annotation can be modified
   * @param {boolean} isSelected
   */
  class FreeTextSelectionModel extends Annotations.BoxSelectionModel {
    constructor(annotation: Annotations.Annotation, canModify: boolean, isSelected: boolean);
    /**
     * Defines thickness of the annotation selection outline. Default is 2.
     * @name Annotations.SelectionModel#selectionOutlineThickness
     */
    selectionOutlineThickness: any;
    /**
     * Defines a padding for selection accuracy. Default is 2.
     * Increase this value to make selection more forgiving.
     * @name Annotations.SelectionModel#selectionAccuracyPadding
     */
    selectionAccuracyPadding: any;
    /**
     * Defines the default color for the annotation selection outline.
     * @name Annotations.SelectionModel#defaultSelectionOutlineColor
     */
    defaultSelectionOutlineColor: any;
    /**
     * Defines the default color for the annotation selection outline when the user is not permitted to make modifications.
     * @name Annotations.SelectionModel#defaultNoPermissionSelectionOutlineColor
     */
    defaultNoPermissionSelectionOutlineColor: any;
    /**
     * Defines the dash size for the selection outline. Default is 4;
     * @name Annotations.SelectionModel#selectionOutlineDashSize
     */
    selectionOutlineDashSize: any;
    /**
     * Determines if the provided point is a hit on the selected annotationhandle.
     * * See {@link Annotations.SelectionAlgorithm} for usuable selection algorithms.
     * @method Annotations.SelectionModel#testSelection
     * @param {Annotations.Annotation} annotation the annotation
     * @param {number} x the x-coordinate of the point to test, in page coordinates
     * @param {number} y the y-coordinate of the point to test, in page coordinates
     * @param {object} pageMatrix the page matrix of the page the annotation is on
     * @param {number} zoom the zoom level of the page the annotation is on
     * @param {CoreControls.PageRotation} rotation the rotation of the page the annotation is on
     * @returns {boolean} true if the provided point is a hit
     */
    testSelection(
      annotation: Annotations.Annotation,
      x: number,
      y: number,
      pageMatrix: any,
      zoom: number,
      rotation: CoreControls.PageRotation,
    ): boolean;
    /**
     * Hit detection for each control handle.
     * @method Annotations.SelectionModel#testControlHandles
     * @param {Annotations.Annotation} annotation
     * @param {number} zoom
     * @param {number} x
     * @param {number} y
     * @returns {Annotations.ControlHandle} the control handle that was hit
     */
    testControlHandles(
      annotation: Annotations.Annotation,
      zoom: number,
      x: number,
      y: number,
    ): Annotations.ControlHandle;
    /**
     * Returns the ControlHandle objects associated with this selection model.
     * @method Annotations.SelectionModel#getControlHandles
     * @returns {Array<Annotations.ControlHandle>} an array of ControlHandleObject
     */
    getControlHandles(): Annotations.ControlHandle[];
    /**
     * Gets the dimensions {x, y, width, height} of the selection bounding box.
     * It may be different from the annotation's bounding box.
     * e.g. The selection bounding box may have a padding.
     * @method Annotations.SelectionModel#getDimensions
     * @param {Annotations.Annotation} annotation
     * @returns {Annotations.Rect}
     */
    getDimensions(annotation: Annotations.Annotation): Annotations.Rect;
    /**
     * Indicates that the associated annotation is able to be modified
     * @method Annotations.SelectionModel#canModify
     * @returns {boolean}
     */
    canModify(): boolean;
    /**
     * Indicates that the associated annotation is already selected.
     * This can be useful to implement different selection behaviors when an annotation is selected.
     * @method Annotations.SelectionModel#isSelected
     * @returns {boolean}
     */
    isSelected(): boolean;
    /**
     * Draws the selection outline of the annotation.
     * By default, a rectangle is drawn based on the annotations x, y, width and height.
     * @method Annotations.SelectionModel#drawSelectionOutline
     * @param {CanvasRenderingContext2D} ctx
     * @param {Annotations.Annotation} annotation
     * @param {number} zoom
     */
    drawSelectionOutline(ctx: CanvasRenderingContext2D, annotation: Annotations.Annotation, zoom: number): void;
  }
  /**
   * Creates a line selection model.
   * @class A selection model for LineAnnotation.
   * @name Annotations.LineSelectionModel
   * @extends Annotations.SelectionModel
   * @param {Annotations.Annotation} annotation the annotation
   * @param {boolean} canModify indicates if the annotation can be modified
   */
  class LineSelectionModel extends Annotations.SelectionModel {
    constructor(annotation: Annotations.Annotation, canModify: boolean);
    /**
     * Defines thickness of the annotation selection outline. Default is 2.
     * @name Annotations.SelectionModel#selectionOutlineThickness
     */
    selectionOutlineThickness: any;
    /**
     * Defines a padding for selection accuracy. Default is 2.
     * Increase this value to make selection more forgiving.
     * @name Annotations.SelectionModel#selectionAccuracyPadding
     */
    selectionAccuracyPadding: any;
    /**
     * Defines the default color for the annotation selection outline.
     * @name Annotations.SelectionModel#defaultSelectionOutlineColor
     */
    defaultSelectionOutlineColor: any;
    /**
     * Defines the default color for the annotation selection outline when the user is not permitted to make modifications.
     * @name Annotations.SelectionModel#defaultNoPermissionSelectionOutlineColor
     */
    defaultNoPermissionSelectionOutlineColor: any;
    /**
     * Defines the dash size for the selection outline. Default is 4;
     * @name Annotations.SelectionModel#selectionOutlineDashSize
     */
    selectionOutlineDashSize: any;
    /**
     * Determines if the provided point is a hit on the selected annotationhandle.
     * * See {@link Annotations.SelectionAlgorithm} for usuable selection algorithms.
     * @method Annotations.SelectionModel#testSelection
     * @param {Annotations.Annotation} annotation the annotation
     * @param {number} x the x-coordinate of the point to test, in page coordinates
     * @param {number} y the y-coordinate of the point to test, in page coordinates
     * @param {object} pageMatrix the page matrix of the page the annotation is on
     * @param {number} zoom the zoom level of the page the annotation is on
     * @param {CoreControls.PageRotation} rotation the rotation of the page the annotation is on
     * @returns {boolean} true if the provided point is a hit
     */
    testSelection(
      annotation: Annotations.Annotation,
      x: number,
      y: number,
      pageMatrix: any,
      zoom: number,
      rotation: CoreControls.PageRotation,
    ): boolean;
    /**
     * Hit detection for each control handle.
     * @method Annotations.SelectionModel#testControlHandles
     * @param {Annotations.Annotation} annotation
     * @param {number} zoom
     * @param {number} x
     * @param {number} y
     * @returns {Annotations.ControlHandle} the control handle that was hit
     */
    testControlHandles(
      annotation: Annotations.Annotation,
      zoom: number,
      x: number,
      y: number,
    ): Annotations.ControlHandle;
    /**
     * Returns the ControlHandle objects associated with this selection model.
     * @method Annotations.SelectionModel#getControlHandles
     * @returns {Array<Annotations.ControlHandle>} an array of ControlHandleObject
     */
    getControlHandles(): Annotations.ControlHandle[];
    /**
     * Gets the dimensions {x, y, width, height} of the selection bounding box.
     * It may be different from the annotation's bounding box.
     * e.g. The selection bounding box may have a padding.
     * @method Annotations.SelectionModel#getDimensions
     * @param {Annotations.Annotation} annotation
     * @returns {Annotations.Rect}
     */
    getDimensions(annotation: Annotations.Annotation): Annotations.Rect;
    /**
     * Indicates that the associated annotation is able to be modified
     * @method Annotations.SelectionModel#canModify
     * @returns {boolean}
     */
    canModify(): boolean;
    /**
     * Indicates that the associated annotation is already selected.
     * This can be useful to implement different selection behaviors when an annotation is selected.
     * @method Annotations.SelectionModel#isSelected
     * @returns {boolean}
     */
    isSelected(): boolean;
    /**
     * Draws the selection outline of the annotation.
     * By default, a rectangle is drawn based on the annotations x, y, width and height.
     * @method Annotations.SelectionModel#drawSelectionOutline
     * @param {CanvasRenderingContext2D} ctx
     * @param {Annotations.Annotation} annotation
     * @param {number} zoom
     */
    drawSelectionOutline(ctx: CanvasRenderingContext2D, annotation: Annotations.Annotation, zoom: number): void;
  }
  /**
   * Creates a path selection model.
   * @class A selection model for path based annotation implementing the {@link Annotations.IPathAnnotation} interface.
   * @name Annotations.PathSelectionModel
   * @extends Annotations.SelectionModel
   * @param {Annotations.Annotation} annotation the annotation
   * @param {boolean} canModify indicates if the annotation can be modified
   */
  class PathSelectionModel extends Annotations.SelectionModel {
    constructor(annotation: Annotations.Annotation, canModify: boolean);
    /**
     * Defines thickness of the annotation selection outline. Default is 2.
     * @name Annotations.SelectionModel#selectionOutlineThickness
     */
    selectionOutlineThickness: any;
    /**
     * Defines a padding for selection accuracy. Default is 2.
     * Increase this value to make selection more forgiving.
     * @name Annotations.SelectionModel#selectionAccuracyPadding
     */
    selectionAccuracyPadding: any;
    /**
     * Defines the default color for the annotation selection outline.
     * @name Annotations.SelectionModel#defaultSelectionOutlineColor
     */
    defaultSelectionOutlineColor: any;
    /**
     * Defines the default color for the annotation selection outline when the user is not permitted to make modifications.
     * @name Annotations.SelectionModel#defaultNoPermissionSelectionOutlineColor
     */
    defaultNoPermissionSelectionOutlineColor: any;
    /**
     * Defines the dash size for the selection outline. Default is 4;
     * @name Annotations.SelectionModel#selectionOutlineDashSize
     */
    selectionOutlineDashSize: any;
    /**
     * Determines if the provided point is a hit on the selected annotationhandle.
     * * See {@link Annotations.SelectionAlgorithm} for usuable selection algorithms.
     * @method Annotations.SelectionModel#testSelection
     * @param {Annotations.Annotation} annotation the annotation
     * @param {number} x the x-coordinate of the point to test, in page coordinates
     * @param {number} y the y-coordinate of the point to test, in page coordinates
     * @param {object} pageMatrix the page matrix of the page the annotation is on
     * @param {number} zoom the zoom level of the page the annotation is on
     * @param {CoreControls.PageRotation} rotation the rotation of the page the annotation is on
     * @returns {boolean} true if the provided point is a hit
     */
    testSelection(
      annotation: Annotations.Annotation,
      x: number,
      y: number,
      pageMatrix: any,
      zoom: number,
      rotation: CoreControls.PageRotation,
    ): boolean;
    /**
     * Hit detection for each control handle.
     * @method Annotations.SelectionModel#testControlHandles
     * @param {Annotations.Annotation} annotation
     * @param {number} zoom
     * @param {number} x
     * @param {number} y
     * @returns {Annotations.ControlHandle} the control handle that was hit
     */
    testControlHandles(
      annotation: Annotations.Annotation,
      zoom: number,
      x: number,
      y: number,
    ): Annotations.ControlHandle;
    /**
     * Returns the ControlHandle objects associated with this selection model.
     * @method Annotations.SelectionModel#getControlHandles
     * @returns {Array<Annotations.ControlHandle>} an array of ControlHandleObject
     */
    getControlHandles(): Annotations.ControlHandle[];
    /**
     * Gets the dimensions {x, y, width, height} of the selection bounding box.
     * It may be different from the annotation's bounding box.
     * e.g. The selection bounding box may have a padding.
     * @method Annotations.SelectionModel#getDimensions
     * @param {Annotations.Annotation} annotation
     * @returns {Annotations.Rect}
     */
    getDimensions(annotation: Annotations.Annotation): Annotations.Rect;
    /**
     * Indicates that the associated annotation is able to be modified
     * @method Annotations.SelectionModel#canModify
     * @returns {boolean}
     */
    canModify(): boolean;
    /**
     * Indicates that the associated annotation is already selected.
     * This can be useful to implement different selection behaviors when an annotation is selected.
     * @method Annotations.SelectionModel#isSelected
     * @returns {boolean}
     */
    isSelected(): boolean;
    /**
     * Draws the selection outline of the annotation.
     * By default, a rectangle is drawn based on the annotations x, y, width and height.
     * @method Annotations.SelectionModel#drawSelectionOutline
     * @param {CanvasRenderingContext2D} ctx
     * @param {Annotations.Annotation} annotation
     * @param {number} zoom
     */
    drawSelectionOutline(ctx: CanvasRenderingContext2D, annotation: Annotations.Annotation, zoom: number): void;
  }
  /**
   * Creates a polygon selection model.
   * @class A selection model for polygon based annotation implementing the {@link Annotations.IPathAnnotation} interface.
   * @name Annotations.PolygonSelectionModel
   * @extends Annotations.PathSelectionModel
   * @param {Annotations.Annotation} annotation the annotation
   * @param {boolean} canModify indicates if the annotation can be modified
   */
  class PolygonSelectionModel extends Annotations.PathSelectionModel {
    constructor(annotation: Annotations.Annotation, canModify: boolean);
    /**
     * Defines thickness of the annotation selection outline. Default is 2.
     * @name Annotations.SelectionModel#selectionOutlineThickness
     */
    selectionOutlineThickness: any;
    /**
     * Defines a padding for selection accuracy. Default is 2.
     * Increase this value to make selection more forgiving.
     * @name Annotations.SelectionModel#selectionAccuracyPadding
     */
    selectionAccuracyPadding: any;
    /**
     * Defines the default color for the annotation selection outline.
     * @name Annotations.SelectionModel#defaultSelectionOutlineColor
     */
    defaultSelectionOutlineColor: any;
    /**
     * Defines the default color for the annotation selection outline when the user is not permitted to make modifications.
     * @name Annotations.SelectionModel#defaultNoPermissionSelectionOutlineColor
     */
    defaultNoPermissionSelectionOutlineColor: any;
    /**
     * Defines the dash size for the selection outline. Default is 4;
     * @name Annotations.SelectionModel#selectionOutlineDashSize
     */
    selectionOutlineDashSize: any;
    /**
     * Determines if the provided point is a hit on the selected annotationhandle.
     * * See {@link Annotations.SelectionAlgorithm} for usuable selection algorithms.
     * @method Annotations.SelectionModel#testSelection
     * @param {Annotations.Annotation} annotation the annotation
     * @param {number} x the x-coordinate of the point to test, in page coordinates
     * @param {number} y the y-coordinate of the point to test, in page coordinates
     * @param {object} pageMatrix the page matrix of the page the annotation is on
     * @param {number} zoom the zoom level of the page the annotation is on
     * @param {CoreControls.PageRotation} rotation the rotation of the page the annotation is on
     * @returns {boolean} true if the provided point is a hit
     */
    testSelection(
      annotation: Annotations.Annotation,
      x: number,
      y: number,
      pageMatrix: any,
      zoom: number,
      rotation: CoreControls.PageRotation,
    ): boolean;
    /**
     * Hit detection for each control handle.
     * @method Annotations.SelectionModel#testControlHandles
     * @param {Annotations.Annotation} annotation
     * @param {number} zoom
     * @param {number} x
     * @param {number} y
     * @returns {Annotations.ControlHandle} the control handle that was hit
     */
    testControlHandles(
      annotation: Annotations.Annotation,
      zoom: number,
      x: number,
      y: number,
    ): Annotations.ControlHandle;
    /**
     * Returns the ControlHandle objects associated with this selection model.
     * @method Annotations.SelectionModel#getControlHandles
     * @returns {Array<Annotations.ControlHandle>} an array of ControlHandleObject
     */
    getControlHandles(): Annotations.ControlHandle[];
    /**
     * Gets the dimensions {x, y, width, height} of the selection bounding box.
     * It may be different from the annotation's bounding box.
     * e.g. The selection bounding box may have a padding.
     * @method Annotations.SelectionModel#getDimensions
     * @param {Annotations.Annotation} annotation
     * @returns {Annotations.Rect}
     */
    getDimensions(annotation: Annotations.Annotation): Annotations.Rect;
    /**
     * Indicates that the associated annotation is able to be modified
     * @method Annotations.SelectionModel#canModify
     * @returns {boolean}
     */
    canModify(): boolean;
    /**
     * Indicates that the associated annotation is already selected.
     * This can be useful to implement different selection behaviors when an annotation is selected.
     * @method Annotations.SelectionModel#isSelected
     * @returns {boolean}
     */
    isSelected(): boolean;
    /**
     * Draws the selection outline of the annotation.
     * By default, a rectangle is drawn based on the annotations x, y, width and height.
     * @method Annotations.SelectionModel#drawSelectionOutline
     * @param {CanvasRenderingContext2D} ctx
     * @param {Annotations.Annotation} annotation
     * @param {number} zoom
     */
    drawSelectionOutline(ctx: CanvasRenderingContext2D, annotation: Annotations.Annotation, zoom: number): void;
  }
  /**
   * Creates a text selection model.
   * @class A selection model for Text annotation.
   * @name Annotations.RedactionSelectionModel
   * @param {Annotations.Annotation} annotation the annotation
   * @param {boolean} canModify indicates if the annotation can be modified
   * @param {boolean} isSelected the annotation is already selected
   */
  class RedactionSelectionModel {
    constructor(annotation: Annotations.Annotation, canModify: boolean, isSelected: boolean);
  }
  /**
   * Represents static utility functions to determine hit testing for annotations.
   * @name Annotations.SelectionAlgorithm
   * @property {number} canvasVisibilityPadding=5 Defines a padding for the canvas visibility test algorithm. Increase this value to make selection more forgiving.
   */
  var SelectionAlgorithm: {
    canvasVisibilityPadding: number;
  };
  /**
   * Create a new selection model.
   * @class Represents a class that contains information about how an annotation should behave when selected.
   * @name Annotations.SelectionModel
   * @param {Annotations.Annotation} annotation the annotation selected
   * @param {boolean} canModify modification of the annotation is allowed
   * @param {boolean} isSelected the annotation is already selected
   */
  class SelectionModel {
    constructor(annotation: Annotations.Annotation, canModify: boolean, isSelected: boolean);
    /**
     * Defines thickness of the annotation selection outline. Default is 2.
     * @name Annotations.SelectionModel#selectionOutlineThickness
     */
    selectionOutlineThickness: any;
    /**
     * Defines a padding for selection accuracy. Default is 2.
     * Increase this value to make selection more forgiving.
     * @name Annotations.SelectionModel#selectionAccuracyPadding
     */
    selectionAccuracyPadding: any;
    /**
     * Defines the default color for the annotation selection outline.
     * @name Annotations.SelectionModel#defaultSelectionOutlineColor
     */
    defaultSelectionOutlineColor: any;
    /**
     * Defines the default color for the annotation selection outline when the user is not permitted to make modifications.
     * @name Annotations.SelectionModel#defaultNoPermissionSelectionOutlineColor
     */
    defaultNoPermissionSelectionOutlineColor: any;
    /**
     * Defines the dash size for the selection outline. Default is 4;
     * @name Annotations.SelectionModel#selectionOutlineDashSize
     */
    selectionOutlineDashSize: any;
    /**
     * Determines if the provided point is a hit on the selected annotationhandle.
     * * See {@link Annotations.SelectionAlgorithm} for usuable selection algorithms.
     * @method Annotations.SelectionModel#testSelection
     * @param {Annotations.Annotation} annotation the annotation
     * @param {number} x the x-coordinate of the point to test, in page coordinates
     * @param {number} y the y-coordinate of the point to test, in page coordinates
     * @param {object} pageMatrix the page matrix of the page the annotation is on
     * @param {number} zoom the zoom level of the page the annotation is on
     * @param {CoreControls.PageRotation} rotation the rotation of the page the annotation is on
     * @returns {boolean} true if the provided point is a hit
     */
    testSelection(
      annotation: Annotations.Annotation,
      x: number,
      y: number,
      pageMatrix: any,
      zoom: number,
      rotation: CoreControls.PageRotation,
    ): boolean;
    /**
     * Hit detection for each control handle.
     * @method Annotations.SelectionModel#testControlHandles
     * @param {Annotations.Annotation} annotation
     * @param {number} zoom
     * @param {number} x
     * @param {number} y
     * @returns {Annotations.ControlHandle} the control handle that was hit
     */
    testControlHandles(
      annotation: Annotations.Annotation,
      zoom: number,
      x: number,
      y: number,
    ): Annotations.ControlHandle;
    /**
     * Returns the ControlHandle objects associated with this selection model.
     * @method Annotations.SelectionModel#getControlHandles
     * @returns {Array<Annotations.ControlHandle>} an array of ControlHandleObject
     */
    getControlHandles(): Annotations.ControlHandle[];
    /**
     * Gets the dimensions {x, y, width, height} of the selection bounding box.
     * It may be different from the annotation's bounding box.
     * e.g. The selection bounding box may have a padding.
     * @method Annotations.SelectionModel#getDimensions
     * @param {Annotations.Annotation} annotation
     * @returns {Annotations.Rect}
     */
    getDimensions(annotation: Annotations.Annotation): Annotations.Rect;
    /**
     * Indicates that the associated annotation is able to be modified
     * @method Annotations.SelectionModel#canModify
     * @returns {boolean}
     */
    canModify(): boolean;
    /**
     * Indicates that the associated annotation is already selected.
     * This can be useful to implement different selection behaviors when an annotation is selected.
     * @method Annotations.SelectionModel#isSelected
     * @returns {boolean}
     */
    isSelected(): boolean;
    /**
     * Draws the selection outline of the annotation.
     * By default, a rectangle is drawn based on the annotations x, y, width and height.
     * @method Annotations.SelectionModel#drawSelectionOutline
     * @param {CanvasRenderingContext2D} ctx
     * @param {Annotations.Annotation} annotation
     * @param {number} zoom
     */
    drawSelectionOutline(ctx: CanvasRenderingContext2D, annotation: Annotations.Annotation, zoom: number): void;
  }
  /**
   * Creates a text selection model.
   * @class A selection model for Text annotation.
   * @name Annotations.TextSelectionModel
   * @extends Annotations.SelectionModel
   * @param {Annotations.Annotation} annotation the annotation
   * @param {boolean} canModify indicates if the annotation can be modified
   */
  class TextSelectionModel extends Annotations.SelectionModel {
    constructor(annotation: Annotations.Annotation, canModify: boolean);
    /**
     * Defines thickness of the annotation selection outline. Default is 2.
     * @name Annotations.SelectionModel#selectionOutlineThickness
     */
    selectionOutlineThickness: any;
    /**
     * Defines a padding for selection accuracy. Default is 2.
     * Increase this value to make selection more forgiving.
     * @name Annotations.SelectionModel#selectionAccuracyPadding
     */
    selectionAccuracyPadding: any;
    /**
     * Defines the default color for the annotation selection outline.
     * @name Annotations.SelectionModel#defaultSelectionOutlineColor
     */
    defaultSelectionOutlineColor: any;
    /**
     * Defines the default color for the annotation selection outline when the user is not permitted to make modifications.
     * @name Annotations.SelectionModel#defaultNoPermissionSelectionOutlineColor
     */
    defaultNoPermissionSelectionOutlineColor: any;
    /**
     * Defines the dash size for the selection outline. Default is 4;
     * @name Annotations.SelectionModel#selectionOutlineDashSize
     */
    selectionOutlineDashSize: any;
    /**
     * Determines if the provided point is a hit on the selected annotationhandle.
     * * See {@link Annotations.SelectionAlgorithm} for usuable selection algorithms.
     * @method Annotations.SelectionModel#testSelection
     * @param {Annotations.Annotation} annotation the annotation
     * @param {number} x the x-coordinate of the point to test, in page coordinates
     * @param {number} y the y-coordinate of the point to test, in page coordinates
     * @param {object} pageMatrix the page matrix of the page the annotation is on
     * @param {number} zoom the zoom level of the page the annotation is on
     * @param {CoreControls.PageRotation} rotation the rotation of the page the annotation is on
     * @returns {boolean} true if the provided point is a hit
     */
    testSelection(
      annotation: Annotations.Annotation,
      x: number,
      y: number,
      pageMatrix: any,
      zoom: number,
      rotation: CoreControls.PageRotation,
    ): boolean;
    /**
     * Hit detection for each control handle.
     * @method Annotations.SelectionModel#testControlHandles
     * @param {Annotations.Annotation} annotation
     * @param {number} zoom
     * @param {number} x
     * @param {number} y
     * @returns {Annotations.ControlHandle} the control handle that was hit
     */
    testControlHandles(
      annotation: Annotations.Annotation,
      zoom: number,
      x: number,
      y: number,
    ): Annotations.ControlHandle;
    /**
     * Returns the ControlHandle objects associated with this selection model.
     * @method Annotations.SelectionModel#getControlHandles
     * @returns {Array<Annotations.ControlHandle>} an array of ControlHandleObject
     */
    getControlHandles(): Annotations.ControlHandle[];
    /**
     * Gets the dimensions {x, y, width, height} of the selection bounding box.
     * It may be different from the annotation's bounding box.
     * e.g. The selection bounding box may have a padding.
     * @method Annotations.SelectionModel#getDimensions
     * @param {Annotations.Annotation} annotation
     * @returns {Annotations.Rect}
     */
    getDimensions(annotation: Annotations.Annotation): Annotations.Rect;
    /**
     * Indicates that the associated annotation is able to be modified
     * @method Annotations.SelectionModel#canModify
     * @returns {boolean}
     */
    canModify(): boolean;
    /**
     * Indicates that the associated annotation is already selected.
     * This can be useful to implement different selection behaviors when an annotation is selected.
     * @method Annotations.SelectionModel#isSelected
     * @returns {boolean}
     */
    isSelected(): boolean;
    /**
     * Draws the selection outline of the annotation.
     * By default, a rectangle is drawn based on the annotations x, y, width and height.
     * @method Annotations.SelectionModel#drawSelectionOutline
     * @param {CanvasRenderingContext2D} ctx
     * @param {Annotations.Annotation} annotation
     * @param {number} zoom
     */
    drawSelectionOutline(ctx: CanvasRenderingContext2D, annotation: Annotations.Annotation, zoom: number): void;
  }
  /**
   * Represents a caret annotation.
   * @class
   * @name CaretAnnotation
   * @memberof Annotations
   * @extends Annotations.MarkupAnnotation
   */
  class CaretAnnotation extends Annotations.MarkupAnnotation {
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Represents a custom annotation.
   * @class
   * @name Annotations.CustomAnnotation
   * @extends Annotations.Annotation
   */
  class CustomAnnotation extends Annotations.Annotation {
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Represents an ellipse annotation.
   * @class
   * @name EllipseAnnotation
   * @memberof Annotations
   * @extends Annotations.MarkupAnnotation
   */
  class EllipseAnnotation extends Annotations.MarkupAnnotation {
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Represents a file attachment annotation.
   * @class
   * @name FileAttachmentAnnotation
   * @memberOf Annotations
   * @extends Annotations.MarkupAnnotation
   * @property {string} Icon Gets or sets the icon for this fileattachment.
   */
  class FileAttachmentAnnotation extends Annotations.MarkupAnnotation {
    /**
     * @method Annotations.FileAttachmentAnnotation#getFileMetadata
     * @returns {Annotations.FileAttachmentAnnotation.FileMetadata} Object containing important attributes of the file
     */
    getFileMetadata(): Annotations.FileAttachmentAnnotation.FileMetadata;
    /**
     * Gets the binary contents of the file attachment
     * @returns {Promise<Blob>} - A blob containing the binary contents of the file attachment
     * @method Annotations.FileAttachmentAnnotation#getFileData
     */
    getFileData(): Promise<Blob>;
    /**
     * Sets the binary contents of the fileattachment
     * @param {Blob} - A Blob containing the binary contents of the fileattachment
     * @method Annotations.FileAttachmentAnnotation#setFileData
     */
    setFileData(): void;
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
    /**
     * Gets or sets the icon for this fileattachment.
     */
    Icon: string;
  }
  namespace FileAttachmentAnnotation {
    /**
     * @typedef Annotations.FileAttachmentAnnotation.FileMetadata
     * @type {Object}
     * @property {string} mimeType - The mimetype attribute of the file
     * @property {string} fileName - The name of the file to be saved
     * @property {string} size - The size in bytes of the file
     */
    type FileMetadata = {
      mimeType: string;
      fileName: string;
      size: string;
    };
  }
  /**
   * Represents a FreeHand annotation.
   * @class
   * @memberof Annotations
   * @name FreeHandAnnotation
   * @extends Annotations.IPathAnnotation
   * @property {number} LeftMost The leftmost point of the annotation.
   * @property {number} RightMost The rightmost point of the annotation.
   * @property {number} TopMost The topmost point of the annotation.
   * @property {number} BottomMost The bottommost point of the annotation.
   * @property {boolean} shouldSimplifyPath Whether to simplify the path points or not. (defaults to false)
   */
  class FreeHandAnnotation extends Annotations.IPathAnnotation {
    /**
     * Adds a point to the specified path.
     * This method will create a new path if the specified path index is equal to the total number of existings paths, and set the x and y value as its first point.
     * @method Annotations.FreeHandAnnotation#addPathPoint
     * @param {number} x The x coordinate of the point
     * @param {number} y The y coordinate of the point
     * @param {number} [pathIndex] The index of the path, defaults to 0
     */
    addPathPoint(x: number, y: number, pathIndex?: number): void;
    /**
     * Sets a point at the specified path.
     * This method will create a new path if the specified path index is equal to the total number of existings paths, and set the x and y value as its first point.
     * @method Annotations.FreeHandAnnotation#setPathPoint
     * @param {number} index The index in the path array to set
     * @param {number} x The x coordinate of the point
     * @param {number} y The y coordinate of the point
     * @param {number} [pathIndex] The index of the path, defaults to 0
     */
    setPathPoint(index: number, x: number, y: number, pathIndex?: number): void;
    /**
     * Gets the specified point in the path at the specified index.
     * @method Annotations.FreeHandAnnotation#getPathPoint
     * @param {number} index The index of the point in the specified path
     * @param {number} [pathIndex] The index of the path, defaults to 0
     * @returns {Annotations.Point} The path point as an object with x and y properties
     */
    getPathPoint(index: number, pathIndex?: number): Annotations.Point;
    /**
     * Removes the last point from the specified path.
     * @method Annotations.FreeHandAnnotation#popPath
     * @param {number} [pathIndex] The index of the path, defaults to 0
     * @returns {Annotations.Point} The point that was removed from the path.
     */
    popPath(pathIndex?: number): Annotations.Point;
    /**
     * Gets the specified path in the path array.
     * @method Annotations.FreeHandAnnotation#getPath
     * @param {number} [pathIndex] The index of the path, defaults to 0
     * @returns {Array<Annotations.Point>} The array of path points
     */
    getPath(pathIndex?: number): Annotations.Point[];
    /**
     * Sets a path in the path array.
     * @method Annotations.FreeHandAnnotation#setPath
     * @param {Array<Annotations.Point>} path An array of Annotation.Point objects.
     * @param {number} pathIndex The index of the path, defaults to 0
     */
    setPath(path: Annotations.Point[], pathIndex: number): void;
    /**
     * empty the paths in the path array.
     * @method Annotations.FreeHandAnnotation#emptyPaths
     */
    emptyPaths(): void;
    /**
     * Gets the array of paths for this annotation.
     * @method Annotations.FreeHandAnnotation#getPaths
     * @returns {Array} an array of paths, where a path is an array of Annotation.Points
     */
    getPaths(): any[];
    /**
     * Recalculate the width and height of the annotation
     * @method Annotations.IPathAnnotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
    /**
     * The leftmost point of the annotation.
     */
    LeftMost: number;
    /**
     * The rightmost point of the annotation.
     */
    RightMost: number;
    /**
     * The topmost point of the annotation.
     */
    TopMost: number;
    /**
     * The bottommost point of the annotation.
     */
    BottomMost: number;
    /**
     * Whether to simplify the path points or not. (defaults to false)
     */
    shouldSimplifyPath: boolean;
  }
  /**
   * Represents a free text annotation.
   * @class
   * @name FreeTextAnnotation
   * @memberof Annotations
   * @extends Annotations.IPathAnnotation
   * @property {Annotations.Color} TextColor The color of the text in the annotation
   * @property {string} Font The font to use for the annotation's text
   * @property {string} FontSize The font size to use for the annotation's text, specified like a CSS font size
   * @property {string} TextAlign The horizontal alignment of the annotation's text (left, right, center)
   * @property {boolean} EXPORT_CALCULATED_FONT_SIZE Whether to export calculated font size for auto-sized fonts (default is true)
   */
  class FreeTextAnnotation extends Annotations.IPathAnnotation {
    /**
     * Gets the intent of the FreeText annotation e.g. FreeTextCallout
     * @method Annotations.FreeTextAnnotation#getIntent
     * @returns {string} The intent of the annotation
     */
    getIntent(): string;
    /**
     * Sets the intent of the FreeText annotation
     * @method Annotations.FreeTextAnnotation#setIntent
     * @param {string} intent The new intent for the annotation
     */
    setIntent(intent: string): void;
    /**
     * Sets the start style of the line. Only applicable for callout annotations.
     * @method Annotations.FreeTextAnnotation#setStartStyle
     * @param {string} startStyle The starting style
     */
    setStartStyle(startStyle: string): void;
    /**
     * Gets the start style of the line. Only applicable for callout annotations
     * @method Annotations.FreeTextAnnotation#getStartStyle
     * @returns {string} The start style
     */
    getStartStyle(): string;
    /**
     * Sets the rectangle difference of the annotation bounding rect and the text rect
     * @method Annotations.FreeTextAnnotation#setPadding
     * @param {Annotations.Rect} rect The new rectangle difference
     */
    setPadding(rect: Annotations.Rect): void;
    /**
     * Get the rectangle difference of the annotation bounding rect and the text rect
     * @method Annotations.FreeTextAnnotation#getPadding
     * @returns {Annotations.Rect} the rectangle difference
     */
    getPadding(): Annotations.Rect;
    /**
     * Adds a point to the path
     * @method Annotations.IPathAnnotation#addPathPoint
     * @param {number} x The x coordinate of the point
     * @param {number} y The y coordinate of the point
     */
    addPathPoint(x: number, y: number): void;
    /**
     * Sets the path point at a specific index
     * @method Annotations.IPathAnnotation#setPathPoint
     * @param {number} index The index in the path array to set
     * @param {number} x The x coordinate of the point
     * @param {number} y The y coordinate of the point
     */
    setPathPoint(index: number, x: number, y: number): void;
    /**
     * Gets the point in the path at the specified index
     * @method Annotations.IPathAnnotation#getPathPoint
     * @param {number} index The index in the path array
     * @returns {object} The path point as an object with x and y properties
     */
    getPathPoint(index: number): any;
    /**
     * Removes the last point from the path
     * @method Annotations.IPathAnnotation#popPath
     */
    popPath(): void;
    /**
     * Gets the path array
     * @method Annotations.IPathAnnotation#getPath
     * @returns {Array<Annotations.Point>} The array of path points
     */
    getPath(): Annotations.Point[];
    /**
     * Recalculate the width and height of the annotation
     * @method Annotations.IPathAnnotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
    /**
     * The color of the text in the annotation
     */
    TextColor: Annotations.Color;
    /**
     * The font to use for the annotation's text
     */
    Font: string;
    /**
     * The font size to use for the annotation's text, specified like a CSS font size
     */
    FontSize: string;
    /**
     * The horizontal alignment of the annotation's text (left, right, center)
     */
    TextAlign: string;
    /**
     * Whether to export calculated font size for auto-sized fonts (default is true)
     */
    EXPORT_CALCULATED_FONT_SIZE: boolean;
  }
  /**
   * An abstract annotation class for aiding the creation of path-based annotations.
   * Classes extending IPathAnnotation or implements the interface can be used by the PathTools.
   * Note: this class makes no assumptions on serialization
   * @class
   * @name IPathAnnotation
   * @memberof Annotations
   * @extends Annotations.MarkupAnnotation
   */
  class IPathAnnotation extends Annotations.MarkupAnnotation {
    /**
     * Adds a point to the path
     * @method Annotations.IPathAnnotation#addPathPoint
     * @param {number} x The x coordinate of the point
     * @param {number} y The y coordinate of the point
     */
    addPathPoint(x: number, y: number): void;
    /**
     * Sets the path point at a specific index
     * @method Annotations.IPathAnnotation#setPathPoint
     * @param {number} index The index in the path array to set
     * @param {number} x The x coordinate of the point
     * @param {number} y The y coordinate of the point
     */
    setPathPoint(index: number, x: number, y: number): void;
    /**
     * Gets the point in the path at the specified index
     * @method Annotations.IPathAnnotation#getPathPoint
     * @param {number} index The index in the path array
     * @returns {object} The path point as an object with x and y properties
     */
    getPathPoint(index: number): any;
    /**
     * Removes the last point from the path
     * @method Annotations.IPathAnnotation#popPath
     */
    popPath(): void;
    /**
     * Gets the path array
     * @method Annotations.IPathAnnotation#getPath
     * @returns {Array<Annotations.Point>} The array of path points
     */
    getPath(): Annotations.Point[];
    /**
     * Recalculate the width and height of the annotation
     * @method Annotations.IPathAnnotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Represents a line annotation.
   * @class
   * @name LineAnnotation
   * @memberof Annotations
   * @extends Annotations.MarkupAnnotation
   */
  class LineAnnotation extends Annotations.MarkupAnnotation {
    /**
     * Sets the starting point of the line
     * @method Annotations.LineAnnotation#setStartPoint
     * @param {number} x The x coordinate of the point
     * @param {number} y The y coordinate of the point
     */
    setStartPoint(x: number, y: number): void;
    /**
     * Gets the starting point of the line
     * @method Annotations.LineAnnotation#getStartPoint
     * @returns {Annotations.Point} The start point
     */
    getStartPoint(): Annotations.Point;
    /**
     * Sets the ending point of the line
     * @method Annotations.LineAnnotation#setEndPoint
     * @param {number} x The x coordinate of the point
     * @param {number} y The y coordinate of the point
     */
    setEndPoint(x: number, y: number): void;
    /**
     * Gets the ending point of the line
     * @method Annotations.LineAnnotation#getEndPoint
     * @returns {Annotations.Point} The end point
     */
    getEndPoint(): Annotations.Point;
    /**
     * Sets the start style of the line
     * @method Annotations.LineAnnotation#setStartStyle
     * @param {string} startStyle The starting style
     */
    setStartStyle(startStyle: string): void;
    /**
     * Gets the start style of the line
     * @method Annotations.LineAnnotation#getStartStyle
     * @returns {string} The start style
     */
    getStartStyle(): string;
    /**
     * Sets the ending style of the line
     * @method Annotations.LineAnnotation#setEndStyle
     * @param {string} endingStyle The ending style
     */
    setEndStyle(endingStyle: string): void;
    /**
     * Gets the end style of the line
     * @method Annotations.LineAnnotation#getEndStyle
     * @returns {string} The end style
     */
    getEndStyle(): string;
    /**
     * Returns the angle in radians from the X axis from start point to end point
     * @method Annotations.LineAnnotation#getAngle
     * @returns {number} The angle in radians
     */
    getAngle(): number;
    /**
     * Returns the length of the line in points
     * @method Annotations.LineAnnotation#getLineLength
     * @returns {number} The length in points
     */
    getLineLength(): number;
    /**
     * Sets the length of a line
     * @method Annotations.LineAnnotation#setLineLength
     * @param {number} length The length in points
     */
    setLineLength(length: number): void;
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Creates a new instance of MarkupAnnotation.
   * @class Represents an extendable Markup annotation. These annotations may optionally include a fill color, stroke color, and stroke thickness.
   * @name MarkupAnnotation
   * @memberof Annotations
   * @extends Annotations.Annotation
   * @property {Annotations.Color} FillColor Gets or sets the color of the annotation's interior.
   * @property {Annotations.Color} StrokeColor Gets or sets the color of the annotation's stroke.
   * @property {number} StrokeThickness Gets or sets the width of the annotation's stroke outline.
   * @property {number} Opacity Gets or sets the opacity of the annotation.
   * @property {Date} DateCreated Gets or sets the date the annotation was created.
   * @property {boolean} IsHoverable Gets or sets whether the annotation is hoverable or not. If it is hoverable then the IsHovering property will be true on the annotation when it is currently being hovered.
   * @property {Annotations.SelectionModel} selectionModel The selection model to use when this annotation is selected
   * @property {string} InReplyTo The Id of the annotation that this sticky annotation is replying to or is grouped with.
   * @property {string} ReplyType The type of reply.
   */
  class MarkupAnnotation extends Annotations.Annotation {
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
    /**
     * Gets or sets the color of the annotation's interior.
     */
    FillColor: Annotations.Color;
    /**
     * Gets or sets the color of the annotation's stroke.
     */
    StrokeColor: Annotations.Color;
    /**
     * Gets or sets the width of the annotation's stroke outline.
     */
    StrokeThickness: number;
    /**
     * Gets or sets the opacity of the annotation.
     */
    Opacity: number;
    /**
     * Gets or sets the date the annotation was created.
     */
    DateCreated: Date;
    /**
     * Gets or sets whether the annotation is hoverable or not. If it is hoverable then the IsHovering property will be true on the annotation when it is currently being hovered.
     */
    IsHoverable: boolean;
    /**
     * The selection model to use when this annotation is selected
     */
    selectionModel: Annotations.SelectionModel;
    /**
     * The Id of the annotation that this sticky annotation is replying to or is grouped with.
     */
    InReplyTo: string;
    /**
     * The type of reply.
     */
    ReplyType: string;
  }
  /**
   * Represents a Polyline annotation.
   * @class
   * @memberof Annotations
   * @name PolylineAnnotation
   * @extends Annotations.IPathAnnotation
   */
  class PolylineAnnotation extends Annotations.IPathAnnotation {
    /**
     * Adds a point to the path
     * @method Annotations.IPathAnnotation#addPathPoint
     * @param {number} x The x coordinate of the point
     * @param {number} y The y coordinate of the point
     */
    addPathPoint(x: number, y: number): void;
    /**
     * Sets the path point at a specific index
     * @method Annotations.IPathAnnotation#setPathPoint
     * @param {number} index The index in the path array to set
     * @param {number} x The x coordinate of the point
     * @param {number} y The y coordinate of the point
     */
    setPathPoint(index: number, x: number, y: number): void;
    /**
     * Gets the point in the path at the specified index
     * @method Annotations.IPathAnnotation#getPathPoint
     * @param {number} index The index in the path array
     * @returns {object} The path point as an object with x and y properties
     */
    getPathPoint(index: number): any;
    /**
     * Removes the last point from the path
     * @method Annotations.IPathAnnotation#popPath
     */
    popPath(): void;
    /**
     * Gets the path array
     * @method Annotations.IPathAnnotation#getPath
     * @returns {Array<Annotations.Point>} The array of path points
     */
    getPath(): Annotations.Point[];
    /**
     * Recalculate the width and height of the annotation
     * @method Annotations.IPathAnnotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Represents a Polygon annotation.
   * @class
   * @memberof Annotations
   * @name PolygonAnnotation
   * @extends Annotations.IPathAnnotation
   * @property {number} Intensity Describes intensity of cloudy style effect. 0 for no effect.
   * @property {string} Intent Describes the intent of the annotation, e.g PolygonCloud, PolygonDimension
   * @property {string} ArcDrawMode Describes how the arcs of a PolygonCloud annotation will be drawn, can be one of either RANDOM_ARCS or EQUAL_ARCS
   */
  class PolygonAnnotation extends Annotations.IPathAnnotation {
    /**
     * Gets whether the polygon annotation is rectangular and behaves the same as a rectangle annotation.
     * @method Annotations.PolygonAnnotation#isRectangularPolygon
     * @returns {boolean} true if the polygon annotation is rectangular and behaves the same a rectangle annotation.
     */
    isRectangularPolygon(): boolean;
    /**
     * Adds a point to the path
     * @method Annotations.IPathAnnotation#addPathPoint
     * @param {number} x The x coordinate of the point
     * @param {number} y The y coordinate of the point
     */
    addPathPoint(x: number, y: number): void;
    /**
     * Sets the path point at a specific index
     * @method Annotations.IPathAnnotation#setPathPoint
     * @param {number} index The index in the path array to set
     * @param {number} x The x coordinate of the point
     * @param {number} y The y coordinate of the point
     */
    setPathPoint(index: number, x: number, y: number): void;
    /**
     * Gets the point in the path at the specified index
     * @method Annotations.IPathAnnotation#getPathPoint
     * @param {number} index The index in the path array
     * @returns {object} The path point as an object with x and y properties
     */
    getPathPoint(index: number): any;
    /**
     * Removes the last point from the path
     * @method Annotations.IPathAnnotation#popPath
     */
    popPath(): void;
    /**
     * Gets the path array
     * @method Annotations.IPathAnnotation#getPath
     * @returns {Array<Annotations.Point>} The array of path points
     */
    getPath(): Annotations.Point[];
    /**
     * Recalculate the width and height of the annotation
     * @method Annotations.IPathAnnotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
    /**
     * Describes intensity of cloudy style effect. 0 for no effect.
     */
    Intensity: number;
    /**
     * Describes the intent of the annotation, e.g PolygonCloud, PolygonDimension
     */
    Intent: string;
    /**
     * Describes how the arcs of a PolygonCloud annotation will be drawn, can be one of either RANDOM_ARCS or EQUAL_ARCS
     */
    ArcDrawMode: string;
  }
  /**
   * Creates a new instance of PopupAnnotation.
   * @class Represents a popup note on an annotation
   * @name PopupAnnotation
   * @memberof Annotations
   * @extends Annotations.Annotation
   */
  class PopupAnnotation extends Annotations.Annotation {
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Represents a rectangle annotation.
   * @class
   * @name RectangleAnnotation
   * @memberof Annotations
   * @extends Annotations.MarkupAnnotation
   */
  class RectangleAnnotation extends Annotations.MarkupAnnotation {
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Represents a redaction annotation.
   * @class
   * @name Annotations.RedactionAnnotation
   * @memberof Annotations
   * @extends Annotations.TextMarkupAnnotation
   * @param {Object} [options] an initialization object that can contain the following optional parameters
   * @param {Annotations.Color} [options.StrokeColor] The color of the redaction border before it been applied. This default to red
   * @param {Annotations.Color} [options.FillColor] The color of the redaction after it been applied. This default to black
   * @param {Annotations.Color} [options.TextColor] The color of the redaction overlay text. The default is red
   * @param {number} options.PageNumber The page number of the redaction
   * @param {Annotations.Rect} [options.Rect] The bounding rectangle of the redaction
   * @param {Array<Annotations.Quad>} [options.Quads] The individual rectangles of a redaction. For text redactions there might be muliple of these
   * @param {string} [options.OverlayText] Text to show after redaction has been applied
   * @param {string} [options.TextAlign] the justification of the redaction text (can be 'left', 'center', or 'right')
   */
  class RedactionAnnotation extends Annotations.TextMarkupAnnotation {
    constructor(options?: {
      StrokeColor?: Annotations.Color;
      FillColor?: Annotations.Color;
      TextColor?: Annotations.Color;
      PageNumber: number;
      Rect?: Annotations.Rect;
      Quads?: Annotations.Quad[];
      OverlayText?: string;
      TextAlign?: string;
    });
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Represents a stamp annotation.
   * @class
   * @name StampAnnotation
   * @memberof Annotations
   * @extends Annotations.MarkupAnnotation
   * @property {string} Icon Gets or sets the type of the stamp.
   * @property {string} ImageData Gets or sets the image data for the stamp.
   */
  class StampAnnotation extends Annotations.MarkupAnnotation {
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
    /**
     * Gets or sets the type of the stamp.
     */
    Icon: string;
    /**
     * Gets or sets the image data for the stamp.
     */
    ImageData: string;
  }
  /**
   * Represents a sticky annotation.
   * @class
   * @name Annotations.StickyAnnotation
   * @extends Annotations.Annotation
   * @property {string} Icon The name of the icon to use for this sticky annotation. Currently only supports "Comment".
   * @property {number} SIZE The size of the width and height of all sticky annotations
   * @property {string} State Gets or sets the state of the annotation. Annotations may have an author-specific state associated with them. State include: Accepted, Rejected, Cancelled, Completed, None.
   * @property {string} StateModel Gets or sets the statemodel of the annotation. Statemodel has two statemodels: Marked, Review. Under Marked, state expands to: Marked, Unmarked.
   */
  class StickyAnnotation extends Annotations.Annotation {
    /**
     * Gets the state of the annotation.
     * @method Annotations.StickyAnnotation#getState
     * @return {string} the state of the annotation.
     */
    getState(): string;
    /**
     * Sets the state of the annotation.
     * @method Annotations.StickyAnnotation#setState
     * @param {string} state the state of the annotation.
     */
    setState(state: string): void;
    /**
     * Gets the statemodel of the annotation.
     * @method Annotations.StickyAnnotation#getStateModel
     * @return {string} the statemodel of the annotation.
     */
    getStateModel(): string;
    /**
     * Sets the statemodel of the annotation.
     * @method Annotations.StickyAnnotation#setStateModel
     * @param {string} stateModel the statemodel of the annotation.
     */
    setStateModel(stateModel: string): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
    /**
     * The name of the icon to use for this sticky annotation. Currently only supports "Comment".
     */
    Icon: string;
    /**
     * The size of the width and height of all sticky annotations
     */
    SIZE: number;
    /**
     * Gets or sets the state of the annotation. Annotations may have an author-specific state associated with them. State include: Accepted, Rejected, Cancelled, Completed, None.
     */
    State: string;
    /**
     * Gets or sets the statemodel of the annotation. Statemodel has two statemodels: Marked, Review. Under Marked, state expands to: Marked, Unmarked.
     */
    StateModel: string;
  }
  /**
   * Represents a text highlight annotation.
   * @class
   * @name Annotations.TextHighlightAnnotation
   * @extends Annotations.TextMarkupAnnotation
   * @property {number} opacityCap The maximum opacity of all highlight annotations.
   */
  class TextHighlightAnnotation extends Annotations.TextMarkupAnnotation {
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
    /**
     * The maximum opacity of all highlight annotations.
     */
    opacityCap: number;
  }
  /**
   * Creates a new instance of TextMarkupAnnotation.
   * @class Represents an extendable text markup annotation. This is the parent class for Highlight, Underline, and Strikeout annotations.
   * @name Annotations.TextMarkupAnnotation
   * @extends Annotations.MarkupAnnotation
   * @property {Array<Quad>} Quads Gets of sets the text quads of the annotation.
   */
  class TextMarkupAnnotation extends Annotations.MarkupAnnotation {
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
    /**
     * Gets of sets the text quads of the annotation.
     */
    Quads: Quad[];
  }
  /**
   * Represents a redaction annotation.
   * @class
   * @name Annotations.TextRedactAnnotation
   * @extends Annotations.TextMarkupAnnotation
   */
  class TextRedactAnnotation extends Annotations.TextMarkupAnnotation {
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Create a new TextSquigglyAnnotation.
   * @class Represents a text squiggly annotation.
   * @name Annotations.TextSquigglyAnnotation
   * @extends Annotations.TextMarkupAnnotation
   */
  class TextSquigglyAnnotation extends Annotations.TextMarkupAnnotation {
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Creates a new TextStrikeout annotation.
   * @class Represents a text strikeout annotation.
   * @name Annotations.TextStrikeoutAnnotation
   * @extends Annotations.TextMarkupAnnotation
   */
  class TextStrikeoutAnnotation extends Annotations.TextMarkupAnnotation {
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Represents a text underline annotation.
   * @class
   * @name Annotations.TextUnderlineAnnotation
   * @extends Annotations.TextMarkupAnnotation
   */
  class TextUnderlineAnnotation extends Annotations.TextMarkupAnnotation {
    /**
     * Sets the annotation's styles for stroke, fill and opacity on the canvas context
     * @method Annotations.MarkupAnnotation#setStyles
     * @param {CanvasRenderingContext2D} ctx A canvas context
     * @param {object} pageMatrix The transformation matrix for the page that the annotation is on
     */
    setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Creates a new instance of ButtonWidgetAnnotation.
   * @class Represents a Button Widget annotation, which includes push button, checkbox, and radio button.
   * @name ButtonWidgetAnnotation
   * @memberof Annotations
   * @extends Annotations.WidgetAnnotation
   * @param {!Annotations.Forms.Field} field The field to associate with the widget
   * @param {?object} options A map of properties to set on the widget
   */
  class ButtonWidgetAnnotation extends Annotations.WidgetAnnotation {
    constructor(field: Annotations.Forms.Field, options: any);
    /**
     * Set all properties on this widget.
     * @method Annotations.WidgetAnnotation#set
     * @param {(Annotations.WidgetAnnotation)} options The set of parameters to set
     */
    set(options: Annotations.WidgetAnnotation): void;
    /**
     * Get the widget's value.
     * @method Annotations.WidgetAnnotation#getValue
     * @return {?(string|number)} The widget's value (potentially formatted).
     */
    getValue(): string | number;
    /**
     * Set and format the widget's value.
     * @method Annotations.WidgetAnnotation#setValue
     * @param {?(string|number)} value The new value to set
     */
    setValue(value: string | number): void;
    /**
     * Gets the widget's associated field.
     * @method Annotations.WidgetAnnotation#getField
     * @return {Annotations.Forms.Field} The widget's field.
     */
    getField(): Annotations.Forms.Field;
    /**
     * Sets the widget's associated field.
     * @method Annotations.WidgetAnnotation#setField
     * @param {Annotations.Forms.Field} field The new field to associate with the widget.
     */
    setField(field: Annotations.Forms.Field): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * A Checkbutton widget annotation.
   * @class Annotations.CheckButtonWidgetAnnotation
   * @augments Annotations.ButtonWidgetAnnotation
   * @param {!Annotations.Forms.Field} field The field to associate with the widget
   * @param {?object} options A map of properties to set on the widget
   */
  class CheckButtonWidgetAnnotation extends Annotations.ButtonWidgetAnnotation {
    constructor(field: Annotations.Forms.Field, options: any);
    /**
     * Set all properties on this widget.
     * @method Annotations.WidgetAnnotation#set
     * @param {(Annotations.WidgetAnnotation)} options The set of parameters to set
     */
    set(options: Annotations.WidgetAnnotation): void;
    /**
     * Get the widget's value.
     * @method Annotations.WidgetAnnotation#getValue
     * @return {?(string|number)} The widget's value (potentially formatted).
     */
    getValue(): string | number;
    /**
     * Set and format the widget's value.
     * @method Annotations.WidgetAnnotation#setValue
     * @param {?(string|number)} value The new value to set
     */
    setValue(value: string | number): void;
    /**
     * Gets the widget's associated field.
     * @method Annotations.WidgetAnnotation#getField
     * @return {Annotations.Forms.Field} The widget's field.
     */
    getField(): Annotations.Forms.Field;
    /**
     * Sets the widget's associated field.
     * @method Annotations.WidgetAnnotation#setField
     * @param {Annotations.Forms.Field} field The new field to associate with the widget.
     */
    setField(field: Annotations.Forms.Field): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Creates a new instance of ChoiceWidgetAnnotation.
   * @class Represents a Choice Widget annotation (a combo box).
   * @name ChoiceWidgetAnnotation
   * @memberof Annotations
   * @extends Annotations.WidgetAnnotation
   * @param {!Annotations.Forms.Field} field The field to associate with the widget
   * @param {?object} options A map of properties to set on the widget
   * @property {boolean} FORCE_SELECT Whether to force all choice widgets to be html select elements
   */
  class ChoiceWidgetAnnotation extends Annotations.WidgetAnnotation {
    constructor(field: Annotations.Forms.Field, options: any);
    /**
     * Set all properties on this widget.
     * @method Annotations.WidgetAnnotation#set
     * @param {(Annotations.WidgetAnnotation)} options The set of parameters to set
     */
    set(options: Annotations.WidgetAnnotation): void;
    /**
     * Get the widget's value.
     * @method Annotations.WidgetAnnotation#getValue
     * @return {?(string|number)} The widget's value (potentially formatted).
     */
    getValue(): string | number;
    /**
     * Set and format the widget's value.
     * @method Annotations.WidgetAnnotation#setValue
     * @param {?(string|number)} value The new value to set
     */
    setValue(value: string | number): void;
    /**
     * Gets the widget's associated field.
     * @method Annotations.WidgetAnnotation#getField
     * @return {Annotations.Forms.Field} The widget's field.
     */
    getField(): Annotations.Forms.Field;
    /**
     * Sets the widget's associated field.
     * @method Annotations.WidgetAnnotation#setField
     * @param {Annotations.Forms.Field} field The new field to associate with the widget.
     */
    setField(field: Annotations.Forms.Field): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
    /**
     * Whether to force all choice widgets to be html select elements
     */
    FORCE_SELECT: boolean;
  }
  /**
   * Creates a new instance of ListWidgetAnnotation.
   * @class Represents a List Widget annotation (a list).
   * @name ListWidgetAnnotation
   * @memberof Annotations
   * @extends Annotations.WidgetAnnotation
   * @param {!Annotations.Forms.Field} field The field to associate with the widget
   * @param {?object} options A map of properties to set on the widget
   */
  class ListWidgetAnnotation extends Annotations.WidgetAnnotation {
    constructor(field: Annotations.Forms.Field, options: any);
    /**
     * Set all properties on this widget.
     * @method Annotations.WidgetAnnotation#set
     * @param {(Annotations.WidgetAnnotation)} options The set of parameters to set
     */
    set(options: Annotations.WidgetAnnotation): void;
    /**
     * Get the widget's value.
     * @method Annotations.WidgetAnnotation#getValue
     * @return {?(string|number)} The widget's value (potentially formatted).
     */
    getValue(): string | number;
    /**
     * Set and format the widget's value.
     * @method Annotations.WidgetAnnotation#setValue
     * @param {?(string|number)} value The new value to set
     */
    setValue(value: string | number): void;
    /**
     * Gets the widget's associated field.
     * @method Annotations.WidgetAnnotation#getField
     * @return {Annotations.Forms.Field} The widget's field.
     */
    getField(): Annotations.Forms.Field;
    /**
     * Sets the widget's associated field.
     * @method Annotations.WidgetAnnotation#setField
     * @param {Annotations.Forms.Field} field The new field to associate with the widget.
     */
    setField(field: Annotations.Forms.Field): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * A Radio button widget.
   * @class Annotations.RadioButtonWidgetAnnotation
   * @augments Annotations.ButtonWidgetAnnotation
   * @param {!Annotations.Forms.Field} field The field to associate with the widget
   * @param {?object} options A map of properties to set on the widget
   */
  class RadioButtonWidgetAnnotation extends Annotations.ButtonWidgetAnnotation {
    constructor(field: Annotations.Forms.Field, options: any);
    /**
     * Set all properties on this widget.
     * @method Annotations.WidgetAnnotation#set
     * @param {(Annotations.WidgetAnnotation)} options The set of parameters to set
     */
    set(options: Annotations.WidgetAnnotation): void;
    /**
     * Get the widget's value.
     * @method Annotations.WidgetAnnotation#getValue
     * @return {?(string|number)} The widget's value (potentially formatted).
     */
    getValue(): string | number;
    /**
     * Set and format the widget's value.
     * @method Annotations.WidgetAnnotation#setValue
     * @param {?(string|number)} value The new value to set
     */
    setValue(value: string | number): void;
    /**
     * Gets the widget's associated field.
     * @method Annotations.WidgetAnnotation#getField
     * @return {Annotations.Forms.Field} The widget's field.
     */
    getField(): Annotations.Forms.Field;
    /**
     * Sets the widget's associated field.
     * @method Annotations.WidgetAnnotation#setField
     * @param {Annotations.Forms.Field} field The new field to associate with the widget.
     */
    setField(field: Annotations.Forms.Field): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Creates a new instance of SignatureWidgetAnnotation.
   * @class Represents a Signature Widget annotation.
   * @name SignatureWidgetAnnotation
   * @memberof Annotations
   * @extends Annotations.WidgetAnnotation
   * @param {!Annotations.Forms.Field} field The field to associate with the widget
   * @param {?object} options A map of properties to set on the widget
   * @property {function} createSignHereElement A function that creates the sign here element in the annotation. This can be replaced with your own function.
   * @property {object} annot The annotation associated with the signature widget.
   */
  class SignatureWidgetAnnotation extends Annotations.WidgetAnnotation {
    constructor(field: Annotations.Forms.Field, options: any);
    /**
     * Returns a promise that will be resolved with a boolean value indicating whether the signature widget is signed digitally by default
     * @method Annotations.SignatureWidgetAnnotation#isSignedDigitally
     * @returns {Promise<any>}
     */
    isSignedDigitally(): Promise<any>;
    /**
     * Returns a promise that will be resolved with a boolean value indicating whether the signature widget is signed digitally by default
     * @method Annotations.SignatureWidgetAnnotation#isSignedInitially
     * @returns {Promise<any>}
     * @deprecated
     */
    isSignedInitially(): Promise<any>;
    /**
     * Set all properties on this widget.
     * @method Annotations.WidgetAnnotation#set
     * @param {(Annotations.WidgetAnnotation)} options The set of parameters to set
     */
    set(options: Annotations.WidgetAnnotation): void;
    /**
     * Get the widget's value.
     * @method Annotations.WidgetAnnotation#getValue
     * @return {?(string|number)} The widget's value (potentially formatted).
     */
    getValue(): string | number;
    /**
     * Set and format the widget's value.
     * @method Annotations.WidgetAnnotation#setValue
     * @param {?(string|number)} value The new value to set
     */
    setValue(value: string | number): void;
    /**
     * Gets the widget's associated field.
     * @method Annotations.WidgetAnnotation#getField
     * @return {Annotations.Forms.Field} The widget's field.
     */
    getField(): Annotations.Forms.Field;
    /**
     * Sets the widget's associated field.
     * @method Annotations.WidgetAnnotation#setField
     * @param {Annotations.Forms.Field} field The new field to associate with the widget.
     */
    setField(field: Annotations.Forms.Field): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
    /**
     * A function that creates the sign here element in the annotation. This can be replaced with your own function.
     */
    createSignHereElement: (...params: any[]) => any;
    /**
     * The annotation associated with the signature widget.
     */
    annot: any;
  }
  /**
   * Represents a Text Widget annotation. These include boxes and fields where text can be entered.
   * @class Annotations.TextWidgetAnnotation
   * @extends Annotations.WidgetAnnotation
   * @param {!Annotations.Forms.Field} field The field to associate with the widget
   * @param {?object} options A map of properties to set on the widget
   */
  class TextWidgetAnnotation extends Annotations.WidgetAnnotation {
    constructor(field: Annotations.Forms.Field, options: any);
    /**
     * Set all properties on this widget.
     * @method Annotations.WidgetAnnotation#set
     * @param {(Annotations.WidgetAnnotation)} options The set of parameters to set
     */
    set(options: Annotations.WidgetAnnotation): void;
    /**
     * Get the widget's value.
     * @method Annotations.WidgetAnnotation#getValue
     * @return {?(string|number)} The widget's value (potentially formatted).
     */
    getValue(): string | number;
    /**
     * Set and format the widget's value.
     * @method Annotations.WidgetAnnotation#setValue
     * @param {?(string|number)} value The new value to set
     */
    setValue(value: string | number): void;
    /**
     * Gets the widget's associated field.
     * @method Annotations.WidgetAnnotation#getField
     * @return {Annotations.Forms.Field} The widget's field.
     */
    getField(): Annotations.Forms.Field;
    /**
     * Sets the widget's associated field.
     * @method Annotations.WidgetAnnotation#setField
     * @param {Annotations.Forms.Field} field The new field to associate with the widget.
     */
    setField(field: Annotations.Forms.Field): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
  }
  /**
   * Creates a new instance of WidgetAnnotation.
   * @class Represents an extendable Widget annotation. These annotations contain a field value
   * @name WidgetAnnotation
   * @memberof Annotations
   * @augments Annotations.HTMLAnnotation
   *
   * @params {!Annotations.Forms.Field} field The field to associate with the widget
   * @params {?object} options A map of properties to set on the widget
   *
   * @property {string} fieldName Gets the name of field associated with the widget annotation.
   * @property {?(string|number)} value Gets or sets the value of the widget annotation (defaults to the field value)
   * @property {?(string|number)} defaultValue Gets or sets the default value of the field associated with the widget annotation.
   * @property {Annotations.WidgetFlags} fieldFlags Gets the flags object of the field associated with this widget.
   * @property {Annotations.WidgetFlags} flags Gets the flags object on this widget.
   * @property {Annotations.Font} font Gets or sets the font object associated with this widget (defaults to the field's font if not set).
   * @property {object} appearances Gets the appearances of this field (currently keys of an object).
   * @property {string} appearance Gets or sets the widgets current appearance name.
   * @property {object} captions Gets the map of this widget's captions. (Normal is used for the face of PushButtonAnnotations)
   * @property {function} getCustomStyles A function that receives the widget object and should return any CSS styles that you want to override
   * @property {function} getContainerCustomStyles A function that receives the widget object and should return any CSS styles that you want to override for its parent container
   */
  class WidgetAnnotation extends Annotations.HTMLAnnotation {
    /**
     * Set all properties on this widget.
     * @method Annotations.WidgetAnnotation#set
     * @param {(Annotations.WidgetAnnotation)} options The set of parameters to set
     */
    set(options: Annotations.WidgetAnnotation): void;
    /**
     * Get the widget's value.
     * @method Annotations.WidgetAnnotation#getValue
     * @return {?(string|number)} The widget's value (potentially formatted).
     */
    getValue(): string | number;
    /**
     * Set and format the widget's value.
     * @method Annotations.WidgetAnnotation#setValue
     * @param {?(string|number)} value The new value to set
     */
    setValue(value: string | number): void;
    /**
     * Gets the widget's associated field.
     * @method Annotations.WidgetAnnotation#getField
     * @return {Annotations.Forms.Field} The widget's field.
     */
    getField(): Annotations.Forms.Field;
    /**
     * Sets the widget's associated field.
     * @method Annotations.WidgetAnnotation#setField
     * @param {Annotations.Forms.Field} field The new field to associate with the widget.
     */
    setField(field: Annotations.Forms.Field): void;
    /**
     * Draws the annotation on the provide canvas context, relative to the page.
     * The point (0,0) coresponds to the top left corner of the page.
     * @method Annotations.Annotation#draw
     * @param {CanvasRenderingContext2D} ctx The canvas context prepared to be drawn on.
     * @param {object} pageMatrix The page matrix for the page that the annotation is on.
     * You can get this object by calling getPageMatrix on the document object.
     */
    draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
    /**
     * Whether the annotation is visible on the document or not.
     * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
     * @method Annotations.Annotation#isVisible
     * @return {boolean} Whether the annotation is visible on the document or not
     */
    isVisible(): boolean;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Use setRectWithNormalization instead of setRect if you want to reverse
     * any wrong-way-round coordinates instead of ignoring them.
     * @method Annotations.Annotation#setRectWithNormalization
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRectWithNormalization(rect: Annotations.Rect): void;
    /**
     * Sets the size and location of the annotation's bounding rectangle.
     * Use this method instead of resize when only the x, y, width and height needs to be modified.
     * Beware: this method ignores coordinates if they are the wrong way around.
     * (It hasn't been fixed for reasons of maintaining backward compatibility.
     * use setRectWithNormalization instead if you want it to reverse the
     * wrong-way-round coordinates instead of ignoring them.)
     * @method Annotations.Annotation#setRect
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    setRect(rect: Annotations.Rect): void;
    /**
     * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
     * e.g. stroke thickness, start/end points, etc
     * @method Annotations.Annotation#adjustRect
     */
    adjustRect(): void;
    /**
     * Resize the annotation based on a new given {@link Annotations.Rect}.
     * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move/resize.
     * @method Annotations.Annotation#resize
     * @export
     * @param {Annotations.Rect} rect the new bounding rectangle
     */
    resize(rect: Annotations.Rect): void;
    /**
     * Gets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#getX
     * @return {number} the x position
     */
    getX(): number;
    /**
     * Sets the x position measured in page coordinates of an annotation.
     * @method Annotations.Annotation#setX
     * @param {number} value the x position
     */
    setX(value: number): void;
    /**
     * Gets the y position measured in page coordinates.
     * @method Annotations.Annotation#getY
     * @return {number}
     */
    getY(): number;
    /**
     * Sets the y position measured in page coordinates.
     * @method Annotations.Annotation#setY
     * @param {number} value the y position
     */
    setY(value: number): void;
    /**
     * Gets the width of the annotation.
     * @method Annotations.Annotation#getWidth
     * @return {number} the width of the annotation.
     */
    getWidth(): number;
    /**
     * Sets the width of the annotation.
     * @method Annotations.Annotation#setWidth
     * @param {number} value the width of the annotation.
     */
    setWidth(value: number): void;
    /**
     * Gets the height of the annotation.
     * @method Annotations.Annotation#getHeight
     * @return {number} the height of the annotation.
     */
    getHeight(): number;
    /**
     * Sets the height of the annotation.
     * @method Annotations.Annotation#setHeight
     * @param {number} value the height of the annotation.
     */
    setHeight(value: number): void;
    /**
     * Get annotation bounding rectangle
     * @method Annotations.Annotation#getRect
     * @returns {Annotations.Rect}
     */
    getRect(): Annotations.Rect;
    /**
     * Gets the padding that will be applied by default on the annotation's rectangle.
     * @method Annotations.Annotation#getRectPadding
     * @returns {number} The amount of padding
     */
    getRectPadding(): number;
    /**
     * Gets the page number of the annotation.
     * Note: page number starts from 1.
     * @method Annotations.Annotation#getPageNumber
     * @returns {number} The annotation's page number
     */
    getPageNumber(): number;
    /**
     * Sets the page number of the annotation.
     * Note: page numbers start from 1.
     * @method Annotations.Annotation#setPageNumber
     * @param {number} value the page number to be set
     */
    setPageNumber(value: number): void;
    /**
     * Gets the leftmost x position measured in page coordinates.
     * @method Annotations.Annotation#getLeft
     * @deprecated Since 1.7
     * @return {number}
     */
    getLeft(): number;
    /**
     * Gets the rightmost x position measured in page coordinates.
     * @method Annotations.Annotation#getRight
     * @deprecated Since 1.7
     * @return {number}
     */
    getRight(): number;
    /**
     * Gets the topmost y position measured in page coordinates.
     * @method Annotations.Annotation#getTop
     * @deprecated Since 1.7
     * @return {number}
     */
    getTop(): number;
    /**
     * Gets the bottommost y position measured in page coordinates.
     * @method Annotations.Annotation#getBottom
     * @deprecated Since 1.7
     * @return {number}
     */
    getBottom(): number;
    /**
     * Sets the custom data associated with the specified key.
     * @method Annotations.Annotation#setCustomData
     * @param {string} key The key under which to store this custom data. Data will automatically be saved in the exported XFDF
     * and merged into the PDF when downloading.
     * @param {*} value The custom data to store
     */
    setCustomData(key: string, value: any): void;
    /**
     * Returns custom data associated with the given key.
     * @method Annotations.Annotation#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {*} value The custom data. If no data is available an empty string is returned.
     */
    getCustomData(key: string): any;
    /**
     * Deletes custom data associated with the given key.
     * @method Annotations.Annotation#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the text content for the annotation.
     * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
     * @method Annotations.Annotation#getContents
     * @return {string} the text content for the annotation.
     */
    getContents(): string;
    /**
     * Set the text content for the annotation.
     * Note that this will not refresh the text in the UI.
     * @method Annotations.Annotation#setContents
     * @param {string} value the text content to be set
     */
    setContents(value: string): void;
    /**
     * Gets the list of replies to this annotation.
     * @method Annotations.Annotation#getReplies
     * @return {Array<Annotations.Annotation>} The list of replies
     */
    getReplies(): Annotations.Annotation[];
    /**
     * Gets the list of group children to this annotation.
     * @method Annotations.Annotation#getGroupedChildren
     * @return {Array<Annotations.Annotation>} The list of group children
     */
    getGroupedChildren(): Annotations.Annotation[];
    /**
     * Gets the status of the annotation, and returns an empty string if no status set.
     * @method Annotations.Annotation#getStatus
     * @return {string} The last status update.
     */
    getStatus(): string;
    /**
     * Gets whether the annotation is a reply to another annotation.
     * @method Annotations.Annotation#isReply
     * @return {boolean} Returns true if it does reply to another annotation, false otherwise.
     */
    isReply(): boolean;
    /**
     * Gets whether the annotation is a child of a group
     * @method Annotations.Annotation#isGrouped
     * @return {boolean} Returns true if the annotation is a child of a group, false otherwise.
     */
    isGrouped(): boolean;
    /**
     * Resolves when all required resources have finished loading.
     * Currently only applicable to stamp annotations that use images.
     * @method Annotations.Annotation#resourcesLoaded
     * @return {Promise<any>} A promise that resolves when the resources have finished loading
     */
    resourcesLoaded(): Promise<any>;
    /**
     * Flags the annotation as modified if it has been before the last call to exportAnnotCommand
     * Removes the annotation's appearance if no parameter is passed
     * Should be called if changing a custom property on the annotation that is used for serialization
     * Otherwise the annotation will serialize the original deserialized value
     * @method Annotations.Annotation#setModified
     * @param {boolean} [keepAppearance] If true then the annotation's appearance will be maintained
     */
    setModified(keepAppearance?: boolean): void;
    /**
     * Associate a link with annotation. The associated links will be deleted with the annotation.
     * You can associate multiple links with a single annotation.
     * @param {Array<string>|string} linkIds The link IDs to associate with the current annotation.
     * @method Annotations.Annotation#associateLink
     */
    associateLink(linkIds: string[] | string): void;
    /**
     * Returns all associated links with the annotation.
     * @method Annotations.Annotation#getAssociatedLinks
     * @returns {Array<string>} Link IDs associated with the annotation.
     */
    getAssociatedLinks(): string[];
    /**
     * Removes all associated links with the annotation. Doesn't remove the underlying links.
     * @method Annotations.Annotation#unassociateLinks
     */
    unassociateLinks(): void;
    /**
     * Serialize the annotation to an xml element
     * @method Annotations.Annotation#serialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert XOD coordinates to PDF coordinates.
     * @returns {Element} the resulting xml element representing the annotation
     */
    serialize(element: Element, pageMatrix: any): Element;
    /**
     * Deserializes the xml element into the annotation
     * @method Annotations.Annotation#deserialize
     * @param {Element} element an xml element representing the annotation
     * @param {object} pageMatrix the page matrix used to convert PDF coordinates to XOD coordinates.
     */
    deserialize(element: Element, pageMatrix: any): void;
    /**
     * Gets the name of field associated with the widget annotation.
     */
    fieldName: string;
    /**
     * Gets or sets the value of the widget annotation (defaults to the field value)
     */
    value: string | number;
    /**
     * Gets or sets the default value of the field associated with the widget annotation.
     */
    defaultValue: string | number;
    /**
     * Gets the flags object of the field associated with this widget.
     */
    fieldFlags: Annotations.WidgetFlags;
    /**
     * Gets the flags object on this widget.
     */
    flags: Annotations.WidgetFlags;
    /**
     * Gets or sets the font object associated with this widget (defaults to the field's font if not set).
     */
    font: Annotations.Font;
    /**
     * Gets the appearances of this field (currently keys of an object).
     */
    appearances: any;
    /**
     * Gets or sets the widgets current appearance name.
     */
    appearance: string;
    /**
     * Gets the map of this widget's captions. (Normal is used for the face of PushButtonAnnotations)
     */
    captions: any;
    /**
     * A function that receives the widget object and should return any CSS styles that you want to override
     */
    getCustomStyles: (...params: any[]) => any;
    /**
     * A function that receives the widget object and should return any CSS styles that you want to override for its parent container
     */
    getContainerCustomStyles: (...params: any[]) => any;
  }
  /**
   * An object that describes flags on a Widget, or other PDF objects.
   * @class Annotations.WidgetFlags
   *
   * @param {?{mask: Array<string>}} options Define the set of supported flags.
   */
  class WidgetFlags {
    constructor(options: any);
    /**
     * Determine if the given flag is set.
     * @method Annotations.WidgetFlags#get
     * @param {string} flag The name of the flag to check
     * @returns {boolean} Whether the flag is set
     */
    get(flag: string): boolean;
    /**
     * Set flags to true or false.
     * If options is an array of strings, set the flags with those names to true.
     * If options is a number or array of numbers, set the flags from the corresponding numbers to true. (deprecated, relies on a limited interpretation of numbers as bitfields)
     * If options is a string, set that flag to shouldSet.
     * @method Annotations.WidgetFlags#set
     * @param {(Array<string>|Array<number>|string|number)} options One of the possible input types to determine which flags to set
     * @param {boolean} [shouldSet] If options is a string, whether to set or unset the flag
     */
    set(options: string[] | number[] | string | number, shouldSet?: boolean): void;
  }
  /**
   * @name Annotations.XfdfUtils
   */
  var XfdfUtils: any;
}

/**
 * The namespace containing WebViewer's core user controls, including DocumentViewer control and the Document class.
 * @namespace CoreControls
 */
declare namespace CoreControls {
  /**
   * Disables the execution of embedded JavaScript
   * @name disableEmbeddedJavaScript
   * @memberof CoreControls
   * @function
   */
  function disableEmbeddedJavaScript(): void;
  /**
   * Creates a new instance of BlackBoxAnnotationManager.
   * @class An object which manages anonymous user annotations when using BlackBox.
   * @param {string} serverRoot The blackbox annotation server to contact for annot storing.
   * @param {CoreControls.DocumentViewer} docViewer
   * @name BlackBoxAnnotationManager
   * @memberof CoreControls
   */
  class BlackBoxAnnotationManager {
    constructor(serverRoot: string, docViewer: CoreControls.DocumentViewer);
    /**
     * Preloads existing annotations made without realtime collaboration enabled,
     * will only trigger once on initial collaboration enabling event.
     * @method CoreControls.BlackBoxAnnotationManager#preloadAnnotations
     * @param {Array<Annotations.Annotation>} An array of annotation objects.
     */
    preloadAnnotations(An: Annotations.Annotation[]): void;
    /**
     * Opens a connection to the annotation server and sets up collaboration.
     * @method CoreControls.BlackBoxAnnotationManager#initiateCollaboration
     * @param {string} The document ID of the object to intiate annotation collaboration on.
     */
    initiateCollaboration(The: string): void;
    /**
     * Disables collaboration by closing the annotation server connection.
     * @method CoreControls.BlackBoxAnnotationManager#disableCollaboration
     */
    disableCollaboration(): void;
  }
  /**
   * @class The manager of the Annotation history state for undoing and redoing annotation changes
   * @memberof CoreControls
   * @name AnnotationHistoryManager
   */
  class AnnotationHistoryManager {
    /**
     * Undoes the most recent annotation change
     * @method CoreControls.AnnotationHistoryManager#undo
     */
    undo(): void;
    /**
     * Reapplies the most recent annotation change that was undone
     * @method CoreControls.AnnotationHistoryManager#redo
     */
    redo(): void;
  }
  /**
   * Creates a new instance of AnnotationManager.
   * @class Represents an object that manages the Annotations that appear on a Document's pages when displayed in a DocumentViewer.
   * @param {CoreControls.DocumentViewer} docViewer
   * @name AnnotationManager
   * @memberof CoreControls
   * @extends EventHandler
   * @property {number} controlPointSize The size of annotation control points.
   * @property {number} controlPointHitBoxScale The scale of the hit box of the annotation control points. Increase to increase the selectable area.
   */
  class AnnotationManager extends EventHandler {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Groups an array of annotations
     * @method CoreControls.AnnotationManager#groupAnnotations
     * @param {number} primaryAnnotation The primary annotation for this group.
     * @param {Array<Annotations.Annotation>} annotations The array of annotations to group.
     */
    groupAnnotations(primaryAnnotation: number, annotations: Annotations.Annotation[]): void;
    /**
     * Ungroups an array of annotations
     * @method CoreControls.AnnotationManager#ungroupAnnotations
     * @param {Array<Annotations.Annotation>} annotations The array of annotations to ungroup.
     */
    ungroupAnnotations(annotations: Annotations.Annotation[]): void;
    /**
     * Gets the number of annotations in the current selection
     * @method CoreControls.AnnotationManager#getNumberOfGroups
     * @return {number} The number of groups in the current selection. A loose annotation is a group of 1.
     */
    getNumberOfGroups(): number;
    /**
     * Gets all the annotations that are grouped with the passed in annotation, including said annotation.
     * @method CoreControls.AnnotationManager#getGroupAnnotations
     * @return {Array<Annotations.Annotation>} Gets all the annotations that are grouped with the passed in annotation, including said annotation.
     */
    getGroupAnnotations(): Annotations.Annotation[];
    /**
     * Returns the user name of the current user.
     * @method CoreControls.AnnotationManager#getCurrentUser
     * @return {string} The user name of the current user.
     */
    getCurrentUser(): string;
    /**
     * Sets the current user of the viewer.
     * @method CoreControls.AnnotationManager#setCurrentUser
     * @param {string} user the user name of the current user.
     */
    setCurrentUser(user: string): void;
    /**
     * Returns whether the current user has admin privileges.
     * @method CoreControls.AnnotationManager#getIsAdminUser
     * @return {boolean} true if the current user is an admin, false otherwise.
     */
    getIsAdminUser(): boolean;
    /**
     * Sets whether the current user is an admin user.
     * @method CoreControls.AnnotationManager#setIsAdminUser
     * @param {boolean} isAdminUser true if the current user is an admin, false otherwise.
     */
    setIsAdminUser(isAdminUser: boolean): void;
    /**
     * Returns whether the viewer is currently in read-only mode.
     * @method CoreControls.AnnotationManager#getReadOnly
     * @return {boolean} true if the current viewer is in read-only mode, false otherwise.
     */
    getReadOnly(): boolean;
    /**
     * Sets whether the viewer is currently in read-only mode.
     * @method CoreControls.AnnotationManager#setReadOnly
     * @param {boolean} readOnly true if the viewer is in read-only mode, false otherwise.
     */
    setReadOnly(readOnly: boolean): void;
    /**
     * Disables the editing of free text annotations directly on the annotation.
     * @method CoreControls.AnnotationManager#disableFreeTextEditing
     */
    disableFreeTextEditing(): void;
    /**
     * Sets the function that should be used to determine if the annotation can be modified or not.
     * @method CoreControls.AnnotationManager#setPermissionCheckCallback
     * @param {function} callback The function that should be called. Should return true or false.
     */
    setPermissionCheckCallback(callback: (...params: any[]) => any): void;
    /**
     * Whether or not the current user can modify the annotation.
     * @method CoreControls.AnnotationManager#canModify
     * @param {object} annotation The annotation to check permissions on.
     * @returns {boolean} Whether the annotation can be modified or not.
     */
    canModify(annotation: any): boolean;
    /**
     * Whether or not the current user can modify the annotation's contents.
     * @method CoreControls.AnnotationManager#canModifyContents
     * @param {object} annotation The annotation to check permissions on.
     * @returns {boolean} Whether the annotation's contents can be modified or not.
     */
    canModifyContents(annotation: any): boolean;
    /**
     * Sets the function to be called when a submit form action is triggered.
     * @method CoreControls.AnnotationManager#setSubmitFormActionCallback
     * @param {function} callback The function that should be called. Will be passed the form data.
     */
    setSubmitFormActionCallback(callback: (...params: any[]) => any): void;
    /**
     * Gets the associated field manager.
     * @method CoreControls.AnnotationManager#getFieldManager
     * @returns {Annotations.Forms.FieldManager}
     */
    getFieldManager(): Annotations.Forms.FieldManager;
    /**
     * Draws all annotations associated with the given page number.
     * Note that the entire annotation canvas for the page will be redrawn.
     * @method CoreControls.AnnotationManager#drawAnnotations
     * @param {number} pageNumber The page number for the page to draw.
     * @param {object} [overrideCanvas] Optionally draw directly to this canvas
     * @param {boolean} [majorRedraw] signify that this is a major redraw, so widget-like annotations must be re-rendered as well
     * @param [overrideContainer]
     * @return {Promise<any>} Returns a promise that resolves when all the annotations on the page have been drawn
     */
    drawAnnotations(
      pageNumber: number,
      overrideCanvas?: any,
      majorRedraw?: boolean,
      overrideContainer?: any,
    ): Promise<any>;
    /**
     * Draw an annotation onto a page
     * @method CoreControls.AnnotationManager#drawAnnotation
     * @param {Annotations.Annotation} annotation The annotation to draw.
     * @param {CanvasRenderingContext2D} annotCanvasContext Annotation canvas context to draw on
     * @param {object} [pageMatrix] The page matrix for the page that the annotation is on. When this is null, it'll default to the normal page canvas pageMatrix
     * @param {object} [options] an options object
     * @param {HTMLElement} [options.overridePageCanvas] The page canvas that the annotation is being draw on top of
     * @param {CoreControls.PageRotation} [options.overridePageRotation] The rotation of the overridePageCanvas being being used. Valid values are CoreControls.PageRotation.e_0, CoreControls.PageRotation.e_90, CoreControls.PageRotation.e_180, CoreControls.PageRotation.e_270.
     */
    drawAnnotation(
      annotation: Annotations.Annotation,
      annotCanvasContext: CanvasRenderingContext2D,
      pageMatrix?: any,
      options?: {
        overridePageCanvas?: HTMLElement;
        overridePageRotation?: CoreControls.PageRotation;
      },
    ): void;
    /**
     * Set the page transform of an annotation canvas
     * @method CoreControls.AnnotationManager#setAnnotationCanvasTransform
     * @param {CanvasRenderingContext2D} annotCanvasContext Annotation canvas context to draw on
     * @param {number} zoom The zoom or the scaling of the page canvas
     * @param {CoreControls.PageRotation} rotation The rotation of the page canvas
     */
    setAnnotationCanvasTransform(
      annotCanvasContext: CanvasRenderingContext2D,
      zoom: number,
      rotation: CoreControls.PageRotation,
    ): void;
    /**
     * Redraws the specified annotation.
     * Note that the entire annotation canvas for the page will be redrawn.
     * @method CoreControls.AnnotationManager#redrawAnnotation
     * @param {Annotations.Annotation} annotation The annotation to be redrawn.
     */
    redrawAnnotation(annotation: Annotations.Annotation): void;
    /**
     * Sets the rate at which the redrawing of annotations is throttled. This can improve
     * annotation rendering on lower quality devices and browsers.
     * @method CoreControls.AnnotationManager#setRedrawThrottle
     * @param {number} value The throttled rate at which annotations will be redrawn, in milliseconds
     */
    setRedrawThrottle(value: number): void;
    /**
     * Jumps to the page of the annotation and if it isn't visible then centers it in the window.
     * @method CoreControls.AnnotationManager#jumpToAnnotation
     * @param {Annotations.Annotation} annotation The annotation to be jumped to.
     */
    jumpToAnnotation(annotation: Annotations.Annotation): void;
    /**
     * Hides the specified annotation.
     * @method CoreControls.AnnotationManager#hideAnnotation
     * @param {Annotations.Annotation} annot The annotation to hide
     */
    hideAnnotation(annot: Annotations.Annotation): void;
    /**
     * Hides all of the annotations in the list
     * @method CoreControls.AnnotationManager#hideAnnotations
     * @param {Array<Annotations.Annotation>} annots Array of annotations to hide
     */
    hideAnnotations(annots: Annotations.Annotation[]): void;
    /**
     * Shows the annotation
     * @method CoreControls.AnnotationManager#showAnnotation
     * @param {Annotations.Annotation} annot The annotation to show
     */
    showAnnotation(annot: Annotations.Annotation): void;
    /**
     * Shows all of the annotations in the list
     * @method CoreControls.AnnotationManager#showAnnotations
     * @param {Array<Annotations.Annotation>} annots Array of annotations to show
     */
    showAnnotations(annots: Annotations.Annotation[]): void;
    /**
     * Determines if the specified annotation exists in the managed list of annotations.
     * @method CoreControls.AnnotationManager#hasAnnotation
     * @param {Annotations.Annotation} annotation An instance of Annotation.
     */
    hasAnnotation(annotation: Annotations.Annotation): void;
    /**
     * Sets the value of the note for the specified annotation.
     * @method CoreControls.AnnotationManager#setNoteContents
     * @param {Annotations.Annotation} annotation The annotation that will have its note updated.
     * @param {string} text The value to update the note text to.
     */
    setNoteContents(annotation: Annotations.Annotation, text: string): void;
    /**
     * Adds the specified annotation to the managed list of annotations.
     * @method CoreControls.AnnotationManager#addAnnotation
     * @param {Annotations.Annotation} annotation An instance of Annotation.
     * @param {boolean} imported Whether the annotation was imported from another source or not.
     */
    addAnnotation(annotation: Annotations.Annotation, imported: boolean): void;
    /**
     * Adds the specified annotations to the managed list of annotations
     * @method CoreControls.AnnotationManager#addAnnotations
     * @param {Array<Annotations.Annotation>} annotations An array of annotations.
     * @param {boolean} [imported] Whether the annotations were imported from another source or not
     * @param {boolean} [isUndoRedo] Whether the annotation change was caused by undo/redo or not
     */
    addAnnotations(annotations: Annotations.Annotation[], imported?: boolean, isUndoRedo?: boolean): void;
    /**
     * Gets the root annotation that this annotation is replying to.
     * If this annotation is not replying to anything then the root is itself.
     * @method CoreControls.AnnotationManager#getRootAnnotation
     * @param {Annotations.Annotation} annotation The annotation from which to find the root annotation in the reply chain
     * @return {Annotations.Annotation} The root annotation
     */
    getRootAnnotation(annotation: Annotations.Annotation): Annotations.Annotation;
    /**
     * Creates an annotation that replies to the passed in annotation. Annotation replies are sticky note annotations.
     * @method CoreControls.AnnotationManager#createAnnotationReply
     * @param {Annotations.Annotation} annotation The annotation to add a reply to
     * @param {string} initialText The initialText for the annotation, defaults to the empty string
     * @return {Annotations.StickyAnnotation} The created annotation reply
     */
    createAnnotationReply(annotation: Annotations.Annotation, initialText: string): Annotations.StickyAnnotation;
    /**
     * Updates the annotation state. This is done by creating an annotation that replies to the passed in annotation.
     * @method CoreControls.AnnotationManager#updateAnnotationState
     * @param {Annotations.Annotation} annotation The annotation to add a reply to
     * @param {string} state Annotations may have an author-specific state associated with them.
     * Valid states are for Review stateModel: Accepted, Rejected, Cancelled, Completed, None. Default is None.
     * Valid states are for Marked stateModel: Marked and Unmarked. Default is Unmarked.
     * @param {string} stateModel Gets or sets the stateModel of the annotation. stateModel has two statemodels: Marked, Review. Default is Review.
     * @param {string} message Message to be set when the state is updated.
     * @return {Annotations.StickyAnnotation} The created annotation reply
     */
    updateAnnotationState(
      annotation: Annotations.Annotation,
      state: string,
      stateModel: string,
      message: string,
    ): Annotations.StickyAnnotation;
    /**
     * Redraws the annotations on the same page as the specified annotation if the annotation has been added.
     * @method CoreControls.AnnotationManager#updateAnnotation
     * @param {Annotations.Annotation} annotation An instance of Annotation.
     */
    updateAnnotation(annotation: Annotations.Annotation): void;
    /**
     * Apply redaction annotations
     * @method CoreControls.AnnotationManager#applyRedactions
     * @param {(Annotations.Annotation|Annotations.Annotation[])} [annotations] An array of redaction annotations or a single redaction annotation.
     * If nothing passed, apply all redactions. If the redaction annotations overlap with other annotations, it calls deleteAnnotations on the other annotations.
     * @return {Promise<Array<CoreControls.AnnotationManager.RedactionInfo>|string>} Returns a promise that resolves with an array of redaction info when the redactions have been applied.
     * If using WebViewer server, the promise will resolve with a URL to the redacted document.
     */
    applyRedactions(
      annotations?: Annotations.Annotation | Annotations.Annotation[],
    ): Promise<CoreControls.AnnotationManager.RedactionInfo[] | string>;
    /**
     * Check if applying redaction is enabled
     * @method CoreControls.AnnotationManager#isApplyRedactionEnabled
     * @return {boolean} True if applying redactions is enabled, false otherwise
     *
     */
    isApplyRedactionEnabled(): boolean;
    /**
     * Check if creating redaction is enabled
     * @method CoreControls.AnnotationManager#isCreateRedactionEnabled
     * @return {boolean} True if creating redactions is enabled, false otherwise
     */
    isCreateRedactionEnabled(): boolean;
    /**
     * A switch for turning on and off redaction tools
     * @method CoreControls.AnnotationManager#enableRedaction
     * @param {(boolean)} isEnabled A value for setting if redaction tools are enabled
     */
    enableRedaction(isEnabled: boolean): void;
    /**
     * Check if an annotation is redactable (is a redaction annotation the user can apply).
     * When using Webviewer Server, single redaction aren't allowed, only redact all is allowed
     * @method CoreControls.AnnotationManager#isAnnotationRedactable
     * @param {(Annotations.Annotation)} annotation An annotation to check if it redactable
     * @return {boolean} True if annotation can be redacted (WebViewer is set up correctly for applying), false otherwise
     */
    isAnnotationRedactable(annotation: Annotations.Annotation): boolean;
    /**
     * Deletes the specified annotation in the managed list of annotations.
     * If an annotation is successfully deleted, the annotationChanged event will be fired with a "delete" action.
     * @method CoreControls.AnnotationManager#deleteAnnotation
     * @param {Annotations.Annotation} annotation An instance of Annotation.
     * @param {boolean} [imported] Whether the annotation was imported from another source or not
     * @param {boolean} [force] If true then the annotation will be deleted regardless of the user's current permissions
     * @param {boolean} [isUndoRedo] Whether the annotation change was caused by undo/redo or not
     */
    deleteAnnotation(
      annotation: Annotations.Annotation,
      imported?: boolean,
      force?: boolean,
      isUndoRedo?: boolean,
    ): void;
    /**
     * Deletes the specified annotations in the managed list of annotations.
     * If an annotation is successfully deleted, the annotationChanged event will be fired with a "delete" action.
     * @method CoreControls.AnnotationManager#deleteAnnotations
     * @param {Array<Annotations.Annotation>} annotation An array of annotations
     * @param {boolean} imported Whether the annotations were imported from another source or not
     * @param {boolean} [force] If true then the annotations will be deleted regardless of the user's current permissions
     * @param {boolean} [isUndoRedo] Whether the annotation change was caused by undo/redo or not
     */
    deleteAnnotations(
      annotation: Annotations.Annotation[],
      imported: boolean,
      force?: boolean,
      isUndoRedo?: boolean,
    ): void;
    /**
     * Copies the currently selected annotations.
     * @method CoreControls.AnnotationManager#updateCopiedAnnotations
     */
    updateCopiedAnnotations(): void;
    /**
     * Pastes the currently copied annotations.
     * @method CoreControls.AnnotationManager#pasteCopiedAnnotations
     */
    pasteCopiedAnnotations(): void;
    /**
     * Returns a deep copy of the annotation
     * @method CoreControls.AnnotationManager#getAnnotationCopy
     * @param {Annotations.Annotation} annotation An instance of Annotation to be copied.
     * @return {Annotations.Annotation} a copy of the annotation, null if annotation cannot be copied
     */
    getAnnotationCopy(annotation: Annotations.Annotation): Annotations.Annotation;
    /**
     * Gets the annotation associated with the popup object.
     * @method CoreControls.AnnotationManager#getAnnotationFromPopup
     * @param {object} popup The popup object associated with an annotation
     * @returns {Annotations.Annotation} The annotation that the popup belongs to
     */
    getAnnotationFromPopup(popup: any): Annotations.Annotation;
    /**
     * Returns whether an annotation is currently selected
     * @method CoreControls.AnnotationManager#isAnnotationSelected
     * @param {Annotations.Annotation} annotation An instance of Annotation.
     * @return {boolean} true if annotation is selected, false otherwise
     */
    isAnnotationSelected(annotation: Annotations.Annotation): boolean;
    /**
     * Selects the specified annotation.
     * If an annotation is successfully selected then the annotationSelected event will be fired with a "selected" action.
     * Note: the annotationSelected event has two parameters: an array of annotations and a string value of either "selected" or "deselected"
     * @method CoreControls.AnnotationManager#selectAnnotation
     * @param {Annotations.Annotation} annotation An instance of Annotation.
     */
    selectAnnotation(annotation: Annotations.Annotation): void;
    /**
     * Selects the specified annotations.
     * If an annotation is successfully selected then the annotationSelected event will be fired with a "selected" action.
     * Note: the annotationSelected event has two parameters: an array of annotations and a string value of either "selected" or "deselected"
     * @method CoreControls.AnnotationManager#selectAnnotations
     * @param {Array<Annotations.Annotation>} annotation An array of Annotations.
     */
    selectAnnotations(annotation: Annotations.Annotation[]): void;
    /**
     * Deselects all annotations.
     * If an annotation is successfully deselected then the annotationSelected event will be trigger with a "deselected" action and a null value as the array of annotations parameter.
     * Note: the annotationSelected event has two parameters: an array of annotations and a string value of either "selected" or "deselected"
     * @method CoreControls.AnnotationManager#deselectAllAnnotations
     */
    deselectAllAnnotations(): void;
    /**
     * Deselects the specified annotation.
     * If an annotation is successfully selected then the annotationSelected event will be fired with a "selected" action.
     * Note: the annotationSelected event has two parameters: an array of annotations and a string value of either "selected" or "deselected"
     * @method CoreControls.AnnotationManager#deselectAnnotation
     * @param {Annotations.Annotation} annotation An instance of Annotation.
     */
    deselectAnnotation(annotation: Annotations.Annotation): void;
    /**
     * Returns the list of selected annotations.
     * @method CoreControls.AnnotationManager#getSelectedAnnotations
     * @return {Array<Annotations.Annotation>} An array of selected annotations.
     */
    getSelectedAnnotations(): Annotations.Annotation[];
    /**
     * Gets the list of all annotations managed by the AnnotationManager.
     * @method CoreControls.AnnotationManager#getAnnotationsList
     * @return {Array<Annotations.Annotation>} An array of Annotations.
     */
    getAnnotationsList(): Annotations.Annotation[];
    /**
     * Gets an annotation object by the annotation's ID.
     * @method CoreControls.AnnotationManager#getAnnotationById
     * @param {string} id The ID of the annotation.
     * @param {Array} annotationList Optionally pass your own array of annotations to search in
     * @returns {Annotations.Annotation} An annotation object.
     */
    getAnnotationById(id: string, annotationList: any[]): Annotations.Annotation;
    /**
     * Gets the top-most annotation using a DOM mouse event. This method can be used to test if a mouse point will hit any annotations on pages.
     * @method CoreControls.AnnotationManager#getAnnotationByMouseEvent
     * @param {MouseEvent} event A DOM mouse event.
     * @returns {Annotations.Annotation} An annotation object.
     */
    getAnnotationByMouseEvent(event: MouseEvent): Annotations.Annotation;
    /**
     * Gets the annotations underneath the cursor using a DOM mouse event. This method can be used to test if a mouse point will hit annotations on pages.
     * @method CoreControls.AnnotationManager#getAnnotationsByMouseEvent
     * @param {MouseEvent} event A DOM mouse event.
     * @returns {Array.<Annotations.Annotation>} An array of annotation objects.
     */
    getAnnotationsByMouseEvent(event: MouseEvent): Annotations.Annotation[];
    /**
     * Exports all annotations as an XFDF (XML) string
     * @method CoreControls.AnnotationManager#exportAnnotations
     * @param {object} [options] Options for the export. Set options.widgets or options.links or options.fields to false to disable exporting of them.
     * @param {Array<Annotations.Annotation>} [options.annotList] An array of annotations to only export the XFDF for those particular annotations.
     * @param {boolean} [options.widgets] Whether to export widget information
     * @param {boolean} [options.links] Whether to export links information
     * @param {boolean} [options.fields] Whether to export fields information
     * @return {Promise<string>} Returns a promise that resolves with the XFDF (XML) annotations as a string
     */
    exportAnnotations(options?: {
      annotList?: Annotations.Annotation[];
      widgets?: boolean;
      links?: boolean;
      fields?: boolean;
    }): Promise<string>;
    /**
     * Gets an XML string specifying the added, modified and deleted annotations.
     * Added and modified annotations will have their XFDF representation included
     * while deleted annotations will only include their id.
     * @deprecated in favor of exportAnnotCommand
     * @method CoreControls.AnnotationManager#getAnnotCommand
     * @returns {Promise<string>} Returns a promise that resolves to an XFDF command string
     */
    getAnnotCommand(): Promise<string>;
    /**
     * Gets an XML string specifying the added, modified and deleted annotations.
     * Added and modified annotations will have their XFDF representation included
     * while deleted annotations will only include their id.
     * @method CoreControls.AnnotationManager#exportAnnotCommand
     * @returns {Promise<string>} Returns a promise that resolves to an XFDF command string
     */
    exportAnnotCommand(): Promise<string>;
    /**
     * Loads XFDF annotations into the viewer
     * @method CoreControls.AnnotationManager#importAnnotations
     * @param {string} xfdfString The XFDF annotations as a string
     * @param {object} [options] The options for importing
     * @param {number} [options.batchSize] The number of annotations to import in each batch (default 100)
     * @param {number} [options.batchDelay] The amount of time in milliseconds to delay between importing each batch (default 0)
     * @param {Annotations.Annotation|Array<Annotations.Annotation>} [options.replace] The type of existing annotations that will be removed before import starts (default [])
     * @return {Promise<any>} Returns a promise that resolves with the annotations have been imported
     */
    importAnnotations(
      xfdfString: string,
      options?: {
        batchSize?: number;
        batchDelay?: number;
        replace?: Annotations.Annotation | Annotations.Annotation[];
      },
    ): Promise<any>;
    /**
     * Updates the viewer with the xfdf changes (add/modify/delete) in the xml string
     * @method CoreControls.AnnotationManager#importAnnotCommand
     * @param {string} xfdfString The XML annotation updates as a string
     * @return {Promise<Array<Annotations.Annotation>>} A promise that resolves to the list of annotations that were updated
     */
    importAnnotCommand(xfdfString: string): Promise<Annotations.Annotation[]>;
    /**
     * Draws all the pages associated with the annotations in the list as long the page is visible.
     * @method CoreControls.AnnotationManager#drawAnnotationsFromList
     * @param {Array<Annotations.Annotation>} annotationList List of annotations
     * @return {Promise<any>} Returns a promise that resolves when all the annotations in the annotationList have been drawn
     */
    drawAnnotationsFromList(annotationList: Annotations.Annotation[]): Promise<any>;
    /**
     * Registers an annotation class. Annotations that are registered will be serialized and deserialized by the AnnotationManager.
     * @method CoreControls.AnnotationManager#registerAnnotationType
     * @param {string} elementName the string representing the xml element name of the annotation
     * @param {Annotations.Annotation} annotationClass the class (constructor) of the annotation
     * @returns {Boolean} true if registration was successful
     */
    registerAnnotationType(elementName: string, annotationClass: Annotations.Annotation): boolean;
    /**
     * Deregisters an annotation class.
     * @method CoreControls.AnnotationManager#deregisterAnnotationType
     * @param {string} elementName the string representing the xml element name of the annotation
     * @param {Annotations.Annotation} annotationClass the class (constructor) of the annotation
     * @returns {Boolean} true if deregistration was successful
     */
    deregisterAnnotationType(elementName: string, annotationClass: Annotations.Annotation): boolean;
    /**
     * Gets a map of registered annotations. This can be modified directly, instead of using AnnotationManager#registerAnnotationType and AnnotationManager#deregisterAnnotationType.
     * @method CoreControls.AnnotationManager#getRegisteredAnnotationTypes
     * @returns {object} a JavaScript object containing a key-value map, where the key is the annotation element name and the value is an array of Annotation classes.
     */
    getRegisteredAnnotationTypes(): any;
    /**
     * Set the styles for the annotation
     * @method CoreControls.AnnotationManager#setAnnotationStyles
     * @param {Annotations.Annotation} annotation an annotation of which the styles will be changed.
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setAnnotationStyles(annotation: Annotations.Annotation, newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Sets the mapping function used to get the display name for annotation authors
     * and is used when calling getDisplayAuthor.
     * @method CoreControls.AnnotationManager#setAnnotationDisplayAuthorMap
     * @param {function} mapFunction The mapping function to use. The function is passed the annotation object and should return the display name for the UI.
     * @example
     * annotManager.setAnnotationDisplayAuthorMap((annotation) => {
     *   if (annotation.Id === '1') {
     *     return 'John';
     *   } else {
     *     return 'Guest';
     *   }
     * });
     */
    setAnnotationDisplayAuthorMap(mapFunction: (...params: any[]) => any): void;
    /**
     * Annotations may set the author to a unique id which isn't suitable for display in the UI.
     * this function gets the author name of the annotation that should be displayed.
     * @method CoreControls.AnnotationManager#getDisplayAuthor
     * @param {object} annotation Annotation object
     * @returns {string} The display author name
     */
    getDisplayAuthor(annotation: any): string;
    /**
     * Changes the sticky note rendering to the old implementation when the sticky note
     * has been created before the specified date.
     * @method CoreControls.AnnotationManager#setOldStickyNoteRenderingDate
     * @param {number} date The date timestamp to use
     */
    setOldStickyNoteRenderingDate(date: number): void;
    /**
     * Add a handler to the given event name
     * @method EventHandler#on
     * @param {string|number} type The name of the event to listen to
     * @param {function} fn The handler to be called when the event is triggered
     * @returns {object} Returns the object that 'on' is being called on
     * @example
     * annotManager.on('annotationChanged', (annotations, action) => {
     *   ...
     * });
     */
    on(type: string | number, fn: (...params: any[]) => any): any;
    /**
     * Remove a handler of the given event name
     * @method EventHandler#off
     * @param {(string|number)} [type] The name of the event to remove the handler of.
     * If type is undefined, all the handlers of the object will be removed
     * @param {function} [fn] The handler associated with this event to be removed.
     * If fn is undefined, all the handlers of the given event name will be removed
     * @returns {object} Returns the object that 'off' is being called on
     * @example
     * annotManager.off();
     * annotManager.off('annotationChanged');
     * annotManager.off('annotationChanged', fn);
     */
    off(type?: string | number, fn?: (...params: any[]) => any): any;
    /**
     * Calls the handlers of the event name with given data
     * @method EventHandler#trigger
     * @param {(string|number)} type event name of which the handlers will be called.
     * @param {*} [data] data that will be passed to the handlers.
     * If data is an array, it will be spread and then passed to the handlers
     * @return {object} Returns the object that 'trigger' is being called on
     * @example
     * annotManager.trigger('annotationChanged');
     * annotManager.trigger('annotationChanged', [[annotation], 'add', {}]);
     */
    trigger(type: string | number, data?: any): any;
    /**
     * Same as 'on' except the handler will be called only once
     * @param {string|number} type The name of the event to listen to
     * @param {function} fn The handler to be called when the event is triggered
     * @returns {object} Returns the object that 'one' is being called on
     * @example
     * annotManager.one('annotationChanged', (annotations, action) => {
     *  ...
     * });
     * @method EventHandler#one
     */
    one(type: string | number, fn: (...params: any[]) => any): any;
    /**
     * The size of annotation control points.
     */
    controlPointSize: number;
    /**
     * The scale of the hit box of the annotation control points. Increase to increase the selectable area.
     */
    controlPointHitBoxScale: number;
  }
  namespace AnnotationManager {
    /**
     * @typedef {object} CoreControls.AnnotationManager.RedactionInfo
     * @property {number} pageNumber The page number of the redaction
     * @property {Annotations.Rect} rect A rect containing the bounding box of the redaction
     */
    type RedactionInfo = {
      pageNumber: number;
      rect: Annotations.Rect;
    };
    /**
     * @typedef {Object} CoreControls.AnnotationManager.AnnotationChangedInfoObject
     * @property {boolean} imported A boolean that will be true if the annotation change is the result of importing annotations using importAnnotations, importAnnotCommand or if the imported parameter is set to true when calling addAnnotations or deleteAnnotations
     * @property {boolean} isUndoRedo A boolean that will be true if the annotation change is the result of an undo or redo action
     */
    type AnnotationChangedInfoObject = {
      imported: boolean;
      isUndoRedo: boolean;
    };
  }
  /**
   * Forces a higher level of accuracy in image downsampling at the expense of rendering performance.
   * This function should be called before loading a document to ensure this setting is used.
   * @name setAdvancedImageScaling
   * @memberof CoreControls
   * @function
   * @param {boolean} advanced if true advanced image scaling will be used. Can alternatively pass a number for
   * the number of downsampling steps to take. Passing true is equivalent to passing 1.4.
   */
  function setAdvancedImageScaling(advanced: boolean): void;
  /**
   * Sets the canvas rendering mode.
   * @method CoreControls.SetCanvasMode
   * @param {CoreControls.CanvasMode} mode The canvas mode to switch to
   */
  function SetCanvasMode(mode: CoreControls.CanvasMode): void;
  /**
   * Canvas mode enumeration, has values of PageCanvas (default) and ViewportCanvas
   * @enum {string}
   * @name CanvasMode
   * @memberof CoreControls
   * @property {string} ViewportCanvas
   * @property {string} PageCanvas
   */
  enum CanvasMode {
    ViewportCanvas,
    PageCanvas,
  }
  /**
   * Creates an initialized CoreControls.Document instance.
   * @name createDocument
   * @memberof CoreControls
   * @function
   * @param {(string|File|ArrayBuffer|Blob)} source - Source parameter, path/url to document or File.
   * @param {object} [options]  - An object that can contain the following optional parameters.
   * @param {string} [options.l] - The license key for viewing PDF or Office files (PDF/Office only).
   * @param {string} [options.docId] An unique identifier for the document, used for offline mode.
   * @param {function} [options.onLoadingProgress] - A callback function for loading progress, function signature function(percent) {}.
   * @param {function} [options.onError] - A callback function that will be called when error occurs in the process of creating a document. function signature function(e) {}
   * @param {Promise<any>} [options.workerTransportPromise] - The workerTransportPromise that should be used to load the document.
   * @param {string|function} [options.password] -  A password string or a function of the form function(callback) where callback is of the form function(password). This 'password' function will be called when a password is required to load a PDF document and should call the callback with the retrieved password.
   * @param {string} [options.filename] - A filename that is used for the downloaded file, and for determining the extension when options.extension isn't used.
   * @param {string} [options.extension] - Used for specifying the extension of the document to be loaded. This is necessary if the URL/path does not contain the file extension or if you're loading a Blob/File.
   * @param {object} [options.customHeaders] - An object containing custom HTTP headers to use when retrieving the document from the specified url. For example: {'Authorization' : 'Basic dXNlcm5hbWU6cGFzc3dvcmQ='}.
   * @param {boolean} [options.useDownloader] - A boolean indicating whether Downloader should be used on urls (PDF only). https://www.pdftron.com/documentation/web/guides/usedownloader-option/.
   * @param {boolean} [options.withCredentials] - Whether to set the withCredentials property on the XMLHttpRequest.
   * @param {Array<object>} [options.pageSizes] - An array of objects in the shape of { width: number, height: number }. Used to determine the page sizes when loading an image file.
   * @param {string} [options.backendType] - A string representing the "backend type" for rendering PDF documents. Pass "ems" to force the use of the ASM.js/WebAssembly worker and "pnacl" for the "PNaCl" worker.
   * @param {object} [options.xodOptions] - An object that contains the options for a XOD document.
   * @param {boolean} [options.xodOptions.decrypt] - Function to be called to decrypt a part of the XOD file. For default XOD AES encryption pass CoreControls.Encryption.decrypt.
   * @param {boolean} [options.xodOptions.decryptOptions] -  An object with options for the decryption e.g. {p: "pass", type: "aes"} where is p is the password.
   * @param {boolean} [options.xodOptions.streaming] - A boolean indicating whether to use http or streaming PartRetriever, it is recommended to keep streaming false for better performance. https://www.pdftron.com/documentation/web/guides/streaming-option.
   * @param {boolean} [options.xodOptions.azureWorkaround] - Whether or not to workaround the issue of Azure not accepting range requests of a certain type. Enabling the workaround will add an extra HTTP request of overhead but will still allow documents to be loaded from other locations.
   * @param {boolean} [options.xodOptions.startOffline] - Whether to start loading the document in offline mode or not. This can be set to true if the document had previously been saved to an offline database using WebViewer APIs. You'll need to use this option to load from a completely offline state.
   * @param {string} [options.pdftronServer] - A URL to the WebViewer server drop-in backend https://www.pdftron.com/documentation/web/guides/wv-server-deployment.
   * @param {string} [options.cacheKey] - A key that will be used for caching the document on WebViewer Server.
   * @param {boolean} [options.forceClientSideInit] - If set to true then when loading a document using WebViewer Server the document will always switch to client only rendering allowing page manipulation and the full API to be used.
   * @returns {Promise<CoreControls.Document>} Promise that resolves when doc.loadAsync has been successfully called and returns CoreControls.Document instance.
   */
  function createDocument(
    source: string | File | ArrayBuffer | Blob,
    options?: {
      l?: string;
      docId?: string;
      onLoadingProgress?: (...params: any[]) => any;
      onError?: (...params: any[]) => any;
      workerTransportPromise?: Promise<any>;
      password?: string | ((...params: any[]) => any);
      filename?: string;
      extension?: string;
      customHeaders?: any;
      useDownloader?: boolean;
      withCredentials?: boolean;
      pageSizes?: object[];
      backendType?: string;
      xodOptions?: {
        decrypt?: boolean;
        decryptOptions?: boolean;
        streaming?: boolean;
        azureWorkaround?: boolean;
        startOffline?: boolean;
      };
      pdftronServer?: string;
      cacheKey?: string;
      forceClientSideInit?: boolean;
    },
  ): Promise<CoreControls.Document>;
  /**
   * Display modes that control how the document's page are displayed
   * @name CoreControls.DisplayModes
   * @property {string} Single Displays one page at a time.
   * @property {string} Continuous Displays all the pages in a scrolling view in one column.
   * @property {string} Facing Displays up to two pages at a time, side by side.
   * @property {string} FacingContinuous Displays all pages in a scrolling view in two columns.
   * @property {string} Cover Displays all pages in a scrolling view in two columns.  The first row has a single page in the second column.
   * @property {string} CoverFacing Same as the Cover display mode except that it is not a scrolling view.
   * @property {string} Custom Any custom display mode.
   */
  var DisplayModes: {
    Single: string;
    Continuous: string;
    Facing: string;
    FacingContinuous: string;
    Cover: string;
    CoverFacing: string;
    Custom: string;
  };
  /**
   * Constructs a new Display Mode that specifies how the pages are displayed on the screen
   * @class Represents a Display Mode.
   * @name CoreControls.DisplayMode
   * @param {object} docViewer The DocumentViewer instance
   * @param {object} mode The display mode type
   * @param {boolean} scrollable Whether the display mode is scrollable or not
   */
  class DisplayMode {
    constructor(docViewer: any, mode: any, scrollable: boolean);
    /**
     * Sets parameters of the display mode
     * @method CoreControls.DisplayMode#setParameters
     * @param {number} nCols The number of columns
     * @param {number} nRows The number of rows
     * @param {number} currentRow The current row to be displayed
     * @param {number} startRow The starting row to have in the DOM
     * @param {number} endRow The ending row to have in the DOM
     */
    setParameters(nCols: number, nRows: number, currentRow: number, startRow: number, endRow: number): void;
    /**
     * Sets callbacks to provide custom functionality when in custom display mode
     * @method CoreControls.DisplayMode#setCustomFunctions
     * @param fns.pageToWindow transform coordinates relative to a document page to coordinates relative to the viewer div
     * @param fns.windowToPage transform coordinates relative to the viewer div relative to a document page
     * @param fns.getSelectedPages returns an array of currently selected page indices
     * @param fns.getVisiblePages returns an array of currently visible pages
     * @param fns.getPageTransform returns the offsets of a page container
     * @param fns.createPageSections lays out pageSection and pageContainer divs to DocumentViewer can put content in them
     */
    setCustomFunctions(): void;
    /**
     * Converts page coordinates to window coordinates.
     * @method CoreControls.DisplayMode#pageToWindow
     * @param {object} pagePt A object with x and y properties in page coordinates
     * @param {number} pageIndex The page index
     * @returns {object} An object with the page index as well as x and y values in window coordinates
     */
    pageToWindow(pagePt: any, pageIndex: number): any;
    /**
     * Converts window coordinates to page coordinates.
     * @method CoreControls.DisplayMode#windowToPage
     * @param {object} windowPt A object with x and y properties in window coordinates
     * @param {number} pageIndex The page index
     * @returns {object} An object with the page index as well as x and y values in page coordinates
     */
    windowToPage(windowPt: any, pageIndex: number): any;
    /**
     * Gets the indexes of the first and last pages selected.
     * @method CoreControls.DisplayMode#getSelectedPages
     * @param {object} mousePt1 The starting mouse point, an object with x and y properties
     * @param {object} mousePt2 The ending mouse point, an object with x and y properties
     * @returns {object} An object with a 'first' property being the first page selected and a 'last'
     *      property being the last page selected.  last must be >= first.
     */
    getSelectedPages(mousePt1: any, mousePt2: any): any;
    /**
     * Returns an array of page indexes that are visible on screen.
     * @method CoreControls.DisplayMode#getVisiblePages
     * @param {number} [amountAhead] The amount of space ahead of the viewport to count as visible as a multiple of the screen height (default is 0.5)
     * @param {number} [amountSide] The amount of space to the side of the viewport to count as visible as a multiple of the screen height (default is 0.5)
     * @returns {Array<number>} an array of 0-indexed page numbers.
     */
    getVisiblePages(amountAhead?: number, amountSide?: number): number[];
    /**
     * Returns the amount the page is shifted relative to the viewport
     * @method CoreControls.DisplayMode#getPageTransform
     * @param {number} pageIndex The index of the page
     * @returns {object} An object with x and y properties of the amount the page is shifted relative to the viewport
     *      and width and height properties of the page.
     */
    getPageTransform(pageIndex: number): any;
    /**
     * Returns the amount the page is offset from its container
     * @method CoreControls.DisplayMode#getPageOffset
     * @param {number} pageIndex The index of the page
     * @returns {object} An object with x and y properties of the amount the page is offset from its container
     */
    getPageOffset(pageIndex: number): any;
  }
  /**
   * Creates a new instance of DisplayModeManager
   * @class Represents an object that manages the display modes used by DocumentViewer
   * @name CoreControls.DisplayModeManager
   * @param {object} docViewer The DocumentViewer instance
   */
  class DisplayModeManager {
    constructor(docViewer: any);
    /**
     * Returns the current display mode.
     * @method CoreControls.DisplayModeManager#getDisplayMode
     * @returns The current display mode.
     */
    getDisplayMode(): any;
    /**
     * Sets the display mode. Also removes selection caused by text selection or search.
     * Only renders if a document has been loaded.
     * @method CoreControls.DisplayModeManager#setDisplayMode
     * @param {object} displayMode The display mode object to set as the current display mode
     */
    setDisplayMode(displayMode: any): void;
  }
  /**
   * BaseDocument is used to alert if a Document implementation is not following the Document interface.
   * @method CoreControls.BaseDocument
   */
  function BaseDocument(): void;
  /**
   * Bookmarks typically represent an outline of the document, and as each bookmark is usually associated with a specific page in a document, they are typically used to facilitate navigation.
   * @class Represents a bookmark in a Document.
   * @name CoreControls.Bookmark
   * @param {Array<CoreControls.Bookmark>} children A list of child bookmarks
   * @param {string} name The name of the bookmark
   * @param {number} pageNumber The page number of the bookmark
   * @param {CoreControls.Bookmark} parent The parent bookmark of this bookmark
   * @param {number} verticalOffset The vertical position that the linked page will be scrolled to
   * @param {number} horizontalOffset The horizontal position that the linked page will be scrolled to
   * @param {string} [url] An optional parameter that allows the bookmark to link to a URL instead of a page number (this overrides the page number)
   */
  class Bookmark {
    constructor(
      children: CoreControls.Bookmark[],
      name: string,
      pageNumber: number,
      parent: CoreControls.Bookmark,
      verticalOffset: number,
      horizontalOffset: number,
      url?: string,
    );
    /**
     * Gets the children of the bookmark.
     * @method CoreControls.Bookmark#getChildren
     * @return {Array<CoreControls.Bookmark>} The children of the bookmark
     */
    getChildren(): CoreControls.Bookmark[];
    /**
     * Gets the name of the bookmark.
     * @method CoreControls.Bookmark#getName
     * @return {string} The name of the bookmark
     */
    getName(): string;
    /**
     * Gets the page number of the bookmark.
     * @method CoreControls.Bookmark#getPageNumber
     * @return {number} The page number of the bookmark
     */
    getPageNumber(): number;
    /**
     * Gets the url of the bookmark if it has one.
     * @method CoreControls.Bookmark#getURL
     * @return {string} The url of the bookmark
     */
    getURL(): string;
    /**
     * Gets the parent of this bookmark if it has one.
     * @method CoreControls.Bookmark#getParent
     * @return {CoreControls.Bookmark} The parent of the bookmark
     */
    getParent(): CoreControls.Bookmark;
    /**
     * Gets the vertical position of the bookmark.
     * @method CoreControls.Bookmark#getVPos
     * @return {number} The vertical position of the bookmark
     */
    getVPos(): number;
    /**
     * Gets the horizontal position of the bookmark.
     * @method CoreControls.Bookmark#getHPos
     * @return {number} The horizontal position of the bookmark
     */
    getHPos(): number;
    /**
     * Determines whether the bookmark goes to a valid destination.
     * @method CoreControls.Bookmark#isValid
     * @return {boolean} Whether the bookmark points to a valid destination
     */
    isValid(): boolean;
  }
  /**
   * Control the time between progressive events when rendering a more complex page.
   * @method CoreControls.setProgressiveTime
   * @param {number} milliseconds the number of milliseconds between progressive events. By default this is disabled for XOD, 1 second (1000) for PNaCl and 3 seconds (3000) for Emscripten.
   */
  function setProgressiveTime(milliseconds: number): void;
  /**
   * Set the caching level between 0 and 10, where 0 is no caching and 10 uses a very large cache
   * @method CoreControls.SetCachingLevel
   * @param {number} level The level to set
   */
  function SetCachingLevel(level: number): void;
  /**
   * Set the pre-render level between 0 and 10, where 0 has pre-rendering and 10 has a lot of pre-rendering.
   * @method CoreControls.SetPreRenderLevel
   * @param {number} level The level to set
   */
  function SetPreRenderLevel(level: number): void;
  /**
   * Constructs a new empty Document, representing a document with individual pages (canvases) that can be displayed on screen and printed.
   * @class Represents a document.
   * @name CoreControls.Document
   * @param {string} id Unique string identifier for the document
   * @param {string} type The type of document that should be instantiated.
   * Values are 'xod' for XOD documents, 'pdf' for PDF, JPG or PNG documents, 'office' for MS Office documents and 'blackbox' for WebViewer Server documents
   */
  class Document {
    constructor(id: string, type: string);
    /**
     * Register new document type with Document class
     * @method CoreControls.Document.registerDocumentType
     * @param {String} type Name of the new document type
     * @param {any} source Class of the new document
     * @param {Array<string>} exposedFuncs An array containing strings of the function names to expose on the document object
     * @return {Boolean}
     */
    static registerDocumentType(type: string, source: any, exposedFuncs: string[]): boolean;
    /**
     * Unregister existing document type form Document class
     * @method CoreControls.Document.unregisterDocumentType
     * @param {String} type Name of registered document type
     * @returns {Boolean}
     */
    static unregisterDocumentType(type: string): boolean;
    /**
     * Gets the type of the document.
     * @method CoreControls.Document#getType
     * @returns {string} The type of the document (xod, pdf, office, blackbox)
     */
    getType(): string;
    /**
     * Gets whether the document will be interacted with as a WebViewer Server document
     * This will return false if the document was loaded from WebViewer Server but forceClientSideInit is set to true
     * @method CoreControls.Document#isWebViewerServerDocument
     * @returns {boolean} Returns whether the document will be interacted with as a WebViewer Server document.
     */
    isWebViewerServerDocument(): boolean;
    /**
     * Cancels the request made for thumbnail with the specified request Id
     * @method CoreControls.Document#cancelLoadThumbnail
     * @param {number} requestId The id returned from loadThumbnailAsync
     */
    cancelLoadThumbnail(requestId: number): void;
    /**
     * Cancels the loadCanvasAsync call corresponding to the passed in id
     * @method CoreControls.Document#cancelLoadCanvas
     * @param {number} id The id returned from the loadCanvasAsync call that will be cancelled.
     */
    cancelLoadCanvas(id: number): void;
    /**
     * Unloads resources for the page associated with the loadCanvasAsync call corresponding to the passed in id.
     * So if the loadCanvasAsync call had requested page 2 then page 2's resources will be cleaned up
     * (as long as nothing else requires those resources). Note that the canvas element itself is not touched.
     * @method CoreControls.Document#unloadCanvasResources
     * @param {number} id The id returned from the loadCanvasAsync call that will have it's page resources unloaded
     */
    unloadCanvasResources(id: number): void;
    /**
     * Cancels a download for offline mode in progress.  If there is no current download then this does nothing.
     * @method CoreControls.Document#cancelOfflineModeDownload
     */
    cancelOfflineModeDownload(): void;
    /**
     * Returns an array containing the bookmarks in the document.
     * @method CoreControls.Document#getBookmarks
     * @returns {Promise<CoreControls.Bookmark[]>} A promise resolving to an array containing the bookmarks in the current document.
     */
    getBookmarks(): Promise<CoreControls.Bookmark[]>;
    /**
     * Returns an array containing the links on the specified page of the document.
     * @method CoreControls.Document#getLinks
     * @param {number} pageIndex The page number, zero-indexed, that the links are on.
     * @returns {Array<string>} An array containing the links on the specified page of the document.
     */
    getLinks(pageIndex: number): string[];
    /**
     * Returns whether offline mode is currently enabled or not.
     * @method CoreControls.Document#getOfflineModeEnabled
     */
    getOfflineModeEnabled(): void;
    /**
     * Returns the number of pages in a document.
     * @method CoreControls.Document#getPageCount
     * @returns {number} The number of the pages in the current document.
     */
    getPageCount(): number;
    /**
     * Returns an object containing the width and height of a page.
     * @method CoreControls.Document#getPageInfo
     * @param {number} pageIndex The page number, zero-indexed, of the requested page.
     * @returns {CoreControls.Document.PageInfo} An object representing the page info. Contains the properties "width" and "height".
     */
    getPageInfo(pageIndex: number): CoreControls.Document.PageInfo;
    /**
     * Returns an object with the original x and y coordinates converted to PDF coordinates for the page.
     * @method CoreControls.Document#getPDFCoordinates
     * @param {number} pageIndex The page number, zero-indexed, that the coordinates are on
     * @param {number} x The x coordinate
     * @param {number} y The y coordinate
     * @returns {object} An object with the x and y PDF coordinates
     */
    getPDFCoordinates(pageIndex: number, x: number, y: number): any;
    /**
     * Gets quads for each of the characters from start to end index.
     * @method CoreControls.Document#getTextPosition
     * @param {number} pageIndex The page number, zero-indexed, that the text is on.
     * @param {number} textStartIndex The position where to start getting character quads from.
     * @param {number} textEndIndex The position (up to, but not including) where to finish getting characters.
     * @param {function} onComplete The callback to call when the text positions are ready. Accepts a quads object as a parameter. Quads is an array of objects with (x1,y1,x2,y2,x3,y3,x4,y4)
     */
    getTextPosition(
      pageIndex: number,
      textStartIndex: number,
      textEndIndex: number,
      onComplete: (...params: any[]) => any,
    ): void;
    /**
     * Returns an object with the original x and y PDF coordinates converted to XOD coordinates for the page.
     * @method CoreControls.Document#getXODCoordinates
     * @param {number} pageIndex The page number, zero-indexed, that the coordinates are on
     * @param {number} x The x coordinate
     * @param {number} y The y coordinate
     * @returns {object} An object with the x and y XOD coordinates
     */
    getXODCoordinates(pageIndex: number, x: number, y: number): any;
    /**
     * Returns an object with the original x and y PDF coordinates converted to Viewer coordinates for the page.
     * @method CoreControls.Document#getViewerCoordinates
     * @param {number} pageIndex The page number, zero-indexed, that the coordinates are on
     * @param {number} x The x coordinate
     * @param {number} y The y coordinate
     * @returns {object} An object with the x and y Viewer coordinates
     */
    getViewerCoordinates(pageIndex: number, x: number, y: number): any;
    /**
     * Returns an object with metadata associated with the document.
     * @method CoreControls.Document#getMetadata
     * @returns {Promise<object>} A promise that resolves to an object with document metadata
     */
    getMetadata(): Promise<object>;
    /**
     * Used to know if a document contains thumbnails.
     * @method CoreControls.Document#includesThumbnails
     * @returns {boolean} True if the document contains thumbnails.
     */
    includesThumbnails(): boolean;
    /**
     * [XOD Document only] Initializes the offline database for use.  Must be called before any other offline mode functions are used.
     * @method CoreControls.Document#initOfflineDB
     * @param {function} onComplete The function that's called when the offline database is ready for use.
     */
    initOfflineDB(onComplete: (...params: any[]) => any): void;
    /**
     * [XOD Document only] Whether the document has already been downloaded for offline mode or not.
     * @method CoreControls.Document#isDownloaded
     */
    isDownloaded(): void;
    /**
     * Initialize a Document so that it can be used to load page canvases.
     * @method CoreControls.Document#loadAsync
     * @param {PartRetrievers.PartRetriever} partRetriever An instance of PartRetriever.
     * @param {CoreControls.Document.LoadAsyncCallback} callback
     * @param options an object that can contain the following optional parameters
     * @param {Promise<any>} [options.workerTransportPromise] Required to load a PDF or Office file. A promise that will be resolved when a worker transport has been initialized. This can be created by calling CoreControls.initPDFWorkerTransports or CoreControls.initOfficeWorkerTransports as appropriate.
     * @param {function} [options.getPassword] A method of the form function(callback) where callback is of the form function(password). getPassword will be called when a password is required to load a PDF document and should call the callback with the retrieved password.
     * @param {string} [options.extension] An field used to specify the type of file being read. This is only relevant for PDF viewing and at the moment only works for certain image formats and .pdf
     */
    loadAsync(
      partRetriever: PartRetrievers.PartRetriever,
      callback: CoreControls.Document.LoadAsyncCallback,
      options: {
        workerTransportPromise?: Promise<any>;
        getPassword?: (...params: any[]) => any;
        extension?: string;
      },
    ): void;
    /**
     * Loads a canvas for a particular page index.
     * @method CoreControls.Document#loadCanvasAsync
     * @param {Object} options An object specifying the options for loading the canvas. The following parameters should be properties on this object. The only non-optional parameter is pageIndex.
     * @param {number} options.pageIndex The page number, zero-indexed, of the requested canvas.
     * @param {number} [options.zoom] The zoom value to render the page at.
     * @param {function} [options.getZoom] A function that returns the zoom value to render the page at. Use this instead of "zoom" if the value might change in the process of setting up the canvas.
     * @param {CoreControls.PageRotation} [options.pageRotation] The rotation of the page. Valid values are CoreControls.PageRotation.e_0, CoreControls.PageRotation.e_90, CoreControls.PageRotation.e_180, CoreControls.PageRotation.e_270.
     * @param {function} [options.getPageRotation] A function that returns the rotation of the page. Use this instead of "pageRotation" if the value might change in the process of setting up the canvas.
     * @param {function} [options.finishedLoading] A callback called after the list of page resources is retrieved. Return true if rendering should continue, false otherwise.
     * @param {function} [options.acquireResources] A function that returns whether resources need to be acquired or not, defaults to true.
     * @param {function} [options.resourcesLoaded] A callback called after the page's resources have been loaded. Return true if rendering should continue, false otherwise.
     * @param {function} [options.getPageTransform] A function that returns the x and y values of the page's translation.
     * @param {function} [options.drawComplete] The callback to call when the canvas has been completely rendered. The first parameter is a canvas object, and the second parameter is the page index.
     * @param {function} [options.drawProgressive] The callback to call when the canvas has been partially rendered.
     * @param {object} [options.renderRect] An object with x1, y1, x2, y2 properties which is the partial rectangle to render of the entire page. The top left of the page is (0, 0).
     * @param {boolean} [options.useProgress] Whether progressive rendering should be used or not.
     * @returns {number} An id that can be passed to the corresponding Pause, Resume or Cancel functions
     */
    loadCanvasAsync(options: {
      pageIndex: number;
      zoom?: number;
      getZoom?: (...params: any[]) => any;
      pageRotation?: CoreControls.PageRotation;
      getPageRotation?: (...params: any[]) => any;
      finishedLoading?: (...params: any[]) => any;
      acquireResources?: (...params: any[]) => any;
      resourcesLoaded?: (...params: any[]) => any;
      getPageTransform?: (...params: any[]) => any;
      drawComplete?: (...params: any[]) => any;
      drawProgressive?: (...params: any[]) => any;
      renderRect?: any;
      useProgress?: boolean;
    }): number;
    /**
     * Gets all the text on the requested page.
     * @method CoreControls.Document#loadPageText
     * @param {number} pageIndex The page number, zero-indexed, that the text is on.
     * @param {function} onComplete The callback to call when the text is ready. Accepts the page's text as the first parameter
     */
    loadPageText(pageIndex: number, onComplete: (...params: any[]) => any): void;
    /**
     * Gets the XFDF data for the document's internal annotations.
     * @method CoreControls.Document#extractXFDF
     * @param {Array<number>} pages An array of page numbers to get the XFDF data for the document. Note: Only one page
     * is supported by XOD documents.
     * @returns {Promise<CoreControls.Document.XFDFInfo>} a promise the resolves to an object with an xfdfString property and a pages property where pages is the array of page numbers that annotations were extracted from
     */
    extractXFDF(pages: number[]): Promise<CoreControls.Document.XFDFInfo>;
    /**
     * Loads a thumbnail image for a particular page.
     * @method CoreControls.Document#loadThumbnailAsync
     * @param {number} pageIndex The page index of the requested thumbnail (0-indexed).
     * @param {function} onLoadThumbnail The callback to call when the thumbnail has been retrieved. Accepts an HTMLImageElement or HTMLCanvasElement as a parameter.
     * @returns {number} The id of the request that can later be used for cancelling the request
     * It is passed an image element if the .xod file contains thumbnails and a canvas element otherwise.
     */
    loadThumbnailAsync(pageIndex: number, onLoadThumbnail: (...params: any[]) => any): number;
    /**
     * Pauses the loadCanvasAsync call corresponding to the passed in id
     * @method CoreControls.Document#pauseLoadCanvas
     * @param {number} id The id returned from the loadCanvasAsync call that will be paused.
     */
    pauseLoadCanvas(id: number): void;
    /**
     * Resumes the loadCanvasAsync call corresponding to the passed in id
     * @method CoreControls.Document#resumeLoadCanvas
     * @param {number} id The id returned from the loadCanvasAsync call that will be resumed.
     */
    resumeLoadCanvas(id: number): void;
    /**
     * Returns the PDFNet.PDFDoc object associated with the document. Note that the full API is required to be enabled
     * and WebViewer Server cannot be enabled.
     * @method CoreControls.Document#getPDFDoc
     * @returns {Promise<PDFNet.PDFDoc>} A promise that resolves to the PDFDoc object.
     */
    getPDFDoc(): Promise<PDFNet.PDFDoc>;
    /**
     * [XOD Document only] Sets whether offline mode is enabled or not.
     * @method CoreControls.Document#setOfflineModeEnabled
     * @param {boolean} enabled The new value for whether offline mode is enabled or not.
     */
    setOfflineModeEnabled(enabled: boolean): void;
    /**
     * [XOD Document only] Downloads the document for offline viewing.
     * @method CoreControls.Document#storeOffline
     * @param {function} onComplete The function that's called when the document has finished being downloaded or the download has been cancelled
     * @param {function(number)} onProgress The function that's called on each update in progress of the download.
     * The fraction downloaded is passed as a parameter. (eg 50% downloaded passes 0.5)
     */
    storeOffline(onComplete: (...params: any[]) => any, onProgress: (...params: any[]) => any): void;
    /**
     * Cleans up the resources associated with the document.
     * @method CoreControls.Document#unloadResources
     */
    unloadResources(): void;
    /**
     * Refresh the text data stored by the viewer.
     * Useful if the text content of the document has changed, e.g. after a redaction.
     * @method CoreControls.Document#refreshTextData
     */
    refreshTextData(): void;
    /**
     * [PDF/Office Document only] Asynchronously saves the document and provides the result as an ArrayBuffer.
     * To include annotations in the saved document, please provide an object with the xfdfString property.
     *
     * @method CoreControls.Document#getFileData
     * @param {Object} [options] An optional object containing save options and parameters.
     * @param {string} [options.xfdfString] An xfdf string containing annotation data to be used when saving. This will usually be retrieved by calling exportAnnotations on a CoreControls.AnnotationManager object.
     * @param {boolean} [options.flatten] A flag that is only useful when the xfdfString option is used. If true all the annotations in the saved document will be flattened.
     * @param {boolean} [options.finishedWithDocument] A flag specifying that the document data may be discarded by the worker after use.
     * Only use this when completely finished with document processing. When handling larger documents this can be useful to avoid memory exhaustion as only one copy of the document needs to be kept.
     * @param {boolean}  [options.printDocument] If true the saved document data will have an open action specifying that it should be printed. This is mostly only used to trigger print actions in the browser's PDF Viewer.
     * @param {string} [options.downloadType] The type to download the file as, by default this is "pdf". PDF and image files can only be downloaded as PDFs, but office files can be downloaded as "pdf" or as "office" if you want to get the original file without annotations.
     * @param {number} [options.flags] The flags with which to save the document.
     * Possible values include CoreControls.SaveOptions.REMOVE_UNUSED (remove unused objects during save) and CoreControls.SaveOptions.LINEARIZED (optimize the document for fast web view and remove unused objects). The default value is CoreControls.SaveOptions.REMOVE_UNUSED.
     * @returns {Promise<Array<any>>} a promise that resolves to an array buffer containing PDF document bytes.
     */
    getFileData(options?: {
      xfdfString?: string;
      flatten?: boolean;
      finishedWithDocument?: boolean;
      printDocument?: boolean;
      downloadType?: string;
      flags?: number;
    }): Promise<any[]>;
    /**
     * Get the document filename used for downloading.
     * @method CoreControls.Document#getFilename
     * @returns {string} filename of the document.
     */
    getFilename(): string;
    /**
     * [PDFTron Server only] Provides a URL to a the PDF with annotations and watermarks merged.
     * @method CoreControls.Document#getDownloadLink
     * @param {Object} [options] An optional object containing download options and parameters.
     * @param {string} [options.filename] The preferred name for the downloaded file on the client side. This has no effect on the backend target of the returned link, only the filename used by the browser when the link is accessed.
     * @returns {(Promise<object>|null)} Will be null if not supported. Otherwise a promise that resolves to an object with a `url` property pointing to the printable PDF.
     */
    getDownloadLink(options?: { filename?: string }): Promise<object> | null;
    /**
     * [PDF Document only] Inserts a set of pages from the provided Document before a given page number. Note that this method will need to wait for the entire file to be downloaded before the change is applied.
     * @method CoreControls.Document#insertPages
     * @param {Document} sourceDocument other document from which to take pages (cannot be the same document)
     * @param {Array<number>} pageArray array of page numbers to extract from the given document
     * @param {number} insertBeforeThisPage page number before which to insert the pages
     * @returns {Promise<object>} a promise that resolves to an object describing the updated state of the pages in the document
     */
    insertPages(sourceDocument: Document, pageArray: number[], insertBeforeThisPage: number): Promise<object>;
    /**
     * [PDF Document only] Moves the pages given in an array so they appear in sequence before a given page number. Note that this method will need to wait for the entire file to be downloaded before the change is applied.
     * @method CoreControls.Document#movePages
     * @param {Array<number>} pageArray the page numbers to move
     * @param {number} insertBeforeThisPage page number before which to insert the other pages
     * @returns {Promise<object>} a promise that resolves to an object describing the updated state of the pages in the document
     */
    movePages(pageArray: number[], insertBeforeThisPage: number): Promise<object>;
    /**
     * [PDF Document only] Removes the given page numbers. Note that this method will need to wait for the entire file to be downloaded before the change is applied.
     * @method CoreControls.Document#removePages
     * @param {Array<number>} pageArray the page numbers to remove
     * @returns {Promise<object>} a promise that resolves to an object describing the updated state of the pages in the document
     */
    removePages(pageArray: number[]): Promise<object>;
    /**
     * [PDF Document only][PDFNetJS full only] Get the updated context of a document as a PDFNet object.
     * @method CoreControls.Document#extractPDFNetLayersContext
     * @param layers layers
     * @returns {Promise<object>} a promise that resolves to a PDFNet Context object representing the current layers/OCG state.
     */
    extractPDFNetLayersContext(layers: any): Promise<object>;
    /**
     * [PDF Document only] Adds the given rotation to the given pages. Note that this method will need to wait for the entire file to be downloaded before the change is applied.
     * @method CoreControls.Document#rotatePages
     * @param {Array<number>} pageArray an array of the numbers of pages to rotate
     * @param {CoreControls.PageRotation} rotation the page rotation to add
     * @returns {Promise<object>} a promise that resolves to an object describing the updated state of the pages in the document
     */
    rotatePages(pageArray: number[], rotation: CoreControls.PageRotation): Promise<object>;
    /**
     * [PDF Document only] Extract the given pages from the document. Note that this method will need to wait for the entire file to be downloaded before the change is applied.
     * @method CoreControls.Document#extractPages
     * @param {Array<number>} pageArray an array of the page numbers to extract
     * @param {string} xfdfString an XFDF string to merge into the document before extracting
     * @returns {Promise<any>} a promise that resolves on completion
     */
    extractPages(pageArray: number[], xfdfString: string): Promise<any>;
    /**
     * [PDF Document only] Merge a file into the currently opened document
     * @method CoreControls.Document#mergeDocument
     * @param {(string|File|ArrayBuffer|Blob)} source Source parameter, path/url to document or File.
     * @param {number} [position] Optional position for where to merge the document, default to end of file if nothing entered
     * @returns {Promise<any>} a promise that resolves on completion
     */
    mergeDocument(source: string | File | ArrayBuffer | Blob, position?: number): Promise<any>;
    /**
     * [PDF Document only] Crop the given pages by the given margins. Note that this method will need to wait for the entire file to be downloaded before the change is applied.
     * @method CoreControls.Document#cropPages
     * @param {Array<number>} pageArray an array of page numbers to crop
     * @param {number} topMargin how much to crop from the top
     * @param {number} botMargin how much to crop from the bottom
     * @param {number} leftMargin how much to crop from the left
     * @param {number} rightMargin how much to crop from the right
     * @returns {Promise<object>} a promise that resolves to an object describing the updated state of the pages in the document
     */
    cropPages(
      pageArray: number[],
      topMargin: number,
      botMargin: number,
      leftMargin: number,
      rightMargin: number,
    ): Promise<object>;
    /**
     * [PDF Document only] Get an array describing the layers/OCG structure in the document.
     * Each entry in the array is a layer entry the form {obj: string, visible: boolean, name: titleString, children: [layerEntry1, layerEntry2...]}.
     * The children entry contains an array which may contain additional layer entries. Both the obj and visible are optional.
     * See the layers sample for an example of how to use getLayersArray and setLayersArray.
     * @method CoreControls.Document#getLayersArray
     * @return {Promise<Array<any>>} A promise that resolves to an array representing the layers in the PDF document
     */
    getLayersArray(): Promise<any[]>;
    /**
     * [PDF Document only] Update the array describing the layers/OCG structure in order
     * to adjust which layers should be enabled or disabled.
     * @method CoreControls.Document#setLayersArray
     * @param {Array<any>} layerContext
     * @see getLayersArray
     */
    setLayersArray(layerContext: any[]): void;
    /**
     * [PDF Document only] Set the overprint preview mode to be used when rendering
     * this document.
     * @method CoreControls.Document#setOverprintPreviewMode
     * @param mode The mode to use. Possible values are CoreControls.OverprintPreviewMode.OFF,
     * CoreControls.OverprintPreviewMode.ON and CoreControls.OverprintPreviewMode.PDFX_ON
     */
    setOverprintPreviewMode(mode: any): void;
    /**
     * Returns an object representing the transformation matrix for the page.
     * @method CoreControls.Document#getPageMatrix
     * @param {number} pageIndex The page number, zero-indexed, of the requested page.
     * @returns {object} An object representing the page matrix.
     */
    getPageMatrix(pageIndex: number): any;
    /**
     * Returns the internal degrees of rotation of a page.
     * @method CoreControls.Document#getPageRotation
     * @param {number} pageIndex The page number, zero-indexed, of the requested page.
     * @returns {number} The internal degrees of rotation of a page. (0, 90, 180 or 270)
     */
    getPageRotation(pageIndex: number): number;
    /**
     * @method CoreControls.Document#documentCompletePromise
     * @returns {Promise<any>} A promise that resolves when all of the page information is available for the document
     */
    documentCompletePromise(): Promise<any>;
    /**
     * [PDF Document only] Inserts blank pages before the given list of pages. Both width and height are in units of PDF points.
     * @method CoreControls.Document#insertBlankPages
     * @param {Array<number>} insertBeforeThesePages array of page numbers before which to insert blanks
     * @param {number} width width of the blank pages to insert. By default the width is 612 PDF points.
     * @param {number} height height of the blank pages to insert. By default the height is 792 PDF points.
     * @returns {Promise<object>} a promise that resolves to an object with info for any pages inserted
     */
    insertBlankPages(insertBeforeThesePages: number[], width: number, height: number): Promise<object>;
    /**
     * [PDF Document only] Returns whether the document is linearized or not.
     * Note that this only works for documents that are loaded by URL and if useDownloader is not set to false.
     * @method CoreControls.Document#isLinearized
     * @returns {boolean} Whether the document is linearized or not
     */
    isLinearized(): boolean;
    /**
     * Sets watermark to be added to the document
     * @method CoreControls.Document#setWatermark
     * @param {object} options Object that contains style/content of the watermark
     * @example
     * doc.setWatermark({
     *   diagonal: {
     *     fontSize: (number),
     *     fontFamily: (string),
     *     color: (string),
     *     opacity: (number),
     *     text: (string)
     *   },
     *   header: {
     *     fontSize: (number),
     *     fontFamily: (string),
     *     color: (string),
     *     opacity: (number),
     *     left: (string),
     *     center: (string),
     *     right: (string)
     *   },
     *   footer: {
     *     fontSize: (number),
     *     fontFamily: (string),
     *     color: (string),
     *     opacity: (number),
     *     left: (string),
     *     center: (string),
     *     right: (string)
     *   }
     *   custom: (function(ctx, pageIndex, pageWidth, pageHeight))
     * });
     *
     * To allow more customization of the header/footer, the following can be done:
     *
     * doc.setWatermark({
     * diagonal: {
     *   fontSize: (number),
     *   fontFamily: (string),
     *   color: (string),
     *   opacity: (number),
     *   text: (string)
     * },
     * headerLeft: {
     *   fontSize: (number),
     *   fontFamily: (string),
     *   color: (string),
     *   opacity: (number),
     *   text: (string)
     * },
     * headerCenter: {
     *   fontSize: (number),
     *   fontFamily: (string),
     *   color: (string),
     *   opacity: (number),
     *   text: (string)
     * },
     * headerRight: {
     *   fontSize: (number),
     *   fontFamily: (string),
     *   color: (string),
     *   opacity: (number),
     *   text: (string)
     * },
     * footerLeft: {
     *   fontSize: (number),
     *   fontFamily: (string),
     *   color: (string),
     *   opacity: (number),
     *   text: (string)
     * },
     * footerCenter: {
     *   fontSize: (number),
     *   fontFamily: (string),
     *   color: (string),
     *   opacity: (number),
     *   text: (string)
     * },
     * footerRight: {
     *   fontSize: (number),
     *   fontFamily: (string),
     *   color: (string),
     *   opacity: (number),
     *   text: (string)
     * },
     * custom: (function(ctx, pageIndex, pageWidth, pageHeight))
     * });
     */
    setWatermark(options: any): void;
    /**
     * [PDF Document only] Enables or disables the color separations feature for rendering.
     * @method CoreControls.Document#enableColorSeparations
     * @param {boolean} enabled Whether to enable or disable color separations rendering.
     */
    enableColorSeparations(enabled: boolean): void;
    /**
     * [PDF Document only] Gets the color separations available on this document.
     * @method CoreControls.Document#getColorSeparations
     * @returns {Array<any>} The color separations of the document
     */
    getColorSeparations(): any[];
    /**
     * [PDF Document only] Enables or disables the rendering of a particular color separation.
     * @method CoreControls.Document#enableSeparation
     * @param {string} name The name of the separation
     * @param {boolean} enabled Whether to enable or disable the separation
     */
    enableSeparation(name: string, enabled: boolean): void;
    /**
     * Only available on documents of type 'video. Returns the instance of {@link Video} associated with the document.
     * @method CoreControls.Document#getVideo
     * @returns {object} the instance of {@link Video} associated with the document.
     */
    getVideo(): any;
  }
  namespace Document {
    /**
     * @typedef {Object} CoreControls.Document.PageInfo
     * @property {number} width The width of the page
     * @property {number} height The height of the page
     */
    type PageInfo = {
      width: number;
      height: number;
    };
    /**
     * The callback to call when the Document has been initialized. If there is an error then an error object will be passed to the callback function.
     * @callback LoadAsyncCallback
     * @memberof CoreControls.Document
     * @param {Object} [error] The error that occurs when initializing the document
     */
    type LoadAsyncCallback = (error?: any) => void;
    /**
     * @typedef {Object} CoreControls.Document.XFDFInfo
     * @property {string} xfdfString The XFDF string
     * @property {Array<number>} pages Array of page numbers that annotations were extracted from
     */
    type XFDFInfo = {
      xfdfString: string;
      pages: number[];
    };
  }
  /**
   * Represents the different save option values that you can use in the getFileData function.
   * @name CoreControls.SaveOptions
   * @property {number} INCREMENTAL Saves new data to the end of the file
   * @property {number} REMOVE_UNUSED Removes unused data when saving
   * @property {number} HEX_STRINGS Save strings in hexadecimal format
   * @property {number} OMIT_XREF Do not save cross reference table
   * @property {number} LINEARIZED Optimize data for speed and remove unused data
   * @property {number} COMPATIBILITY Maximize compatibility with older PDF consumers (e.g. the file will not use object and compressed XREF streams)
   */
  var SaveOptions: {
    INCREMENTAL: number;
    REMOVE_UNUSED: number;
    HEX_STRINGS: number;
    OMIT_XREF: number;
    LINEARIZED: number;
    COMPATIBILITY: number;
  };
  /**
   * Creates a new empty DocumentViewer.
   * @class Represents a full-featured control used for displaying a Document. The viewer supports text selection and text search, and several page view modes.
   * @name DocumentViewer
   * @memberof CoreControls
   * @extends EventHandler
   * @property {object} defaults Default values for document viewer. Set FitMode, DisplayMode or Zoom.
   */
  class DocumentViewer extends EventHandler {
    /**
     * Search modes that control how searching is conducted.
     * @name CoreControls.DocumentViewer#SearchMode
     * @property {number} e_case_sensitive If set, the found text must match the case of the search term.
     * @property {number} e_whole_word If set, the found text must be a whole word (preceeded and followed by a non-alphabetical character, or in the case of a number, a non-numerical character.
     * @property {number} e_search_up If set, the document pages will be searched in descending order, from bottom to top.
     * @property {number} e_page_stop If set, the search will return with a result code of Page at the end of every page. Useful for updating the UI.
     * @property {number} e_highlight If set, the bounding box the found term will be included. Useful for highlighting text and positioning the page.
     * @property {number} e_ambient_string If set, the characters surrounding the found term will be included. This gives context to the search result may be useful when providing a list of search results.
     */
    SearchMode: {
      e_case_sensitive: number;
      e_whole_word: number;
      e_search_up: number;
      e_page_stop: number;
      e_highlight: number;
      e_ambient_string: number;
    };
    /**
     * Enum for snap mode values. Snap modes control which point within the page is considered as the queried point.
     * @name CoreControls.DocumentViewer#SnapMode
     * @property {number} e_DefaultSnapMode
     * @property {number} e_PointOnLine
     * @property {number} e_LineMidpoint
     * @property {number} e_LineIntersection
     * @property {number} e_PathEndpoint
     */
    SnapMode: {
      e_DefaultSnapMode: number;
      e_PointOnLine: number;
      e_LineMidpoint: number;
      e_LineIntersection: number;
      e_PathEndpoint: number;
    };
    /**
     * This function must be called after modifying the ScrollView (#DocumentViewer) element's dimensions or properties.
     * @method CoreControls.DocumentViewer#scrollViewUpdated
     */
    scrollViewUpdated(): void;
    /**
     * Reinitializes data and clears the viewer area content.
     * @method CoreControls.DocumentViewer#closeDocument
     */
    closeDocument(): void;
    /**
     * Request a recalculation of page layout and rerender all pages. For use when modifying the underlying Document without using the provided page modification functions (cropPages, rotatePages...)
     * @method CoreControls.DocumentViewer#recalculateLayout
     * @param {Array<number>} pagesToRecalculate An array of page numbers (1-indexed) that should be recalculated
     */
    recalculateLayout(pagesToRecalculate: number[]): void;
    /**
     * Initialize the viewer and load a .xod document into the viewer.
     * @method CoreControls.DocumentViewer#loadAsync
     * @param {PartRetrievers.HttpPartRetriever|PartRetrievers.LocalPartRetriever|PartRetrievers.StreamingPartRetriever} partRetriever An instance of PartRetriever.
     * @param {object} options An object that can contain the following optional parameters
     * @param {string} [options.type] The type of document being loaded. Values are xod, pdf, office, blackbox. Default is xod.
     * @param {string} [options.docId] An optional unique identifier for the document, used for offline mode
     * @param {function} [options.onError] A callback of the form function(err) which will be called when a loading error occurs.
     * @param {Promise<void>} [options.workerTransportPromise] Required for PDF viewing. A promise that will be resolved when a worker transport has been initialized. This can be created by calling CoreControls.initializeWorkerTransport
     * @param {function} [options.getPassword] An method of the form function(callback) where callback is of the form function(password). getPassword will be called when a password is required to load a PDF document and should call the callback with the retrieved password.
     * @param {string} [options.extension] An field used to specify the type of file being read. This is only relevant for PDF viewing and at the moment only works for certain image formats and .pdf
     * @param {string} [options.licenseKey] The license key to use. Only necessary for client side and WebViewer Server rendering.
     */
    loadAsync(
      partRetriever:
        | PartRetrievers.HttpPartRetriever
        | PartRetrievers.LocalPartRetriever
        | PartRetrievers.StreamingPartRetriever,
      options: {
        type?: string;
        docId?: string;
        onError?: (...params: any[]) => any;
        workerTransportPromise?: Promise<void>;
        getPassword?: (...params: any[]) => any;
        extension?: string;
        licenseKey?: string;
      },
    ): void;
    /**
     * Initialize the viewer and load the given file into the viewer.
     * @method CoreControls.DocumentViewer#loadDocument
     * @param {(string|File|ArrayBuffer|Blob)} source - Source parameter, path/url to document or File.
     * @param {object} [options]  - An object that can contain the following optional parameters.
     * @param {string} [options.l] - The license key for viewing PDF or Office files (PDF/Office only).
     * @param {string} [options.docId] An unique identifier for the document, used for offline mode.
     * @param {function} [options.onLoadingProgress] - A callback function for loading progress, function signature function(percent) {}.
     * @param {function} [options.onError] - A callback function that will be called when error occurs in the process of loading a document. function signature function(e) {}
     * @param {Promise<any>} [options.workerTransportPromise] - The workerTransportPromise that should be used to load the document.
     * @param {string|function} [options.password] -  A password string or a function of the form function(callback) where callback is of the form function(password). This 'password' function will be called when a password is required to load a PDF document and should call the callback with the retrieved password.
     * @param {string} [options.filename] - A filename that is used for the downloaded file, and for determining the extension when options.extension isn't used.
     * @param {string} [options.extension] - Used for specifying the extension of the document to be loaded. This is necessary if the URL/path does not contain the file extension or if you're loading a Blob/File.
     * @param {object} [options.customHeaders] - An object containing custom HTTP headers to use when retrieving the document from the specified url. For example: {'Authorization' : 'Basic dXNlcm5hbWU6cGFzc3dvcmQ='}.
     * @param {boolean} [options.useDownloader] - A boolean indicating whether Downloader should be used on urls (PDF only). https://www.pdftron.com/documentation/web/guides/usedownloader-option/.
     * @param {boolean} [options.withCredentials] - Whether to set the withCredentials property on the XMLHttpRequest.
     * @param {Array<object>} [options.pageSizes] - An array of objects in the shape of { width: number, height: number }. Used to determine the page sizes when loading an image file.
     * @param {string} [options.backendType] - A string representing the "backend type" for rendering PDF documents. Pass "ems" to force the use of the ASM.js/WebAssembly worker and "pnacl" for the "PNaCl" worker.
     * @param {object} [options.xodOptions] - An object that contains the options for a XOD document.
     * @param {boolean} [options.xodOptions.decrypt] - Function to be called to decrypt a part of the XOD file. For default XOD AES encryption pass CoreControls.Encryption.decrypt.
     * @param {boolean} [options.xodOptions.decryptOptions] -  An object with options for the decryption e.g. {p: "pass", type: "aes"} where is p is the password.
     * @param {boolean} [options.xodOptions.streaming] - A boolean indicating whether to use http or streaming PartRetriever, it is recommended to keep streaming false for better performance. https://www.pdftron.com/documentation/web/guides/streaming-option.
     * @param {boolean} [options.xodOptions.azureWorkaround] - Whether or not to workaround the issue of Azure not accepting range requests of a certain type. Enabling the workaround will add an extra HTTP request of overhead but will still allow documents to be loaded from other locations.
     * @param {boolean} [options.xodOptions.startOffline] - Whether to start loading the document in offline mode or not. This can be set to true if the document had previously been saved to an offline database using WebViewer APIs. You'll need to use this option to load from a completely offline state.
     * @param {string} [options.pdftronServer] - A URL to the WebViewer server drop-in backend https://www.pdftron.com/documentation/web/guides/wv-server-deployment.
     * @param {string} [options.cacheKey] - A key that will be used for caching the document on WebViewer Server.
     * @param {boolean} [options.forceClientSideInit] - If set to true then when loading a document using WebViewer Server the document will always switch to client only rendering allowing page manipulation and the full API to be used.
     * @returns {Promise<void>} A promise that resolves when the document is finished loading
     */
    loadDocument(
      source: string | File | ArrayBuffer | Blob,
      options?: {
        l?: string;
        docId?: string;
        onLoadingProgress?: (...params: any[]) => any;
        onError?: (...params: any[]) => any;
        workerTransportPromise?: Promise<any>;
        password?: string | ((...params: any[]) => any);
        filename?: string;
        extension?: string;
        customHeaders?: any;
        useDownloader?: boolean;
        withCredentials?: boolean;
        pageSizes?: object[];
        backendType?: string;
        xodOptions?: {
          decrypt?: boolean;
          decryptOptions?: boolean;
          streaming?: boolean;
          azureWorkaround?: boolean;
          startOffline?: boolean;
        };
        pdftronServer?: string;
        cacheKey?: string;
        forceClientSideInit?: boolean;
      },
    ): Promise<void>;
    /**
     * Gets a promise that resolves when the annotations in the current document have all been loaded
     * @method CoreControls.DocumentViewer#getAnnotationsLoadedPromise
     * @returns {Promise<any>} Promise that resolves when the annotations in the current document have loaded.
     */
    getAnnotationsLoadedPromise(): Promise<any>;
    /**
     * Gets the scrollview element that is being used by DocumentViewer
     * @method CoreControls.DocumentViewer#getScrollViewElement
     * @returns {Element} The scrollview DOM element that DocumentViewer appends pages
     */
    getScrollViewElement(): Element;
    /**
     * Sets the scrollview element that DocumentViewer will append rendered pages to.
     * @method CoreControls.DocumentViewer#setScrollViewElement
     * @param {Element} scrollViewElement The scrollview DOM element to be used
     */
    setScrollViewElement(scrollViewElement: Element): void;
    /**
     * Gets the viewer element that is being used by DocumentViewer
     * @method CoreControls.DocumentViewer#getViewerElement
     * @returns {Element} The viewer DOM element that DocumentViewer appends pages
     */
    getViewerElement(): Element;
    /**
     * Sets the viewer element that DocumentViewer will append rendered pages to.
     * @method CoreControls.DocumentViewer#setViewerElement
     * @param {Element} viewerElement The viewer DOM element to be used
     */
    setViewerElement(viewerElement: Element): void;
    /**
     * Disposes the current document's data
     * @method CoreControls.DocumentViewer#dispose
     */
    dispose(): void;
    /**
     * Get the current height of the specified page, taking into account rotation.
     * @method CoreControls.DocumentViewer#getPageHeight
     * @param {number} pageIndex The page index
     * @returns {number} The height of the page
     */
    getPageHeight(pageIndex: number): number;
    /**
     * Get the current width of the specified page, taking into account rotation.
     * @method CoreControls.DocumentViewer#getPageWidth
     * @param {number} pageIndex The page index
     * @returns {number} The width of the page
     */
    getPageWidth(pageIndex: number): number;
    /**
     * Returns the AnnotationManager used by this DocumentViewer
     * @method CoreControls.DocumentViewer#getAnnotationManager
     * @returns {AnnotationManager} an instance of AnnotationManager
     */
    getAnnotationManager(): AnnotationManager;
    /**
     * Returns the AnnotationHistoryManager used by this DocumentViewer
     * @method CoreControls.DocumentViewer#getAnnotationHistoryManager
     * @returns {AnnotationHistoryManager} an instance of AnnotationHistoryManager
     */
    getAnnotationHistoryManager(): AnnotationHistoryManager;
    /**
     * Set the options that are used when importing annotations from a document asynchronously.
     * These are the options that will be passed to AnnotationManager.importAnnotations.
     * @method CoreControls.DocumentViewer#setAnnotationImportOptions
     * @param {object} options The options for importing
     * @param options.batchSize {number} The number of annotations to import in each batch
     * @param options.batchDelay {number} The amount of time in milliseconds to delay between importing each batch
     */
    setAnnotationImportOptions(options: { batchSize: number; batchDelay: number }): void;
    /**
     * Sets whether annotations should only be loaded from the visible pages and removed when a page is no longer visible.
     * Note that when enabling this option only annotations on the visible pages will be exported or included in the downloaded document
     * @method CoreControls.DocumentViewer#setLoadAnnotationsFromVisiblePages
     * @param {boolean} val Whether the option should be enabled or not
     */
    setLoadAnnotationsFromVisiblePages(val: boolean): void;
    /**
     * Allows you to transform (or replace) the internal annotations of the document. Note that to handle annotations using PDFNetJS without useDownloader: false you will also want to call setPagesUpdatedInternalAnnotationsTransform
     * @method CoreControls.DocumentViewer#setInternalAnnotationsTransform
     * @param {function} handler A handler function that takes annotation data as the first parameter and a callback that is called when the transformed data is ready as the second parameter
     */
    setInternalAnnotationsTransform(handler: (...params: any[]) => any): void;
    /**
     * Allows you to transform (or replace) the internal annotations of the document when pages receive an update event. This includes when using PDFNetJS with downloader enabled (default) on a linearized document. For completeness you will also want to call setInternalAnnotationsTransform.
     * @method CoreControls.DocumentViewer#setPagesUpdatedInternalAnnotationsTransform
     * @param {function} handler A handler function that takes annotation data as the first parameter, an array of updated page numbers as a second parameter and a callback that is called when the transformed data is ready as a third parameter
     */
    setPagesUpdatedInternalAnnotationsTransform(handler: (...params: any[]) => any): void;
    /**
     * Sets the callback function that will be called when a page is newly visible in the viewer.
     * @method CoreControls.DocumentViewer#setPageVisibilityCallback
     * @param {function} callback A function that takes in a page number indicating the page that is now visible
     */
    setPageVisibilityCallback(callback: (...params: any[]) => any): void;
    /**
     * Returns the DisplayModeManager used by this DocumentViewer
     * @method CoreControls.DocumentViewer#getDisplayModeManager
     * @returns {DisplayModeManager} an instance of DisplayModeManager
     */
    getDisplayModeManager(): DisplayModeManager;
    /**
     * Returns the path coordinate within the page that is closest to the queried point.
     * @method CoreControls.DocumentViewer#snapToNearest
     * @param {number} pageNumber The page number the point is on
     * @param {number} x The x position to calculate the snap point from
     * @param {number} y The y position to calculate the snap point from
     * @param {number} [mode] Enum for an optional snapping mode for the snapping
     * @returns {Promise<any>} A promise that resolves to an object with x and y properties representing the nearest path point
     */
    snapToNearest(pageNumber: number, x: number, y: number, mode?: number): Promise<any>;
    /**
     * Sets the number of pages that will be visible on each canvas. Only valid in viewport canvas mode.
     * @method CoreControls.DocumentViewer#setPagesPerCanvas
     * @param {number} numPages
     * @param {boolean} isCover
     */
    setPagesPerCanvas(numPages: number, isCover: boolean): void;
    /**
     * Sets specific DocumentViewer options.
     * @method CoreControls.DocumentViewer#setOptions
     * @param {object} options An options object, currently valid options are enableAnnotations and annotMode
     */
    setOptions(options: any): void;
    /**
     * Returns the current zoom level
     * @method CoreControls.DocumentViewer#getZoom
     * @returns {number} The current zoom level.
     */
    getZoom(): number;
    /**
     * Returns a pixel value, representing the left, right, top and bottom margins.
     * @method CoreControls.DocumentViewer#getMargin
     * @returns {number} The margin value.
     */
    getMargin(): number;
    /**
     * Set the pixel value to use for the left, right, top and bottom margins.
     * @method CoreControls.DocumentViewer#setMargin
     * @param {number} margin The margin value to set.
     */
    setMargin(margin: number): void;
    /**
     * Returns the text selected by text selection tool or search.
     * @method CoreControls.DocumentViewer#getSelectedText
     * @param {number} [pageNumber] Optionally pass the 1-indexed page number
     * @returns {string} Selected text.
     */
    getSelectedText(pageNumber?: number): string;
    /**
     * Returns the quads of the text selected by text selection tool or search.
     * @method CoreControls.DocumentViewer#getSelectedTextQuads
     * @param {number} [pageNumber] Optionally pass the 1-indexed page number
     * @returns {object} Selected text quads.
     */
    getSelectedTextQuads(pageNumber?: number): any;
    /**
     * Sets the color to use when highlighting text from text selection.
     * @method CoreControls.DocumentViewer#setTextHighlightColor
     * @param {string} color The color to set.  eg 'rgba(0, 0, 200, 0.3)'
     */
    setTextHighlightColor(color: string): void;
    /**
     * Sets the color to use when highlighting text from searching.
     * @method CoreControls.DocumentViewer#setSearchHighlightColors
     * @param {object} colorOptions An object with searchResult or activeSearchResult properties
     * set as a color eg 'rgba(0, 0, 200, 0.5)'
     * @example
     * docViewer.setSearchHighlightColors({
     *   searchResult: 'rgba(255, 0, 0, 0.5)',
     *   activeSearchResult: 'rgba(0, 255, 0, 0.5)'
     * });
     */
    setSearchHighlightColors(colorOptions: any): void;
    /**
     * Returns the current tool.
     * @method CoreControls.DocumentViewer#getToolMode
     * @returns {Tools.Tool} The current tool.
     */
    getToolMode(): Tools.Tool;
    /**
     * Returns the tool mode map object.
     * @method CoreControls.DocumentViewer#getToolModeMap
     * @returns {object} The tool mode map object.
     */
    getToolModeMap(): any;
    /**
     * Returns a specific tool from the tool mode map.
     * @method CoreControls.DocumentViewer#getTool
     * @param {string|Tools.ToolNames} Name of the tool. eg 'AnnotationEdit'
     * @returns {object} The tool mode map object.
     */
    getTool(Name: string | Tools.ToolNames): any;
    /**
     * Returns the current viewing rotation.
     * @method CoreControls.DocumentViewer#getRotation
     * @param {number} [pageNumber] Optionally pass the page number to get the specific page's rotation
     * @returns {CoreControls.PageRotation} The current viewing rotation.
     * @example PageRotation['e_0'] = 0 (0 degress) <br/>
     * PageRotation['e_90'] = 1 (90 degress) <br/>
     * PageRotation['e_180'] = 2 (180 degress) <br/>
     * PageRotation['e_270'] = 3 (270 degress) <br/>
     */
    getRotation(pageNumber?: number): CoreControls.PageRotation;
    /**
     * Returns the complete rotation of the page including the document's rotation.
     * @method CoreControls.DocumentViewer#getCompleteRotation
     * @param {number} pageNumber The page number to get that page's rotation
     * @returns {CoreControls.PageRotation} The current complete rotation.
     */
    getCompleteRotation(pageNumber: number): CoreControls.PageRotation;
    /**
     * Sets the current viewing rotation.
     * @method CoreControls.DocumentViewer#setRotation
     * @param {CoreControls.PageRotation} pageRotation desired viewing rotation.
     * @param {number} [pageNumber] Optionally pass the page number to set the specific page's rotation
     */
    setRotation(pageRotation: CoreControls.PageRotation, pageNumber?: number): void;
    /**
     * Sets the individual page rotations of multiple pages at once. Pages that aren't specified will
     * use the default document rotation.
     * @method CoreControls.DocumentViewer#setPageRotations
     * @param {object} rotations An object with keys that are page indexes (0-indexed) and values that are rotation values.
     * Rotations should be specified as {CoreControls.PageRotation}s
     */
    setPageRotations(rotations: any): void;
    /**
     * Gets the individual page rotations of the document. Only returns pages that have been rotated individually.
     * @method CoreControls.DocumentViewer#getPageRotations
     * @returns {object} An object with keys that are page indexes (0-indexed) and values that are rotation values.
     */
    getPageRotations(): any;
    /**
     * Returns the Document that is currently being displayed by the viewer.
     * @method CoreControls.DocumentViewer#getDocument
     * @returns {CoreControls.Document} returns the current document.
     */
    getDocument(): CoreControls.Document;
    /**
     * Returns the current viewport rendering region if viewport rendering is enabled.
     * @method CoreControls.DocumentViewer#getViewportRegionRect
     * @param {number} pageIndex The page index
     * @returns {object} returns the current viewport rendering region
     */
    getViewportRegionRect(pageIndex: number): any;
    /**
     * Returns the current fit mode.
     * @method CoreControls.DocumentViewer#getFitMode
     * @returns {CoreControls.DocumentViewer.FitMode} The current fit mode.
     */
    getFitMode(): CoreControls.DocumentViewer.FitMode;
    /**
     * Returns the page rendering order.
     * @method CoreControls.DocumentViewer#getRightToLeftPages
     * @returns {boolean} The current page rendering order.
     */
    getRightToLeftPages(): boolean;
    /**
     * Sets the page rendering order.
     * @method CoreControls.DocumentViewer#setRightToLeftPages
     * @param {boolean} rightToLeftPages Whether the new page rendering order should be right to left or not.
     */
    setRightToLeftPages(rightToLeftPages: boolean): void;
    /**
     * If the boomark is an internal link then it scrolls the viewer so that the position of the bookmark is in the upper-left corner of the viewer.
     * If it's an external URL then it opens the URL.
     * @method CoreControls.DocumentViewer#displayBookmark
     * @param {Bookmark} bookmark A bookmark that specifies the location to go to. Returned by {@link CoreControls.Document#getBookmarks}.
     */
    displayBookmark(bookmark: Bookmark): void;
    /**
     * Display the specified page location in the viewer
     * @method CoreControls.DocumentViewer#displayPageLocation
     * @param {number} pageNumber The page number the location is on
     * @param {number} horizontalPosition The horizontal position from the left of the page
     * @param {number} verticalPostion The vertical position from the top of the page
     * @param {boolean} [doNotJumpIfInView] If true then if the page location is currently in view don't cause the viewer to shift
     */
    displayPageLocation(
      pageNumber: number,
      horizontalPosition: number,
      verticalPostion: number,
      doNotJumpIfInView?: boolean,
    ): void;
    /**
     * Searches for a particular text string on the currently displayed Document, starting on the current page unless otherwise specified.
     * @method CoreControls.DocumentViewer#textSearchInit
     * @param {string} pattern The text to search for.
     * @param {number} mode The options for search, controlling options such as case sensitivity and search direction.
     * @see CoreControls.DocumentViewer#SearchMode
     * @param {object} [options] An object that can contain the following optional parameters
     * @param {boolean} [options.fullSearch] If true, a search of the entire document will be performed. Otherwise, a single search will be performed.
     * @param {function} [options.onResult] (result) The callback function that is called when the search returns a result.
     * @param {function} [options.onPageEnd] (result) The callback function that is called when reaching the end of the page (if using page_stop mode).
     * @param {function} [options.onDocumentEnd] (result) The callback function that is called when reaching the end of the document.
     * @param {number} [options.startPage] Page to start the search on (1-indexed).
     * @param {number} [options.endPage] Page to end the search on inclusively (1-indexed).
     * The search may complete when the search term is found, when the entire document has been searched, and, depending on the search options, at the end of every page. Parameter result: {@link DocumentViewer.SearchResults}.
     */
    textSearchInit(
      pattern: string,
      mode: number,
      options?: {
        fullSearch?: boolean;
        onResult?: (...params: any[]) => any;
        onPageEnd?: (...params: any[]) => any;
        onDocumentEnd?: (...params: any[]) => any;
        startPage?: number;
        endPage?: number;
      },
    ): void;
    /**
     *   The code indicating the reason that the search process concluded.
     *   @name SearchResults
     *   @memberof CoreControls.DocumentViewer
     *   @property {string} ambient_str The text surrounding the result string.
     *   @property {string} result_str The found text.
     *   @property {number} result_str_start The index in ambient string where the result string starts.
     *   @property {number} result_str_end The index in ambient string where the result string end.
     *   @property {number} page_num The page number which the search was conducted on.
     *   @property {number} resultCode The reason the search completed.
     *   @property {object} quads A list of Quads, representing the bounding box(es) of the found text. Useful for highlighting the text.
     */
    static SearchResults: {
      ambient_str: string;
      result_str: string;
      result_str_start: number;
      result_str_end: number;
      page_num: number;
      resultCode: number;
      quads: any;
    };
    /**
     * Scrolls the viewer so that the position of the search result is in the middle of the viewer.
     * @method CoreControls.DocumentViewer#displaySearchResult
     * @param {object} result The result of a search, {@link DocumentViewer.SearchResults}. Returned by onResult in {@link CoreControls.DocumentViewer#textSearchInit}.
     * @param {function} jump The callback for navigating to the found result.
     */
    displaySearchResult(result: any, jump: (...params: any[]) => any): void;
    /**
     * Displays the new search result without clearing previous results
     * @method CoreControls.DocumentViewer#displayAdditionalSearchResult
     * @param {object} result The result of a search, {@link DocumentViewer.SearchResults}. Returned by onResult in {@link CoreControls.DocumentViewer#textSearchInit}.
     */
    displayAdditionalSearchResult(result: any): void;
    /**
     * Sets the active search result, causing it to be displayed as a different color and visible on the screen.
     * @method CoreControls.DocumentViewer#setActiveSearchResult
     * @param {Object} result The result of a search, {@link DocumentViewer.SearchResults}. Returned by onResult in {@link CoreControls.DocumentViewer#textSearchInit}.
     */
    setActiveSearchResult(result: any): void;
    /**
     * Clears all search results from the viewer
     * @method CoreControls.DocumentViewer#clearSearchResults
     */
    clearSearchResults(): void;
    /**
     * Draws the text selection for the specified page. Should be called after calling
     * AnnotationManager's drawAnnotations function if the selection should still be shown.
     * @method CoreControls.DocumentViewer#drawSelection
     * @param {number} pageNumber The page number to draw the selection on
     */
    drawSelection(pageNumber: number): void;
    /**
     * Selects the text content of the document given two page coordinates.
     * @method CoreControls.DocumentViewer#select
     * @param pt1 Starting page coordinate. Requires properties x, y and pageIndex.
     * @param pt2 Ending page coordinate. Requires properties x, y and pageIndex.
     */
    select(pt1: any, pt2: any): void;
    /**
     * Clears any selected text on the all pages.
     * @method CoreControls.DocumentViewer#clearSelection
     */
    clearSelection(): void;
    /**
     * Gets the color separation values for the specified point. The x and y values should be in page coordinates.
     * @method CoreControls.DocumentViewer#getColorSeparationsAtPoint
     * @param {number} pageNumber The page number of the point
     * @param {number} x The x value of the point
     * @param {number} y The y value of the point
     * @returns {Array<any>} A list of objects which each have the name of the separation and the saturation percentage of the color at the point [{ name, value }, ...]
     */
    getColorSeparationsAtPoint(pageNumber: number, x: number, y: number): any[];
    /**
     * Sets the tool mode. Also removes selection caused by text selection or search.
     * @method CoreControls.DocumentViewer#setToolMode
     * @param {Tools.Tool} tool An instance of the toolmode
     */
    setToolMode(tool: Tools.Tool): void;
    /**
     * Sets how the document will scale to fit the size of the scrollviewer's viewport.
     * Also re-renders content to the appropriate zoom level.
     * Only renders if a document has been loaded.
     * @method CoreControls.DocumentViewer#setFitMode
     * @param {DocumentViewer.FitMode} fitMode
     */
    setFitMode(fitMode: DocumentViewer.FitMode): void;
    /**
     * Rotates all pages in the currently displayed document clockwise by 90 degrees.
     * @method CoreControls.DocumentViewer#rotateClockwise
     * @param {number} [pageNumber] Optionally pass the page number to rotate only a specific page
     */
    rotateClockwise(pageNumber?: number): void;
    /**
     * Rotates all pages in the currently displayed document counter-clockwise by 90 degrees.
     * @method CoreControls.DocumentViewer#rotateCounterClockwise
     * @param {number} [pageNumber] Optionally pass the page number to rotate only a specific page
     */
    rotateCounterClockwise(pageNumber?: number): void;
    /**
     * Adjusts the viewer's zoom factor, and positions the point (x,y) at the upper left corner of the viewer.
     * Only renders if a document has been loaded.
     * @method CoreControls.DocumentViewer#zoomTo
     * @param {number} zoom Zoom value.
     * @param {number} [x] Horizontal position to scroll to.
     * @param {number} [y] Vertical position to scroll to.
     */
    zoomTo(zoom: number, x?: number, y?: number): void;
    /**
     * Adjusts the viewer's zoom factor and positions the point on the document under the mouse at the same position
     * after zooming in.
     * @method CoreControls.DocumentViewer#zoomToMouse
     * @param {number} zoom Zoom value
     * @param {number} offsetX The x offset from the mouse position to the viewer's position (e.g. taking into account toolbars)
     * @param {number} offsetY The y offset from the mouse position to the viewer's position (e.g. taking into side panels)
     */
    zoomToMouse(zoom: number, offsetX: number, offsetY: number): void;
    /**
     * Get the zoom value for a particular page.
     * @method CoreControls.DocumentViewer#getPageZoom
     * @param {number} pageIndex The page index.
     */
    getPageZoom(pageIndex: number): void;
    /**
     * Sets the zoom for a particular page. Should be followed by a call to updateView to actually render the page.
     * @method CoreControls.DocumentViewer#setPageZoom
     * @param {number} pageIndex The page index.
     * @param {number} zoom Zoom value for page.
     */
    setPageZoom(pageIndex: number, zoom: number): void;
    /**
     * Removes all the page content from the DOM.
     * Also clear the cache if the zoom or rotation has changed.
     * @method CoreControls.DocumentViewer#removeContent
     * @param {boolean} removeData Whether or not to remove all event handlers and data on the elements
     * @param {boolean} rotationChanged
     * @param {boolean} isZoomChanged
     */
    removeContent(removeData: boolean, rotationChanged: boolean, isZoomChanged: boolean): void;
    /**
     * Sets the current page. Updates the current page and jumps to it.
     * @method CoreControls.DocumentViewer#setCurrentPage
     * @param {number} pageNumber The page number to jump to.
     */
    setCurrentPage(pageNumber: number): void;
    /**
     * Returns the current page number.
     * @method CoreControls.DocumentViewer#getCurrentPage
     * @returns {number} The current 1-indexed page number.
     */
    getCurrentPage(): number;
    /**
     * Returns the number of pages in a document.
     * @method CoreControls.DocumentViewer#getPageCount
     * @returns {number} The number of the pages in the current document.
     */
    getPageCount(): number;
    /**
     * Scrolls the viewer so that the upper-left corner of the Document's last page is in the upper-left corner of the viewer.
     * @method CoreControls.DocumentViewer#displayLastPage
     */
    displayLastPage(): void;
    /**
     * Scrolls the viewer so that the upper-left corner of the Document's first page is in the upper-left corner of the viewer.
     * @method CoreControls.DocumentViewer#displayFirstPage
     */
    displayFirstPage(): void;
    /**
     * Returns the canvas so that it can be reused.  Should be called when the canvas is no longer used by the viewer.
     * Only valid in viewport canvas mode.
     * @method CoreControls.DocumentViewer#returnCanvas
     * @param {number} pageIndex The page index of the canvas
     * @param {object} canvas The canvas element to return
     */
    returnCanvas(pageIndex: number, canvas: any): void;
    /**
     * Invalidates the rendering cache for all pages
     * @method CoreControls.DocumentViewer#refreshAll
     */
    refreshAll(): void;
    /**
     * Invalidates the rendering cache for the specified page
     * @method CoreControls.DocumentViewer#refreshPage
     * @param {number} pageNumber The page number of the page (1-indexed)
     */
    refreshPage(pageNumber: number): void;
    /**
     * Updates old xod (version <= 1.2) link annotations in the annotation manager
     * @method CoreControls.DocumentViewer#updateLinks
     * @param {number} pageIndex The zero-indexed page number to update
     */
    updateLinks(pageIndex: number): void;
    /**
     * Removes previously drawn pages that are no longer visible and
     * draws pages that are visible and have not been drawn.
     * If visiblePages are provided then those pages are rendered otherwise visiblePages are calculated
     * depending on where the DIV elements for the pages are located.
     * @method CoreControls.DocumentViewer#updateView
     * @param {Object} visiblePages An array of integers representing the pages to render.
     * @param {number} currentPageIndex The index of the page that is currently visible in the viewer.
     */
    updateView(visiblePages: any, currentPageIndex: number): void;
    /**
     * Notifies the document viewer that the visible pages have changed
     * but does not draw any pages.
     * @method CoreControls.DocumentViewer#updateVisiblePages
     * @param visiblePages
     */
    updateVisiblePages(visiblePages: any): void;
    /**
     * Stops the rendering of the specified page.
     * @method CoreControls.DocumentViewer#stopPageRender
     * @param {number} pageIndex The index of the page who's rendering should be stopped.
     */
    stopPageRender(pageIndex: number): void;
    /**
     * Sets whether viewport rendering mode should be used
     * @method CoreControls.DocumentViewer#setViewportRenderMode
     * @param {boolean} val Whether viewport rendering mode should be used or not
     */
    setViewportRenderMode(val: boolean): void;
    /**
     * Returns a boolean to denote if viewer is in viewport rendering mode
     * @method CoreControls.DocumentViewer#isInViewportRenderMode
     * @returns {boolean} the boolean to denote if in viewport render mode
     */
    isInViewportRenderMode(): boolean;
    /**
     * Sets watermark to be added to documents. Instead of an options object you can also pass a Promise
     * that resolves with the watermark options object. If the document hasn't been loaded yet then
     * DocumentViewer will wait to finish loading it until the watermark options are ready.
     * @method CoreControls.DocumentViewer#setWatermark
     * @param {object} options Object that contains style/content of the watermark
     * @example docViewer.setWatermark({
     *   diagonal: {
     *     text: (string),
     *     fontSize: (number || 20),
     *     fontFamily: (string || 'sans-serif'),
     *     color: (string || 'black'),
     *     opacity: (number || 100)
     *   },
     *   header: {
     *     left: (string),
     *     center: (string),
     *     right: (string),
     *     fontSize: (number || 20),
     *     fontFamily: (string || 'sans-serif'),
     *     color: (string || 'black'),
     *     opacity: (number || 100)
     *   },
     *   footer: {
     *     left: (string)
     *     center: (string),
     *     right: (string),
     *     fontSize: (number || 20),
     *     fontFamily: (string || 'sans-serif'),
     *     color: (string || 'black'),
     *     opacity: (number || 100),
     *   },
     *   custom: (function(ctx, pageIndex, pageWidth, pageHeight)),
     *   shouldDrawOverAnnotations: (boolean || false)
     * });
     */
    setWatermark(options: any): void;
    /**
     * Gets the watermark options that had been previously set.
     * @method CoreControls.DocumentViewer#getWatermark
     * @returns {Promise<object>} Returns a promise containing the watermark options.
     */
    getWatermark(): Promise<object>;
    /**
     * Add a handler to the given event name
     * @method EventHandler#on
     * @param {string|number} type The name of the event to listen to
     * @param {function} fn The handler to be called when the event is triggered
     * @returns {object} Returns the object that 'on' is being called on
     * @example
     * annotManager.on('annotationChanged', (annotations, action) => {
     *   ...
     * });
     */
    on(type: string | number, fn: (...params: any[]) => any): any;
    /**
     * Remove a handler of the given event name
     * @method EventHandler#off
     * @param {(string|number)} [type] The name of the event to remove the handler of.
     * If type is undefined, all the handlers of the object will be removed
     * @param {function} [fn] The handler associated with this event to be removed.
     * If fn is undefined, all the handlers of the given event name will be removed
     * @returns {object} Returns the object that 'off' is being called on
     * @example
     * annotManager.off();
     * annotManager.off('annotationChanged');
     * annotManager.off('annotationChanged', fn);
     */
    off(type?: string | number, fn?: (...params: any[]) => any): any;
    /**
     * Calls the handlers of the event name with given data
     * @method EventHandler#trigger
     * @param {(string|number)} type event name of which the handlers will be called.
     * @param {*} [data] data that will be passed to the handlers.
     * If data is an array, it will be spread and then passed to the handlers
     * @return {object} Returns the object that 'trigger' is being called on
     * @example
     * annotManager.trigger('annotationChanged');
     * annotManager.trigger('annotationChanged', [[annotation], 'add', {}]);
     */
    trigger(type: string | number, data?: any): any;
    /**
     * Same as 'on' except the handler will be called only once
     * @param {string|number} type The name of the event to listen to
     * @param {function} fn The handler to be called when the event is triggered
     * @returns {object} Returns the object that 'one' is being called on
     * @example
     * annotManager.one('annotationChanged', (annotations, action) => {
     *  ...
     * });
     * @method EventHandler#one
     */
    one(type: string | number, fn: (...params: any[]) => any): any;
    /**
     * Default values for document viewer. Set FitMode, DisplayMode or Zoom.
     */
    defaults: any;
  }
  namespace DocumentViewer {
    /**
     * Contains a list of available fit modes for the DocumentViewer.
     * @enum {function}
     * @name CoreControls.DocumentViewer.FitMode
     * @property {function} FitWidth Zoom level is constrained such that the current page's width will exactly fill the available space.
     * @property {function} FitPage Zoom level is constrained such that the current page's width or height will exactly fill the available space.
     * @property {function} Zoom Zoom level is not constrained.
     */
    enum FitMode {
      FitWidth,
      FitPage,
      Zoom,
    }
  }
  /**
   * Sets the path to the resources folder.
   * @name setResourcesPath
   * @memberof CoreControls
   * @function
   * @param {string} path Path to the resources folder relative to the HTML file
   */
  function setResourcesPath(path: string): void;
  /**
   * Gets the path to the resources folder
   * @name getResourcesPath
   * @memberof CoreControls
   * @function
   * @returns {string} The path to the resources folder
   */
  function getResourcesPath(): string;
  /**
   * Set default backend type. This method can be used for forced backend type for
   * specific workers, for example, "ems" for Emscripten worker type
   * @name forceBackendType
   * @memberof CoreControls
   * @function
   * @param {string} backendType value for default backed type, e.g. pnacl, ems, jsworker.
   */
  function forceBackendType(backendType: string): void;
  /**
   * Gets the default pdf backend type that should be used for this browser.
   * @name getDefaultBackendType
   * @memberof CoreControls
   * @function
   * @returns {'pnacl' | 'ems'} Returns "pnacl" is PNaCl should be used and "ems" if Emscripten should be used
   */
  function getDefaultBackendType(): 'pnacl' | 'ems';
  /**
   * Gets the current backend type being used.
   * @name getCurrentPDFBackendType
   * @memberof CoreControls
   * @function
   * @returns {string} Returns "pnacl" is PNaCl is being used, "ems" if Emscripten is being used and undefined if nothing is being used yet
   */
  function getCurrentPDFBackendType(): string;
  /**
   * Gets the current backend type being used.
   * @name getCurrentPDFBackendType
   * @memberof CoreControls
   * @function
   * @returns {string} Returns "pnacl" is PNaCl is being used, "ems" if Emscripten is being used and undefined if nothing is being used yet
   */
  function getCurrentPDFBackendType(): string;
  /**
   * Enable or disable use of the full version of PDFNetJS.
   * @name enableFullPDF
   * @memberof CoreControls
   * @function
   * @param {boolean} value Whether to enable or disable the full version of PDFNetJS
   */
  function enableFullPDF(value: boolean): void;
  /**
   * Returns whether the full version of PDFNetJS is enabled or not.
   * @name isFullPDFEnabled
   * @memberof CoreControls
   * @function
   * @returns {boolean} returns true if the full version is enabled and false otherwise.
   */
  function isFullPDFEnabled(): boolean;
  /**
   * Set the location of the PDF worker. This will override the location specified by CoreControls.setWorkerPath for PDF worker files.
   * @name setPDFWorkerPath
   * @memberof CoreControls
   * @function
   * @param {string} workerPath the prefix url for PDFworker.js, ResizableWorker.js, .nmf and .pexe files.
   */
  function setPDFWorkerPath(workerPath: string): void;
  /**
   * Get the location of the PDF asm.js file PDFNetC.gz.js.
   * @name getPDFAsmPath
   * @memberof CoreControls
   * @function
   * @returns {string} the prefix url for PDFNetC.gz.js.
   */
  function getPDFAsmPath(): string;
  /**
   * Set the location of the PDF worker. This will override the location specified by CoreControls.setWorkerPath for PDF worker files.
   * @name setPDFAsmPath
   * @memberof CoreControls
   * @function
   * @param {string} workerPath the prefix url for PDFNetC.gz.js.
   */
  function setPDFAsmPath(workerPath: string): void;
  /**
   * Get the location of the PDF worker.
   * @name getPDFWorkerPath
   * @memberof CoreControls
   * @function
   * @returns {string} the prefix url for PDFworker.js, ResizableWorker.js, .nmf and .pexe files.
   */
  function getPDFWorkerPath(): string;
  /**
   * Set the location of PDF resources. This will override the location specified by CoreControls.setWorkerPath for PDF resource files.
   * @name setPDFResourcePath
   * @memberof CoreControls
   * @function
   * @param {string} resourcePath the prefix url for PDFNetC.js.mem and PDFNet.res.
   */
  function setPDFResourcePath(resourcePath: string): void;
  /**
   * Get the location of PDF resources.
   * @name getPDFResourcePath
   * @memberof CoreControls
   * @function
   * @returns {string} the prefix url for PDFNetC.js.mem and PDFNet.res.
   */
  function getPDFResourcePath(): string;
  /**
   * Sets the location of the local worker files CORSWorker.js/CoreWorker.js which will be different when setting the main worker path to another domain.
   * Note that this path should be on the same domain as WebViewer is being loaded.
   * @name setLocalWorkerPath
   * @memberof CoreControls
   * @function
   * @param {string} workerPath The path to the local worker files
   * @param {boolean} isExact By default this function will add a trailing slash if it wasn't added but in rare cases you may not want this behavior and can pass true for isExact
   */
  function setLocalWorkerPath(workerPath: string, isExact: boolean): void;
  /**
   * Get the location of the local worker files.
   * @name getLocalWorkerPath
   * @memberof CoreControls
   * @function
   * @returns {string} the path to CORSWorker.js/CoreWorker.js
   */
  function getLocalWorkerPath(): string;
  /**
   * Set the location of external scripts.
   * @name setExternalPath
   * @memberof CoreControls
   * @function
   */
  function setExternalPath(): void;
  /**
   * Get the location of external scripts.
   * @name getExternalPath
   * @memberof CoreControls
   * @function
   * @returns {string} the prefix url external scripts.
   */
  function getExternalPath(): string;
  /**
   * Resets the worker so that the next time initPDFWorkerTransports is called it will set up the worker transports.
   * @name resetWorker
   * @memberof CoreControls
   * @function
   */
  function resetWorker(): void;
  /**
   * Set the URL at which PDFNetJS backend will request font resources for the purposes
   * of font substitution. By default they are retrieved from the pdftron website.
   * @name setCustomFontURL
   * @memberof CoreControls
   * @function
   * @param {string} url The url at which font resources should be requested.
   */
  function setCustomFontURL(url: string): void;
  /**
   * Enables or color management for PDFNetJS backend. Color management is off by default.
   * Enabling color management will better reflect correct color conversions but has a performance penalty.
   * @name setColorManagement
   * @memberof CoreControls
   * @function
   * @param [boolean] value if true enable color management. Otherwise disable it.
   * @note setColorManagement(true) is equivalent to PDFNet.setColorManagement(PDFNet.CMSType.e_lcms)
   * and setColorManagement(false) is equivalent to PDFNet.setColorManagement(PDFNet.CMSType.e_no_cms)
   */
  function setColorManagement(boolean?: any): void;
  /**
   * Adjusts the up front heap size used by Emscripten. This method must be called before the worker is
   * initialized to change heap allocation behaviour. By default the heap size is set to 50331648 bytes.
   * Note that decreasing the heap size very low or running complex operations may require a resize.
   * @name setEmscriptenHeapSize
   * @memberof CoreControls
   * @function
   * @param {number} The number of bytes to allocate for the Emscripten heap.
   */
  function setEmscriptenHeapSize(The: number): void;
  /**
   * Begins setup of PDF Worker Object. This can be used to load the workers before a license key has been loaded.
   * @name preloadPDFWorker
   * @memberof CoreControls
   * @function
   * @param {string} pdfBackendType object representing an PDF backend type ("pnacl" or "ems")
   * @param {object} workerHandlers object holding event and error handlers for the worker (workerLoadingProgress).
   * @param {object} options An object with the following optional values:
   *   useEmscriptenWhileLoading If the backend type is set to pnacl then this determines whether emscripten should be used if PNaCl needs time to set up.
   * @returns {object} The worker object
   */
  function preloadPDFWorker(pdfBackendType: string, workerHandlers: any, options: any): any;
  /**
   * Begins setup of PDF Worker Object.
   * @name initPDFWorkerTransports
   * @memberof CoreControls
   * @function
   * @param {string} pdfBackendType object representing an PDF backend type ("pnacl" or "ems")
   * @param {object} workerHandlers object holding event and error handlers for the worker (workerLoadingProgress,  pnaclCrashError, pnaclLoadError, emsWorkerError).
   * @param {string} l The license key to use for this worker. If undefined PDFNet will be initialized in demo mode.
   * @returns a promise that will be resolved when worker transport initialization is complete.
   */
  function initPDFWorkerTransports(pdfBackendType: string, workerHandlers: any, l: string): any;
  /**
   * Enable or disable using PNaCl subzero compiler. With subzero enabled the first load and execution is significantly faster at the expense of slightly slower execution (about 10%) for subsequent usage.
   * Note that subzero is only consistently available on Chrome 56 or above (and is on by default on Chrome 56+) so this function call will be ignored on earlier Chrome versions and other browsers.
   * @name enableSubzero
   * @memberof CoreControls
   * @function
   * @param {boolean} value If true and subzero is supported by the browser it will be enabled.
   */
  function enableSubzero(value: boolean): void;
  /**
   * Returns whether PNaCl subzero is supported by the browser and enabled.
   * @name isSubzeroEnabled
   * @memberof CoreControls
   * @function
   * @returns {boolean} returns true if subzero is supported and enabled and false otherwise.
   */
  function isSubzeroEnabled(): boolean;
  /**
   * Gets the path to the Web Worker JavaScript file
   * @name getWorkerPath
   * @memberof CoreControls
   * @function
   * @returns {string} The path to the worker
   */
  function getWorkerPath(): string;
  /**
   * Sets the path to the Web Worker JavaScript file.
   * By default the file is expected to be in the same directory as the html file of the viewer
   * and the path should be specified relative to the html file
   * @name setWorkerPath
   * @memberof CoreControls
   * @function
   * @param {string} path Path to the Web Worker JS file relative to the html file of the viewer
   */
  function setWorkerPath(path: string): void;
  /**
   * Returns whether demo mode is active or not. Must be called after the document is loaded
   * or after the call to CoreControls.initPDFWorkerTransports if you're calling it directly.
   * @name isDemoMode
   * @memberof CoreControls
   * @function
   * @returns {boolean} true or false depending on whether the viewer is in demo mode or not
   */
  function isDemoMode(): boolean;
  /**
   * Returns the WebViewer version.
   * @method CoreControls#getVersion
   * @returns {string} WebViewer version
   */
  function getVersion(): string;
  /**
   * Returns the specific hashed commit id that is used to build the current WebViewer version.
   * @method CoreControls#getBuild
   * @returns {string} A hashed commit id
   */
  function getBuild(): string;
  /**
   * Set the location of the Office asm worker. This will override the location specified by CoreControls.setWorkerPath for Office worker files.
   * @name setOfficeAsmPath
   * @memberof CoreControls
   * @function
   * @param {string} workerPath the prefix url for WebOfficeWorker.br.js.mem.
   */
  function setOfficeAsmPath(workerPath: string): void;
  /**
   * Get the location of the Office asm worker.
   * @name getOfficeAsmPath
   * @memberof CoreControls
   * @function
   * @returns {string} the prefix url for WebOfficeWorker.br.js.mem.
   */
  function getOfficeAsmPath(): string;
  /**
   * Gets the current backend type being used.
   * @name getCurrentOfficeBackendType
   * @memberof CoreControls
   * @function
   * @returns {string} Returns "pnacl" is PNaCl is being used, "ems" if Emscripten is being used and undefined if nothing is being used yet
   */
  function getCurrentOfficeBackendType(): string;
  /**
   * Begins setup of Office Worker Object. This can be used to load the workers before a license key has been loaded.
   * @name preloadOfficeWorker
   * @memberof CoreControls
   * @function
   * @param {string} officeBackendType object representing an Office backend type ("pnacl" or "ems")
   * @param {object} workerHandlers object holding event and error handlers for the worker (workerLoadingProgress).
   * @param {object} options An object with the following optional values:
   *   useEmscriptenWhileLoading If the backend type is set to pnacl then this determines whether emscripten should be used if PNaCl needs time to set up.
   *   autoSwap Whether PNaCl should automatically be swapped to when it finishes loading
   * @returns {object} The worker object
   */
  function preloadOfficeWorker(officeBackendType: string, workerHandlers: any, options: any): any;
  /**
   * Resets the worker so that the next time initOfficeWorkerTransports is called it will set up the worker transports with the specified worker.
   * @name resetOfficeWorker
   * @memberof CoreControls
   * @function
   * @param {object} worker The new worker to use the next time initOfficeWorkerTransports is called
   */
  function resetOfficeWorker(worker: any): void;
  /**
   * Begins setup of Office Worker Object.
   * @name initOfficeWorkerTransports
   * @memberof CoreControls
   * @function
   * @param {string} officeType object representing an Office backend type ("pnacl" or "ems")
   * @param {object} workerHandlers object holding event and error handlers for the worker (workerLoadingProgress,  pnaclCrashError, pnaclLoadError, emsWorkerError).
   * @param {string} l The license key to use for this worker. If undefined, initialization will be done in demo mode.
   * @returns a promise that will be resolved when worker transport initialization is complete.
   */
  function initOfficeWorkerTransports(officeType: string, workerHandlers: any, l: string): any;
  /**
   * Set the location of the Office resource worker. This will override the
   * location specified by CoreControls.setWorkerPath for Office worker files
   * This new officeResourcePath will be used in very specific situations where
   * worker files are located in different locations.
   * @name setOfficeResourcePath
   * @memberof CoreControls
   * @function
   * @param {string} workerPath the prefix url for WebOfficeWorker.js, .mem, .nmf and .pexe files.
   */
  function setOfficeResourcePath(workerPath: string): void;
  /**
   * Get the location of the Office worker.
   * @name getOfficeResourcePath
   * @memberof CoreControls
   * @function
   * @returns {string} the prefix url for OfficeWorker.js, .nmf, and .pexe files.
   */
  function getOfficeResourcePath(): string;
  /**
   * @method CoreControls.office2PDFBuffer
   * @param {string|ArrayBuffer} input Either a url from which to download the file or an ArrayBuffer containing the file data.
   * @param {Object} options An object containing conversion options
   * @param {string=} options.l The license key with which to initialize the SDK
   * @return {ArrayBuffer} A promise that resolves to an ArrayBuffer containing the resulting PDF data.
   */
  function office2PDFBuffer(
    input: string | ArrayBuffer,
    options: {
      l?: string;
    },
  ): ArrayBuffer;
  /**
   * Represents the different page rotation values that you can apply to pages.
   * @enum {number}
   * @name PageRotation
   * @memberof CoreControls
   * @property {number} e_0 0 degree rotation
   * @property {number} e_90 90 degree rotation
   * @property {number} e_180 180 degree rotation
   * @property {number} e_270 270 degree rotation
   */
  enum PageRotation {
    e_0,
    e_90,
    e_180,
    e_270,
  }
  /**
   * Represents the different review state values that you can apply to annotation status.
   * @enum {string}
   * @name ReviewStates
   * @memberof CoreControls
   * @property {string} Accepted Accepted State
   * @property {string} Rejected Rejected State
   * @property {string} Cancelled Cancelled State
   * @property {string} Completed Completed State
   * @property {string} None None State
   */
  enum ReviewStates {
    Accepted,
    Rejected,
    Cancelled,
    Completed,
    None,
  }
  /**
   * Represents the different Marked state values that you can apply to annotation status.
   * @name MarkedStates
   * @enum {string}
   * @memberof CoreControls
   * @property {string} Marked Marked State
   * @property {string} Unmarked Unmarked State
   */
  enum MarkedStates {
    Marked,
    Unmarked,
  }
  /**
   * Represents the different state models that you can apply to annotation.
   * @enum {string}
   * @name StateModel
   * @memberof CoreControls
   * @property {string} Marked Marked State
   * @property {string} Review Review State
   */
  enum StateModel {
    Marked,
    Review,
  }
  /**
   * Represents the font style for the watermark text
   * @name CoreControls.FONT_STYLES
   * @property {string} BOLD specifies that the text should be bolded
   * @property {string} ITALIC specifies that the text should be italicized
   * @property {string} UNDERLINE specifies that the text should be underlined
   */
  var FONT_STYLES: {
    BOLD: string;
    ITALIC: string;
    UNDERLINE: string;
  };
  /**
   * Represents all the supported file formats in WebViewer
   * @enum {Array}
   * @name SupportedFileFormats
   * @memberof CoreControls
   * @property {Array.<string>} CLIENT Supported file formats when using WebViewer client side rendering
   * @property {Array.<string>} SERVER Supported file formats when using WebViewer with WebViewer Server
   */
  enum SupportedFileFormats {
    CLIENT,
    SERVER,
  }
  /**
   * Enables or disables all logs coming from WebViewer.
   * @name disableLogs
   * @memberof CoreControls
   * @function
   * @param {boolean} disabled Whether or not to disable all WebViewer logs. Defaults to true
   */
  function disableLogs(disabled: boolean): void;
}

/**
 * Contains tools for pan scrolling, text selection, annotation editing and annotation creation. You can access it as follows:
 * @namespace Tools
 * @example
WebViewer(...)
  .then(function(instance) {
    var Tools = instance.Tools;
    // Tools.SomeClass
  });
 */
declare namespace Tools {
  /**
   * Creates a new instance of AnnotationEditTool.
   * @class Represents a tool for DocumentViewer's built-in annotation editing.
   * @name AnnotationEditTool
   * @memberof Tools
   * @extends Tools.AnnotationSelectTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class AnnotationEditTool extends Tools.AnnotationSelectTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * @class Represents a tool that can select annotations
   * @name AnnotationSelectTool
   * @memberof Tools
   * @extends Tools.Tool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   * @property {boolean} overrideSelection Whether to override the default annotation selection behavior of the tool. If true then annotations will not be selected by the tool.
   */
  class AnnotationSelectTool extends Tools.Tool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * @name Tools.AnnotationSelectTool.PAGE_PADDING
     * @type {Annotations.Rect}
     * padding at the page edges that defines how close annotations can be created and dragged to the edge
     */
    static PAGE_PADDING: Annotations.Rect;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
    /**
     * Whether to override the default annotation selection behavior of the tool. If true then annotations will not be selected by the tool.
     */
    overrideSelection: boolean;
  }
  /**
   * Creates a new instance of the AreaMeasurementCreateTool.
   * @class Represents the tool for creating polygon annotations with a measure dictionary.
   * @memberof Tools
   * @extends Tools.PerimeterMeasurementCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class AreaMeasurementCreateTool extends Tools.PerimeterMeasurementCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Set the snap mode that will be used to calculate the end point position
     * @method Tools.PerimeterMeasurementCreateTool#setSnapMode
     * @param {number} mode Enum for a snapping mode for the snapping.
     * @see CoreControls.DocumentViewer#SnapMode
     */
    setSnapMode(mode: number): void;
    /**
     * Sets whether new annotations can be created by the tool when hovering over an existing annotation
     * @method Tools.PolylineCreateTool#setAllowCreationOverAnnotation
     * @param {boolean} val Whether creation of annotation is allowed when hovering over another annotation
     */
    setAllowCreationOverAnnotation(val: boolean): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * Creates a new instance of the ArrowCreateTool.
   * @class Represents the tool for creating line annotations with an arrow head.
   * @memberof Tools
   * @extends Tools.LineCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class ArrowCreateTool extends Tools.LineCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Sets the draw mode for the tool.
     * @method Tools.LineCreateTool#setDrawMode
     * @param {Tools.LineCreateTool.DrawModes} drawMode One of the available draw modes.
     */
    setDrawMode(drawMode: Tools.LineCreateTool.DrawModes): void;
    /**
     * Sets the draw mode for the tool.
     * @method Tools.LineCreateTool#getDrawMode
     * @returns {Tools.LineCreateTool.DrawModes} The current draw mode of the tool.
     */
    getDrawMode(): Tools.LineCreateTool.DrawModes;
    /**
     * Set the snap mode that will be used to calculate the end point position
     * @method Tools.LineCreateTool#setSnapMode
     * @param {number} mode Enum for a snapping mode for the snapping.
     * @see CoreControls.DocumentViewer.SnapMode
     */
    setSnapMode(mode: number): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * Creates a new instance of the CalloutCreateTool.
   * @class Represents the tool for creating {@link Annotations.FreeTextAnnotation}.
   * @memberof Tools
   * @extends Tools.PolylineCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   * @property {number} lineCount The number of segments for the line of the created callout
   */
  class CalloutCreateTool extends Tools.PolylineCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Sets whether new annotations can be created by the tool when hovering over an existing annotation
     * @method Tools.PolylineCreateTool#setAllowCreationOverAnnotation
     * @param {boolean} val Whether creation of annotation is allowed when hovering over another annotation
     */
    setAllowCreationOverAnnotation(val: boolean): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
    /**
     * The number of segments for the line of the created callout
     */
    lineCount: number;
  }
  namespace CropCreateTool {
    /**
     * @enum {string}
     * @name Tools.CropCreateTool.CropModes
     * @property {string} SINGLE_PAGE Sets the CropTool to the default single page mode
     * @property {string} ALL_PAGES Sets the CropTool to apply the crop to all pages
     */
    enum CropModes {
      SINGLE_PAGE,
      ALL_PAGES,
    }
  }
  /**
   * Creates a new instance of the CropCreateTool.
   * @class Represents the tool for cropping a page.
   * @memberof Tools
   * @extends Tools.RectangleCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class CropCreateTool extends Tools.RectangleCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Sets the crop mode for the tool
     * @method Tools.CropCreateTool#setCropMode
     * @param {Tools.CropCreateTool.CropModes} cropMode The crop mode to select
     * @example
     * WebViewer(...).then(instance => {
     *  const tool = instance.docViewer.getTool('CropPage');
     *  tool.setCropMode(instance.Tools.CropCreateTool.CropModes.ALL_PAGES);
     * })
     */
    setCropMode(cropMode: Tools.CropCreateTool.CropModes): void;
    /**
     * Gets the current crop mode.
     * @method Tools.CropCreateTool#getCropMode
     * @returns {Tools.CropCreateTool.CropModes} Returns the current crop mode;
     */
    getCropMode(): Tools.CropCreateTool.CropModes;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * Creates a new instance of the DistanceMeasurementCreateTool.
   * @class Represents the tool for creating line annotations with a measure dictionary.
   * @memberof Tools
   * @extends Tools.LineCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class DistanceMeasurementCreateTool extends Tools.LineCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Set if the tool should draw leader lines after the first mouse up instead of finishing it
     * @method Tools.DistanceMeasurementCreateTool#setEnableLeaderLines
     * @param {boolean} enable a boolean indicating whether leader lines should be drawn
     */
    setEnableLeaderLines(enable: boolean): void;
    /**
     * Sets the draw mode for the tool.
     * @method Tools.LineCreateTool#setDrawMode
     * @param {Tools.LineCreateTool.DrawModes} drawMode One of the available draw modes.
     */
    setDrawMode(drawMode: Tools.LineCreateTool.DrawModes): void;
    /**
     * Sets the draw mode for the tool.
     * @method Tools.LineCreateTool#getDrawMode
     * @returns {Tools.LineCreateTool.DrawModes} The current draw mode of the tool.
     */
    getDrawMode(): Tools.LineCreateTool.DrawModes;
    /**
     * Set the snap mode that will be used to calculate the end point position
     * @method Tools.LineCreateTool#setSnapMode
     * @param {number} mode Enum for a snapping mode for the snapping.
     * @see CoreControls.DocumentViewer.SnapMode
     */
    setSnapMode(mode: number): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * Creates a new instance of the EllipseCreateTool.
   * @class Represents the tool for creating {@link Annotations.EllipseAnnotation}.
   * @memberof Tools
   * @extends Tools.GenericAnnotationCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class EllipseCreateTool extends Tools.GenericAnnotationCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Sets the draw mode for the tool.
     * @method Tools.EllipseCreateTool#setDrawMode
     * @param {Tools.EllipseCreateTool.DrawModes} drawMode One of the available draw modes.
     */
    setDrawMode(drawMode: Tools.EllipseCreateTool.DrawModes): void;
    /**
     * Sets the draw mode for the tool.
     * @method Tools.EllipseCreateTool#getDrawMode
     * @returns {Tools.EllipseCreateTool.DrawModes} The current draw mode of the tool.
     */
    getDrawMode(): Tools.EllipseCreateTool.DrawModes;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  class exports extends Tools.EllipseCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Sets the draw mode for the tool.
     * @method Tools.EllipseCreateTool#setDrawMode
     * @param {Tools.EllipseCreateTool.DrawModes} drawMode One of the available draw modes.
     */
    setDrawMode(drawMode: Tools.EllipseCreateTool.DrawModes): void;
    /**
     * Sets the draw mode for the tool.
     * @method Tools.EllipseCreateTool#getDrawMode
     * @returns {Tools.EllipseCreateTool.DrawModes} The current draw mode of the tool.
     */
    getDrawMode(): Tools.EllipseCreateTool.DrawModes;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * Represents the tool for erasing annotations.
   * @class Represents the tool for creating {@link Annotations.EraserTool}.
   * @memberof Tools
   * @extends Tools.GenericAnnotationCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class EraserTool extends Tools.GenericAnnotationCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  class FileAttachmentCreateTool extends Tools.Tool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
    /**
     * A string specifying the accepted file types to be opened by the file picker. By default any file type is accepted.
     */
    ACCEPTED_FILE_TYPES: string;
  }
  /**
   * Creates a new instance of the FreeHandCreateTool.
   * @class Represents the tool for creating {@link Annotations.FreeHandAnnotation}.
   * @memberof Tools
   * @extends Tools.GenericAnnotationCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   * @property {number} createDelay The delay to allow for multiple paths to be added as part of the same annotation
   * @property {boolean} simplifyPen Whether to simplify the annotation path when a pen input is used, defaults to false
   */
  class FreeHandCreateTool extends Tools.GenericAnnotationCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * When called, the current freehand annotation being created is added to the AnnotationManager, ignoring the createDelay.
     * It is only necessary to call this function if you want the annotation to be added before the createDelay elapses.
     * @method Tools.FreeHandCreateTool#complete
     * @return {Promise<any>} A promise that resolves when the current freehand annotation has been added to the AnnotationManager
     */
    complete(): Promise<any>;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
    /**
     * The delay to allow for multiple paths to be added as part of the same annotation
     */
    createDelay: number;
    /**
     * Whether to simplify the annotation path when a pen input is used, defaults to false
     */
    simplifyPen: boolean;
  }
  /**
   * Creates a new instance of the FreeTextCreateTool.
   * @class Represents the tool for creating {@link Annotations.FreeTextAnnotation}.
   * @memberof Tools
   * @extends Tools.GenericAnnotationCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   * @property {string} initialText The initial text to populate new FreeText annotations with
   */
  class FreeTextCreateTool extends Tools.GenericAnnotationCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * @method Tools.FreeTextCreateTool.setTextHandler
     * @param {function} textHandler A function that should return a string that will be used as the initial text for a freetext annotation
     */
    static setTextHandler(textHandler: (...params: any[]) => any): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
    /**
     * The initial text to populate new FreeText annotations with
     */
    initialText: string;
  }
  /**
   * @class Represents a generic tool use to create markup annotations based on two mouse points (mouse left down and mouse left up).
   * @name GenericAnnotationCreateTool
   * @memberof Tools
   * @extends Tools.AnnotationSelectTool
   * @param {CoreControls.DocumentViewer} docViewer the instance of the corresponding DocumentViewer
   * @param {Annotations.Annotation} annotationPrototype the prototype of the Annotation to create.
   * @param {object} [constructorArg] optional argument to pass to the annotation's constructor
   * @property {Annotations.Annotation} annotation the instance of the annotation object created
   * @property {Object} defaults the default styles of the tool
   * @property {Annotations.Color} defaults.StrokeColor the stroke color of the tool
   * @property {Annotations.Color} defaults.FillColor the fill color of the tool
   * @property {number} defaults.Opacity the opacity of the tool
   * @property {number} defaults.StrokeThickness the stroke thickness of the tool
   */
  class GenericAnnotationCreateTool extends Tools.AnnotationSelectTool {
    constructor(
      docViewer: CoreControls.DocumentViewer,
      annotationPrototype: Annotations.Annotation,
      constructorArg?: any,
    );
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
    /**
     * the instance of the annotation object created
     */
    annotation: Annotations.Annotation;
    /**
     * the default styles of the tool
     */
    defaults: {
      StrokeColor: Annotations.Color;
      FillColor: Annotations.Color;
      Opacity: number;
      StrokeThickness: number;
    };
  }
  /**
   * Creates a new instance of the LineCreateTool.
   * @class Represents the tool for creating {@link Annotations.LineAnnotations}.
   * @memberof Tools
   * @extends Tools.GenericAnnotationCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class LineCreateTool extends Tools.GenericAnnotationCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Sets the draw mode for the tool.
     * @method Tools.LineCreateTool#setDrawMode
     * @param {Tools.LineCreateTool.DrawModes} drawMode One of the available draw modes.
     */
    setDrawMode(drawMode: Tools.LineCreateTool.DrawModes): void;
    /**
     * Sets the draw mode for the tool.
     * @method Tools.LineCreateTool#getDrawMode
     * @returns {Tools.LineCreateTool.DrawModes} The current draw mode of the tool.
     */
    getDrawMode(): Tools.LineCreateTool.DrawModes;
    /**
     * Set the snap mode that will be used to calculate the end point position
     * @method Tools.LineCreateTool#setSnapMode
     * @param {number} mode Enum for a snapping mode for the snapping.
     * @see CoreControls.DocumentViewer.SnapMode
     */
    setSnapMode(mode: number): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * Creates a new instance of MarqueeZoomTool.
   * @class Represents a tool for DocumentViewer's built-in marquee zoom.
   * @name MarqueeZoomTool
   * @memberof Tools
   * @extends Tools.Tool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   * @property {function} setZoomHandler Sets the function that takes the current zoom level and returns the next zoom level if a mouse click without drag is performed
   */
  class MarqueeZoomTool extends Tools.Tool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
    /**
     * Sets the function that takes the current zoom level and returns the next zoom level if a mouse click without drag is performed
     */
    setZoomHandler: (...params: any[]) => any;
  }
  /**
   * @class Represents a point on a page
   * @name PageCoordinate
   * @memberof Tools
   * @property {number} pageIndex the 0-based page value
   * @property {number} x the x offset of this point relative to the top left corner of the page
   * @property {number} y the y offset of this point relative to the top left corner of the page
   */
  class PageCoordinate {
    /**
     * the 0-based page value
     */
    pageIndex: number;
    /**
     * the x offset of this point relative to the top left corner of the page
     */
    x: number;
    /**
     * the y offset of this point relative to the top left corner of the page
     */
    y: number;
  }
  /**
   * @class Represents a tool for DocumentViewer's built-in mouse pan scrolling.
   * @name PanTool
   * @memberof Tools
   * @extends Tools.AnnotationSelectTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class PanTool extends Tools.AnnotationSelectTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * Creates a new instance of the PerimeterMeasurementCreateTool.
   * @class Represents the tool for creating polyline annotations with a measure dictionary.
   * @memberof Tools
   * @extends Tools.PolylineCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class PerimeterMeasurementCreateTool extends Tools.PolylineCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Set the snap mode that will be used to calculate the end point position
     * @method Tools.PerimeterMeasurementCreateTool#setSnapMode
     * @param {number} mode Enum for a snapping mode for the snapping.
     * @see CoreControls.DocumentViewer#SnapMode
     */
    setSnapMode(mode: number): void;
    /**
     * Sets whether new annotations can be created by the tool when hovering over an existing annotation
     * @method Tools.PolylineCreateTool#setAllowCreationOverAnnotation
     * @param {boolean} val Whether creation of annotation is allowed when hovering over another annotation
     */
    setAllowCreationOverAnnotation(val: boolean): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  namespace PolygonCloudCreateTool {
    /**
     * @name Tools.PolygonCloudCreateTool.ArcDrawModes
     * @enum {string}
     * @property {string} EQUAL_ARCS The arcs in the cloud have the same width. This is the default setting
     * @property {string} RANDOM_ARCS The arcs in the cloud have random widths
     */
    enum ArcDrawModes {
      EQUAL_ARCS,
      RANDOM_ARCS,
    }
  }
  /**
   * Creates a new instance of the PolygonCloudCreateTool.
   * @class Represents the tool for creating {@link Annotations.PolygonAnnotation}.
   * @memberof Tools
   * @extends Tools.PolylineCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class PolygonCloudCreateTool extends Tools.PolylineCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Sets the arc drawing mode for annotations created by the tool
     * @method Tools.PolygonCloudCreateTool#setArcDrawMode
     * @param {string} arcDrawMode is either RANDOM_ARCS or EQUAL_ARCs
     * use existing ENUM to pass this value
     * @see Tools.PolygonCloudCreateTool.ArcDrawModes
     * @example
     * const cloudTool = docViewer.getTool('AnnotationCreatePolygonCloud');
     * cloudTool.setArcDrawMode(instance.Tools.PolygonCloudCreateTool.ArcDrawModes.RANDOM_ARCS);
     */
    setArcDrawMode(arcDrawMode: string): void;
    /**
     * Returns the current ArcDrawMode for the tool
     * @method Tools.PolygonCloudCreateTool#getArcDrawMode
     * @returns {string} the ArcDrawMode
     */
    getArcDrawMode(): string;
    /**
     * Sets whether new annotations can be created by the tool when hovering over an existing annotation
     * @method Tools.PolylineCreateTool#setAllowCreationOverAnnotation
     * @param {boolean} val Whether creation of annotation is allowed when hovering over another annotation
     */
    setAllowCreationOverAnnotation(val: boolean): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * Creates a new instance of the PolygonCreateTool.
   * @class Represents the tool for creating {@link Annotations.PolygonAnnotation}.
   * @memberof Tools
   * @extends Tools.PolylineCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class PolygonCreateTool extends Tools.PolylineCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Sets whether new annotations can be created by the tool when hovering over an existing annotation
     * @method Tools.PolylineCreateTool#setAllowCreationOverAnnotation
     * @param {boolean} val Whether creation of annotation is allowed when hovering over another annotation
     */
    setAllowCreationOverAnnotation(val: boolean): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * Creates a new instance of the PolylineCreateTool.
   * @class Represents the tool for creating {@link Annotations.PolylineAnnotation}.
   * @memberof Tools
   * @extends Tools.GenericAnnotationCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class PolylineCreateTool extends Tools.GenericAnnotationCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Sets whether new annotations can be created by the tool when hovering over an existing annotation
     * @method Tools.PolylineCreateTool#setAllowCreationOverAnnotation
     * @param {boolean} val Whether creation of annotation is allowed when hovering over another annotation
     */
    setAllowCreationOverAnnotation(val: boolean): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * Creates a new instance of the RectangleCreateTool.
   * @class Represents the tool for creating {@link Annotations.RectangleAnnotations}.
   * @memberof Tools
   * @extends Tools.GenericAnnotationCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class RectangleCreateTool extends Tools.GenericAnnotationCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  class RectangularAreaMeasurementTool extends Tools.AreaMeasurementCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Sets the draw mode for the tool.
     * @method Tools.RectangularAreaMeasurementTool#setDrawMode
     * @param {Tools.RectangularAreaMeasurementTool.DrawModes} drawMode One of the available draw modes.
     */
    setDrawMode(drawMode: Tools.RectangularAreaMeasurementTool.DrawModes): void;
    /**
     * Sets the draw mode for the tool.
     * @method Tools.RectangularAreaMeasurementTool#getDrawMode
     * @returns {Tools.RectangularAreaMeasurementTool.DrawModes} The current draw mode of the tool.
     */
    getDrawMode(): Tools.RectangularAreaMeasurementTool.DrawModes;
    /**
     * Set the snap mode that will be used to calculate the end point position
     * @method Tools.PerimeterMeasurementCreateTool#setSnapMode
     * @param {number} mode Enum for a snapping mode for the snapping.
     * @see CoreControls.DocumentViewer#SnapMode
     */
    setSnapMode(mode: number): void;
    /**
     * Sets whether new annotations can be created by the tool when hovering over an existing annotation
     * @method Tools.PolylineCreateTool#setAllowCreationOverAnnotation
     * @param {boolean} val Whether creation of annotation is allowed when hovering over another annotation
     */
    setAllowCreationOverAnnotation(val: boolean): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * Creates a new instance of the RedactionCreateTool.
   * @class Represents the tool for creating {@link Annotations.RedactionAnnotation}.
   * @memberof Tools
   * @extends Tools.TextAnnotationCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class RedactionCreateTool extends Tools.TextAnnotationCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Set if tool should automatically automatically set font size based on the selected text (if redacting text)
     * @method Tools.RedactionCreateTool#setEnableTextAutoSize
     * @param {boolean} enable a boolean indicating whether overlay text font should be automatically set
     */
    setEnableTextAutoSize(enable: boolean): void;
    /**
     * Select text based on two points
     * @method Tools.TextTool#select
     * @param {object} pagePt1 The start point to select from. Is an object with pageIndex, x and y properties.
     * @param {object} pagePt2 The end point to select to. Is an object with pageIndex, x and y properties.
     */
    select(pagePt1: any, pagePt2: any): void;
    /**
     * The function called when a text region is selected.
     * @method Tools.TextTool#textSelected
     * @param {number} pageIndex
     * @param {Annotations.Quad} quads the quad coordinates for the selected text.
     * @param {string} text the text selected.
     */
    textSelected(pageIndex: number, quads: Annotations.Quad, text: string): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * Creates a new instance of the RubberStampCreateTool.
   * @class Represents the tool for creating {@link Annotations.StampAnnotation}.
   * @memberOf Tools
   * @extends Tools.Tool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class RubberStampCreateTool extends Tools.Tool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Sets the underlying annotation used by the tool
     * @param {(Annotations.StampAnnotation)} annotation annotation to set
     * @method Tools.RubberStampCreateTool#setRubberStamp
     */
    setRubberStamp(annotation: Annotations.StampAnnotation): void;
    /**
     * Add the stamp to the document.
     * @method Tools.RubberStampCreateTool#addStamp
     */
    addStamp(): void;
    /**
     * Gets the preview about how the annot will be drawn on the document
     * @param {Annotations.StampAnnotation} annotation annotation to get the preview for.
     * @param {Object} parameters canvas parameters and optional text for annotation, e.g. translated text.
     *  e.g. { canvasHeight: number, canvasWidth: number, text: string }
     * @returns {String} A base64 string of the preview image
     * @method Tools.RubberStampCreateTool#getPreview
     */
    getPreview(annotation: Annotations.StampAnnotation, parameters: any): string;
    /**
     * Shows the preview about how the underlying annot looks like if it's drawn.
     * @method Tools.RubberStampCreateTool#showPreview
     */
    showPreview(): void;
    /**
     * Hide the preview element
     * @method Tools.RubberStampCreateTool#hidePreview
     */
    hidePreview(): void;
    /**
     * Checks if the underlying annotation is empty.
     * If the underlying annotation is a StampAnnotation type return true.
     * @method Tools.RubberStampCreateTool#isEmptyStamp
     * @return {boolean}
     */
    isEmptyStamp(): boolean;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * Creates a new instance of the SignatureCreateTool.
   * @name SignatureCreateTool
   * @class Represents the tool for creating a Signature which is represented by an {@link Annotations.FreeHandAnnotation}.
   * @extends Tools.Tool
   * @memberof Tools
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   * @property {CanvasRenderingContext2D} ctx The signature canvas context
   * @property {Annotations.FreeHandAnnotation|Annotations.StampAnnotation} annot The underlying annotation used by the tool
   */
  class SignatureCreateTool extends Tools.Tool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * @method Tools.SignatureCreateTool.setTextHandler
     * @param {function} textHandler A function that should return a string that will be used as the "sign here" text
     */
    static setTextHandler(textHandler: (...params: any[]) => any): void;
    /**
     * Clears the signature canvas and the underlying annotation
     * @method Tools.SignatureCreateTool#clearSignatureCanvas
     */
    clearSignatureCanvas(): void;
    /**
     * Resize the current signature canvas
     * @method Tools.SignatureCreateTool#resizeCanvas
     */
    resizeCanvas(): void;
    /**
     * Save an array of freehand or stamp annotations to the signature tool
     * @param {(Annotations.FreeHandAnnotation|Annotations.StampAnnotation)} annotations annotations to be saved to the signature tool
     * @method Tools.SignatureCreateTool#saveSignatures
     */
    saveSignatures(annotations: Annotations.FreeHandAnnotation | Annotations.StampAnnotation): void;
    /**
     * Returns the array of saved annotations
     * @return {Array<Annotations.FreeHandAnnotation|Annotations.StampAnnotation>} an array of annotations
     * @method Tools.SignatureCreateTool#getSavedSignatures
     */
    getSavedSignatures(): (Annotations.FreeHandAnnotation | Annotations.StampAnnotation)[];
    /**
     * Delete an annotation in the tool
     * @param {number} index The index of the saved annotation to be deleted
     * @method Tools.SignatureCreateTool#deleteSavedSignature
     */
    deleteSavedSignature(index: number): void;
    /**
     * Loads signature data into the signature tool
     * @param {Array<string|Array<Annotations.Point>>} signatureData an array contains arrays of path points or base64 image data
     * If the element is a string, a stamp annotation will be saved and the string will be the value of its ImageData property
     * If the element is an array of objects, a freehand annotation will be saved and the array will be its paths
     * @method Tools.SignatureCreateTool#importSignatures
     */
    importSignatures(signatureData: (string | Annotations.Point[])[]): void;
    /**
     * Exports all saved signatures as an array
     * The array can be stringified using JSON.stringify and saved for later use
     * @return {Array<string|Array<Annotations.Point>>} Returns an array that contains arrays of path points or base64 image data
     * @method Tools.SignatureCreateTool#exportSignatures
     */
    exportSignatures(): (string | Annotations.Point[])[];
    /**
     * Sets the underlying annotation used by the tool
     * If a base64 string is passed, the underlying annotation will be a stamp annotation with the string being its ImageData
     * @param {(Annotations.FreeHandAnnotation|Annotations.StampAnnotation|string|Array<object>)} annotation annotation to set
     * @method Tools.SignatureCreateTool#setSignature
     */
    setSignature(annotation: Annotations.FreeHandAnnotation | Annotations.StampAnnotation | string | object[]): void;
    /**
     * Clear the location which is set when a mouse click is performed
     * @method Tools.SignatureCreateTool#clearLocation
     */
    clearLocation(): void;
    /**
     * Returns if the signature tool has any location to draw the signature
     * @method Tools.SignatureCreateTool#hasLocation
     * @returns {boolean}
     */
    hasLocation(): boolean;
    /**
     * Gets the preview about how the annot will be drawn on the document
     * @returns {Promise<any>} A promise that resolves with a base64 string of the preview image
     * @method Tools.SignatureCreateTool#getPreview
     */
    getPreview(): Promise<any>;
    /**
     * Shows the preview about how the underlying annot looks like if it's drawn.
     * @method Tools.SignatureCreateTool#showPreview
     */
    showPreview(): void;
    /**
     * Hide the preview element
     * @method Tools.SignatureCreateTool#hidePreview
     */
    hidePreview(): void;
    /**
     * Add the signature to the document.
     * @method Tools.SignatureCreateTool#addSignature
     * @returns {Promise<void>} A promise that resolves when the signature is added
     */
    addSignature(): Promise<void>;
    /**
     * Checks if the underlying annotation is empty.
     * If the underlying annotation is a freehand, it's empty if it doesn't have any paths
     * If the underlying annotation is a stamp, it's empty if its ImageData property has a falsy value
     * @method Tools.SignatureCreateTool#isEmptySignature
     * @return {boolean} If number of drawn paths is 0.
     */
    isEmptySignature(): boolean;
    /**
     * Sets the canvas to be used by the signature tool.
     * @method Tools.SignatureCreateTool#setSignatureCanvas
     * @param {HTMLElement} canvas The canvas that the signature tool uses to draw on.
     */
    setSignatureCanvas(canvas: HTMLElement): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
    /**
     * The signature canvas context
     */
    ctx: CanvasRenderingContext2D;
    /**
     * The underlying annotation used by the tool
     */
    annot: Annotations.FreeHandAnnotation | Annotations.StampAnnotation;
  }
  /**
   * Creates a new instance of the StampCreateTool.
   * @class Represents the tool for creating {@link Annotations.StampAnnotation}.
   * @memberof Tools
   * @extends Tools.Tool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   * @property {string} ACCEPTED_IMAGE_TYPES A string specifying the accepted image types to be opened by the file picker default is image/*
   */
  class StampCreateTool extends Tools.Tool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
    /**
     * A string specifying the accepted image types to be opened by the file picker default is image/*
     */
    ACCEPTED_IMAGE_TYPES: string;
  }
  /**
   * Creates a new instance of the StickyCreateTool.
   * @class Represents the tool for creating {@link Annotations.StickyAnnotation}.
   * @memberof Tools
   * @extends Tools.Tool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class StickyCreateTool extends Tools.Tool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Sets whether new annotations can be created by the tool when hovering over an existing annotation
     * @method Tools.StickyCreateTool#setAllowCreationOverAnnotation
     * @param {boolean} val Whether creation of annotation is allowed when hovering over another annotation
     */
    setAllowCreationOverAnnotation(val: boolean): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * This class should not be instantiated.
   * @class Represents an abstract class for text-based annotation creation tools.
   * @name TextAnnotationCreateTool
   * @memberof Tools
   * @extends Tools.TextTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   * @param {Function} textAnnotationPrototype the prototype the text-based annotation to create.
   * @property {Object} defaults the default styles of the tool
   * @property {Annotations.Color} defaults.StrokeColor the stroke color of the tool
   * @property {number} defaults.Opacity the opacity of the tool
   */
  class TextAnnotationCreateTool extends Tools.TextTool {
    constructor(docViewer: CoreControls.DocumentViewer, textAnnotationPrototype: (...params: any[]) => any);
    /**
     * @name Tools.TextAnnotationCreateTool.AUTO_SET_TEXT
     * @type {boolean}
     * toggle whether selected text should be set as annotation note contents
     */
    static AUTO_SET_TEXT: boolean;
    /**
     * Select text based on two points
     * @method Tools.TextTool#select
     * @param {object} pagePt1 The start point to select from. Is an object with pageIndex, x and y properties.
     * @param {object} pagePt2 The end point to select to. Is an object with pageIndex, x and y properties.
     */
    select(pagePt1: any, pagePt2: any): void;
    /**
     * The function called when a text region is selected.
     * @method Tools.TextTool#textSelected
     * @param {number} pageIndex
     * @param {Annotations.Quad} quads the quad coordinates for the selected text.
     * @param {string} text the text selected.
     */
    textSelected(pageIndex: number, quads: Annotations.Quad, text: string): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
    /**
     * the default styles of the tool
     */
    defaults: {
      StrokeColor: Annotations.Color;
      Opacity: number;
    };
  }
  /**
   * Creates a new instance of the TextHighlightCreateTool.
   * @class Represents the tool for creating {@link Annotations.TextHighlightAnnotation}.
   * @memberof Tools
   * @extends Tools.TextAnnotationCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class TextHighlightCreateTool extends Tools.TextAnnotationCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Select text based on two points
     * @method Tools.TextTool#select
     * @param {object} pagePt1 The start point to select from. Is an object with pageIndex, x and y properties.
     * @param {object} pagePt2 The end point to select to. Is an object with pageIndex, x and y properties.
     */
    select(pagePt1: any, pagePt2: any): void;
    /**
     * The function called when a text region is selected.
     * @method Tools.TextTool#textSelected
     * @param {number} pageIndex
     * @param {Annotations.Quad} quads the quad coordinates for the selected text.
     * @param {string} text the text selected.
     */
    textSelected(pageIndex: number, quads: Annotations.Quad, text: string): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * @class Represents a tool for DocumentViewer's built-in text selection.
   * @name TextSelectTool
   * @memberof Tools
   * @extends Tools.TextTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class TextSelectTool extends Tools.TextTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Select text based on two points
     * @method Tools.TextTool#select
     * @param {object} pagePt1 The start point to select from. Is an object with pageIndex, x and y properties.
     * @param {object} pagePt2 The end point to select to. Is an object with pageIndex, x and y properties.
     */
    select(pagePt1: any, pagePt2: any): void;
    /**
     * The function called when a text region is selected.
     * @method Tools.TextTool#textSelected
     * @param {number} pageIndex
     * @param {Annotations.Quad} quads the quad coordinates for the selected text.
     * @param {string} text the text selected.
     */
    textSelected(pageIndex: number, quads: Annotations.Quad, text: string): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * Creates a new instance of the TextSquigglyCreateTool.
   * @class Represents the tool for creating {@link Annotations.TextSquigglyAnnotation}.
   * @memberof Tools
   * @extends Tools.TextAnnotationCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class TextSquigglyCreateTool extends Tools.TextAnnotationCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Select text based on two points
     * @method Tools.TextTool#select
     * @param {object} pagePt1 The start point to select from. Is an object with pageIndex, x and y properties.
     * @param {object} pagePt2 The end point to select to. Is an object with pageIndex, x and y properties.
     */
    select(pagePt1: any, pagePt2: any): void;
    /**
     * The function called when a text region is selected.
     * @method Tools.TextTool#textSelected
     * @param {number} pageIndex
     * @param {Annotations.Quad} quads the quad coordinates for the selected text.
     * @param {string} text the text selected.
     */
    textSelected(pageIndex: number, quads: Annotations.Quad, text: string): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * Creates a new instance of the TextStrikeoutCreateTool.
   * @class Represents the tool for creating {@link Annotations.TextStrikeoutAnnotation}.
   * @memberof Tools
   * @extends Tools.TextAnnotationCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class TextStrikeoutCreateTool extends Tools.TextAnnotationCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Select text based on two points
     * @method Tools.TextTool#select
     * @param {object} pagePt1 The start point to select from. Is an object with pageIndex, x and y properties.
     * @param {object} pagePt2 The end point to select to. Is an object with pageIndex, x and y properties.
     */
    select(pagePt1: any, pagePt2: any): void;
    /**
     * The function called when a text region is selected.
     * @method Tools.TextTool#textSelected
     * @param {number} pageIndex
     * @param {Annotations.Quad} quads the quad coordinates for the selected text.
     * @param {string} text the text selected.
     */
    textSelected(pageIndex: number, quads: Annotations.Quad, text: string): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * @class Represents an extendable class for text-based tool.
   * @name TextTool
   * @memberof Tools
   * @extends Tools.AnnotationSelectTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   * @property {string} SELECTION_MODE Selection mode used by text tools (structural or rectangular)
   */
  class TextTool extends Tools.AnnotationSelectTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Select text based on two points
     * @method Tools.TextTool#select
     * @param {object} pagePt1 The start point to select from. Is an object with pageIndex, x and y properties.
     * @param {object} pagePt2 The end point to select to. Is an object with pageIndex, x and y properties.
     */
    select(pagePt1: any, pagePt2: any): void;
    /**
     * The function called when a text region is selected.
     * @method Tools.TextTool#textSelected
     * @param {number} pageIndex
     * @param {Annotations.Quad} quads the quad coordinates for the selected text.
     * @param {string} text the text selected.
     */
    textSelected(pageIndex: number, quads: Annotations.Quad, text: string): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
    /**
     * Selection mode used by text tools (structural or rectangular)
     */
    SELECTION_MODE: string;
  }
  /**
   * Creates a new instance of the TextUnderlineCreateTool.
   * @class Represents the tool for creating {@link Annotations.TextUnderlineAnnotation}.
   * @memberof Tools
   * @extends Tools.TextAnnotationCreateTool
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   */
  class TextUnderlineCreateTool extends Tools.TextAnnotationCreateTool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * Select text based on two points
     * @method Tools.TextTool#select
     * @param {object} pagePt1 The start point to select from. Is an object with pageIndex, x and y properties.
     * @param {object} pagePt2 The end point to select to. Is an object with pageIndex, x and y properties.
     */
    select(pagePt1: any, pagePt2: any): void;
    /**
     * The function called when a text region is selected.
     * @method Tools.TextTool#textSelected
     * @param {number} pageIndex
     * @param {Annotations.Quad} quads the quad coordinates for the selected text.
     * @param {string} text the text selected.
     */
    textSelected(pageIndex: number, quads: Annotations.Quad, text: string): void;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
  }
  /**
   * @class Represents the base class for DocumentViewer UI tools.
   * @name Tool
   * @memberof Tools
   * @param {CoreControls.DocumentViewer} docViewer an instance of DocumentViewer.
   * @property {CoreControls.DocumentViewer} docViewer the reference to the current DocumentViewer instance
   * @property {Array<Tools.PageCoordinate>} pageCoordinates an array of page coordinates this tool currently holds. The default is index 0 for the mouse left down and index 1 for mouse left up.
   * @property {string} name The name of the tool
   */
  class Tool {
    constructor(docViewer: CoreControls.DocumentViewer);
    /**
     * @name Tools.Tool.ENABLE_TEXT_SELECTION
     * @type {boolean}
     * A boolean indicating whether text selection is enabled
     */
    static ENABLE_TEXT_SELECTION: boolean;
    /**
     * @name Tools.Tool.ENABLE_AUTO_SWITCH
     * @type {boolean}
     * A boolean indicating whether the text select tool should automatically switch if the cursor is hovering over text or not
     */
    static ENABLE_AUTO_SWITCH: boolean;
    /**
     * @name Tools.Tool.ENABLE_ANNOTATION_HOVER_CURSORS
     * @type {boolean}
     * A boolean indicating whether the cursor should change when hovering over annotations. Default is true.
     */
    static ENABLE_ANNOTATION_HOVER_CURSORS: boolean;
    /**
     * @name Tools.Tool.ALLOW_ANNOTS_OUTSIDE_PAGE
     * @type {boolean}
     * A boolean indicating whether annotations can be dragged outside of the page boundaries. Default is false.
     */
    static ALLOW_ANNOTS_OUTSIDE_PAGE: boolean;
    /**
     * Takes an event object from a mouse event and converts the location into window coordinates
     * @method Tools.Tool#getMouseLocation
     * @param e the event object containing mouse coordinates
     */
    getMouseLocation(e: any): void;
    /**
     * The function called when the left mouse button is down
     * @method Tools.Tool#mouseLeftDown
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftDown(e: any): void;
    /**
     * The function called when the left mouse button is up.
     * Typically, annotations are created and added to the annotation manager at this point.
     * @method Tools.Tool#mouseLeftUp
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseLeftUp(e: any): void;
    /**
     * The function called when the mouse moves.
     * @method Tools.Tool#mouseMove
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseMove(e: any): void;
    /**
     * The function called when the mouse left button is double clicked.
     * @method Tools.Tool#mouseDoubleClick
     * @param e the event object containing mouse coordinates.
     *
     */
    mouseDoubleClick(e: any): void;
    /**
     * The function called when a keyboard key is down.
     * @method Tools.Tool#keyDown
     * @param e the event object containing keyboard key data.
     *
     */
    keyDown(e: any): void;
    /**
     * The function called when a context menu should be shown.
     * Use e.preventDefault to disable the default browser context menu
     * @method Tools.Tool#contextMenu
     * @param e the event object
     */
    contextMenu(e: any): void;
    /**
     * The function called when this tool is selected.
     * Typically use for changing mouse cursors, and initializing states for the tool.
     * @method Tools.Tool#switchIn
     * @param {Tools.Tool} oldTool the Tool class that was previously selected.
     *
     */
    switchIn(oldTool: Tools.Tool): void;
    /**
     * The function called when this tool is deselected.
     * Typically use for changing mouse cursors, and cleaning up states for the tool.
     * @method Tools.Tool#switchOut
     * @param {Tools.Tool} newTool the Tool class that was newly selected.
     *
     */
    switchOut(newTool: Tools.Tool): void;
    /**
     * Returns the instance of DocumentViewer for this tool.
     * @method Tools.Tool#getDocumentViewer
     * @return {CoreControls.DocumentViewer} the instance of DocumentViewer for this tool.
     */
    getDocumentViewer(): CoreControls.DocumentViewer;
    /**
     * Set the style for the tool, which will be applied to annotations drawn afterwards
     * @method Tools.Tool#setStyles
     * @param {object|function} newStyles if an object is used, it should contain properties of the new styles.
     * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
     * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
     */
    setStyles(newStyles: any | ((...params: any[]) => any)): void;
    /**
     * Set the name of the tool, which can be accessed by toolObject.name
     * @method Tools.Tool#setName
     * @param {string} name name of the tool
     */
    setName(name: string): void;
    /**
     * the reference to the current DocumentViewer instance
     */
    docViewer: CoreControls.DocumentViewer;
    /**
     * an array of page coordinates this tool currently holds. The default is index 0 for the mouse left down and index 1 for mouse left up.
     */
    pageCoordinates: Tools.PageCoordinate[];
    /**
     * The name of the tool
     */
    name: string;
  }
  namespace LineCreateTool {
    /**
     * An enum representing the draw modes available for creating annotations.
     * @name Tools.LineCreateTool.DrawModes
     * @enum {string}
     * @property {string} HOLD_TO_DRAW The annotation is created by clicking and dragging
     * @property {string} TWO_CLICKS The annotation is created by one click for the start point and a second click for the end point
     */
    enum DrawModes {
      HOLD_TO_DRAW,
      TWO_CLICKS,
    }
  }
  namespace EllipseCreateTool {
    /**
     * An enum representing the draw modes available for creating annotations.
     * @name Tools.EllipseCreateTool.DrawModes
     * @enum {string}
     * @property {string} HOLD_TO_DRAW The annotation is created by clicking and dragging
     * @property {string} TWO_CLICKS The annotation is created by one click for the start point and a second click for the end point
     */
    enum DrawModes {
      HOLD_TO_DRAW,
      TWO_CLICKS,
    }
  }
  namespace RectangularAreaMeasurementTool {
    /**
     * An enum representing the draw modes available for creating annotations.
     * @name Tools.RectangularAreaMeasurementTool.DrawModes
     * @enum {string}
     * @property {string} HOLD_TO_DRAW The annotation is created by clicking and dragging
     * @property {string} TWO_CLICKS The annotation is created by one click for the start point and a second click for the end point
     */
    enum DrawModes {
      HOLD_TO_DRAW,
      TWO_CLICKS,
    }
  }
  /**
   * Represents the names for the built-in tools
   * @name Tools.ToolNames
   * @enum {string}
   * @property {string} ARROW name of the arrow line tool
   * @property {string} CALLOUT name of the callout tool
   * @property {string} ELLIPSE name of the ellipse tool
   * @property {string} FREEHAND name of the freehand tool
   * @property {string} FREEHAND2 name of the second freehand tool
   * @property {string} FREEHAND3 name of the third freehand tool
   * @property {string} FREEHAND4 name of the fourth freehand tool
   * @property {string} FREETEXT name of the freetext tool
   * @property {string} LINE name of the line tool
   * @property {string} POLYGON name of the polygon tool
   * @property {string} POLYGON_CLOUD name of the polygon cloud tool
   * @property {string} POLYLINE name of the polyline tool
   * @property {string} RECTANGLE name of the rectangle tool
   * @property {string} DISTANCE_MEASUREMENT name of the distance measurement tool
   * @property {string} PERIMETER_MEASUREMENT name of the perimeter measurement tool
   * @property {string} AREA_MEASUREMENT name of the area measurement tool
   * @property {string} SIGNATURE name of the signature tool
   * @property {string} STAMP name of the stamp tool
   * @property {string} FILEATTACHMENT name of the file attachment tool
   * @property {string} STICKY name of the sticky note tool
   * @property {string} HIGHLIGHT name of the text highlight tool
   * @property {string} HIGHLIGHT2 name of the second text highlight tool
   * @property {string} HIGHLIGHT3 name of the third text highlight tool
   * @property {string} HIGHLIGHT4 name of the fourth text highlight tool
   * @property {string} SQUIGGLY name of the text squiggly tool
   * @property {string} STRIKEOUT name of the text strikeout tool
   * @property {string} UNDERLINE name of the text underline tool
   * @property {string} REDACTION name of the text redaction tool
   * @property {string} TEXT_SELECT name of the text select tool
   * @property {string} EDIT name of the edit(select) tool
   * @property {string} PAN name of the pan tool
   * @property {string} CROP name of the page crop tool
   * @property {string} MARQUEE name of the marquee zoom tool
   * @property {string} ERASER name of the eraser tool
   */
  enum ToolNames {
    ARROW,
    CALLOUT,
    ELLIPSE,
    FREEHAND,
    FREEHAND2,
    FREEHAND3,
    FREEHAND4,
    FREETEXT,
    LINE,
    POLYGON,
    POLYGON_CLOUD,
    POLYLINE,
    RECTANGLE,
    DISTANCE_MEASUREMENT,
    PERIMETER_MEASUREMENT,
    AREA_MEASUREMENT,
    SIGNATURE,
    STAMP,
    FILEATTACHMENT,
    STICKY,
    HIGHLIGHT,
    HIGHLIGHT2,
    HIGHLIGHT3,
    HIGHLIGHT4,
    SQUIGGLY,
    STRIKEOUT,
    UNDERLINE,
    REDACTION,
    TEXT_SELECT,
    EDIT,
    PAN,
    CROP,
    MARQUEE,
    ERASER,
  }
}

/**
 * Contains PDFNetJS classes and functions
 * @namespace PDFNet
 */
declare namespace PDFNet {
  /**
   * Converter is a utility class used to convert documents and files to PDF.
   * Conversion of XPS, EMF and image files to PDF documents is performed internally.
   * Other document formats are converted via native application and printing.
   *
   * @class
   * @name Convert
   * @memberof PDFNet
   */
  class Convert {
    /**
     * Method to create an OfficeToPDFOptions object
     * @method PDFNet.Convert.createOfficeToPDFOptions
     * @return {Promise<PDFNet.Convert.OfficeToPDFOptions>} A promise that resolves to a PDFNet.Convert.OfficeToPDFOptions.
     */
    static createOfficeToPDFOptions(): Promise<PDFNet.Convert.OfficeToPDFOptions>;
    /**
     * Convert the specified XPS document contained in memory to PDF
     * and append converted pages to the specified PDF document.
     *
     * @method PDFNet.Convert.fromXpsMem
     * @param {PDFNet.PDFDoc} in_pdfdoc the PDFDoc to append to
     *
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf the buffer containing the xps document
     *
     */
    static fromXpsMem(in_pdfdoc: PDFNet.PDFDoc, buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): void;
    /**
     * Create a DocumentConversion object suitable for converting a file to pdf.
     * Handles incoming files in .docx, .xlsx, pptx, .doc, .png, .jpg, .bmp, .gif, .jp2, .tif, .txt, .xml and .md format
     * This conversion will be performed entirely within PDFNet, and does not rely on any external functionality.
     *
     * This method allows for more control over the conversion process than the single call
     * ToPDF() interface. It does not perform any  conversion logic immediately, and can be expected
     * to return quickly. To perform the actual conversion, use the returned DocumentConversion object.
     *
     * @method PDFNet.Convert.streamingPdfConversionWithPath
     * @see DocumentConversion
     *
     * @note Font requirements: on some systems you may need to specify extra font resources to aid
     * in conversion. Please see http://www.pdftron.com/kb_fonts_and_builtin_office_conversion
     *
     * @param {string} in_filename the path to the source document.
     *
     * @param {PDFNet.Obj} [options] the conversion options
     *
     * @return {Promise<PDFNet.DocumentConversion>} A promise that resolves to a DocumentConversion object which encapsulates this particular conversion.
     *
     * @see ConversionOptions
     *
     */
    static streamingPdfConversionWithPath(
      in_filename: string,
      options?: PDFNet.Obj,
    ): Promise<PDFNet.DocumentConversion>;
    /**
     * Create a DocumentConversion object suitable for converting a file to pdf and appending to the specified PDF document.
     * Handles incoming files in .docx, .xlsx, pptx, .doc, .png, .jpg, .bmp, .gif, .jp2, .tif, .txt, .xml and .md format
     * This conversion will be performed entirely within PDFNet, and does not rely on any external functionality.
     *
     * This method allows for more control over the conversion process than the single call
     * ToPDF() interface. It does not perform any  conversion logic immediately, and can be expected
     * to return quickly. To perform the actual conversion, use the returned DocumentConversion object.
     *
     * @method PDFNet.Convert.streamingPdfConversionWithPdfAndPath
     * @see DocumentConversion
     *
     * @note Font requirements: on some systems you may need to specify extra font resources to aid
     * in conversion. Please see http://www.pdftron.com/kb_fonts_and_builtin_office_conversion
     *
     * @param {PDFNet.PDFDoc} in_pdfdoc the conversion result will be appended to this pdf.
     *
     * @param {string} in_filename the path to the source document.
     *
     * @param {PDFNet.Obj} [options] the conversion options
     *
     * @return {Promise<PDFNet.DocumentConversion>} A promise that resolves to a DocumentConversion object which encapsulates this particular conversion.
     *
     * @see ConversionOptions
     *
     */
    static streamingPdfConversionWithPdfAndPath(
      in_pdfdoc: PDFNet.PDFDoc,
      in_filename: string,
      options?: PDFNet.Obj,
    ): Promise<PDFNet.DocumentConversion>;
    /**
     * Convert the an office document (in .docx, .xlsx, pptx, or .doc format) to pdf and append to the specified PDF document.
     * This conversion is performed entirely within PDFNet, and does not rely on Word
     * interop or any other external functionality.
     *
     * @method PDFNet.Convert.officeToPdfWithFilter
     * @note Font requirements: on some systems you may need to specify extra font resources to aid
     * in conversion. Please see http://www.pdftron.com/kb_fonts_and_builtin_office_conversion
     *
     * @param {PDFNet.PDFDoc} in_pdfdoc the conversion result will be appended to this pdf.
     *
     * @param {PDFNet.Filter} in_stream the source document data.
     *
     * @param {PDFNet.Obj} [options] the conversion options
     *
     * @throws PDFNetException
     *
     * @see ConversionOptions
     *
     * @see StreamingPDFConversion() if you would like more control over the conversion process
     *
     */
    static officeToPdfWithFilter(in_pdfdoc: PDFNet.PDFDoc, in_stream: PDFNet.Filter, options?: PDFNet.Obj): void;
    /**
     * Create a DocumentConversion object suitable for converting an office document (in .docx, .xlsx, pptx, or .doc format)
     * to pdf and appending to the specified PDF document.
     * This conversion will be performed entirely within PDFNet, and does not rely on Word
     * interop or any other external functionality.
     *
     * This method does not perform any  conversion logic and can be expected
     * to return quickly. To do the actual conversion, use the returned DocumentConversion object.
     *
     * @method PDFNet.Convert.streamingPdfConversionWithFilter
     * @see DocumentConversion
     *
     * @note Font requirements: on some systems you may need to specify extra font resources to aid
     * in conversion. Please see http://www.pdftron.com/kb_fonts_and_builtin_office_conversion
     *
     * @param {PDFNet.Filter} in_stream the source document data.
     *
     * @param {PDFNet.Obj} [options] the conversion options
     *
     * @return {Promise<PDFNet.DocumentConversion>} A promise that resolves to a DocumentConversion object which encapsulates this particular conversion.
     *
     * @see ConversionOptions
     *
     */
    static streamingPdfConversionWithFilter(
      in_stream: PDFNet.Filter,
      options?: PDFNet.Obj,
    ): Promise<PDFNet.DocumentConversion>;
    /**
     * Create a DocumentConversion object suitable for converting an office document (in .docx, .xlsx, pptx, or .doc format)
     * to pdf and appending to the specified PDF document.
     * This conversion will be performed entirely within PDFNet, and does not rely on Word
     * interop or any other external functionality.
     *
     * This method does not perform any  conversion logic and can be expected
     * to return quickly. To do the actual conversion, use the returned DocumentConversion object.
     *
     * @method PDFNet.Convert.streamingPdfConversionWithPdfAndFilter
     * @see DocumentConversion
     *
     * @note Font requirements: on some systems you may need to specify extra font resources to aid
     * in conversion. Please see http://www.pdftron.com/kb_fonts_and_builtin_office_conversion
     *
     * @param {PDFNet.PDFDoc} in_pdfdoc the conversion result will be appended to this pdf.
     *
     * @param {PDFNet.Filter} in_stream the source document data.
     *
     * @param {PDFNet.Obj} [options] the conversion options
     *
     * @return {Promise<PDFNet.DocumentConversion>} A promise that resolves to a DocumentConversion object which encapsulates this particular conversion.
     *
     * @see ConversionOptions
     *
     */
    static streamingPdfConversionWithPdfAndFilter(
      in_pdfdoc: PDFNet.PDFDoc,
      in_stream: PDFNet.Filter,
      options?: PDFNet.Obj,
    ): Promise<PDFNet.DocumentConversion>;
    /**
     *
     * @method PDFNet.Convert.fromTiff
     * @param {PDFNet.PDFDoc} in_pdfdoc
     * @param {PDFNet.Filter} in_data
     */
    static fromTiff(in_pdfdoc: PDFNet.PDFDoc, in_data: PDFNet.Filter): void;
    /**
     * Convert the an office document (in .docx, .xlsx, pptx, or .doc format) to pdf.
     *
     * @method PDFNet.Convert.office2PDF
     * @param {string|ArrayBuffer} input Either a url from which to download the file or an ArrayBuffer containing the file data.
     * @param {Object} options An object containing conversion options
     * @return {Promise<PDFNet.PDFDoc>} A promise that resolves to a "PDFDoc".
     */
    static office2PDF(input: string | ArrayBuffer, options: any): Promise<PDFNet.PDFDoc>;
  }
  /**
   * The Optimizer class provides functionality for optimizing/shrinking
   * output PDF files.
   *
   * 'pdftron.PDF.Optimizer' is an optional PDFNet Add-On utility class that can be
   * used to optimize PDF documents by reducing the file size, removing redundant
   * information, and compressing data streams using the latest in image compression
   * technology. PDF Optimizer can compress and shrink PDF file size with the
   * following operations:
   * - Remove duplicated fonts, images, ICC profiles, and any other data stream.
   * - Optionally convert high-quality or print-ready PDF files to small, efficient and web-ready PDF.
   * - Optionally down-sample large images to a given resolution.
   * - Optionally compress or recompress PDF images using JBIG2 and JPEG2000 compression formats.
   * - Compress uncompressed streams and remove unused PDF objects.
   *
   * @note 'Optimizer' is available as a separately licensable add-on to PDFNet
   * core license.
   *
   * @note See 'pdftron.PDF.Flattener' for alternate approach to optimize PDFs for fast
   * viewing on mobile devices and the Web.
   *
   * @class
   * @name Optimizer
   * @memberof PDFNet
   */
  class Optimizer {
    /**
     * Method to create an ImageSettings object
     * @method PDFNet.Optimizer.createImageSettings
     * @return {Promise<PDFNet.Optimizer.ImageSettings>} A promise that resolves to a PDFNet.Optimizer.ImageSettings.
     */
    static createImageSettings(): Promise<PDFNet.Optimizer.ImageSettings>;
    /**
     * Method to create an MonoImageSettings object
     * @method PDFNet.Optimizer.createMonoImageSettings
     * @return {Promise<PDFNet.Optimizer.MonoImageSettings>} A promise that resolves to a PDFNet.Optimizer.MonoImageSettings.
     */
    static createMonoImageSettings(): Promise<PDFNet.Optimizer.MonoImageSettings>;
    /**
     * Method to create an TextSettings object
     * @method PDFNet.Optimizer.createTextSettings
     * @return {Promise<PDFNet.Optimizer.TextSettings>} A promise that resolves to a PDFNet.Optimizer.TextSettings.
     */
    static createTextSettings(): Promise<PDFNet.Optimizer.TextSettings>;
    /**
     * Method to create an OptimizerSettings object
     * @method PDFNet.Optimizer.createOptimizerSettings
     * @return {Promise<PDFNet.Optimizer.OptimizerSettings>} A promise that resolves to a PDFNet.Optimizer.OptimizerSettings.
     */
    static createOptimizerSettings(): Promise<PDFNet.Optimizer.OptimizerSettings>;
    /**
     * Optimize the given document using the optimizers settings
     * @method PDFNet.Optimizer.optimize
     * @param {PDFNet.PDFDoc} doc the document to optimize
     * @param {Object} [optimizerSettings] the settings for the optimizer
     */
    static optimize(doc: PDFNet.PDFDoc, optimizerSettings?: any): void;
  }
  /**
   * Method to create a DiffOptions object
   * @method PDFNet.createDiffOptions
   * @return {Promise<PDFNet.DiffOptions>} A promise that resolves to a PDFNet.DiffOptions.
   */
  function createDiffOptions(): Promise<PDFNet.DiffOptions>;
  /**
   * Options for PDFNet.PDFDoc.appendVisualDiff
   * @class
   * @name DiffOptions
   * @memberof PDFNet
   */
  class DiffOptions {
    /**
     * Gets the value AddGroupAnnots from the options object
     * Whether we should add an annot layer indicating the difference regions
     * @method PDFNet.DiffOptions#getAddGroupAnnots
     * @return {boolean} a bool, the current value for AddGroupAnnots.
     */
    getAddGroupAnnots(): boolean;
    /**
     * Sets the value for AddGroupAnnots in the options object
     * Whether we should add an annot layer indicating the difference regions
     * @method PDFNet.DiffOptions#setAddGroupAnnots
     * @param {boolean} value the new value for AddGroupAnnots
     * @return {PDFNet.DiffOptions} this object, for call chaining
     */
    setAddGroupAnnots(value: boolean): PDFNet.DiffOptions;
    /**
     * Gets the value BlendMode from the options object
     * How the two colors should be blended.
     * @method PDFNet.DiffOptions#getBlendMode
     * @return {number} the current value for BlendMode.
     * @example Return value:
     * <pre>
     * PDFNet.GState.BlendMode = {
     * 	e_bl_compatible : 0
     * 	e_bl_normal : 1
     * 	e_bl_multiply : 2
     * 	e_bl_screen : 3
     * 	e_bl_difference : 4
     * 	e_bl_darken : 5
     * 	e_bl_lighten : 6
     * 	e_bl_color_dodge : 7
     * 	e_bl_color_burn : 8
     * 	e_bl_exclusion : 9
     * 	e_bl_hard_light : 10
     * 	e_bl_overlay : 11
     * 	e_bl_soft_light : 12
     * 	e_bl_luminosity : 13
     * 	e_bl_hue : 14
     * 	e_bl_saturation : 15
     * 	e_bl_color : 16
     * }
     * </pre>
     */
    getBlendMode(): number;
    /**
     * Sets the value for BlendMode in the options object
     * How the two colors should be blended.
     * @method PDFNet.DiffOptions#setBlendMode
     * @param {number} value the new value for BlendMode
     * <pre>
     * PDFNet.GState.BlendMode = {
     * 	e_bl_compatible : 0
     * 	e_bl_normal : 1
     * 	e_bl_multiply : 2
     * 	e_bl_screen : 3
     * 	e_bl_difference : 4
     * 	e_bl_darken : 5
     * 	e_bl_lighten : 6
     * 	e_bl_color_dodge : 7
     * 	e_bl_color_burn : 8
     * 	e_bl_exclusion : 9
     * 	e_bl_hard_light : 10
     * 	e_bl_overlay : 11
     * 	e_bl_soft_light : 12
     * 	e_bl_luminosity : 13
     * 	e_bl_hue : 14
     * 	e_bl_saturation : 15
     * 	e_bl_color : 16
     * }
     * </pre>
     * @return {PDFNet.DiffOptions} this object, for call chaining
     */
    setBlendMode(value: number): PDFNet.DiffOptions;
    /**
     * Gets the value ColorA from the options object
     * The difference color for the first page.
     * @method PDFNet.DiffOptions#getColorA
     * @return {PDFNet.ColorPt} a ColorPt, the current value for ColorA.
     */
    getColorA(): PDFNet.ColorPt;
    /**
     * Sets the value for ColorA in the options object
     * The difference color for the first page.
     * @method PDFNet.DiffOptions#setColorA
     * @param {PDFNet.ColorPt} value the new value for ColorA
     * @return {PDFNet.DiffOptions} this object, for call chaining
     */
    setColorA(value: PDFNet.ColorPt): PDFNet.DiffOptions;
    /**
     * Gets the value ColorB from the options object
     * The difference color for the second page
     * @method PDFNet.DiffOptions#getColorB
     * @return {PDFNet.ColorPt} a ColorPt, the current value for ColorB.
     */
    getColorB(): PDFNet.ColorPt;
    /**
     * Sets the value for ColorB in the options object
     * The difference color for the second page
     * @method PDFNet.DiffOptions#setColorB
     * @param {PDFNet.ColorPt} value the new value for ColorB
     * @return {PDFNet.DiffOptions} this object, for call chaining
     */
    setColorB(value: PDFNet.ColorPt): PDFNet.DiffOptions;
  }
  /**
   * Actions are typically what happens when a user clicks on a link or bookmark.
   *
   * Instead of simply jumping to a destination in the document, an annotation or
   * outline item can specify an action for the viewer application to perform, such
   * as launching an application, playing a sound, or changing an annotation's
   * appearance state.
   *
   * @note Although the Action class provides utility functions for most commonly used
   * action types, it is possible to read, write, and edit any action type using SDF API
   * and dictionary entries described in Section 8.5 in the PDF Reference Manual.
   * @class
   * @name Action
   * @memberof PDFNet
   */
  class Action {
    /**
     * creates a new 'GoTo'action. GoTo action takes the user to the
     * specified Destination view located in the same document.
     *
     * @method PDFNet.Action.createGoto
     * @param {PDFNet.Destination} dest A Destination for the new Action.
     *
     * @note This method can only be used for destinations in the same
     * document as the source document. For cross-document links use
     * Action::CreateGotoRemote().
     * @return {Promise<PDFNet.Action>} A promise that resolves to an object of type: "Action"
     */
    static createGoto(dest: PDFNet.Destination): Promise<PDFNet.Action>;
    /**
     *
     * @method PDFNet.Action.createGotoWithKey
     * @param {string} key
     * @param {PDFNet.Destination} dest
     * @return {Promise<PDFNet.Action>} A promise that resolves to an object of type: "Action"
     */
    static createGotoWithKey(key: string, dest: PDFNet.Destination): Promise<PDFNet.Action>;
    /**
     * creates a new 'GoToR'action. A remote go-to action is similar to an
     * ordinary go-to action but jumps to a destination in another PDF file
     * instead of the current file.
     *
     * @method PDFNet.Action.createGotoRemote
     * @param {PDFNet.FileSpec} file The file referred to by the action.
     * @param {number} page_num A page number within the remote document. The first page is
     * numbered 0.
     * @new_window A flag specifying whether to open the destination document
     * in a new window. If new_window is false, the destination document replaces
     * the current document in the same window, otherwise the viewer application
     * should behave in accordance with the current user preference.
     * @return {Promise<PDFNet.Action>} A promise that resolves to an object of type: "Action"
     */
    static createGotoRemote(file: PDFNet.FileSpec, page_num: number): Promise<PDFNet.Action>;
    /**
     * Creates a new 'GoToR'action. See the above method for details.
     *
     * @method PDFNet.Action.createGotoRemoteSetNewWindow
     * @param {PDFNet.FileSpec} file The file referred to by the action.
     * @param {number} page_num A page number within the remote document. The first page is
     * numbered 0.
     * @param {boolean} new_window A flag specifying whether to open the destination document
     * in a new window. If new_window is false, the destination document replaces
     * the current document in the same window, otherwise the viewer application
     * should behave in accordance with the current user preference.
     * @return {Promise<PDFNet.Action>} A promise that resolves to an object of type: "Action"
     */
    static createGotoRemoteSetNewWindow(
      file: PDFNet.FileSpec,
      page_num: number,
      new_window: boolean,
    ): Promise<PDFNet.Action>;
    /**
     * Create a new URI action. The URI action is typically resolved by opening a URL in
     * the default web browser.
     *
     * @method PDFNet.Action.createURI
     * @param {PDFNet.SDFDoc} sdfdoc The document in which to create the action.
     * @param {string} uri The uniform resource identifier to resolve, encoded in 7-bit ASCII.
     * A uniform resource identifier (URI) is a string that identifies (resolves to) a resource
     * on the Internet; typically a file that is the destination of a hypertext link, although
     * it can also resolve to a query or other entity. (URIs are described in Internet RFC 2396,
     * Uniform Resource Identifiers (URI).
     * @return {Promise<PDFNet.Action>} A promise that resolves to an object of type: "Action"
     */
    static createURI(sdfdoc: PDFNet.SDFDoc, uri: string): Promise<PDFNet.Action>;
    /**
     *
     * @method PDFNet.Action.createURIWithUString
     * @param {PDFNet.SDFDoc} sdfdoc
     * @param {string} current
     * @return {Promise<PDFNet.Action>} A promise that resolves to an object of type: "Action"
     */
    static createURIWithUString(sdfdoc: PDFNet.SDFDoc, current: string): Promise<PDFNet.Action>;
    /**
     * creates a new 'SubmitForm'action. A submit-form action transmits the names
     * and values of selected interactive form fields to a specified uniform
     * resource locator (URL), presumably the address of a Web server that will
     * process them and send back a response.
     *
     * @method PDFNet.Action.createSubmitForm
     * @param {PDFNet.FileSpec} url A URL file specification giving the uniform resource locator (URL)
     * of the script at the Web server that will process the submission.
     * @return {Promise<PDFNet.Action>} A promise that resolves to an object of type: "Action"
     */
    static createSubmitForm(url: PDFNet.FileSpec): Promise<PDFNet.Action>;
    /**
     * Creates a new 'Launch' action. A launch action opens up a file using the
     * most appropriate program.
     *
     * @method PDFNet.Action.createLaunch
     * @param {PDFNet.SDFDoc} sdfdoc the document in which to create the action
     * @param {string} path the full path of the file to be opened
     * @return {Promise<PDFNet.Action>} A promise that resolves to an object of type: "Action"
     */
    static createLaunch(sdfdoc: PDFNet.SDFDoc, path: string): Promise<PDFNet.Action>;
    /**
     * Creates a new 'Show/Hide Field' action. A show/hide field action shows
     * or hide certain fields when it's invoked.
     *
     * @method PDFNet.Action.createHideField
     * @param {PDFNet.SDFDoc} sdfdoc the document in which to create the action
     * @param {number} list_length the number of fields to hide
     * @param {string} field_list the list of fields to hide
     * @return {Promise<PDFNet.Action>} A promise that resolves to an object of type: "Action"
     */
    static createHideField(sdfdoc: PDFNet.SDFDoc, list_length: number, field_list: string): Promise<PDFNet.Action>;
    /**
     * Creates a new 'Import Data' action. An import data action imports
     * form data from a FDF file into a PDF document.
     *
     * @method PDFNet.Action.createImportData
     * @param {PDFNet.SDFDoc} sdfdoc the document in which to create the action
     * @param {string} path the full path of the FDF file
     * @return {Promise<PDFNet.Action>} A promise that resolves to an object of type: "Action"
     */
    static createImportData(sdfdoc: PDFNet.SDFDoc, path: string): Promise<PDFNet.Action>;
    /**
     * Creates a new 'Reset Form' action. A reset form action reset chosen
     * form fields to their default value.
     *
     * @method PDFNet.Action.createResetForm
     * @param {PDFNet.SDFDoc} sdfdoc the document in which to create the action
     * @return {Promise<PDFNet.Action>} A promise that resolves to an object of type: "Action"
     */
    static createResetForm(sdfdoc: PDFNet.SDFDoc): Promise<PDFNet.Action>;
    /**
     * Creates a new 'JavaScript' action. A javascript action executes a JavaScript
     * script when it's invoked.
     *
     * @method PDFNet.Action.createJavaScript
     * @param {PDFNet.SDFDoc} sdfdoc the document in which to create the action
     * @param {string} script the JavaScript script to be executed
     * @return {Promise<PDFNet.Action>} A promise that resolves to an object of type: "Action"
     */
    static createJavaScript(sdfdoc: PDFNet.SDFDoc, script: string): Promise<PDFNet.Action>;
    /**
     * A constructor. Creates an Action and initializes it using given Cos/SDF object.
     *
     * @method PDFNet.Action.create
     * @param {PDFNet.Obj} [in_obj] Pointer to the Cos/SDF object.
     *
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.Action>} A promise that resolves to an object of type: "Action"
     */
    static create(in_obj?: PDFNet.Obj): Promise<PDFNet.Action>;
    /**
     *
     * @method PDFNet.Action#copy
     * @return {Promise<PDFNet.Action>} A promise that resolves to an object of type: "Action"
     */
    copy(): Promise<PDFNet.Action>;
    /**
     * Compares two Action objects for equality.
     *
     * @method PDFNet.Action#compare
     * @param {PDFNet.Action} in_action A reference to an existing Action object.
     *
     * @return {Promise<boolean>} A promise that resolves to true if the both Actions share the same underlying SDF/Cos object; otherwise false.
     */
    compare(in_action: PDFNet.Action): Promise<boolean>;
    /**
     * Indicates whether the Action is valid (non-null).
     *
     * @method PDFNet.Action#isValid
     * @return {Promise<boolean>} A promise that resolves to true if this is a valid (non-null) Action; otherwise false.
     *
     * @note If this method returns false the underlying SDF/Cos object is null and
     * the Action object should be treated as null as well.
     */
    isValid(): Promise<boolean>;
    /**
     * @method PDFNet.Action#getType
     * @return {Promise<number>} A promise that resolves to the type of this Action.
     * @example Return value enum:
     * <pre>
     * PDFNet.Action.Type = {
     * 	e_GoTo : 0
     * 	e_GoToR : 1
     * 	e_GoToE : 2
     * 	e_Launch : 3
     * 	e_Thread : 4
     * 	e_URI : 5
     * 	e_Sound : 6
     * 	e_Movie : 7
     * 	e_Hide : 8
     * 	e_Named : 9
     * 	e_SubmitForm : 10
     * 	e_ResetForm : 11
     * 	e_ImportData : 12
     * 	e_JavaScript : 13
     * 	e_SetOCGState : 14
     * 	e_Rendition : 15
     * 	e_Trans : 16
     * 	e_GoTo3DView : 17
     * 	e_RichMediaExecute : 18
     * 	e_Unknown : 19
     * }
     * </pre>
     */
    getType(): Promise<number>;
    /**
     * @method PDFNet.Action#getDest
     * @return {Promise<PDFNet.Destination>} A promise that resolves to the Action's Destination view.
     *
     * @note This only works for Actions whose subtype is "GoTo".
     *
     * @note All named destinations are automatically resolved to the
     * explicit destination so you can access destination members directly.
     */
    getDest(): Promise<PDFNet.Destination>;
    /**
     * @method PDFNet.Action#getNext
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the next action dictionary, an array of action dictionaries,
     * or NULL if there are no additional actions.
     *
     * Sequences of actions can be chained together. For example, the effect
     * of clicking a link annotation with the mouse might be to play a sound,
     * jump to a new page, and start up a movie. Note that the Next entry is
     * not restricted to a single action but may contain an array of actions,
     * each of which in turn may have a Next entry of its own. The actions may
     * thus form a tree instead of a simple linked list. Actions within each
     * Next array are executed in order, each followed in turn by any actions
     * specified in its Next entry, and so on recursively.
     */
    getNext(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Action#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to pointer to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Action#getFormActionFlag
     * @param {number} flag
     * <pre>
     * PDFNet.Action.FormActionFlag = {
     * 	e_exclude : 0
     * 	e_include_no_value_fields : 1
     * 	e_export_format : 2
     * 	e_get_method : 3
     * 	e_submit_coordinates : 4
     * 	e_xfdf : 5
     * 	e_include_append_saves : 6
     * 	e_include_annotations : 7
     * 	e_submit_pdf : 8
     * 	e_canonical_format : 9
     * 	e_excl_non_user_annots : 10
     * 	e_excl_F_key : 11
     * 	e_embed_form : 13
     * }
     * </pre>
     * Action flag to get the value from.
     * @return {Promise<boolean>} A promise that resolves to boolean value of the given action flag.
     * @note Action flags are currently only used by submit and reset form actions.
     */
    getFormActionFlag(flag: number): Promise<boolean>;
    /**
     * Set the value of a given field flag.
     * @method PDFNet.Action#setFormActionFlag
     * @param {number} flag
     * <pre>
     * PDFNet.Action.FormActionFlag = {
     * 	e_exclude : 0
     * 	e_include_no_value_fields : 1
     * 	e_export_format : 2
     * 	e_get_method : 3
     * 	e_submit_coordinates : 4
     * 	e_xfdf : 5
     * 	e_include_append_saves : 6
     * 	e_include_annotations : 7
     * 	e_submit_pdf : 8
     * 	e_canonical_format : 9
     * 	e_excl_non_user_annots : 10
     * 	e_excl_F_key : 11
     * 	e_embed_form : 13
     * }
     * </pre>
     * Action flag to get the value from.
     * @param {boolean} value Boolean to set the value of the flag to.
     * Action flags are currently only used by submit and reset form actions.
     */
    setFormActionFlag(flag: number, value: boolean): void;
    /**
     * Test if the action needs writeLock
     * @method PDFNet.Action#needsWriteLock
     * @return {Promise<boolean>} A promise that resolves to ture if needs, otherwise false
     */
    needsWriteLock(): Promise<boolean>;
    /**
     * Executes current action; this will only work for some action types that can be executed
     * only using the information contained in the action object or the associated PDF doc.
     * See also PDFViewCtrl::ExecuteAction()
     * @method PDFNet.Action#execute
     */
    execute(): void;
    /**
     * Executes KeyStrokeAction, this shall be performed when the user modifies a character in a text field
     * or combo box or modifies the selecton in a scrollable list box. This action checks the added text for
     * validity and reject or modify it.
     *
     * @method PDFNet.Action#executeKeyStrokeAction
     * @param {PDFNet.KeyStrokeEventData} data Data that contains previous text, added text,and added position information.
     * @return {Promise<PDFNet.KeyStrokeActionResult>} A promise that resolves to an object of type: "KeyStrokeActionResult"
     */
    executeKeyStrokeAction(data: PDFNet.KeyStrokeEventData): Promise<PDFNet.KeyStrokeActionResult>;
  }
  /**
   * [Missing documentation]
   * @class
   * @name ActionParameter
   * @memberof PDFNet
   */
  class ActionParameter {}
  /**
   * Annot is a base class for different types of annotations. For annotation
   * specific properties, please refer to derived classes.
   *
   * An annotation is an interactive object placed on a page, such as a text note, a link,
   * or an embedded file. PDF includes a wide variety of standard annotation types.
   * An annotation associates an object such as a widget, note, or movie with a location
   * on a page of a PDF document, or provides a means of interacting with the user
   * via the mouse and keyboard. For more details on PDF annotations please refer to
   * section 12.5 in the PDF Reference Manual and the documentation in derived classes.
   * @class
   * @name Annot
   * @memberof PDFNet
   */
  class Annot {
    /**
     * Creates a new annotation of a given type, in the specified document.
     * The newly created annotation does not contain any properties specific
     * to a given annotation type, which means an invalid annotation object could be created.
     * It is therefore recommended to always create an annotation using type specific methods,
     * such as Annots::Line::Create() or Annots::FileAttachment::Create().
     * Users should only call Annot::Create() to create annotations of non-standard types
     * that are not recognized by PDFTron software (by using Annot::e_Unknown as a type).
     *
     * @method PDFNet.Annot.create
     * @param {PDFNet.SDFDoc} doc A document to which the annotation is added.
     * @param {number} type
     * <pre>
     * PDFNet.Annot.Type = {
     * 	e_Text : 0
     * 	e_Link : 1
     * 	e_FreeText : 2
     * 	e_Line : 3
     * 	e_Square : 4
     * 	e_Circle : 5
     * 	e_Polygon : 6
     * 	e_Polyline : 7
     * 	e_Highlight : 8
     * 	e_Underline : 9
     * 	e_Squiggly : 10
     * 	e_StrikeOut : 11
     * 	e_Stamp : 12
     * 	e_Caret : 13
     * 	e_Ink : 14
     * 	e_Popup : 15
     * 	e_FileAttachment : 16
     * 	e_Sound : 17
     * 	e_Movie : 18
     * 	e_Widget : 19
     * 	e_Screen : 20
     * 	e_PrinterMark : 21
     * 	e_TrapNet : 22
     * 	e_Watermark : 23
     * 	e_3D : 24
     * 	e_Redact : 25
     * 	e_Projection : 26
     * 	e_RichMedia : 27
     * 	e_Unknown : 28
     * }
     * </pre>
     * Subtype of annotation to create.
     * @param {PDFNet.Rect} pos A rectangle specifying the annotation's bounds, specified in
     * user space coordinates.
     *
     * @return {Promise<PDFNet.Annot>} A promise that resolves to a newly created blank annotation for the given annotation type.
     */
    static create(doc: PDFNet.SDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
    /**
     * Create an annotation and initialize it using given Cos/SDF object.
     * @method PDFNet.Annot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.Annot>} A promise that resolves to an object of type: "Annot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.Annot>;
    /**
     * Assignment operator
     * @method PDFNet.Annot#copy
     * @return {Promise<PDFNet.Annot>} A promise that resolves to an object of type: "Annot"
     */
    copy(): Promise<PDFNet.Annot>;
    /**
     * Compares two annotations for equality. The comparison will return true
     * only if both annotations share the same underlying SDF/Cos object.
     * @method PDFNet.Annot#compare
     * @param {PDFNet.Annot} d Annotation to compare to
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    compare(d: PDFNet.Annot): Promise<boolean>;
    /**
     * @method PDFNet.Annot#isValid
     * @return {Promise<boolean>} A promise that resolves to true if this is a valid (non-null) annotation, false otherwise.
     * If the function returns false the underlying SDF/Cos object is null or is
     * not valid and the annotation object should be treated as a null object.
     */
    isValid(): Promise<boolean>;
    /**
     * @method PDFNet.Annot#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Annot#getType
     * @return {Promise<number>} A promise that resolves to the type of this annotation. Corresponds to the "Subtype" entry of annotation
     * dictionary, as per PDF Reference Manual section 12.5.2
     * @example Return value enum:
     * <pre>
     * PDFNet.Annot.Type = {
     * 	e_Text : 0
     * 	e_Link : 1
     * 	e_FreeText : 2
     * 	e_Line : 3
     * 	e_Square : 4
     * 	e_Circle : 5
     * 	e_Polygon : 6
     * 	e_Polyline : 7
     * 	e_Highlight : 8
     * 	e_Underline : 9
     * 	e_Squiggly : 10
     * 	e_StrikeOut : 11
     * 	e_Stamp : 12
     * 	e_Caret : 13
     * 	e_Ink : 14
     * 	e_Popup : 15
     * 	e_FileAttachment : 16
     * 	e_Sound : 17
     * 	e_Movie : 18
     * 	e_Widget : 19
     * 	e_Screen : 20
     * 	e_PrinterMark : 21
     * 	e_TrapNet : 22
     * 	e_Watermark : 23
     * 	e_3D : 24
     * 	e_Redact : 25
     * 	e_Projection : 26
     * 	e_RichMedia : 27
     * 	e_Unknown : 28
     * }
     * </pre>
     */
    getType(): Promise<number>;
    /**
     * Return true if this annotation is classified as a markup annotation.
     *
     * @method PDFNet.Annot#isMarkup
     * @return {Promise<boolean>} A promise that resolves to boolean value, true if this annotation is classified as a markup annotation.
     */
    isMarkup(): Promise<boolean>;
    /**
     * @method PDFNet.Annot#getRect
     * @return {Promise<PDFNet.Rect>} A promise that resolves to annotation's bounding rectangle, specified in user space coordinates.
     *
     * The meaning of the rectangle depends on the annotation type. For Link and RubberStamp
     * annotations, the rectangle specifies the area containing the hyperlink area or stamp.
     * For Note annotations, the rectangle is describing the popup window when it's opened.
     * When it's closed, the icon is positioned at lower left corner.
     */
    getRect(): Promise<PDFNet.Rect>;
    /**
     * It is possible during viewing that GetRect does not return the most accurate bounding box
     * of what is actually rendered. This method calculates the bounding box, rather than relying
     * on what is specified in the PDF document. The bounding box is defined as the smallest
     * rectangle that includes all the visible content on the annotation.
     *
     * @method PDFNet.Annot#getVisibleContentBox
     * @return {Promise<PDFNet.Rect>} A promise that resolves to the bounding box for this annotation. The dimensions are specified in user space
     * coordinates.
     */
    getVisibleContentBox(): Promise<PDFNet.Rect>;
    /**
     * Sets the size and location of an annotation on its page.
     * @method PDFNet.Annot#setRect
     * @param {PDFNet.Rect} pos Annotation's bounding rectangle, specified in user space coordinates.
     *
     * The meaning of the rectangle depends on the annotation type. For Link and RubberStamp
     * annotations, the rectangle specifies the area containing the hyperlink area or stamp.
     * For Note annotations, the rectangle is describing the popup window when it's opened.
     * When it's closed, the icon is positioned at lower left corner.
     */
    setRect(pos: PDFNet.Rect): void;
    /**
     * Scales the geometry of the annotation so that its appearance would now fit a new
     * rectangle on the page, in user units. Users still have to call RefreshAppearance() later
     * if they want a corresponding appearance stream to be generated for the new rectangle.
     * The main reason for not combining the two operations together is to be able to resize
     * annotations that do not have an appearance stream.
     *
     * @method PDFNet.Annot#resize
     * @param {PDFNet.Rect} newrect A reference to the new rectangle to which this annotation has to be resized.
     */
    resize(newrect: PDFNet.Rect): void;
    /**
     * Sets the content of this annotation. (Optional).
     *
     * @method PDFNet.Annot#setContents
     * @param {string} contents A reference to unicode string object with the text that will be associated with
     * this annotation. This is the text that annotation displays on user interaction, if the annotation
     * type supports it.
     */
    setContents(contents: string): void;
    /**
     * Extract the content of this annotation. (Optional).
     *
     * @method PDFNet.Annot#getContents
     * @return {Promise<string>} A promise that resolves to  A unicode string object with the text that is associated with
     * this annotation. This is the text that annotation displays on user interaction,
     * if the annotation type supports it.
     */
    getContents(): Promise<string>;
    /**
     * Get the Action associated with the selected Annot Trigger event.
     *
     * @method PDFNet.Annot#getTriggerAction
     * @param {number} trigger
     * <pre>
     * PDFNet.Annot.EventType = {
     * 	e_action_trigger_activate : 0
     * 	e_action_trigger_annot_enter : 1
     * 	e_action_trigger_annot_exit : 2
     * 	e_action_trigger_annot_down : 3
     * 	e_action_trigger_annot_up : 4
     * 	e_action_trigger_annot_focus : 5
     * 	e_action_trigger_annot_blur : 6
     * 	e_action_trigger_annot_page_open : 7
     * 	e_action_trigger_annot_page_close : 8
     * 	e_action_trigger_annot_page_visible : 9
     * 	e_action_trigger_annot_page_invisible : 10
     * }
     * </pre>
     * the type of trigger event to get
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the Action Obj if present, otherwise NULL
     */
    getTriggerAction(trigger: number): Promise<PDFNet.Obj>;
    /**
     * Returns custom data associated with the given key.
     *
     * @method PDFNet.Annot#getCustomData
     * @param {string} key The key for which to retrieve the associated data.
     * @return {Promise<string>} A promise that resolves to the custom data string. If no data is available an empty string is returned.
     */
    getCustomData(key: string): Promise<string>;
    /**
     * Sets the custom data associated with the specified key.
     *
     * @method PDFNet.Annot#setCustomData
     * @param {string} key The key under which to store this custom data
     * @param {string} value The custom data string to store
     */
    setCustomData(key: string, value: string): void;
    /**
     * Deletes custom data associated with the given key.
     *
     * @method PDFNet.Annot#deleteCustomData
     * @param {string} key The key for which to delete the associated data.
     */
    deleteCustomData(key: string): void;
    /**
     * Gets the page the annotation is associated with.
     *
     * @method PDFNet.Annot#getPage
     * @return {Promise<PDFNet.Page>} A promise that resolves to a Page object or null page object if the page reference is not available.
     * The page object returned is an indirect reference to the page object with which
     * this annotation is associated.
     * This entry shall be present in screen annotations associated with rendition actions.
     *
     * Optional. PDF 1.3 PDF 1.4 PDF 1.5 not used in FDF files.
     */
    getPage(): Promise<PDFNet.Page>;
    /**
     * sets the reference to a page the annotation is associated with.
     * (Optional PDF 1.3; not used in FDF files)
     *
     * @method PDFNet.Annot#setPage
     * @param {PDFNet.Page} Page The page object user wants the annotation to be associated with.
     *
     * @note The parameter should be an indirect reference to the page object with
     * which this annotation is associated. This entry shall be present in screen
     * annotations associated with rendition actions
     */
    setPage(Page: PDFNet.Page): void;
    /**
     * @method PDFNet.Annot#getUniqueID
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the unique identifier for this annotation, or NULL if the identifier is not
     * available. The returned value is a String object and is the value of the "NM"
     * field, which was added as an optional attribute in PDF 1.4.
     */
    getUniqueID(): Promise<PDFNet.Obj>;
    /**
     * Gets an annotation's last modified date.
     * @method PDFNet.Annot#getDate
     * @return {Promise<PDFNet.Date>} A promise that resolves to the annotation's last modified time and date. If the annotation has no associated
     * date structure, the returned date is not valid (date.IsValid() returns false). Corresponds
     * to the "M" entry of the annotation dictionary.
     */
    getDate(): Promise<PDFNet.Date>;
    /**
     * Sets an annotation's last modified date.
     * @method PDFNet.Annot#setDate
     * @param {PDFNet.Date} date The annotation's last modified time and date. Corresponds to the "M" entry of the
     * annotation dictionary.
     */
    setDate(date: PDFNet.Date): void;
    /**
     * @method PDFNet.Annot#getFlag
     * @return {Promise<boolean>} A promise that resolves to the value of given Flag
     * @param {number} flag
     * <pre>
     * PDFNet.Annot.Flag = {
     * 	e_invisible : 0
     * 	e_hidden : 1
     * 	e_print : 2
     * 	e_no_zoom : 3
     * 	e_no_rotate : 4
     * 	e_no_view : 5
     * 	e_annot_read_only : 6
     * 	e_locked : 7
     * 	e_toggle_no_view : 8
     * 	e_locked_contents : 9
     * }
     * </pre>
     * The Flag property to query.
     */
    getFlag(flag: number): Promise<boolean>;
    /**
     * sets the value of given Flag.
     *
     * @method PDFNet.Annot#setFlag
     * @param {number} flag
     * <pre>
     * PDFNet.Annot.Flag = {
     * 	e_invisible : 0
     * 	e_hidden : 1
     * 	e_print : 2
     * 	e_no_zoom : 3
     * 	e_no_rotate : 4
     * 	e_no_view : 5
     * 	e_annot_read_only : 6
     * 	e_locked : 7
     * 	e_toggle_no_view : 8
     * 	e_locked_contents : 9
     * }
     * </pre>
     * The Flag property to modify.
     * @param {boolean} value The new value for the property.
     */
    setFlag(flag: number, value: boolean): void;
    /**
     * Gets the annotation's appearance for the given combination of annotation
     * and appearance states.
     *
     * @method PDFNet.Annot#getAppearance
     * @param {number} [annot_state]
     * <pre>
     * PDFNet.Annot.State = {
     * 	e_normal : 0
     * 	e_rollover : 1
     * 	e_down : 2
     * }
     * </pre>
     * the annotation's appearance state, which selects the applicable
     * appearance stream from the appearance sub-dictionary. An annotation can define as many
     * as three separate appearances: The normal, rollover, and down appearance.
     * @param {string} [app_state] is an optional parameter specifying the appearance state
     * to look for (e.g. "Off", "On", etc). If appearance_state is NULL, the choice
     * between different appearance states is determined by the AS (Appearance State)
     * entry in the annotation dictionary.
     *
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the appearance stream for this annotation, or NULL if the annotation
     * does not have an appearance for the given combination of annotation and
     * appearance states.
     */
    getAppearance(annot_state?: number, app_state?: string): Promise<PDFNet.Obj>;
    /**
     * Sets the annotation's appearance for the given combination of annotation
     * and appearance states.
     * (Optional; PDF 1.2)
     *
     * @method PDFNet.Annot#setAppearance
     * @param {PDFNet.Obj} app_stream a content stream defining the new appearance.
     *
     * @param {number} [annot_state]
     * <pre>
     * PDFNet.Annot.State = {
     * 	e_normal : 0
     * 	e_rollover : 1
     * 	e_down : 2
     * }
     * </pre>
     * the annotation's appearance state, which selects the applicable
     * appearance stream from the appearance sub-dictionary. An annotation can define as many
     * as three separate appearances: The normal, rollover, and down appearance.
     *
     * @param {string} [app_state] is an optional parameter specifying the appearance state
     * (e.g. "Off", "On", etc) under which the new appearance should be stored. If
     * appearance_state is NULL, the annotation will have only one annotation state.
     */
    setAppearance(app_stream: PDFNet.Obj, annot_state?: number, app_state?: string): void;
    /**
     * Removes the annotation's appearance for the given combination of annotation
     * and appearance states.
     *
     * @method PDFNet.Annot#removeAppearance
     * @param {number} [annot_state]
     * <pre>
     * PDFNet.Annot.State = {
     * 	e_normal : 0
     * 	e_rollover : 1
     * 	e_down : 2
     * }
     * </pre>
     * the annotation's appearance state, which selects the applicable
     * appearance stream from the appearance sub-dictionary. An annotation can define as many
     * as three separate appearances: The normal, rollover, and down appearance.
     *
     * @param {string} [app_state] is an optional parameter specifying the appearance state
     * (e.g. "Off", "On", etc) under which the new appearance should be stored. If
     * appearance_state is NULL, the annotation will have only one annotation state.
     */
    removeAppearance(annot_state?: number, app_state?: string): void;
    /**
     *
     * @method PDFNet.Annot#flatten
     * @param {PDFNet.Page} page
     */
    flatten(page: PDFNet.Page): void;
    /**
     * Gets the annotation's active appearance state.
     *
     * @method PDFNet.Annot#getActiveAppearanceState
     * @return {Promise<string>} A promise that resolves to the name of the active state.
     * The annotation's appearance state, which
     * selects the applicable appearance stream from an appearance subdictionary.
     */
    getActiveAppearanceState(): Promise<string>;
    /**
     *
     * @method PDFNet.Annot#setActiveAppearanceState
     * @param {string} astate
     */
    setActiveAppearanceState(astate: string): void;
    /**
     * Gets an annotation's color without any specified color space. It is generally recommended
     * to use getColorAsRGB(), getColorAsCMYK() or getColorAsGray() for more predictable behavior
     *
     * @method PDFNet.Annot#getColor
     * @return {Promise<PDFNet.ColorPt>} A promise that resolves to a ColorPt object containing an array of numbers in the
     * range 0.0 to 1.0.
     */
    getColor(): Promise<PDFNet.ColorPt>;
    /**
     * Gets an annotation's color in RGB color space.
     *
     * @method PDFNet.Annot#getColorAsRGB
     * @return {Promise<PDFNet.ColorPt>} A promise that resolves to a ColorPt object containing an array of three numbers in the range 0.0 to 1.0,
     * representing an RGB colour used for the following purposes:
     *   The background of the annotation's icon when closed
     *   The title bar of the annotation's pop-up window
     *   The border of a link annotation
     *
     *  If the annotation does not specify an explicit color, a default color is returned.
     *  Text annotations return 'default yellow;' all others return black.
     */
    getColorAsRGB(): Promise<PDFNet.ColorPt>;
    /**
     * Returns the annotation's color in CMYK color space.
     *
     * @method PDFNet.Annot#getColorAsCMYK
     * @return {Promise<PDFNet.ColorPt>} A promise that resolves to a ColorPt object containing an array of four numbers in the range 0.0 to 1.0,
     * representing a CMYK color used for the following purposes:
     *   The background of the annotation's icon when closed
     *   The title bar of the annotation's pop-up window
     *   The border of a link annotation
     *
     * If the annotation does not specify an explicit color, a default color is returned.
     * Text annotations return 'default yellow;' all others return black.
     */
    getColorAsCMYK(): Promise<PDFNet.ColorPt>;
    /**
     * Returns the annotation's color in Gray color space.
     *
     * @method PDFNet.Annot#getColorAsGray
     * @return {Promise<PDFNet.ColorPt>} A promise that resolves to a ColorPt object containing a number in the range 0.0 to 1.0,
     * representing a Gray Scale color used for the following purposes:
     * The background of the annotation's icon when closed
     * The title bar of the annotation's pop-up window
     * The border of a link annotation
     * If the annotation does not specify an explicit color, black color is returned.
     */
    getColorAsGray(): Promise<PDFNet.ColorPt>;
    /**
     * Returns the color space the annotation's color is represented in.
     *
     * @method PDFNet.Annot#getColorCompNum
     * @return {Promise<number>} A promise that resolves to an integer that is either 1(for DeviceGray), 3(DeviceRGB), or 4(DeviceCMYK).
     * If the annotation has no color, i.e. is transparent, 0 will be returned.
     */
    getColorCompNum(): Promise<number>;
    /**
     *
     * @method PDFNet.Annot#setColorDefault
     * @param {PDFNet.ColorPt} col
     */
    setColorDefault(col: PDFNet.ColorPt): void;
    /**
     * Sets an annotation's color.
     * (Optional; PDF 1.1)
     *
     * @method PDFNet.Annot#setColor
     * @param {PDFNet.ColorPt} col A ColorPt object in RGB or Gray or CMYK color space representing the annotation's color.
     * The ColorPt contains an array of numbers in the range 0.0 to 1.0, representing a color used for the following purposes:
     *    The background of the annotation's icon when closed
     *     The title bar of the annotation's pop-up window
     *     The border of a link annotation
     *
     * The number of array elements determines the color space in which the color shall be defined:
     * 0 No color; transparent
     * 1 DeviceGray
     * 3 DeviceRGB
     * 4 DeviceCMYK
     *
     * @param {number} [numcomp] The number of color components used to represent the color (i.e. 1, 3, 4).
     */
    setColor(col: PDFNet.ColorPt, numcomp?: number): void;
    /**
     * Returns the struct parent of an annotation.
     * (Required if the annotation is a structural content item; PDF 1.3)
     *
     * @method PDFNet.Annot#getStructParent
     * @return {Promise<number>} A promise that resolves to an integer which is the integer key of the annotation's entry
     * in the structural parent tree.
     * @note The StructParent is the integer key of the annotation's entry
     * in the structural parent tree.
     */
    getStructParent(): Promise<number>;
    /**
     * sets the struct parent of an annotation.
     * (Required if the annotation is a structural content item; PDF 1.3)
     *
     * @method PDFNet.Annot#setStructParent
     * @param {number} parkeyval An integer which is the integer key of the
     * annotation's entry in the structural parent tree.
     * @note The StructParent is the integer key of the annotation's entry
     * in the structural parent tree.
     */
    setStructParent(parkeyval: number): void;
    /**
     * Returns optional content associated with this annotation.
     *
     * @method PDFNet.Annot#getOptionalContent
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a SDF object corresponding to the group of optional properties.
     * @note The return value is an Optional Content Group (OCG) or Optional Content Membership
     * Dictionary (PDF::OCG::OCMD) specifying the optional content properties for the annotation.
     * Before the annotation is drawn, its visibility shall be determined based on this entry
     * as well as the annotation flags specified in the Flag entry. If it is determined to be
     * invisible, the annotation shall be skipped, as if it were not in the document.
     */
    getOptionalContent(): Promise<PDFNet.Obj>;
    /**
     * Associates optional content with this annotation. (Optional, PDF1.5).
     *
     * @method PDFNet.Annot#setOptionalContent
     * @param {PDFNet.Obj} content A pointer to an SDF object corresponding to the optional content,
     * a PDF::OCG::Group or membership dictionary specifying the PDF::OCG::Group properties for
     * the annotation. Before the annotation is drawn, its visibility
     * shall be determined based on this entry as well as the annotation
     * flags specified in the Flag entry . If it is determined to be invisible,
     * the annotation shall be skipped, as if it were not in the document.
     */
    setOptionalContent(content: PDFNet.Obj): void;
    /**
     * Regenerates the appearance stream for the annotation.
     * This method can be used to auto-generate the annotation appearance after creating
     * or modifying the annotation without providing an explicit appearance or
     * setting the "NeedAppearances" flag in the AcroForm dictionary.
     *
     * @method PDFNet.Annot#refreshAppearance
     * @note If this annotation contains text, and has been added to a rotated page, the text in
     * the annotation may be rotated. If RefreshAppearance is called *after* the annotation is added
     * to a rotated page, then any text will be rotated in the opposite direction of the page
     * rotation. If this method is called *before* the annotation is added to any rotated page, then
     * no counter rotation will be applied. If you wish to call RefreshAppearance on an annotation
     * already added to a rotated page, but you don't want the text to be rotated, you can do one
     * of the following; temporarily un-rotate the page, or, temporarily remove the "Rotate" object
     * from the annotation. To support users adding text annotations while using a PDF viewer,
     * you can also add any viewer rotation to the annotations Rotate object, to have text always
     * rotated correctly, from the users perspective.
     */
    refreshAppearance(): void;
    /**
     * @method PDFNet.Annot#getRotation
     * @note The functionality documented below is part of the appearance characteristics dictionary, the dictionary
     * that shall be used in constructing a dynamic appearance stream specifying the annotation's visual
     * presentation on the page.
     */
    getRotation(): void;
    /**
     * Sets the rotation value of the annotation. The Rotation specifies the number of degrees by which the
     * annotation shall be rotated counterclockwise relative to the page.
     * The value shall be a multiple of 90.
     * (Optional)
     *
     * @method PDFNet.Annot#setRotation
     * @param {number} angle An integer representing the rotation value of the annotation.
     * @note This property is part of the appearance characteristics dictionary, this dictionary
     * that shall be used in constructing a dynamic appearance stream specifying the annotation’s visual
     * presentation on the page.
     */
    setRotation(angle: number): void;
    /**
     * Gets the border style for the annotation. Typically used for Link annotations.
     *
     * @method PDFNet.Annot#getBorderStyle
     * @return {Promise<PDFNet.AnnotBorderStyle>} A promise that resolves to annotation's border style.
     */
    getBorderStyle(): Promise<PDFNet.AnnotBorderStyle>;
    /**
     * Sets the border style for the annotation.
     *
     * @method PDFNet.Annot#setBorderStyle
     * @param {PDFNet.AnnotBorderStyle} bs New border style for this annotation.
     * @param {boolean} [oldStyleOnly] PDF manual specifies two ways to add border information to an annotation object,
     * either through an array named 'Border' (PDF 1.0), or a dictionary called 'BS' (PDF 1.2) the latter
     * taking precedence over the former. However, if you want to create a border with rounded corners, you can only
     * do that using PDF 1.0 Border specification, in which case if you call SetBorderStyle() set the parameter
     * oldStyleOnly to true. This parameter has a default value of false in the API and does not need to be used otherwise.
     */
    setBorderStyle(bs: PDFNet.AnnotBorderStyle, oldStyleOnly?: boolean): void;
    /**
     *
     * @method PDFNet.Annot.getBorderStyleStyle
     * @param {PDFNet.AnnotBorderStyle} bs
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     * <pre>
     * PDFNet.AnnotBorderStyle.Style = {
     * 	e_solid : 0
     * 	e_dashed : 1
     * 	e_beveled : 2
     * 	e_inset : 3
     * 	e_underline : 4
     * }
     * </pre>
     */
    static getBorderStyleStyle(bs: PDFNet.AnnotBorderStyle): Promise<number>;
    /**
     *
     * @method PDFNet.Annot.setBorderStyleStyle
     * @param {PDFNet.AnnotBorderStyle} bs
     * @param {number} bst
     */
    static setBorderStyleStyle(bs: PDFNet.AnnotBorderStyle, bst: number): void;
  }
  /**
   * AnnotBorderStyle structure specifies the characteristics of the annotation's border.
   * The border is specified as a rounded rectangle.
   * @class
   * @name AnnotBorderStyle
   * @memberof PDFNet
   */
  class AnnotBorderStyle {
    /**
     * Constructor
     * @method PDFNet.AnnotBorderStyle.create
     * @param {number} s
     * <pre>
     * PDFNet.AnnotBorderStyle.Style = {
     * 	e_solid : 0
     * 	e_dashed : 1
     * 	e_beveled : 2
     * 	e_inset : 3
     * 	e_underline : 4
     * }
     * </pre>
     * @param {number} b_width
     * @param {number} b_hr
     * @param {number} b_vr
     * @return {Promise<PDFNet.AnnotBorderStyle>} A promise that resolves to an object of type: "AnnotBorderStyle"
     */
    static create(s: number, b_width: number, b_hr: number, b_vr: number): Promise<PDFNet.AnnotBorderStyle>;
    /**
     *
     * @method PDFNet.AnnotBorderStyle.createWithDashPattern
     * @param {number} s
     * <pre>
     * PDFNet.AnnotBorderStyle.Style = {
     * 	e_solid : 0
     * 	e_dashed : 1
     * 	e_beveled : 2
     * 	e_inset : 3
     * 	e_underline : 4
     * }
     * </pre>
     * @param {number} b_width
     * @param {number} b_hr
     * @param {number} b_vr
     * @param {Array} buffer
     * @return {Promise<PDFNet.AnnotBorderStyle>} A promise that resolves to an object of type: "AnnotBorderStyle"
     */
    static createWithDashPattern(
      s: number,
      b_width: number,
      b_hr: number,
      b_vr: number,
      buffer: any[],
    ): Promise<PDFNet.AnnotBorderStyle>;
    /**
     * Copy Constructor
     * @method PDFNet.AnnotBorderStyle#copy
     * @return {Promise<PDFNet.AnnotBorderStyle>} A promise that resolves to an object of type: "AnnotBorderStyle"
     */
    copy(): Promise<PDFNet.AnnotBorderStyle>;
    /**
     * @method PDFNet.AnnotBorderStyle#getStyle
     * @return {Promise<number>} A promise that resolves to the border style.
     * @example Return value enum:
     * <pre>
     * PDFNet.AnnotBorderStyle.Style = {
     * 	e_solid : 0
     * 	e_dashed : 1
     * 	e_beveled : 2
     * 	e_inset : 3
     * 	e_underline : 4
     * }
     * </pre>
     */
    getStyle(): Promise<number>;
    /**
     * Sets the border style.
     * @method PDFNet.AnnotBorderStyle#setStyle
     * @param {number} style
     * <pre>
     * PDFNet.AnnotBorderStyle.Style = {
     * 	e_solid : 0
     * 	e_dashed : 1
     * 	e_beveled : 2
     * 	e_inset : 3
     * 	e_underline : 4
     * }
     * </pre>
     */
    setStyle(style: number): void;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.AnnotBorderStyle#destroy
     */
    destroy(): void;
    /**
     * @method PDFNet.AnnotBorderStyle#getWidth
     * @return {Promise<number>} A promise that resolves to the border width.
     */
    getWidth(): Promise<number>;
    /**
     * Sets the border width
     * @method PDFNet.AnnotBorderStyle#setWidth
     * @param {number} width A number representing the width value to set the annotation to.
     */
    setWidth(width: number): void;
    /**
     * @method PDFNet.AnnotBorderStyle#getHR
     * @return {Promise<number>} A promise that resolves to horizontal corner radius.
     */
    getHR(): Promise<number>;
    /**
     * Sets horizontal corner radius.
     * @method PDFNet.AnnotBorderStyle#setHR
     * @param {number} horizontal_radius A number representing the value of the horizontal radius to set the annotation to.
     */
    setHR(horizontal_radius: number): void;
    /**
     * @method PDFNet.AnnotBorderStyle#getVR
     * @return {Promise<number>} A promise that resolves to vertical corner radius.
     */
    getVR(): Promise<number>;
    /**
     * Sets vertical corner radius.
     * @method PDFNet.AnnotBorderStyle#setVR
     * @param {number} vertical_radius A number representing the value of the vertical radius to set the annotation to.
     */
    setVR(vertical_radius: number): void;
    /**
     * @method PDFNet.AnnotBorderStyle#getDashPattern
     * @return the border dash pattern.
     * @see BorderStyle()
     */
    getDashPattern(): any;
  }
  /**
   * [Missing documentation]
   * @class
   * @name AppearanceReferenceList
   * @memberof PDFNet
   */
  class AppearanceReferenceList {}
  /**
   * An application or plug-in extension that processes logical structure can attach
   * additional information, called attributes, to any structure element.
   * The attribute information is held in one or more attribute objects associated
   * with the structure element. An attribute object is a dictionary or stream
   * that includes an entry identifying the application or plug-in that owns the
   * attribute information. Other entries represent the attributes: the keys are
   * attribute names, and values are the corresponding attribute values.
   * @class
   * @name AttrObj
   * @memberof PDFNet
   */
  class AttrObj {
    /**
     * Initialize a AttrObj using an existing low-level Cos/SDF object.
     *
     * @method PDFNet.AttrObj.create
     * @param {PDFNet.Obj} [dict] a low-level (SDF/Cos) dictionary representing the attribute object.
     *
     * @note This constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.AttrObj>} A promise that resolves to an object of type: "AttrObj"
     */
    static create(dict?: PDFNet.Obj): Promise<PDFNet.AttrObj>;
    /**
     * Copy Constructor
     * @method PDFNet.AttrObj#copy
     * @return {Promise<PDFNet.AttrObj>} A promise that resolves to an object of type: "AttrObj"
     */
    copy(): Promise<PDFNet.AttrObj>;
    /**
     * @method PDFNet.AttrObj#getOwner
     * @return {Promise<string>} A promise that resolves to the name of the application or plug-in extension owning the
     * attribute data.
     */
    getOwner(): Promise<string>;
    /**
     * @method PDFNet.AttrObj#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to pointer to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
  }
  /**
   * A %PDF document may optionally display a document outline on the screen, allowing
   * the user to navigate interactively from one part of the document to another.
   * The outline consists of a tree-structured hierarchy of Bookmarks (sometimes
   * called outline items), which serve as a 'visual table of contents' to display the
   * document's structure to the user.
   *
   * Each Bookmark has a title that appears on screen, and an Action that specifies
   * what happens when a user clicks on the Bookmark. The typical action for a
   * user-created Bookmark is to move to another location in the current document,
   * although any action (see PDF::Action) can be specified.
   *
   * Bookmark is a utility class used to simplify work with %PDF bookmarks (or
   * outlines; see section 8.2.2 'Document Outline' in %PDF Reference Manual for
   * more details).
   * @class
   * @name Bookmark
   * @memberof PDFNet
   */
  class Bookmark {
    /**
     * Creates a new valid Bookmark with given title in the
     * specified document.
     *
     * @method PDFNet.Bookmark.create
     * @param {PDFNet.PDFDoc} in_doc The document in which a Bookmark is to be created.
     * @param {string} in_title The title string value of the new Bookmark.
     *
     * @return {Promise<PDFNet.Bookmark>} A promise that resolves to the new Bookmark.
     *
     * @note The new Bookmark is not linked to the outline tree.
     * Use AddChild()/AddNext()/AddPrev() methods in order to link the Bookmark
     * to the outline tree
     */
    static create(in_doc: PDFNet.PDFDoc, in_title: string): Promise<PDFNet.Bookmark>;
    /**
     * A constructor. Creates a Bookmark and initialize it using given Cos/SDF object.
     *
     * @method PDFNet.Bookmark.createFromObj
     * @param {PDFNet.Obj} in_bookmark_dict Pointer to the Cos/SDF object (outline item dictionary).
     *
     * @return {Promise<PDFNet.Bookmark>} A promise that resolves to the new Bookmark.
     *
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     */
    static createFromObj(in_bookmark_dict: PDFNet.Obj): Promise<PDFNet.Bookmark>;
    /**
     *	Copy Constructor. Creates a new Bookmark object equal to the existing Bookmark object.
     *
     * @method PDFNet.Bookmark#copy
     * @return {Promise<PDFNet.Bookmark>} A promise that resolves to a new Bookmark object.
     */
    copy(): Promise<PDFNet.Bookmark>;
    /**
     * Compares two Bookmark objects for equality.
     *
     * @method PDFNet.Bookmark#compare
     * @param {PDFNet.Bookmark} in_bookmark A reference to an existing Bookmark object.
     *
     * @return {Promise<boolean>} A promise that resolves to true if the both Bookmarks share the same underlying SDF/Cos object; otherwise false.
     */
    compare(in_bookmark: PDFNet.Bookmark): Promise<boolean>;
    /**
     * Indicates whether the Bookmark is valid (non-null).
     *
     * @method PDFNet.Bookmark#isValid
     * @return {Promise<boolean>} A promise that resolves to true if this is a valid (non-null) Bookmark; otherwise false.
     *
     * @note If this method returns false the underlying SDF/Cos object is null and
     * the Bookmark object should be treated as null as well.
     */
    isValid(): Promise<boolean>;
    /**
     * Indicates whether the Bookmark has children.
     *
     * @method PDFNet.Bookmark#hasChildren
     * @return {Promise<boolean>} A promise that resolves to true if the Bookmark has children; otherwise false.
     */
    hasChildren(): Promise<boolean>;
    /**
     * Returns the Bookmark's next (right) sibling.
     *
     * @method PDFNet.Bookmark#getNext
     * @return {Promise<PDFNet.Bookmark>} A promise that resolves to the Bookmark's next (right) sibling.
     */
    getNext(): Promise<PDFNet.Bookmark>;
    /**
     * Returns the Bookmark's previous (left) sibling.
     *
     * @method PDFNet.Bookmark#getPrev
     * @return {Promise<PDFNet.Bookmark>} A promise that resolves to the Bookmark's previous (left) sibling.
     */
    getPrev(): Promise<PDFNet.Bookmark>;
    /**
     * Returns the Bookmark's first child.
     *
     * @method PDFNet.Bookmark#getFirstChild
     * @return {Promise<PDFNet.Bookmark>} A promise that resolves to the Bookmark's first child.
     */
    getFirstChild(): Promise<PDFNet.Bookmark>;
    /**
     * Returns the Bookmark's last child.
     *
     * @method PDFNet.Bookmark#getLastChild
     * @return {Promise<PDFNet.Bookmark>} A promise that resolves to the Bookmark's last child.
     */
    getLastChild(): Promise<PDFNet.Bookmark>;
    /**
     * Returns the Bookmark's parent Bookmark.
     *
     * @method PDFNet.Bookmark#getParent
     * @return {Promise<PDFNet.Bookmark>} A promise that resolves to the Bookmark's parent Bookmark.
     */
    getParent(): Promise<PDFNet.Bookmark>;
    /**
     * Returns the Bookmark specified by the given title string.
     *
     * @method PDFNet.Bookmark#find
     * @param {string} in_title The title string value of the Bookmark to find.
     *
     * @return {Promise<PDFNet.Bookmark>} A promise that resolves to a Bookmark matching the title string value specified.
     */
    find(in_title: string): Promise<PDFNet.Bookmark>;
    /**
     * Adds a new Bookmark as the new last child of this Bookmark.
     *
     * @method PDFNet.Bookmark#addNewChild
     * @param {string} in_title The title string value of the new Bookmark.
     *
     * @return {Promise<PDFNet.Bookmark>} A promise that resolves to the newly created child Bookmark.
     *
     * @note If this Bookmark previously had no children, it will be open
     * after the child is added.
     */
    addNewChild(in_title: string): Promise<PDFNet.Bookmark>;
    /**
     * adds the specified Bookmark as the new last child of this Bookmark.
     *
     * @method PDFNet.Bookmark#addChild
     * @param {PDFNet.Bookmark} in_bookmark The Bookmark object to be added as a last child of this Bookmark.
     *
     * @note Parameter in_bookmark must not be linked to a bookmark tree.
     * @note If this Bookmark previously had no children, it will be open
     * after the child is added.
     */
    addChild(in_bookmark: PDFNet.Bookmark): void;
    /**
     * Adds a new Bookmark to the tree containing this Bookmark, as the
     * new right sibling.
     *
     * @method PDFNet.Bookmark#addNewNext
     * @param {string} in_title The title string value of the new Bookmark.
     *
     * @return {Promise<PDFNet.Bookmark>} A promise that resolves to the newly created sibling Bookmark.
     */
    addNewNext(in_title: string): Promise<PDFNet.Bookmark>;
    /**
     * adds the specified Bookmark as the new right sibling to this Bookmark,
     * adjusting the tree containing this Bookmark appropriately.
     *
     * @method PDFNet.Bookmark#addNext
     * @param {PDFNet.Bookmark} in_bookmark The Bookmark object to be added to this Bookmark.
     *
     * @note Parameter in_bookmark must not be linked to a bookmark tree.
     */
    addNext(in_bookmark: PDFNet.Bookmark): void;
    /**
     * Adds a new Bookmark to the tree containing this Bookmark, as the
     * new left sibling.
     *
     * @method PDFNet.Bookmark#addNewPrev
     * @param {string} in_title The title string value of the new Bookmark.
     *
     * @return {Promise<PDFNet.Bookmark>} A promise that resolves to the newly created sibling Bookmark.
     */
    addNewPrev(in_title: string): Promise<PDFNet.Bookmark>;
    /**
     * adds the specified Bookmark as the new left sibling to this Bookmark,
     * adjusting the tree containing this Bookmark appropriately.
     *
     * @method PDFNet.Bookmark#addPrev
     * @param {PDFNet.Bookmark} in_bookmark The Bookmark object to be added to this Bookmark.
     *
     * @note Parameter in_bookmark must not be linked to a bookmark tree.
     */
    addPrev(in_bookmark: PDFNet.Bookmark): void;
    /**
     * removes the Bookmark's subtree from the bookmark tree containing it.
     * @method PDFNet.Bookmark#delete
     */
    delete(): void;
    /**
     * unlinks this Bookmark from the bookmark tree that contains it, and
     * adjusts the tree appropriately.
     *
     * @method PDFNet.Bookmark#unlink
     * @note After the bookmark is unlinked is can be moved to another place
     * in the bookmark tree located in the same document.
     */
    unlink(): void;
    /**
     * Returns the indentation level of the Bookmark in its containing tree.
     *
     * @method PDFNet.Bookmark#getIndent
     * @return {Promise<number>} A promise that resolves to the indentation level of the Bookmark in its containing tree.
     *
     * @note The root level has an indentation level of zero.
     */
    getIndent(): Promise<number>;
    /**
     * Indicates whether the Bookmark is open.
     *
     * @method PDFNet.Bookmark#isOpen
     * @return {Promise<boolean>} A promise that resolves to true if this Bookmark is open; otherwise false.
     *
     * @note An open Bookmark shows all its children.
     */
    isOpen(): Promise<boolean>;
    /**
     * Opens or closes the Bookmark.
     *
     * @method PDFNet.Bookmark#setOpen
     * @param {boolean} in_open Boolean value that contains the status.
     * If true, the Bookmark is opened. Otherwise the Bookmark is closed.
     *
     * @note An opened Bookmark shows its children, while a closed Bookmark does not.
     */
    setOpen(in_open: boolean): void;
    /**
     * Returns the number of opened bookmarks in this subtree.
     *
     * @method PDFNet.Bookmark#getOpenCount
     * @return {Promise<number>} A promise that resolves to the number of opened bookmarks in this subtree (not including
     * this Bookmark). If the item is closed, a negative integer whose
     * absolute value specifies how many descendants would appear if the
     * item were reopened.
     */
    getOpenCount(): Promise<number>;
    /**
     * Returns the Bookmark's title string.
     *
     * @method PDFNet.Bookmark#getTitle
     * @return {Promise<string>} A promise that resolves to the Bookmark's title string).
     */
    getTitle(): Promise<string>;
    /**
     * Returns the Bookmark's title string object.
     * @method PDFNet.Bookmark#getTitleObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the Bookmark's title string object.
     */
    getTitleObj(): Promise<PDFNet.Obj>;
    /**
     * Sets the Bookmark's title string.
     *
     * @method PDFNet.Bookmark#setTitle
     * @param {string} title The new title string for the bookmark.
     */
    setTitle(title: string): void;
    /**
     * Returns the Bookmark's action.
     *
     * @method PDFNet.Bookmark#getAction
     * @return {Promise<PDFNet.Action>} A promise that resolves to the Bookmark's action.
     */
    getAction(): Promise<PDFNet.Action>;
    /**
     * sets the Bookmark's action.
     *
     * @method PDFNet.Bookmark#setAction
     * @param {PDFNet.Action} in_action The new Action for the Bookmark.
     */
    setAction(in_action: PDFNet.Action): void;
    /**
     * removes the Bookmark's action.
     * @method PDFNet.Bookmark#removeAction
     */
    removeAction(): void;
    /**
     * Returns the Bookmark's flags.
     *
     * @method PDFNet.Bookmark#getFlags
     * @return {Promise<number>} A promise that resolves to the flags of the Bookmark object.
     * Bit 1 (least-significant bit) indicates italic font whereas
     * bit 2 indicates bold font.
     * Therefore, 0 indicates normal, 1 is italic, 2 is bold, and 3 is bold-italic.
     */
    getFlags(): Promise<number>;
    /**
     * Sets the Bookmark's flags.
     *
     * @method PDFNet.Bookmark#setFlags
     * @param {number} in_flags The new bookmark flags.
     * Bit 1 (the least-significant bit) indicates italic font whereas
     * bit 2 indicates bold font.
     * Therefore, 0 indicates normal, 1 is italic, 2 is bold, and 3 is bold-italic.
     */
    setFlags(in_flags: number): void;
    /**
     * Returns the Bookmark's RGB color value.
     *
     * @method PDFNet.Bookmark#getColor
     * @note The three numbers  \a out_r, \a out_g, and \a out_b are in the range 0.0 to 1.0,
     * representing the components in the DeviceRGB color space of the color
     * to be used for the Bookmark's text.
     *
     * <b>Example:</b>
     * \code
     *   double red, green, blue;
     *   bookmark.GetColor(red, green, blue);
     * \endcode
     */
    getColor(): void;
    /**
     * Sets the Bookmark's color value.
     *
     * @method PDFNet.Bookmark#setColor
     * @param {number} [in_r] The red component of the color.
     * @param {number} [in_g] The green component of the color.
     * @param {number} [in_b] The blue component of the color.
     *
     * @note The three numbers \a in_r, \a in_g, and \a in_b are in the range 0.0 to 1.0, representing
     * the components in the DeviceRGB color space of the color to be used
     * for the Bookmark's text.
     * Default color value is black, [0.0 0.0 0.0].
     */
    setColor(in_r?: number, in_g?: number, in_b?: number): void;
    /**
     * Returns the underlying SDF/Cos object.
     *
     * @method PDFNet.Bookmark#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the underlying SDF/Cos object.
     *
     * @note A null (non-valid) bookmark returns a null object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
  }
  /**
   * A Caret annotation (PDF 1.5) is a visual symbol that indicates
   * the presence of text edits.
   * @class
   * @name CaretAnnot
   * @memberof PDFNet
   */
  class CaretAnnot {
    /**
     * creates an Caret annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.CaretAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.CaretAnnot>} A promise that resolves to an object of type: "CaretAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.CaretAnnot>;
    /**
     * creates an Caret annotation and initializes it using given annotation object.
     * @method PDFNet.CaretAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Caret annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.CaretAnnot>} A promise that resolves to an object of type: "CaretAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.CaretAnnot>;
    /**
     * Creates a new Caret annotation in the specified document.
     *
     * @method PDFNet.CaretAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the Caret annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the Caret annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.CaretAnnot>} A promise that resolves to a newly created blank Caret annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.CaretAnnot>;
    /**
     * Returns the paragraph symbol associated with the caret.
     *
     * @method PDFNet.CaretAnnot#getSymbol
     * @return {Promise<string>} A promise that resolves to the name of the symbol. This can be either "P" (Use a new
     * paragraph symbol) or "None" (Don't use any symbol).
     * Default value: None.
     */
    getSymbol(): Promise<string>;
    /**
     * sets the caret symbol.
     * @method PDFNet.CaretAnnot#setSymbol
     * @param {string} symbol The name of the symbol. This can be either "P" (Use a new
     * paragraph symbol) or "None" (Don't use any symbol).
     * Default value: None.
     */
    setSymbol(symbol: string): void;
  }
  /**
   * [Missing documentation]
   * @class
   * @name CheckBoxWidget
   * @memberof PDFNet
   */
  class CheckBoxWidget {
    /**
     * Constructor
     * @method PDFNet.CheckBoxWidget.create
     * @param {PDFNet.PDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @param {string} [field_name]
     * @return {Promise<PDFNet.CheckBoxWidget>} A promise that resolves to an object of type: "CheckBoxWidget"
     */
    static create(doc: PDFNet.PDFDoc, pos: PDFNet.Rect, field_name?: string): Promise<PDFNet.CheckBoxWidget>;
    /**
     *
     * @method PDFNet.CheckBoxWidget.createWithField
     * @param {PDFNet.PDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @param {PDFNet.Field} field
     * @return {Promise<PDFNet.CheckBoxWidget>} A promise that resolves to an object of type: "CheckBoxWidget"
     */
    static createWithField(doc: PDFNet.PDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.CheckBoxWidget>;
    /**
     *
     * @method PDFNet.CheckBoxWidget.createFromObj
     * @param {PDFNet.Obj} [obj]
     * @return {Promise<PDFNet.CheckBoxWidget>} A promise that resolves to an object of type: "CheckBoxWidget"
     */
    static createFromObj(obj?: PDFNet.Obj): Promise<PDFNet.CheckBoxWidget>;
    /**
     *
     * @method PDFNet.CheckBoxWidget.createFromAnnot
     * @param {PDFNet.Annot} annot
     * @return {Promise<PDFNet.CheckBoxWidget>} A promise that resolves to an object of type: "CheckBoxWidget"
     */
    static createFromAnnot(annot: PDFNet.Annot): Promise<PDFNet.CheckBoxWidget>;
    /**
     *
     * @method PDFNet.CheckBoxWidget#isChecked
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    isChecked(): Promise<boolean>;
    /**
     *
     * @method PDFNet.CheckBoxWidget#setChecked
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    setChecked(): Promise<boolean>;
  }
  /**
   * [Not Yet Documented]
   * @class
   * @name ChunkRenderer
   * @memberof PDFNet
   */
  class ChunkRenderer {}
  /**
   * A Circle annotation is a type of markup annotation that displays an ellipse on
   * the page. When opened, it can display a pop-up window containing the text of
   * the associated note. The ellipse may be inscribed and possibly padded within the
   * annotation rectangle defined by the annotation dictionary's Rect entry.
   * @class
   * @name CircleAnnot
   * @memberof PDFNet
   */
  class CircleAnnot {
    /**
     * creates an Circle annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.CircleAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.CircleAnnot>} A promise that resolves to an object of type: "CircleAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.CircleAnnot>;
    /**
     * creates a Circle annotation and initializes it using given annotation object.
     * @method PDFNet.CircleAnnot.createFromAnnot
     * @param {PDFNet.Annot} circle Annot object used to initialize the Circle annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.CircleAnnot>} A promise that resolves to an object of type: "CircleAnnot"
     */
    static createFromAnnot(circle: PDFNet.Annot): Promise<PDFNet.CircleAnnot>;
    /**
     * Creates a new Circle annotation in the specified document.
     *
     * @method PDFNet.CircleAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.CircleAnnot>} A promise that resolves to a newly created blank Circle annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.CircleAnnot>;
    /**
     *
     * @method PDFNet.CircleAnnot#getInteriorColor
     * @return {Promise<PDFNet.ColorPt>} A promise that resolves to an object of type: "ColorPt"
     */
    getInteriorColor(): Promise<PDFNet.ColorPt>;
    /**
     *
     * @method PDFNet.CircleAnnot#getInteriorColorCompNum
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     */
    getInteriorColorCompNum(): Promise<number>;
    /**
     *
     * @method PDFNet.CircleAnnot#setInteriorColorDefault
     * @param {PDFNet.ColorPt} col
     */
    setInteriorColorDefault(col: PDFNet.ColorPt): void;
    /**
     *
     * @method PDFNet.CircleAnnot#setInteriorColor
     * @param {PDFNet.ColorPt} col
     * @param {number} numcomp
     */
    setInteriorColor(col: PDFNet.ColorPt, numcomp: number): void;
    /**
     *
     * @method PDFNet.CircleAnnot#getContentRect
     * @return {Promise<PDFNet.Rect>} A promise that resolves to an object of type: "Rect"
     */
    getContentRect(): Promise<PDFNet.Rect>;
    /**
     *
     * @method PDFNet.CircleAnnot#setContentRect
     * @param {PDFNet.Rect} cr
     */
    setContentRect(cr: PDFNet.Rect): void;
    /**
     *
     * @method PDFNet.CircleAnnot#getPadding
     * @return {Promise<PDFNet.Rect>} A promise that resolves to an object of type: "Rect"
     */
    getPadding(): Promise<PDFNet.Rect>;
    /**
     *
     * @method PDFNet.CircleAnnot#setPadding
     * @param {PDFNet.Rect} cr
     */
    setPadding(cr: PDFNet.Rect): void;
  }
  /**
   * @class
   * @name ClassMap
   * @memberof PDFNet
   */
  class ClassMap {
    /**
     * Initialize a ClassMap using an existing low-level Cos/SDF ClassMap object.
     *
     * @method PDFNet.ClassMap.create
     * @param {PDFNet.Obj} [dict] a low-level (SDF/Cos) ClassMap dictionary.
     *
     * @note This constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.ClassMap>} A promise that resolves to an object of type: "ClassMap"
     */
    static create(dict?: PDFNet.Obj): Promise<PDFNet.ClassMap>;
    /**
     * Copy Constructor
     * @method PDFNet.ClassMap#copy
     * @return {Promise<PDFNet.ClassMap>} A promise that resolves to an object of type: "ClassMap"
     */
    copy(): Promise<PDFNet.ClassMap>;
    /**
     * @method PDFNet.ClassMap#isValid
     * @return {Promise<boolean>} A promise that resolves to true if this is a valid (non-null) ClassMap, false otherwise.
     * If the function returns false the underlying SDF/Cos object is null or is
     * not valid and the ClassMap object should be treated as a null object.
     */
    isValid(): Promise<boolean>;
    /**
     * Returns the ClassMap dictionary.
     *
     * @method PDFNet.ClassMap#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the object to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
  }
  /**
   * ColorPt is an array of colorants (or tint values) representing a color point
   * in an associated color space.
   * @class
   * @name ColorPt
   * @memberof PDFNet
   */
  class ColorPt {
    /**
     * Constructor
     * @method PDFNet.ColorPt.init
     * @param {number} [x] initialized value of first color value (eg. red for rgb colorspace);
     * @param {number} [y] initialized value of second color value (eg. green for rgb colorspace);
     * @param {number} [z] initialized value of third color value (eg. blue for rgb colorspace);
     * @param {number} [w] initialized value of fourth color value (eg. when using CMYK);
     * @return {Promise<PDFNet.ColorPt>} A promise that resolves to an object of type: "ColorPt"
     */
    static init(x?: number, y?: number, z?: number, w?: number): Promise<PDFNet.ColorPt>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.ColorPt#destroy
     */
    destroy(): void;
    /**
     * A utility method to set the first 4 tint values. For example,
     * color.Set(red, green, blue) will initialize the ColorPt to given
     * tint values.
     * @method PDFNet.ColorPt#set
     * @param {number} [x] initialized value of first color value (eg. red for rgb colorspace);
     * @param {number} [y] initialized value of second color value (eg. green for rgb colorspace);
     * @param {number} [z] initialized value of third color value (eg. blue for rgb colorspace);
     * @param {number} [w] initialized value of fourth color value (eg. when using CMYK);
     * @note All colorants should be in the range [0..1].
     * @note color.Set(gray) is equivalent to Set(0, gray);
     */
    set(x?: number, y?: number, z?: number, w?: number): void;
    /**
     * Sets a tint value at a given colorant index.
     *
     * @method PDFNet.ColorPt#setByIndex
     * @param {number} colorant_index the color index. For example, for a color point
     * associated with a Gray color space the only allowed value for index
     * is 0. For a color point associated with a CMYK color space, the color_index
     * can range from 0 (cyan) to 4 (black).
     *
     * @param {number} colorant_value The new tint value.
     *
     * For example, the following snippet will initialize the color point
     * to [red, green, blue]:
     * <pre>
     * color.SetColorantNum(3);
     * color.Set(0, red);
     * color.Set(1, green);
     * color.Set(2, blue);
     * </pre>
     *
     * The above code snippet is equivalent to the following line:
     *   color.Set(red, green, blue)
     *
     * @note If a color point has more than 4 colorants, SetColorantNum(num_colorants)
     * must be called before getting or setting tint values.
     */
    setByIndex(colorant_index: number, colorant_value: number): void;
    /**
     * The number of colorants depends on the associated color space. To find
     * how many colorant are associated with a given color space use
     * color_space.GetComponentNum().
     *
     * For example, if you have a color point in the RGB color space you can
     * extract its colorants as follows:
     * <pre>
     * UInt8 rgb[3] = { UInt8(c.Get(0)*255), UInt8(c.Get(1)*255), UInt8(c.Get(2)*255) };
     * </pre>
     * @method PDFNet.ColorPt#get
     * @param {number} colorant_index number representing the index of the color space to get the tint from
     * @return {Promise<number>} A promise that resolves to the tint value at a given colorant index.
     */
    get(colorant_index: number): Promise<number>;
    /**
     *
     * @method PDFNet.ColorPt#setColorantNum
     * @param {number} num
     */
    setColorantNum(num: number): void;
  }
  /**
   * This abstract class is used to serve as a color space tag to identify the specific
   * color space of a Color object. It contains methods that transform colors in a specific
   * color space to/from several color space such as DeviceRGB and DeviceCMYK.
   *
   * For purposes of the methods in this class, colors are represented as arrays of color
   * components represented as doubles in a normalized range defined by each ColorSpace.
   * For many ColorSpaces (e.g. DeviceRGB), this range is 0.0 to 1.0. However, some ColorSpaces
   * have components whose values have a different range. Methods are provided to inquire per
   * component minimum and maximum normalized values.
   *
   * @note Note that in Pattern color space (i.e. for PDFNet.ColorSpace.Type.e_pattern) 'color values'
   * are PDFNet.PatternColor objects instead of the numeric component values (i.e. ColorPt)
   * used with other spaces.
   * @class
   * @name ColorSpace
   * @memberof PDFNet
   */
  class ColorSpace {
    /**
     * Create a new DeviceGray ColorSpace object
     * @method PDFNet.ColorSpace.createDeviceGray
     * @return {Promise<PDFNet.ColorSpace>} A promise that resolves to an object of type: "ColorSpace"
     */
    static createDeviceGray(): Promise<PDFNet.ColorSpace>;
    /**
     * Create a new DeviceRGB ColorSpace object
     * @method PDFNet.ColorSpace.createDeviceRGB
     * @return {Promise<PDFNet.ColorSpace>} A promise that resolves to an object of type: "ColorSpace"
     */
    static createDeviceRGB(): Promise<PDFNet.ColorSpace>;
    /**
     * Create a new DeviceCMYK ColorSpace object
     * @method PDFNet.ColorSpace.createDeviceCMYK
     * @return {Promise<PDFNet.ColorSpace>} A promise that resolves to an object of type: "ColorSpace"
     */
    static createDeviceCMYK(): Promise<PDFNet.ColorSpace>;
    /**
     * Create a new Pattern ColorSpace object
     * @method PDFNet.ColorSpace.createPattern
     * @return {Promise<PDFNet.ColorSpace>} A promise that resolves to an object of type: "ColorSpace"
     */
    static createPattern(): Promise<PDFNet.ColorSpace>;
    /**
     * Create a ColorSpace from the given SDF/Cos object listed under ColorSpaces entry
     * in page Resource dictionary. If color_space dictionary is null, a non valid ColorSpace
     * object is created.
     * @method PDFNet.ColorSpace.create
     * @param {PDFNet.Obj} [color_space] The Cos/SDF object to initialze the ColorSpace object with.
     * @return {Promise<PDFNet.ColorSpace>} A promise that resolves to an object of type: "ColorSpace"
     */
    static create(color_space?: PDFNet.Obj): Promise<PDFNet.ColorSpace>;
    /**
     *
     * @method PDFNet.ColorSpace.createICCFromFilter
     * @param {PDFNet.SDFDoc} doc
     * @param {PDFNet.Filter} filter
     * @return {Promise<PDFNet.ColorSpace>} A promise that resolves to an object of type: "ColorSpace"
     */
    static createICCFromFilter(doc: PDFNet.SDFDoc, filter: PDFNet.Filter): Promise<PDFNet.ColorSpace>;
    /**
     *
     * @method PDFNet.ColorSpace.createICCFromBuffer
     * @param {PDFNet.SDFDoc} doc
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf
     * @return {Promise<PDFNet.ColorSpace>} A promise that resolves to an object of type: "ColorSpace"
     */
    static createICCFromBuffer(
      doc: PDFNet.SDFDoc,
      buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray,
    ): Promise<PDFNet.ColorSpace>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.ColorSpace#destroy
     */
    destroy(): void;
    /**
     * @method PDFNet.ColorSpace.getComponentNumFromObj
     * @return {Promise<number>} A promise that resolves to the number of components (tint components) used to represent color
     * point for this color space
     *
     * @param {number} cs_type
     * <pre>
     * PDFNet.ColorSpace.Type = {
     * 	e_device_gray : 0
     * 	e_device_rgb : 1
     * 	e_device_cmyk : 2
     * 	e_cal_gray : 3
     * 	e_cal_rgb : 4
     * 	e_lab : 5
     * 	e_icc : 6
     * 	e_indexed : 7
     * 	e_pattern : 8
     * 	e_separation : 9
     * 	e_device_n : 10
     * 	e_null : 11
     * }
     * </pre>
     * @param {PDFNet.Obj} cs_obj Cos/SDF color space object.
     */
    static getComponentNumFromObj(cs_type: number, cs_obj: PDFNet.Obj): Promise<number>;
    /**
     * @method PDFNet.ColorSpace.getTypeFromObj
     * @return {Promise<number>} A promise that resolves to the Type of a given SDF/Cos color space, or e_null for if
     * SDF object is not a valid color space
     *
     * @param {PDFNet.Obj} cs_obj Cos/SDF color space object.
     * @example Return value enum:
     * <pre>
     * PDFNet.ColorSpace.Type = {
     * 	e_device_gray : 0
     * 	e_device_rgb : 1
     * 	e_device_cmyk : 2
     * 	e_cal_gray : 3
     * 	e_cal_rgb : 4
     * 	e_lab : 5
     * 	e_icc : 6
     * 	e_indexed : 7
     * 	e_pattern : 8
     * 	e_separation : 9
     * 	e_device_n : 10
     * 	e_null : 11
     * }
     * </pre>
     */
    static getTypeFromObj(cs_obj: PDFNet.Obj): Promise<number>;
    /**
     * @method PDFNet.ColorSpace#getType
     * @return {Promise<number>} A promise that resolves to the type of this color space
     * @example Return value enum:
     * <pre>
     * PDFNet.ColorSpace.Type = {
     * 	e_device_gray : 0
     * 	e_device_rgb : 1
     * 	e_device_cmyk : 2
     * 	e_cal_gray : 3
     * 	e_cal_rgb : 4
     * 	e_lab : 5
     * 	e_icc : 6
     * 	e_indexed : 7
     * 	e_pattern : 8
     * 	e_separation : 9
     * 	e_device_n : 10
     * 	e_null : 11
     * }
     * </pre>
     */
    getType(): Promise<number>;
    /**
     * @method PDFNet.ColorSpace#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the underlying SDF/Cos object
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.ColorSpace#getComponentNum
     * @return {Promise<number>} A promise that resolves to the number of colorants (tint components) used to represent color
     *  point in this color space
     */
    getComponentNum(): Promise<number>;
    /**
     * Set color to the initial value used for this color space.
     * The initial value depends on the color space (see 4.5.7 in PDF Ref. Manual).
     * @method PDFNet.ColorSpace#initColor
     */
    initColor(): void;
    /**
     *
     * @method PDFNet.ColorSpace#initComponentRanges
     * @param {number} num_comps
     */
    initComponentRanges(num_comps: number): void;
    /**
     * A convenience function used to convert color points from the current
     * color space to DeviceGray color space.
     *
     * @method PDFNet.ColorSpace#convert2Gray
     * @param {PDFNet.ColorPt} in_color input color point in the current color space
     * @note the number to input colorants must match the number of colorants
     * expected by the current color space.
     */
    convert2Gray(in_color: PDFNet.ColorPt): void;
    /**
     * A convenience function used to convert color points from the current
     * color space to DeviceRGB color space.
     *
     * @method PDFNet.ColorSpace#convert2RGB
     * @param {PDFNet.ColorPt} in_color input color point in the current color space
     * @note the number to input colorants must match the number of colorants
     * expected by the current color space.
     */
    convert2RGB(in_color: PDFNet.ColorPt): void;
    /**
     * A convenience function used to convert color points from the current
     * color space to DeviceCMYK color space.
     *
     * @method PDFNet.ColorSpace#convert2CMYK
     * @param {PDFNet.ColorPt} in_color input color point in the current color space
     * @note the number to input colorants must match the number of colorants
     * expected by the current color space.
     */
    convert2CMYK(in_color: PDFNet.ColorPt): void;
    /**
     * @method PDFNet.ColorSpace#getAlternateColorSpace
     * @return {Promise<PDFNet.ColorSpace>} A promise that resolves to the alternate color space if it is available or NULL otherwise.
     * Color spaces that include alternate color space are e_separation, e_device_n,
     * and e_icc.
     */
    getAlternateColorSpace(): Promise<PDFNet.ColorSpace>;
    /**
     * @method PDFNet.ColorSpace#getBaseColorSpace
     * @return {Promise<PDFNet.ColorSpace>} A promise that resolves to the base color space if this is an e_indexed or e_pattern with
     * associated base color space; NULL otherwise.
     */
    getBaseColorSpace(): Promise<PDFNet.ColorSpace>;
    /**
     * @method PDFNet.ColorSpace#getHighVal
     * @return {Promise<number>} A promise that resolves to the highest index for the color lookup table for Indexed color space.
     * Since the color table is indexed from zero to highval, the actual number of entries is
     * highval + 1. For color spaces other than indexed the method returns 0.
     *
     * @note for color spaces other than Indexed this method throws an exception.
     */
    getHighVal(): Promise<number>;
    /**
     * @method PDFNet.ColorSpace#getLookupTable
     * @return {Promise<number>} A promise that resolves to the color lookup table for Indexed color space. for color spaces other
     * than indexed the method returns NULL.
     *
     * @note for color spaces other than Indexed this method throws an exception.
     */
    getLookupTable(): Promise<number>;
    /**
     * Get the base color given a component value (index) in Indexed color space.
     *
     * @method PDFNet.ColorSpace#getBaseColor
     * @param {number} color_idx color value represented in the index color space
     * @note for color spaces other than Indexed this method throws an exception.
     */
    getBaseColor(color_idx: number): void;
    /**
     * @method PDFNet.ColorSpace#getTintFunction
     * @return {Promise<PDFNet.Function>} A promise that resolves to the function that transforms tint values into color component
     * values in the alternate color space.
     *
     * @note for color spaces other than Separation this method throws an exception.
     */
    getTintFunction(): Promise<PDFNet.Function>;
    /**
     * @method PDFNet.ColorSpace#isAll
     * @return {Promise<boolean>} A promise that resolves to true if Separation color space contains the colorant All.
     *
     * @note for color spaces other than Separation this method throws an exception.
     */
    isAll(): Promise<boolean>;
    /**
     * @method PDFNet.ColorSpace#isNone
     * @return {Promise<boolean>} A promise that resolves to true if Separation or DeviceN color space contains None colorants.
     * For DeviceN the function returns true only if component colorant names are all None.
     *
     * @note for color spaces other than Separation or DeviceN this method throws
     * an exception.
     */
    isNone(): Promise<boolean>;
  }
  /**
   * [Missing documentation]
   * @class
   * @name ComboBoxWidget
   * @memberof PDFNet
   */
  class ComboBoxWidget {
    /**
     * Constructor
     * @method PDFNet.ComboBoxWidget.create
     * @param {PDFNet.PDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @param {string} [field_name]
     * @return {Promise<PDFNet.ComboBoxWidget>} A promise that resolves to an object of type: "ComboBoxWidget"
     */
    static create(doc: PDFNet.PDFDoc, pos: PDFNet.Rect, field_name?: string): Promise<PDFNet.ComboBoxWidget>;
    /**
     *
     * @method PDFNet.ComboBoxWidget.createWithField
     * @param {PDFNet.PDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @param {PDFNet.Field} field
     * @return {Promise<PDFNet.ComboBoxWidget>} A promise that resolves to an object of type: "ComboBoxWidget"
     */
    static createWithField(doc: PDFNet.PDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.ComboBoxWidget>;
    /**
     *
     * @method PDFNet.ComboBoxWidget.createFromObj
     * @param {PDFNet.Obj} [obj]
     * @return {Promise<PDFNet.ComboBoxWidget>} A promise that resolves to an object of type: "ComboBoxWidget"
     */
    static createFromObj(obj?: PDFNet.Obj): Promise<PDFNet.ComboBoxWidget>;
    /**
     *
     * @method PDFNet.ComboBoxWidget.createFromAnnot
     * @param {PDFNet.Annot} annot
     * @return {Promise<PDFNet.ComboBoxWidget>} A promise that resolves to an object of type: "ComboBoxWidget"
     */
    static createFromAnnot(annot: PDFNet.Annot): Promise<PDFNet.ComboBoxWidget>;
    /**
     *
     * @method PDFNet.ComboBoxWidget#addOption
     * @param {string} value
     */
    addOption(value: string): void;
    /**
     *
     * @method PDFNet.ComboBoxWidget#addOptions
     * @param {string} options
     * @param {number} options_size
     */
    addOptions(options: string, options_size: number): void;
    /**
     *
     * @method PDFNet.ComboBoxWidget#setSelectedOption
     * @param {string} value
     */
    setSelectedOption(value: string): void;
    /**
     *
     * @method PDFNet.ComboBoxWidget#getSelectedOption
     * @return {Promise<string>} A promise that resolves to an object of type: "string"
     */
    getSelectedOption(): Promise<string>;
    /**
     *
     * @method PDFNet.ComboBoxWidget#replaceOptions
     * @param {string} options
     * @param {number} options_size
     */
    replaceOptions(options: string, options_size: number): void;
    /**
     *
     * @method PDFNet.ComboBoxWidget#removeOption
     * @param {string} value
     */
    removeOption(value: string): void;
  }
  /**
   * Content items are graphical objects that exist in the document independently
   * of the structure tree but are associated with structure elements.
   *
   * Content items are leaf nodes of the structure tree.
   * @class
   * @name ContentItem
   * @memberof PDFNet
   */
  class ContentItem {
    /**
     * Copy Constructor
     * @method PDFNet.ContentItem#copy
     * @return {Promise<PDFNet.ContentItem>} A promise that resolves to an object of type: "ContentItem"
     */
    copy(): Promise<PDFNet.ContentItem>;
    /**
     * @method PDFNet.ContentItem#getType
     * @return {Promise<number>} A promise that resolves to the content item type.
     * @example Return value enum:
     * <pre>
     * PDFNet.ContentItem.Type = {
     * 	e_MCR : 0
     * 	e_MCID : 1
     * 	e_OBJR : 2
     * 	e_Unknown : 3
     * }
     * </pre>
     */
    getType(): Promise<number>;
    /**
     * find the parent structure element.
     * @method PDFNet.ContentItem#getParent
     * @return {Promise<PDFNet.SElement>} A promise that resolves to an object of type: "SElement"
     */
    getParent(): Promise<PDFNet.SElement>;
    /**
     * the page on which the marked content is drawn, whether directly as part of
     * page content or indirectly by being in a Form XObject or annotation drawn
     * on that page.
     * @method PDFNet.ContentItem#getPage
     * @return {Promise<PDFNet.Page>} A promise that resolves to an object of type: "Page"
     */
    getPage(): Promise<PDFNet.Page>;
    /**
     * @method PDFNet.ContentItem#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to pointer to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.ContentItem#getMCID
     * @return {Promise<number>} A promise that resolves to mcid (marked-content identifier).
     *
     * @note this method only applies to content items with types e_MCR or e_MCID.
     */
    getMCID(): Promise<number>;
    /**
     * @method PDFNet.ContentItem#getContainingStm
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the stream object that contains the marked-content sequence.
     * The function will return a non-NULL object only if the marked-content
     * sequence resides in a content stream other than the content stream for the
     * page (e.g. in a form XObject).
     *
     * @note this method only applies to content items with type e_MCR.
     */
    getContainingStm(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.ContentItem#getStmOwner
     * @return {Promise<PDFNet.Obj>} A promise that resolves to nULL or the PDF object owning the stream returned by
     * GetContainingStm() (e.g. the annotation to which an appearance stream
     * belongs).
     *
     * @note this method only applies to content items with type e_MCR.
     */
    getStmOwner(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.ContentItem#getRefObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the referenced object.
     * @note this method only applies to content items with type e_OBJR.
     */
    getRefObj(): Promise<PDFNet.Obj>;
  }
  /**
   * ContentReplacer is a utility class for replacing content (text and images)
   * in existing PDF (template) documents.
   *
   * Users can replace content in a PDF page using the following operations:
   * - Replace an image that exists in a target rectangle with a replacement image.
   * - Replace text that exists in a target rectangle with replacement text.
   * - Replace all instances of a specially marked string with replacement string.
   *
   * The following code replaces an image in a target region. This code also
   * replaces the text "[NAME]" and "[JOB_TITLE]" with "John Smith"
   * and "Software Developer" respectively. Notice the square braces ('[' and ']') on
   * the target strings in the original PDFDoc. These square braces are not included in
   * the actual function calls below, as they're implicitly added.
   *
   * <pre>
   * PDFDoc doc("../../TestFiles/BusinessCardTemplate.pdf");
   * doc.InitSecurityHandler();
   * ContentReplacer replacer;
   * Page page = doc.GetPage(1);
   * Image img = Image::Create(doc, "../../TestFiles/peppers.jpg");
   * replacer.AddImage(page.GetMediaBox(), img.GetSDFObj());
   * replacer.AddString("NAME", "John Smith");
   * replacer.AddString("JOB_TITLE", "Software Developer");
   * replacer.Process(page);
   * </pre>
   * @class
   * @name ContentReplacer
   * @memberof PDFNet
   */
  class ContentReplacer {
    /**
     * Create a new ContentReplacer object, to which replacement rules will be added.
     * The same object can be used to 'Process' multiple pages.
     * @method PDFNet.ContentReplacer.create
     * @return {Promise<PDFNet.ContentReplacer>} A promise that resolves to an object of type: "ContentReplacer"
     */
    static create(): Promise<PDFNet.ContentReplacer>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.ContentReplacer#destroy
     */
    destroy(): void;
    /**
     * Replace the image that best fits into 'target_region' with 'replacement_image'.
     *
     * @method PDFNet.ContentReplacer#addImage
     * @param {PDFNet.Rect} target_region The rectangle defining the area in which an image
     * that best fits the rectangle will be replaced by 'replacement_image'.
     *
     * @param {PDFNet.Obj} replacement_image The 'SDF.Obj' of a 'PDF.Image' object.
     *
     * @note The best fit is the image that closest matches 'target_region'. For example if
     * there are two images on the page, one taking up all of the page, and the other
     * smaller, and the smaller one has similar dimensions and position of
     * 'target_region', then the smaller image would be replaced, not the larger.
     * Furthermore, if 'target_region' encloses multiple images, then only the image
     * with the largest area in 'target_region' will be replaced.
     */
    addImage(target_region: PDFNet.Rect, replacement_image: PDFNet.Obj): void;
    /**
     * All text inside 'target_region' will be deleted and replaced with 'replacement_text'.
     *
     * @method PDFNet.ContentReplacer#addText
     * @param {PDFNet.Rect} target_region The rectangle defining the area in which all text will
     * be replaced by 'replacement_text'.
     *
     * @param {string} replacement_text The new text that will replace the existing text
     * in 'target_region'.
     *
     * @note The 'replacement_text' will be styled in the same font/color/style that is used
     * by the original text. If there are multiple font styles, the most prevalent style will
     * be used. Also, the 'replacement_text' will wrap within the 'target_region',
     * but if it is too long, the overflow text will not be visible, and no surrounding
     * content will be affected.
     */
    addText(target_region: PDFNet.Rect, replacement_text: string): void;
    /**
     * Any text of the form "[template_text]" will be replaced by "replacement_text".
     *
     * @method PDFNet.ContentReplacer#addString
     * @param {string} template_text The text to remove.
     *
     * @param {string} replacement_text The new text that will appear in place of 'template_text'.
     *
     * @note Only text wrapped in '[' and ']' will be checked, and if it matches 'template_text',
     * then 'template_text' and the surrounding square braces will be replaced
     * by 'replacement_text'. For example AddString("TITLE", "Doctor") will replace any
     * text consisting of "[TITLE]" with "Doctor".
     */
    addString(template_text: string, replacement_text: string): void;
    /**
     * Change the delimiters from '[' and ']' to arbitary strings.
     *
     * @method PDFNet.ContentReplacer#setMatchStrings
     * @param {string} start_str The starting delimiter string.
     *
     * @param {string} end_str The ending delimiter string.
     *
     * @note While empty strings are allowed as delimiters, a warning is displayed.
     * Otherwise there are no restrictions.  For example, after SetMatchStrings("<<", ">>"),
     * AddString("TITLE", "Doctor") will replace any text consisting of "<<TITLE>>" with
     * "Doctor".  Similarly, after SetMatchStrings("Beginning...", "...ending."),
     * AddString("TITLE", "Doctor") will replace "Beginning...TITLE...ending." with
     * "Doctor".
     */
    setMatchStrings(start_str: string, end_str: string): void;
    /**
     * Apply the replacement instructions to the target page. Subsequent calls
     * to 'Process' can be made on other pages, and it will apply the same rules.
     *
     * @method PDFNet.ContentReplacer#process
     * @param {PDFNet.Page} page The page to apply the content replacement instructions to.
     */
    process(page: PDFNet.Page): void;
  }
  /**
   * Experimental. Developer use only.
   * @class
   * @name ConversionMonitor
   * @memberof PDFNet
   */
  class ConversionMonitor {
    /**
     *
     * @method PDFNet.ConversionMonitor#next
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    next(): Promise<boolean>;
    /**
     *
     * @method PDFNet.ConversionMonitor#ready
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    ready(): Promise<boolean>;
    /**
     *
     * @method PDFNet.ConversionMonitor#progress
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     */
    progress(): Promise<number>;
    /**
     *
     * @method PDFNet.ConversionMonitor#filter
     * @return {Promise<PDFNet.Filter>} A promise that resolves to an object of type: "Filter"
     */
    filter(): Promise<PDFNet.Filter>;
    /**
     * Destructor
     * @method PDFNet.ConversionMonitor#destroy
     */
    destroy(): void;
  }
  /**
   * The Date class is a utility class used to simplify work with PDF date objects.
   *
   * PDF defines a standard date format, which closely follows international
   * standard ASN.1 (Abstract Syntax Notation One), A date is a string of the form
   * (D:YYYYMMDDHHmmSSOHH'mm'); See PDF Reference Manual for details.
   *
   * Date can be associated with a SDF/Cos date string using Date(Obj*) constructor
   * or later using Date::Attach(Obj*) or Date::Update(Obj*) methods.
   *
   * Date keeps a local date/time cache so it is necessary to call Date::Update()
   * method if the changes to the Date should be saved in the attached Cos/SDF string.
   * @class
   * @name Date
   * @memberof PDFNet
   */
  class Date {
    /**
     * Create a Date and initialize it using specified parameters.
     * The Date is not attached to any Cos/SDF object.
     * @method PDFNet.Date.init
     * @param {number} year number representing the year to initialize the Date object to.
     * @param {number} month number representing the month to initialize the Date object to.
     * @param {number} day number representing the day to initialize the Date object to.
     * @param {number} hour number representing the hour to initialize the Date object to.
     * @param {number} minute number representing the minute to initialize the Date object to.
     * @param {number} second number representing the second to initialize the Date object to.
     * @return {Promise<PDFNet.Date>} A promise that resolves to an object of type: "Date"
     */
    static init(
      year: number,
      month: number,
      day: number,
      hour: number,
      minute: number,
      second: number,
    ): Promise<PDFNet.Date>;
    /**
     * Indicates whether the Date is valid (non-null).
     *
     * @method PDFNet.Date#isValid
     * @return {Promise<boolean>} A promise that resolves to true if this is a valid (non-null) Date; otherwise false.
     *
     * @note If this method returns false the underlying SDF/Cos object is null and
     * the Date object should be treated as null as well.
     */
    isValid(): Promise<boolean>;
    /**
     * attach the Cos/SDF object to the Date.
     *
     * @method PDFNet.Date#attach
     * @param {PDFNet.Obj} d underlying Cos/SDF object. Must be an SDF::Str containing
     *  a PDF date object.
     */
    attach(d: PDFNet.Obj): void;
    /**
     * Saves changes made to the Date object in the attached (or specified) SDF/Cos string.
     *
     * @method PDFNet.Date#update
     * @param {PDFNet.Obj} [d] an optional parameter indicating a SDF string that should be
     *  updated and attached to this Date. If parameter d is NULL or is omitted, update
     *  is performed on previously attached Cos/SDF date.
     *
     * @return {Promise<boolean>} A promise that resolves to true if the attached Cos/SDF string was successfully updated, false otherwise.
     */
    update(d?: PDFNet.Obj): Promise<boolean>;
  }
  /**
   * A destination defines a particular view of a document, consisting of the
   * following:
   *
   * - The page of the document to be displayed
   * - The location of the document window on that page
   * - The magnification (zoom) factor to use when displaying the page
   *
   * Destinations may be associated with Bookmarks, Annotations, and Remote Go-To Actions.
   *
   * Destination is a utility class used to simplify work with PDF Destinations;
   * Please refer to section 8.2.1 'Destinations' in PDF Reference Manual for details.
   * @class
   * @name Destination
   * @memberof PDFNet
   */
  class Destination {
    /**
     * Create a new 'XYZ' Destination.
     *
     * The new Destination displays the page designated by 'page', with the
     * coordinates ('left', 'top') positioned at the top-left corner of the
     * window and the contents of the page magnified by the factor 'zoom'.
     * A null value for any of the parameters 'left', 'top', or 'zoom' specifies
     * that the current value of that parameter is to be retained unchanged.
     * A 'zoom' value of 0 has the same meaning as a null value.
     * the page within the window in the other dimension.
     * @method PDFNet.Destination.createXYZ
     * @param {PDFNet.Page} page Page object to display
     * @param {number} left horizontal coordinate of the left edge of the window
     * @param {number} top vertical coordinate of the top edge of the window
     * @param {number} zoom amount to zoom the page by
     * @return {Promise<PDFNet.Destination>} A promise that resolves to an object of type: "Destination"
     */
    static createXYZ(page: PDFNet.Page, left: number, top: number, zoom: number): Promise<PDFNet.Destination>;
    /**
     * Create a new 'Fit' Destination.
     *
     * The new Destination displays the page designated by 'page', with its contents
     * magnified just enough to fit the entire page within the window both
     * horizontally and vertically. If the required horizontal and vertical
     * magnification factors are different, use the smaller of the two, centering
     * the page within the window in the other dimension.
     * @method PDFNet.Destination.createFit
     * @param {PDFNet.Page} page Page object to display
     * @return {Promise<PDFNet.Destination>} A promise that resolves to an object of type: "Destination"
     */
    static createFit(page: PDFNet.Page): Promise<PDFNet.Destination>;
    /**
     * Create a new 'FitH' Destination.
     *
     * The new Destination displays the page designated by 'page', with the
     * vertical coordinate 'top' positioned at the top edge of the window and
     * the contents of the page magnified just enough to fit the entire width
     * of the page within the window.
     * @method PDFNet.Destination.createFitH
     * @param {PDFNet.Page} page Page object to display
     * @param {number} top vertical coordinate of the top edge of the window
     * @return {Promise<PDFNet.Destination>} A promise that resolves to an object of type: "Destination"
     */
    static createFitH(page: PDFNet.Page, top: number): Promise<PDFNet.Destination>;
    /**
     * Create a new 'FitV' Destination.
     *
     * The new Destination displays the page designated by 'page', with the
     * horizontal coordinate 'left' positioned at the left edge of the window
     * and the contents of the page magnified just enough to fit the entire
     * height of the page within the window.
     * @method PDFNet.Destination.createFitV
     * @param {PDFNet.Page} page Page object to display
     * @param {number} left horizontal coordinate of the left edge of the window
     * @return {Promise<PDFNet.Destination>} A promise that resolves to an object of type: "Destination"
     */
    static createFitV(page: PDFNet.Page, left: number): Promise<PDFNet.Destination>;
    /**
     * Create a new 'FitR' Destination.
     *
     * The new Destination displays the page designated by 'page', with its
     * contents magnified just enough to fit the rectangle specified by the
     * coordinates 'left', 'bottom', 'right', and 'top' entirely within the
     * window both horizontally and vertically. If the required horizontal
     * and vertical magnification factors are different, use the smaller of
     * the two, centering the rectangle within the window in the other
     * dimension.
     * @method PDFNet.Destination.createFitR
     * @param {PDFNet.Page} page Page object to display
     * @param {number} left horizontal coordinate of the left edge of the window
     * @param {number} bottom vertical coordinate of the bottom edge of the window
     * @param {number} right horizontal coordinate of the right edge of the window
     * @param {number} top vertical coordinate of the top edge of the window
     * @return {Promise<PDFNet.Destination>} A promise that resolves to an object of type: "Destination"
     */
    static createFitR(
      page: PDFNet.Page,
      left: number,
      bottom: number,
      right: number,
      top: number,
    ): Promise<PDFNet.Destination>;
    /**
     * Create a new 'FitB' Destination.
     *
     * The new Destination displays the page designated by 'page', with its
     * contents magnified just enough to fit its bounding box entirely within
     * the window both horizontally and vertically. If the required
     * horizontal and vertical magnification factors are different, use the
     * smaller of the two, centering the bounding box within the window in
     * the other dimension.
     * @method PDFNet.Destination.createFitB
     * @param {PDFNet.Page} page Page object to display
     * @return {Promise<PDFNet.Destination>} A promise that resolves to an object of type: "Destination"
     */
    static createFitB(page: PDFNet.Page): Promise<PDFNet.Destination>;
    /**
     * Create a new 'FitBH' Destination.
     *
     * The new Destination displays the page designated by 'page', with
     * the vertical coordinate 'top' positioned at the top edge of the window
     * and the contents of the page magnified just enough to fit the entire
     * width of its bounding box within the window.
     * @method PDFNet.Destination.createFitBH
     * @param {PDFNet.Page} page Page object to display
     * @param {number} top vertical coordinate of the top edge of the window
     * @return {Promise<PDFNet.Destination>} A promise that resolves to an object of type: "Destination"
     */
    static createFitBH(page: PDFNet.Page, top: number): Promise<PDFNet.Destination>;
    /**
     * Create a new 'FitBV' Destination.
     *
     * The new Destination displays Display the page designated by 'page',
     * with the horizontal coordinate 'left' positioned at the left edge of
     * the window and the contents of the page magnified just enough to fit
     * the entire height of its bounding box within the window.
     * @method PDFNet.Destination.createFitBV
     * @param {PDFNet.Page} page Page object to display
     * @param {number} left horizontal coordinate of the left edge of the window
     * @return {Promise<PDFNet.Destination>} A promise that resolves to an object of type: "Destination"
     */
    static createFitBV(page: PDFNet.Page, left: number): Promise<PDFNet.Destination>;
    /**
     * Create a Destination and initialize it using given Cos/SDF object.
     *
     * @method PDFNet.Destination.create
     * @param {PDFNet.Obj} dest a low-level (SDF/Cos) destination object. The low-level
     * destination can be either a named destination (i.e. a Name or a String)
     * or an explicit destination (i.e. an Array Obj). Please refer to section
     * 8.2.1 'Destinations' in PDF Reference Manual for more details.
     *
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     *
     * @note Named destinations (in case 'dest' is a Name or a String) are
     * automatically resolved to the explicit destination. If the name can't
     * be resolved to the explicit destination dest.IsValid() will return false.
     * @return {Promise<PDFNet.Destination>} A promise that resolves to an object of type: "Destination"
     */
    static create(dest: PDFNet.Obj): Promise<PDFNet.Destination>;
    /**
     * Assignment operator
     * @method PDFNet.Destination#copy
     * @return {Promise<PDFNet.Destination>} A promise that resolves to an object of type: "Destination"
     */
    copy(): Promise<PDFNet.Destination>;
    /**
     * @method PDFNet.Destination#isValid
     * @return {Promise<boolean>} A promise that resolves to true if this is a valid Destination and can be resolved, false otherwise.
     *
     * @note If this method returns false the underlying SDF/Cos object is null and
     * the Action object should be treated as null as well.
     */
    isValid(): Promise<boolean>;
    /**
     * @method PDFNet.Destination#getFitType
     * @return {Promise<number>} A promise that resolves to destination's FitType.
     * @example Return value enum:
     * <pre>
     * PDFNet.Destination.FitType = {
     * 	e_XYZ : 0
     * 	e_Fit : 1
     * 	e_FitH : 2
     * 	e_FitV : 3
     * 	e_FitR : 4
     * 	e_FitB : 5
     * 	e_FitBH : 6
     * 	e_FitBV : 7
     * }
     * </pre>
     */
    getFitType(): Promise<number>;
    /**
     * @method PDFNet.Destination#getPage
     * @return {Promise<PDFNet.Page>} A promise that resolves to the Page that this destination refers to.
     */
    getPage(): Promise<PDFNet.Page>;
    /**
     * Modify the destination so that it refers to the new 'page' as the destination page.
     *
     * @method PDFNet.Destination#setPage
     * @param {PDFNet.Page} page The new page associated with this Destination.
     */
    setPage(page: PDFNet.Page): void;
    /**
     * @method PDFNet.Destination#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the object to the underlying SDF/Cos object.
     * The returned SDF/Cos object is an explicit destination (i.e. the Obj is either
     * an array defining the destination, using the syntax shown in Table 8.2 in PDF
     * Reference Manual), or a dictionary with a 'D' entry whose value is such an
     * array. The latter form allows additional attributes to be associated with
     * the destination
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Destination#getExplicitDestObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the explicit destination SDF/Cos object. This is always an Array
     * as shown in Table 8.2 in PDF Reference Manual.
     */
    getExplicitDestObj(): Promise<PDFNet.Obj>;
  }
  /**
   * DictIterator is used to traverse key/value pairs in a dictionary.
   * For example a DictIterator can be used to print out all the entries
   * in a given Obj dictionary as follows:
   * <pre>
   *  DictIterator itr = dict.GetDictIterator();
   *  while (itr.HasNext()) {
   *      Obj key = itr.Key();
   *	    cout << key.GetName() << endl;
   *      Obj value = itr.Value();
   *      // ...
   *      itr.Next()
   *   }
   * </pre>
   * @class
   * @name DictIterator
   * @memberof PDFNet
   */
  class DictIterator {
    /**
     * @method PDFNet.DictIterator#hasNext
     * @return {Promise<boolean>} A promise that resolves to true if the iterator can be successfully advanced to the
     * next element; false if the end collection is reached.
     */
    hasNext(): Promise<boolean>;
    /**
     * @method PDFNet.DictIterator#key
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the key of the current dictionary entry.
     */
    key(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.DictIterator#value
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the value of the current dictionary entry.
     */
    value(): Promise<PDFNet.Obj>;
    /**
     * Advances the iterator to the next element of the collection.
     * @method PDFNet.DictIterator#next
     */
    next(): void;
    /**
     * Destructor
     * @method PDFNet.DictIterator#destroy
     */
    destroy(): void;
  }
  /**
   * [Missing documentation]
   * @class
   * @name DigestAlgorithm
   * @memberof PDFNet
   */
  class DigestAlgorithm {}
  /**
   * The class DigitalSignatureField.
   * A class representing a digital signature form field.
   * @class
   * @name DigitalSignatureField
   * @memberof PDFNet
   */
  class DigitalSignatureField {
    /**
     * Returns whether the digital signature field has been cryptographically signed. Checks whether there is a digital signature dictionary in the field and whether it has a Contents entry. Must be called before using various digital signature dictionary-related functions. Does not check validity will return true even if a valid hash has not yet been generated (which will be the case after [Certify/Sign]OnNextSave[WithCustomHandler] has been called on the signature but even before Save is called on the document).
     *
     * @method PDFNet.DigitalSignatureField#hasCryptographicSignature
     * @return {Promise<boolean>} A promise that resolves to a boolean value representing whether the digital signature field has a digital signature dictionary with a Contents entry.
     */
    hasCryptographicSignature(): Promise<boolean>;
    /**
     * Returns the SubFilter type of the digital signature. Specification says that one must check the SubFilter before using various getters. Must call HasCryptographicSignature first and use it to check whether the signature is signed.
     *
     * @method PDFNet.DigitalSignatureField#getSubFilter
     * @return {Promise<number>} A promise that resolves to an enumeration describing what the SubFilter of the digital signature is from within the digital signature dictionary.
     * @example Return value enum:
     * <pre>
     * PDFNet.DigitalSignatureField.SubFilterType = {
     * 	e_adbe_x509_rsa_sha1 : 0
     * 	e_adbe_pkcs7_detached : 1
     * 	e_adbe_pkcs7_sha1 : 2
     * 	e_ETSI_CAdES_detached : 3
     * 	e_ETSI_RFC3161 : 4
     * 	e_unknown : 5
     * 	e_absent : 6
     * }
     * </pre>
     */
    getSubFilter(): Promise<number>;
    /**
     * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp). Returns the name of the signer of the signature from the digital signature dictionary. Must call HasCryptographicSignature first and use it to check whether the signature is signed.
     *
     * @method PDFNet.DigitalSignatureField#getSignatureName
     * @return {Promise<string>} A promise that resolves to a unicode string containing the name of the signer from within the digital signature dictionary. Empty if Name entry not present.
     */
    getSignatureName(): Promise<string>;
    /**
     * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp). Returns the Location of the signature from the digital signature dictionary. Must call HasCryptographicSignature first and use it to check whether the signature is signed.
     *
     * @method PDFNet.DigitalSignatureField#getLocation
     * @return {Promise<string>} A promise that resolves to a unicode string containing the signing location from within the digital signature dictionary. Empty if Location entry not present.
     */
    getLocation(): Promise<string>;
    /**
     * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp). Returns the Reason for the signature from the digital signature dictionary. Must call HasCryptographicSignature first and use it to check whether the signature is signed.
     *
     * @method PDFNet.DigitalSignatureField#getReason
     * @return {Promise<string>} A promise that resolves to a unicode string containing the reason for the signature from within the digital signature dictionary. Empty if Reason entry not present.
     */
    getReason(): Promise<string>;
    /**
     * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp). Returns the contact information of the signer from the digital signature dictionary. Must call HasCryptographicSignature first and use it to check whether the signature is signed.
     *
     * @method PDFNet.DigitalSignatureField#getContactInfo
     * @return {Promise<string>} A promise that resolves to a unicode string containing the contact information of the signer from within the digital signature dictionary. Empty if ContactInfo entry not present.
     */
    getContactInfo(): Promise<string>;
    /**
     * Gets number of certificates in certificate chain (Cert entry of digital signature dictionary). Must call HasCryptographicSignature first and use it to check whether the signature is signed.
     *
     * @method PDFNet.DigitalSignatureField#getCertCount
     * @return {Promise<number>} A promise that resolves to an integer value the number of certificates in the Cert entry of the digital signature dictionary.
     */
    getCertCount(): Promise<number>;
    /**
     * Returns whether the field has a visible appearance. Can be called without checking HasCryptographicSignature first, since it operates on the surrounding Field dictionary, not the "V" entry (i.e. digital signature dictionary). Performs the zero-width+height check, the Hidden bit check, and the NoView bit check as described by the PDF 2.0 specification, section 12.7.5.5 "Signature fields".
     *
     * @method PDFNet.DigitalSignatureField#hasVisibleAppearance
     * @return {Promise<boolean>} A promise that resolves to a boolean representing whether or not the signature field has a visible signature.
     */
    hasVisibleAppearance(): Promise<boolean>;
    /**
     * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp). Sets the ContactInfo entry in the digital signature dictionary. Must create a digital signature dictionary first using [Certify/Sign]OnNextSave[WithCustomHandler]. If this function is called on a digital signature field that has already been cryptographically signed with a valid hash, the hash will no longer be valid, so do not call Save (to sign/create the hash) until after you call this function, if you need to call this function in the first place. Essentially, call this function after [Certify/Sign]OnNextSave[WithCustomHandler] and before Save.
     *
     * @method PDFNet.DigitalSignatureField#setContactInfo
     * @param {string} in_contact_info -- A string containing the ContactInfo to be set.
     */
    setContactInfo(in_contact_info: string): void;
    /**
     * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp). Sets the Location entry in the digital signature dictionary. Must create a digital signature dictionary first using [Certify/Sign]OnNextSave[WithCustomHandler]. If this function is called on a digital signature field that has already been cryptographically signed with a valid hash, the hash will no longer be valid, so do not call Save (to sign/create the hash) until after you call this function, if you need to call this function in the first place. Essentially, call this function after [Certify/Sign]OnNextSave[WithCustomHandler] and before Save.
     *
     * @method PDFNet.DigitalSignatureField#setLocation
     * @param {string} in_location -- A string containing the Location to be set.
     */
    setLocation(in_location: string): void;
    /**
     * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp). Sets the Reason entry in the digital signature dictionary. Must create a digital signature dictionary first using [Certify/Sign]OnNextSave[WithCustomHandler]. If this function is called on a digital signature field that has already been cryptographically signed with a valid hash, the hash will no longer be valid, so do not call Save (to sign/create the hash) until after you call this function, if you need to call this function in the first place. Essentially, call this function after [Certify/Sign]OnNextSave[WithCustomHandler] and before Save.
     *
     * @method PDFNet.DigitalSignatureField#setReason
     * @param {string} in_reason -- A string containing the Reason to be set.
     */
    setReason(in_reason: string): void;
    /**
     * Sets the document locking permission level for this digital signature field. Call only on unsigned signatures, otherwise a valid hash will be invalidated.
     *
     * @method PDFNet.DigitalSignatureField#setDocumentPermissions
     * @param {number} in_perms
     * <pre>
     * PDFNet.DigitalSignatureField.DocumentPermissions = {
     * 	e_no_changes_allowed : 1
     * 	e_formfilling_signing_allowed : 2
     * 	e_annotating_formfilling_signing_allowed : 3
     * 	e_unrestricted : 4
     * }
     * </pre>
     * -- An enumerated value representing the document locking permission level to set.
     */
    setDocumentPermissions(in_perms: number): void;
    /**
     * Must be called to prepare a signature for signing, which is done afterwards by calling Save. Cannot sign two signatures during one save (throws). Default document permission level is e_annotating_formfilling_signing_allowed. Throws if signature field already has a digital signature dictionary.
     *
     * @method PDFNet.DigitalSignatureField#signOnNextSave
     * @param {string} in_pkcs12_keyfile_path -- The path to the PKCS #12 private keyfile to use to sign this digital signature.
     * @param {string} in_password -- The password to use to parse the PKCS #12 keyfile.
     */
    signOnNextSave(in_pkcs12_keyfile_path: string, in_password: string): void;
    /**
     * Must be called to prepare a signature for certification, which is done afterwards by calling Save. Throws if document already certified. Default document permission level is e_annotating_formfilling_signing_allowed. Throws if signature field already has a digital signature dictionary.
     *
     * @method PDFNet.DigitalSignatureField#certifyOnNextSave
     * @param {string} in_pkcs12_keyfile_path -- The path to the PKCS #12 private keyfile to use to certify this digital signature.
     * @param {string} in_password -- The password to use to parse the PKCS #12 keyfile.
     */
    certifyOnNextSave(in_pkcs12_keyfile_path: string, in_password: string): void;
    /**
     * Returns whether this digital signature field is locked against modifications by any digital signatures. Can be called when this field is unsigned.
     *
     * @method PDFNet.DigitalSignatureField#isLockedByDigitalSignature
     * @return {Promise<boolean>} A promise that resolves to a boolean representing whether this digital signature field is locked against modifications by any digital signatures in the document.
     */
    isLockedByDigitalSignature(): Promise<boolean>;
    /**
     * If HasCryptographicSignature, returns most restrictive permissions found in any reference entries in this digital signature. Returns Lock-resident (i.e. tentative) permissions otherwise. Throws if invalid permission value is found.
     *
     * @method PDFNet.DigitalSignatureField#getDocumentPermissions
     * @return {Promise<number>} A promise that resolves to an enumeration value representing the level of restrictions (potentially) placed on the document by this signature.
     * @example Return value enum:
     * <pre>
     * PDFNet.DigitalSignatureField.DocumentPermissions = {
     * 	e_no_changes_allowed : 1
     * 	e_formfilling_signing_allowed : 2
     * 	e_annotating_formfilling_signing_allowed : 3
     * 	e_unrestricted : 4
     * }
     * </pre>
     */
    getDocumentPermissions(): Promise<number>;
    /**
     * Clears cryptographic signature, if present. Otherwise, does nothing. Do not need to call HasCryptographicSignature before calling this. After clearing, other signatures should still pass validation if saving after clearing was done incrementally. Clears the appearance as well.
     * @method PDFNet.DigitalSignatureField#clearSignature
     */
    clearSignature(): void;
    /**
     *
     * @method PDFNet.DigitalSignatureField.createFromField
     * @param {PDFNet.Field} d
     * @return {Promise<PDFNet.DigitalSignatureField>} A promise that resolves to an object of type: "DigitalSignatureField"
     */
    static createFromField(d: PDFNet.Field): Promise<PDFNet.DigitalSignatureField>;
    /**
     * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp).
     * Returns the "M" entry from the digital signature dictionary, which represents the
     * signing date/time. Must call HasCryptographicSignature first and use it to check whether the
     * signature is signed.
     *
     * @method PDFNet.DigitalSignatureField#getSigningTime
     * @return {Promise<PDFNet.Date>} A promise that resolves to a PDF::Date object holding the signing date/time from within the digital signature dictionary. Returns a default-constructed PDF::Date if no date is present.
     */
    getSigningTime(): Promise<PDFNet.Date>;
    /**
     *
     * @method PDFNet.DigitalSignatureField#signOnNextSaveFromBuffer
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} in_pkcs12_buffer
     * @param {string} in_password
     */
    signOnNextSaveFromBuffer(
      in_pkcs12_buffer: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray,
      in_password: string,
    ): void;
    /**
     * Must be called to prepare a signature for signing, which is done afterwards by calling Save. Cannot sign two signatures during one save (throws). Default document permission level is e_annotating_formfilling_signing_allowed. Throws if signature field already has a digital signature dictionary.
     *
     * @method PDFNet.DigitalSignatureField#signOnNextSaveWithCustomHandler
     * @param {number} in_signature_handler_id -- The unique id of the signature handler to use to sign this digital signature.
     */
    signOnNextSaveWithCustomHandler(in_signature_handler_id: number): void;
    /**
     *
     * @method PDFNet.DigitalSignatureField#certifyOnNextSaveFromBuffer
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} in_pkcs12_buffer
     * @param {string} in_password
     */
    certifyOnNextSaveFromBuffer(
      in_pkcs12_buffer: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray,
      in_password: string,
    ): void;
    /**
     * Must be called to prepare a signature for certification, which is done afterwards by calling Save. Throws if document already certified. Default document permission level is e_annotating_formfilling_signing_allowed. Throws if signature field already has a digital signature dictionary.
     *
     * @method PDFNet.DigitalSignatureField#certifyOnNextSaveWithCustomHandler
     * @param {number} in_signature_handler_id -- The unique id of the signature handler to use to certify this digital signature.
     */
    certifyOnNextSaveWithCustomHandler(in_signature_handler_id: number): void;
    /**
     * Retrieves the SDF Obj of the digital signature field.
     *
     * @method PDFNet.DigitalSignatureField#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * Verifies this cryptographic digital signature in the manner specified by the VerificationOptions. EXPERIMENTAL. Digital signature verification is undergoing active development, but currently does not support a number of features. If we are missing a feature that is important to you, or if you have files that do not act as expected, please contact us using one of the following forms: https://www.pdftron.com/form/trial-support/ or https://www.pdftron.com/form/request/
     *
     * @method PDFNet.DigitalSignatureField#verify
     * @param {PDFNet.VerificationOptions} in_opts -- The options specifying how to do the verification.
     * @return {Promise<PDFNet.VerificationResult>} A promise that resolves to a VerificationResult object containing various information about the verifiability of the cryptographic digital signature.
     */
    verify(in_opts: PDFNet.VerificationOptions): Promise<PDFNet.VerificationResult>;
  }
  /**
   * The class DisallowedChange.
   * Data pertaining to a change detected in a document during a digital
   * signature modification permissions verification step, the change bein
   * g both made after the signature was signed, and disallowed by t
   * he signature's permissions settings.
   * @class
   * @name DisallowedChange
   * @memberof PDFNet
   */
  class DisallowedChange {
    /**
     * Returns the SDF object number of the indirect object associated with this DisallowedChange.
     *
     * @method PDFNet.DisallowedChange#getObjNum
     * @return {Promise<number>} A promise that resolves to an unsigned 32-bit integer value.
     */
    getObjNum(): Promise<number>;
    /**
     * Returns an enumeration value representing the semantic type of this disallowed change.
     *
     * @method PDFNet.DisallowedChange#getType
     * @return {Promise<number>} A promise that resolves to an enumeration value of type: Type of DisallowedChange.
     * @example Return value enum:
     * <pre>
     * PDFNet.DisallowedChange.Type = {
     * 	e_form_filled : 0
     * 	e_digital_signature_signed : 1
     * 	e_page_template_instantiated : 2
     * 	e_annotation_created_or_updated_or_deleted : 3
     * 	e_other : 4
     * 	e_unknown : 5
     * }
     * </pre>
     */
    getType(): Promise<number>;
    /**
     * Returns a string value representing the semantic type of this disallowed change.
     *
     * @method PDFNet.DisallowedChange#getTypeAsString
     * @return {Promise<string>} A promise that resolves to a string.
     */
    getTypeAsString(): Promise<string>;
    /**
     * Destructor
     * @method PDFNet.DisallowedChange#destroy
     */
    destroy(): void;
  }
  /**
   * The class DocSnapshot.
   * Represents a state of the document.
   * @class
   * @name DocSnapshot
   * @memberof PDFNet
   */
  class DocSnapshot {
    /**
     * Returns a hash that is unique to particular document states.
     *
     * @method PDFNet.DocSnapshot#getHash
     * @return {Promise<number>} A promise that resolves to a hash that is unique to particular document states.
     */
    getHash(): Promise<number>;
    /**
     * Returns whether this snapshot is valid.
     *
     * @method PDFNet.DocSnapshot#isValid
     * @return {Promise<boolean>} A promise that resolves to whether this snapshot is valid.
     */
    isValid(): Promise<boolean>;
    /**
     * Returns whether this snapshot's document state is equivalent to another.
     *
     * @method PDFNet.DocSnapshot#equals
     * @param {PDFNet.DocSnapshot} snapshot -- the other snapshot with which to compare.
     * @return {Promise<boolean>} A promise that resolves to whether this snapshot's document state is equivalent to another.
     */
    equals(snapshot: PDFNet.DocSnapshot): Promise<boolean>;
    /**
     * Destructor
     * @method PDFNet.DocSnapshot#destroy
     */
    destroy(): void;
  }
  /**
   * The class DocumentConversion.
   * Encapsulates the conversion of a single document from one format to another.
   *
   * DocumentConversion instances are created through methods belonging to
   * the Convert class. See Convert.WordToPDFConversion for an example.
   * @class
   * @name DocumentConversion
   * @memberof PDFNet
   */
  class DocumentConversion {
    /**
     *
     * @method PDFNet.DocumentConversion#getDoc
     * @return {Promise<PDFNet.PDFDoc>} A promise that resolves to an object of type: "PDFDoc"
     */
    getDoc(): Promise<PDFNet.PDFDoc>;
    /**
     *
     * @method PDFNet.DocumentConversion#isCancelled
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    isCancelled(): Promise<boolean>;
    /**
     *
     * @method PDFNet.DocumentConversion#getNumConvertedPages
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     */
    getNumConvertedPages(): Promise<number>;
  }
  /**
   * Element is the abstract interface used to access graphical elements used to build the
   * display list.
   *
   * Just like many other classes in PDFNet (e.g. ColorSpace, Font, Annot, etc), Element
   * class follows the composite design pattern. This means that all Elements are
   * accessed through the same interface, but depending on the Element type (that can be
   * obtained using GetType()), only methods related to that type can be called.
   * For example, if GetType() returns e_image, it is illegal to call a method specific to
   * another Element type (i.e. a call to a text specific GetTextData() will throw an
   * Exception).
   * @class
   * @name Element
   * @memberof PDFNet
   */
  class Element {
    /**
     * @method PDFNet.Element#getType
     * @return {Promise<number>} A promise that resolves to the current element type.
     * @example Return value enum:
     * <pre>
     * PDFNet.Element.Type = {
     * 	e_null : 0
     * 	e_path : 1
     * 	e_text_begin : 2
     * 	e_text : 3
     * 	e_text_new_line : 4
     * 	e_text_end : 5
     * 	e_image : 6
     * 	e_inline_image : 7
     * 	e_shading : 8
     * 	e_form : 9
     * 	e_group_begin : 10
     * 	e_group_end : 11
     * 	e_marked_content_begin : 12
     * 	e_marked_content_end : 13
     * 	e_marked_content_point : 14
     * }
     * </pre>
     */
    getType(): Promise<number>;
    /**
     * @method PDFNet.Element#getGState
     * @return {Promise<PDFNet.GState>} A promise that resolves to gState of this Element
     */
    getGState(): Promise<PDFNet.GState>;
    /**
     * @method PDFNet.Element#getCTM
     * @return {Promise<PDFNet.Matrix2D>} A promise that resolves to current Transformation Matrix (CTM) that maps coordinates to the
     * initial user space.
     */
    getCTM(): Promise<PDFNet.Matrix2D>;
    /**
     * @method PDFNet.Element#getParentStructElement
     * @return {Promise<PDFNet.SElement>} A promise that resolves to parent logical structure element (such as 'span' or 'paragraph').
     * If the Element is not associated with any structure element, the returned
     * SElement will not be valid (i.e. selem.IsValid() -> false).
     */
    getParentStructElement(): Promise<PDFNet.SElement>;
    /**
     * @method PDFNet.Element#getStructMCID
     * @return {Promise<number>} A promise that resolves to marked Content Identifier (MCID) for this Element or
     * a negative number if the element is not assigned an identifier/MCID.
     *
     * Marked content identifier can be used to associate an Element with
     * logical structure element that refers to the Element.
     */
    getStructMCID(): Promise<number>;
    /**
     * @method PDFNet.Element#isOCVisible
     * @return {Promise<boolean>} A promise that resolves to true if this element is visible in the optional-content
     * context (OCG::Context). The method considers the context's current OCMD stack,
     * the group ON-OFF states, the non-OC drawing status, the drawing and enumeration mode,
     * and the intent.
     *
     * When enumerating page content, OCG::Context can be passed as a parameter in
     * ElementReader.Begin() method. When using PDFDraw, PDFRasterizer, or PDFView class to
     * render PDF pages use PDFDraw::SetOCGContext() method to select an OC context.
     */
    isOCVisible(): Promise<boolean>;
    /**
     * @method PDFNet.Element#isClippingPath
     * @return {Promise<boolean>} A promise that resolves to true if the current path element is a clipping path and should be added
     * to clipping path stack.
     */
    isClippingPath(): Promise<boolean>;
    /**
     * @method PDFNet.Element#isStroked
     * @return {Promise<boolean>} A promise that resolves to true if the current path element should be stroked
     */
    isStroked(): Promise<boolean>;
    /**
     * @method PDFNet.Element#isFilled
     * @return {Promise<boolean>} A promise that resolves to true if the current path element should be filled
     */
    isFilled(): Promise<boolean>;
    /**
     * @method PDFNet.Element#isWindingFill
     * @return {Promise<boolean>} A promise that resolves to true if the current path should be filled using non-zero winding rule,
     * or false if the path should be filled using even-odd rule.
     *
     * According non-zero winding rule, you can determine whether a test point is inside or
     * outside a closed curve as follows: Draw a line from a test point to a point that
     * is distant from the curve. Count the number of times the curve crosses the test
     * line from left to right, and count the number of times the curve crosses the test
     * line from right to left. If those two numbers are the same, the test point is
     * outside the curve; otherwise, the test point is inside the curve.
     *
     * According to even-odd rule, you can determine whether a test point is inside
     * or outside a closed curve as follows: Draw a line from the test point to a point
     * that is distant from the curve. If that line crosses the curve an odd number of
     * times, the test point is inside the curve; otherwise, the test point is outside
     * the curve.
     */
    isWindingFill(): Promise<boolean>;
    /**
     * @method PDFNet.Element#isClipWindingFill
     * @return {Promise<boolean>} A promise that resolves to true if the current clip path is using non-zero winding rule, or false
     * for even-odd rule.
     */
    isClipWindingFill(): Promise<boolean>;
    /**
     * indicate whether the path is a clipping path or non-clipping path
     * @method PDFNet.Element#setPathClip
     * @param {boolean} clip true to set path to clipping path. False for non-clipping path.
     */
    setPathClip(clip: boolean): void;
    /**
     * indicate whether the path should be stroked
     * @method PDFNet.Element#setPathStroke
     * @param {boolean} stroke true to set path to be stroked. False for no stroke path.
     */
    setPathStroke(stroke: boolean): void;
    /**
     * indicate whether the path should be filled
     * @method PDFNet.Element#setPathFill
     * @param {boolean} fill true to set path to be filled. False for no fill path.
     */
    setPathFill(fill: boolean): void;
    /**
     * sets path's fill rule.
     * @method PDFNet.Element#setWindingFill
     * @param {boolean} winding_rule if winding_rule is true path will be filled using non-zero
     * winding fill rule, otherwise even-odd fill will be used.
     */
    setWindingFill(winding_rule: boolean): void;
    /**
     * sets clipping path's fill rule.
     * @method PDFNet.Element#setClipWindingFill
     * @param {boolean} winding_rule if winding_rule is true clipping should use non-zero
     * winding rule, or false for even-odd rule.
     */
    setClipWindingFill(winding_rule: boolean): void;
    /**
     *
     * @method PDFNet.Element#setPathTypes
     * @param {string} in_seg_types
     * @param {number} count
     */
    setPathTypes(in_seg_types: string, count: number): void;
    /**
     * @method PDFNet.Element#getXObject
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the SDF object of the Image/Form object.
     */
    getXObject(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Element#getImageData
     * @return {Promise<PDFNet.Filter>} A promise that resolves to a stream (filter) containing decoded image data
     */
    getImageData(): Promise<PDFNet.Filter>;
    /**
     * @method PDFNet.Element#getImageDataSize
     * @return {Promise<number>} A promise that resolves to the size of image data in bytes
     */
    getImageDataSize(): Promise<number>;
    /**
     * @method PDFNet.Element#getImageColorSpace
     * @return {Promise<PDFNet.ColorSpace>} A promise that resolves to the SDF object representing the color space in which image
     * are specified or NULL if the image is an image mask
     *
     * The returned color space may be any type of color space except Pattern.
     */
    getImageColorSpace(): Promise<PDFNet.ColorSpace>;
    /**
     * @method PDFNet.Element#getImageWidth
     * @return {Promise<number>} A promise that resolves to the width of the image, in samples.
     */
    getImageWidth(): Promise<number>;
    /**
     * @method PDFNet.Element#getImageHeight
     * @return {Promise<number>} A promise that resolves to the height of the image, in samples.
     */
    getImageHeight(): Promise<number>;
    /**
     * @method PDFNet.Element#getDecodeArray
     * @return {Promise<PDFNet.Obj>} A promise that resolves to decode array or NULL if the parameter is not specified. A decode object is an
     * array of numbers describing how to map image samples into the range of values
     * appropriate for the color space of the image. If ImageMask is true, the array must be
     * either [0 1] or [1 0]; otherwise, its length must be twice the number of color
     * components required by ColorSpace. Default value depends on the color space,
     * See Table 4.36 in PDF Ref. Manual.
     */
    getDecodeArray(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Element#getBitsPerComponent
     * @return {Promise<number>} A promise that resolves to the number of bits used to represent each color component. Only a
     * single value may be specified; the number of bits is the same for all color
     * components. Valid values are 1, 2, 4, and 8.
     */
    getBitsPerComponent(): Promise<number>;
    /**
     * @method PDFNet.Element#getComponentNum
     * @return {Promise<number>} A promise that resolves to the number of color components per sample.
     */
    getComponentNum(): Promise<number>;
    /**
     * @method PDFNet.Element#isImageMask
     * @return {Promise<boolean>} A promise that resolves to a boolean indicating whether the inline image is to be treated as an image mask.
     */
    isImageMask(): Promise<boolean>;
    /**
     * @method PDFNet.Element#isImageInterpolate
     * @return {Promise<boolean>} A promise that resolves to a boolean indicating whether image interpolation is to be performed.
     */
    isImageInterpolate(): Promise<boolean>;
    /**
     * @method PDFNet.Element#getMask
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an image XObject defining an image mask to be applied to this image (See
     * 'Explicit Masking', 4.8.5), or an array specifying a range of colors
     * to be applied to it as a color key mask (See 'Color Key Masking').
     *
     * If IsImageMask() return true, this method will return NULL.
     */
    getMask(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Element#getImageRenderingIntent
     * @return {Promise<number>} A promise that resolves to the color rendering intent to be used in rendering the image.
     * @example Return value enum:
     * <pre>
     * PDFNet.GState.RenderingIntent = {
     * 	e_absolute_colorimetric : 0
     * 	e_relative_colorimetric : 1
     * 	e_saturation : 2
     * 	e_perceptual : 3
     * }
     * </pre>
     */
    getImageRenderingIntent(): Promise<number>;
    /**
     * @method PDFNet.Element#getTextString
     * @return {Promise<string>} A promise that resolves to a pointer to Unicode string for this text Element. The
     * function maps character codes to Unicode array defined by Adobe
     * Glyph List (http://partners.adobe.com/asn/developer/type/glyphlist.txt).
     *
     * @note In PDF text can be encoded using various encoding schemes
     * and in some cases it is not possible to extract Unicode encoding.
     * If it is not possible to map charcode to Unicode the function will
     * map a character to undefined code, 0xFFFD. This code is defined in
     * private Unicode range.
     *
     * @note If you would like to map raw text to Unicode (or some other encoding)
     * yourself use CharIterators returned by CharBegin()/CharEnd() and
     * PDF::Font code mapping methods.
     *
     * @note The string owner is the current element (i.e. ElementReader or ElementBuilder).
     */
    getTextString(): Promise<string>;
    /**
     * @method PDFNet.Element#getTextMatrix
     * @return {Promise<PDFNet.Matrix2D>} A promise that resolves to a reference to the current text matrix (Tm).
     */
    getTextMatrix(): Promise<PDFNet.Matrix2D>;
    /**
     * @method PDFNet.Element#getCharIterator
     * @return {Promise<PDFNet.Iterator>} A promise that resolves to a CharIterator addressing the first CharData element in the text run.
     *
     * CharIterator points to CharData. CharData is a data structure that contains
     * the char_code number (used to retrieve glyph outlines, to map to Unicode, etc.),
     * character positioning information (x, y), and the number of bytes taken by the
     * character within the text buffer.
     *
     * @note CharIterator follows the standard STL forward-iterator interface.
     *
     * An example of how to use CharIterator.
     * <pre>
     *     for (CharIterator itr = element.GetCharIterator(); itr.HasNext(); itr.Next()) {
     * 			unsigned int char_code = itr.Current().char_code;
     * 			double char_pos_x = itr.Current().x;
     * 			double char_pos_y = itr.Current().y;
     *     }
     * </pre>
     *
     * @note Character positioning information (x, y) is represented in text space.
     * In order to get the positioning in the user space, the returned value should
     * be scaled using the text matrix (GetTextMatrix()) and the current transformation
     * matrix (GetCTM()). See section 4.2 'Other Coordinate Spaces' in PDF Reference
     * Manual for details and PDFNet FAQ "How do I get absolute/relative text and
     * character positioning?".
     *
     * @note within a text run a character may occupy more than a single byte (e.g.
     * in case of composite/Type0 fonts). The role of CharIterator/CharData is to
     * provide a uniform and easy to use interface to access character information.
     */
    getCharIterator(): Promise<PDFNet.Iterator>;
    /**
     * @method PDFNet.Element#getTextLength
     * @return {Promise<number>} A promise that resolves to the text advance distance in text space.
     *
     * The total sum of all of the advance values from rendering all of the characters
     * within this element, including the advance value on the glyphs, the effect of
     * properties such as 'char-spacing', 'word-spacing' and positioning adjustments
     * on 'TJ' elements.
     *
     * @note Computed text length is represented in text space. In order to get the
     * length of the text run in the user space, the returned value should be scaled
     * using the text matrix (GetTextMatrix()) and the current transformation
     * matrix (GetCTM()). See section 4.2 'Other Coordinate Spaces' in PDF Reference
     * Manual for details.
     */
    getTextLength(): Promise<number>;
    /**
     * @method PDFNet.Element#getPosAdjustment
     * @return {Promise<number>} A promise that resolves to the number used to adjust text matrix in horizontal direction when drawing
     * text. The number is expressed in thousandths of a unit of text space. The returned
     * number corresponds to a number value within TJ array. For 'Tj' text strings the
     * returned value is always 0.
     *
     * @note because CharIterator positioning information already accounts for TJ
     * adjustments this method is rarely used.
     */
    getPosAdjustment(): Promise<number>;
    /**
     * returns the offset (out_x, out_y) to the start of the current line relative to
     * the beginning of the previous line.
     *
     * out_x and out_y are numbers expressed in unscaled text space units.
     * The returned numbers correspond to the arguments of 'Td' operator.
     * @method PDFNet.Element#getNewTextLineOffset
     */
    getNewTextLineOffset(): void;
    /**
     * @method PDFNet.Element#hasTextMatrix
     * @return {Promise<boolean>} A promise that resolves to true if this element is directly associated with a text matrix
     * (that is Tm operator is just before this text element) or false if the text
     * matrix is default or is inherited from previous text elements.
     */
    hasTextMatrix(): Promise<boolean>;
    /**
     * set the text data for the current e_text Element.
     * @method PDFNet.Element#setTextData
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf_text_data a pointer to a buffer containing text.
     */
    setTextData(buf_text_data: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): void;
    /**
     * Sets the text matrix for a text element.
     *
     * @method PDFNet.Element#setTextMatrix
     * @param {PDFNet.Matrix2D} mtx The new text matrix for this text element
     */
    setTextMatrix(mtx: PDFNet.Matrix2D): void;
    /**
     * Sets the text matrix for a text element. This method accepts text
     * transformation matrix components directly.
     *
     * A transformation matrix in PDF is specified by six numbers, usually
     * in the form of an array containing six elements. In its most general
     * form, this array is denoted [a b c d h v]; it can represent any linear
     * transformation from one coordinate system to another. For more
     * information about PDF matrices please refer to section 4.2.2 'Common
     * Transformations' in PDF Reference Manual, and to documentation for
     * Matrix2D class.
     *
     * @method PDFNet.Element#setTextMatrixEntries
     * @param {number} a horizontal 'scaling' component of the new text matrix.
     * @param {number} b 'rotation' component of the new text matrix.
     * @param {number} c 'rotation' component of the new text matrix.
     * @param {number} d vertical 'scaling' component of the new text matrix.
     * @param {number} h horizontal translation component of the new text matrix.
     * @param {number} v vertical translation component of the new text matrix.
     */
    setTextMatrixEntries(a: number, b: number, c: number, d: number, h: number, v: number): void;
    /**
     * @method PDFNet.Element#setPosAdjustment
     * @param {number} adjust number to set the horizontal adjustment to
     *
     * @note Positive values move the current text element backwards (along text direction).
     *       Negative values move the current text element forward (along text direction).
     */
    setPosAdjustment(adjust: number): void;
    /**
     * Recompute the character positioning information (i.e. CharIterator-s) and
     * text length.
     *
     * Element objects caches text length and character positioning information.
     * If the user modifies the text data or graphics state the cached information
     * is not correct. UpdateTextMetrics() can be used to recalculate the correct
     * positioning and length information.
     * @method PDFNet.Element#updateTextMetrics
     */
    updateTextMetrics(): void;
    /**
     * sets the offset (dx, dy) to the start of the current line relative to the beginning
     * of the previous line.
     * @method PDFNet.Element#setNewTextLineOffset
     * @param {number} dx horizontal offset to the start of the curret line
     * @param {number} dy vertical offset to the start of the current line
     */
    setNewTextLineOffset(dx: number, dy: number): void;
    /**
     * @method PDFNet.Element#getShading
     * @return {Promise<PDFNet.Shading>} A promise that resolves to the SDF object of the Shading object.
     */
    getShading(): Promise<PDFNet.Shading>;
    /**
     * @method PDFNet.Element#getMCPropertyDict
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a dictionary containing the property list or NULL if property
     * dictionary is not present.
     *
     * @note the function automatically looks under Properties sub-dictionary of the
     * current resource dictionary if the dictionary is not in-line. Therefore you
     * can assume that returned Obj is dictionary if it is not NULL.
     */
    getMCPropertyDict(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Element#getMCTag
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a tag is a name object indicating the role or significance of
     * the marked content point/sequence.
     */
    getMCTag(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Element#getTextData
     * @return {Promise<number>} A promise that resolves to a pointer to the internal text buffer for this text element.
     * @note GetTextData() returns the raw text data and not a Unicode string.
     * In PDF text can be encoded using various encoding schemes so it is necessary
     * to consider Font encoding while processing the content of this buffer.
     *
     * @note Most of the time GetTextString() is what you are looking for instead.
     * GetTextString() maps the raw text directly into Unicode (as specified by Adobe
     * Glyph List (AGL) ). Even if you would prefer to decode text yourself it is more
     * convenient to use CharIterators returned by CharBegin()/CharEnd() and
     * PDF::Font code mapping methods.
     *
     * @note the buffer owner is the current element (i.e. ElementReader or ElementBuilder).
     */
    getTextData(): Promise<number>;
    /**
     * Obtains the bounding box for a graphical element.
     *
     * Calculates the bounding box for a graphical element (i.e. an Element that belongs
     * to one of following types: e_path, e_text, e_image, e_inline_image, e_shading e_form).
     * The returned bounding box is guaranteed to encompass the Element, but is not guaranteed
     * to be the smallest box that could contain the element. For example, for Bezier curves
     * the bounding box will enclose all control points, not just the curve itself.
     *
     * @method PDFNet.Element#getBBox
     * @return {Promise<Rect>} A promise that resolves to a rectangle specifying the bounding box of Element (a rectangle that surrounds the
     * entire element). The coordinates are represented in the default PDF page coordinate system
     * and are using units called points ( 1 point = 1/72 inch =  2.54 /72 centimeter). The
     * bounding box already accounts for the effects of current transformation matrix (CTM),
     * text matrix, font size, and other properties in the graphics state. If this is a non-graphical
     * element, the bounding box is undefined.
     */
    getBBox(): Promise<Rect>;
  }
  /**
   * ElementBuilder is used to build new PDF::Elements (e.g. image, text, path, etc)
   * from scratch. In conjunction with ElementWriter, ElementBuilder can be used to create
   * new page content.
   *
   * @note Analogous to ElementReader, every call to ElementBuilder.Create? method destroys
   * the Element currently associated with the builder and all previous Element pointers are
   * invalidated.
   *
   * @note For C++ developers. Analogous to ElementReader, ElementBuilder is the owner of
   * all Element objects it creates.
   * @class
   * @name ElementBuilder
   * @memberof PDFNet
   */
  class ElementBuilder {
    /**
     * Constructor for an ElementBuilder object that can be used to build new PDF::Elements
     * (eg. image, text, path, etc.) from scratch. In conjunction with ElementWriter,
     * ElementBuilder can be used to create new page content.
     *
     * @method PDFNet.ElementBuilder.create
     * @return {Promise<PDFNet.ElementBuilder>} A promise that resolves to Returns an ElementBuilder object
     */
    static create(): Promise<PDFNet.ElementBuilder>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.ElementBuilder#destroy
     */
    destroy(): void;
    /**
     * The function sets the graphics state of this Element to the given value.
     * If 'gs' parameter is not specified or is NULL the function resets the
     * graphics state of this Element to the default graphics state (i.e. the
     * graphics state at the beginning of the display list).
     *
     * The function can be used in situations where the same ElementBuilder is used
     * to create content on several pages, XObjects, etc. If the graphics state is not
     * Reset() when moving to a new display list, the new Element will have the same
     * graphics state as the last Element in the previous display list (and this may
     * or may not be your intent).
     *
     * Another use of Reset(gs) is to make sure that two Elements have the graphics
     * state.
     * @method PDFNet.ElementBuilder#reset
     * @param {PDFNet.GState} [gs] GState (graphics state) object. If NULL or unspecified, resets graphics state to default.
     */
    reset(gs?: PDFNet.GState): void;
    /**
     * Create a content image Element out of a given document Image.
     * @method PDFNet.ElementBuilder#createImage
     * @param {PDFNet.Image} img the given image.
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createImage(img: PDFNet.Image): Promise<PDFNet.Element>;
    /**
     * Create a content image Element out of a given document Image.
     * @method PDFNet.ElementBuilder#createImageFromMatrix
     * @param {PDFNet.Image} img the given image.
     * @param {PDFNet.Matrix2D} mtx the image transformation matrix.
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createImageFromMatrix(img: PDFNet.Image, mtx: PDFNet.Matrix2D): Promise<PDFNet.Element>;
    /**
     * Create a content image Element out of a given document Image with
     * the lower left corner at (x, y), and scale factors (hscale, vscale).
     * @method PDFNet.ElementBuilder#createImageScaled
     * @param {PDFNet.Image} img the given image.
     * @param {number} x The horizontal x position to place the lower left corner of the image
     * @param {number} y The vertical x position to place the lower left corner of the image
     * @param {number} hscale The horizontal scale of the image
     * @param {number} vscale The vertical scale of the image
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createImageScaled(img: PDFNet.Image, x: number, y: number, hscale: number, vscale: number): Promise<PDFNet.Element>;
    /**
     * Create e_group_begin Element (i.e. 'q' operator in PDF content stream).
     * The function saves the current graphics state.
     * @method PDFNet.ElementBuilder#createGroupBegin
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createGroupBegin(): Promise<PDFNet.Element>;
    /**
     * Create e_group_end Element (i.e. 'Q' operator in PDF content stream).
     * The function restores the previous graphics state.
     * @method PDFNet.ElementBuilder#createGroupEnd
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createGroupEnd(): Promise<PDFNet.Element>;
    /**
     * @method PDFNet.ElementBuilder#createShading
     * @param {PDFNet.Shading} sh A Shading object. Shading objects represent a flat interface around
     * all PDF shading types (e_function_shading, e_axial_shading, etc.)
     * Create a shading Element.
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createShading(sh: PDFNet.Shading): Promise<PDFNet.Element>;
    /**
     * Create a Form XObject Element.
     * @method PDFNet.ElementBuilder#createFormFromStream
     * @param {PDFNet.Obj} form a Form XObject content stream
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createFormFromStream(form: PDFNet.Obj): Promise<PDFNet.Element>;
    /**
     * Create a Form XObject Element using the content of the existing page.
     * This method assumes that the XObject will be used in the same
     * document as the given page. If you need to create the Form XObject
     * in a different document use CreateForm(Page, Doc) method.
     *
     * @method PDFNet.ElementBuilder#createFormFromPage
     * @param {PDFNet.Page} page A page used to create the Form XObject.
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createFormFromPage(page: PDFNet.Page): Promise<PDFNet.Element>;
    /**
     * Create a Form XObject Element using the content of the existing page.
     * Unlike CreateForm(Page) method, you can use this method to create form
     * in another document.
     *
     * @method PDFNet.ElementBuilder#createFormFromDoc
     * @param {PDFNet.Page} page A page used to create the Form XObject.
     * @param {PDFNet.PDFDoc} doc Destination document for the Form XObject.
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createFormFromDoc(page: PDFNet.Page, doc: PDFNet.PDFDoc): Promise<PDFNet.Element>;
    /**
     * Start a text block ('BT' operator in PDF content stream).
     * The function installs the given font in the current graphics state.
     * @method PDFNet.ElementBuilder#createTextBeginWithFont
     * @param {PDFNet.Font} font font to set the text in the text block to
     * @param {number} font_sz size to set the text in the text block to
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createTextBeginWithFont(font: PDFNet.Font, font_sz: number): Promise<PDFNet.Element>;
    /**
     * Start a text block ('BT' operator in PDF content stream).
     * @method PDFNet.ElementBuilder#createTextBegin
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createTextBegin(): Promise<PDFNet.Element>;
    /**
     * Ends a text block.
     * @method PDFNet.ElementBuilder#createTextEnd
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createTextEnd(): Promise<PDFNet.Element>;
    /**
     * Create a text run using the given font.
     * @method PDFNet.ElementBuilder#createTextRun
     * @param {string} text_data text to initialize the text run with
     * @param {PDFNet.Font} font font of the text in the text run
     * @param {number} font_sz size of the text in the text run
     * @note a text run can be created only within a text block
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createTextRun(text_data: string, font: PDFNet.Font, font_sz: number): Promise<PDFNet.Element>;
    /**
     * Create a text run using the given font.
     * @method PDFNet.ElementBuilder#createTextRunWithSize
     * @param {string} text_data text to initialize the text run with
     * @param {number} text_data_sz size of the text run
     * @param {PDFNet.Font} font font of the text in the text run
     * @param {number} font_sz size of the text in the text run
     * @note a text run can be created only within a text block
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createTextRunWithSize(
      text_data: string,
      text_data_sz: number,
      font: PDFNet.Font,
      font_sz: number,
    ): Promise<PDFNet.Element>;
    /**
     * Create a text run using the given font.
     * @method PDFNet.ElementBuilder#createTextRunUnsigned
     * @param {string} text_data text to initialize the text run with. Uses unsigned characters.
     * @param {PDFNet.Font} font font of the text in the text run
     * @param {number} font_sz size of the text in the text run
     * @note a text run can be created only within a text block
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createTextRunUnsigned(text_data: string, font: PDFNet.Font, font_sz: number): Promise<PDFNet.Element>;
    /**
     * Create a new text run.
     * @method PDFNet.ElementBuilder#createNewTextRun
     * @param {string} text_data text to initialize the text run with.
     * @note a text run can be created only within a text block
     * @note you must set the current Font and font size before calling this function.
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createNewTextRun(text_data: string): Promise<PDFNet.Element>;
    /**
     * Create a new text run.
     * @method PDFNet.ElementBuilder#createNewTextRunWithSize
     * @param {string} text_data text to initialize the text run with.
     * @param {number} text_data_sz size pf the text run.
     * @note a text run can be created only within a text block
     * @note you must set the current Font and font size before calling this function.
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createNewTextRunWithSize(text_data: string, text_data_sz: number): Promise<PDFNet.Element>;
    /**
     * Create a new text run.
     * @method PDFNet.ElementBuilder#createNewTextRunUnsigned
     * @param {string} text_data text to initialize the text run with. Uses unsigned characters.
     * @note a text run can be created only within a text block
     * @note you must set the current Font and font size before calling this function.
     * @return {Promise<PDFNet.Element>} A promise that resolves to an object of type: "Element"
     */
    createNewTextRunUnsigned(text_data: string): Promise<PDFNet.Element>;
    /**
     * Create e_text_new_line Element (i.e. a Td operator in PDF content stream).
     * Move to the start of the next line, offset from the start of the current
     * line by (dx , dy). dx and dy are numbers expressed in unscaled text space
     * units.
     * @method PDFNet.ElementBuilder#createTextNewLineWithOffset
     * @param {number} dx The horizontal x offset from the start of the current line
     * @param {number} dy The vertical y offset from the start of the current line
     * @return {Promise<PDFNet.Element>} A promise that resolves to the path Element
     */
    createTextNewLineWithOffset(dx: number, dy: number): Promise<PDFNet.Element>;
    /**
     * Create e_text_new_line Element (i.e. a T* operator in PDF content stream).
     * @method PDFNet.ElementBuilder#createTextNewLine
     * @return {Promise<PDFNet.Element>} A promise that resolves to the path Element
     */
    createTextNewLine(): Promise<PDFNet.Element>;
    /**
     * Create a path Element using the given path segment data
     * @method PDFNet.ElementBuilder#createPath
     * @param {Array} buf_points A buffer/array containing data on the points in the path.
     * What each point represents is determined by the corresponding segment type.
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf_seg_types A buffer/array containing data on the segment types.
     * Possible segment types are as follows:
     * <pre>
     * PDFNet.Element.PathSegmentType = {
     *	e_moveto : 1,
     *	e_lineto : 2,
     *	e_cubicto : 3,
     *	e_conicto : 4,
     *	e_rect : 5,
     *	e_closepath : 6
     * }
     * </pre>
     * @return {Promise<PDFNet.Element>} A promise that resolves to the path Element
     */
    createPath(
      buf_points: any[],
      buf_seg_types: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray,
    ): Promise<PDFNet.Element>;
    /**
     * Create a rectangle path Element.
     *
     * @method PDFNet.ElementBuilder#createRect
     * @param {number} x The horizontal coordinate of the lower left corner of the rectangle.
     * @param {number} y The vertical coordinate of the lower left corner of the rectangle.
     * @param {number} width The width of the rectangle.
     * @param {number} height The height of the rectangle.
     * @return {Promise<PDFNet.Element>} A promise that resolves to the path Element
     */
    createRect(x: number, y: number, width: number, height: number): Promise<PDFNet.Element>;
    /**
     * Create an ellipse (or circle, if width == height) path Element.
     *
     * @method PDFNet.ElementBuilder#createEllipse
     * @param {number} x The horizontal x coordinate of the ellipse center.
     * @param {number} y The vertical y coordinate of the ellipse center.
     * @param {number} width The width of the ellipse rectangle.
     * @param {number} height The height of the ellipse rectangle.
     * @return {Promise<PDFNet.Element>} A promise that resolves to the path Element
     */
    createEllipse(x: number, y: number, width: number, height: number): Promise<PDFNet.Element>;
    /**
     * Starts building a new path Element that can contain an arbitrary sequence
     * of lines, curves, and rectangles.
     * @method PDFNet.ElementBuilder#pathBegin
     */
    pathBegin(): void;
    /**
     * Finishes building of the path Element.
     * @method PDFNet.ElementBuilder#pathEnd
     * @return {Promise<PDFNet.Element>} A promise that resolves to the path Element
     */
    pathEnd(): Promise<PDFNet.Element>;
    /**
     * Add a rectangle to the current path as a complete subpath.
     * Setting the current point is not required before using this function.
     *
     * @method PDFNet.ElementBuilder#rect
     * @param {number} x The x coordinate of the lower left corner of the rectangle.
     * @param {number} y The y coordinate of the lower left corner of the rectangle.
     * @param {number} width The width of the rectangle.
     * @param {number} height The height of the rectangle.
     */
    rect(x: number, y: number, width: number, height: number): void;
    /**
     * Add an ellipse (or circle, if rx == ry) to the current path as a complete subpath.
     * Setting the current point is not required before using this function.
     *
     * @method PDFNet.ElementBuilder#ellipse
     * @param {number} x The x coordinate of the ellipse center.
     * @param {number} y The y coordinate of the ellipse center.
     * @param {number} width The x radii of the ellipse.
     * @param {number} height The y radii of the ellipse.
     */
    ellipse(x: number, y: number, width: number, height: number): void;
    /**
     * Set the current point.
     * @method PDFNet.ElementBuilder#moveTo
     * @param {number} x The horizontal x component of the point
     * @param {number} y The vertical y component of the point
     */
    moveTo(x: number, y: number): void;
    /**
     * Draw a line from the current point to the given point.
     * @method PDFNet.ElementBuilder#lineTo
     * @param {number} x The horizontal x component of the goal point
     * @param {number} y The vertical y component of the goal point
     */
    lineTo(x: number, y: number): void;
    /**
     * Draw a Bezier curve from the current point to the given point (x2, y2) using
     * (cx1, cy1) and (cx2, cy2) as control points.
     * @method PDFNet.ElementBuilder#curveTo
     * @param {number} cx1 The x component of the first control point
     * @param {number} cy1 The y component of the first control point
     * @param {number} cx2 The x component of the second control point
     * @param {number} cy2 The y component of the second control point
     * @param {number} x2 The horizontal x component of the goal point
     * @param {number} y2 The vertical y component of the goal point
     */
    curveTo(cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number): void;
    /**
     * Draw an arc with the specified parameters (lower left corner, width, height and angles).
     *
     * @method PDFNet.ElementBuilder#arcTo
     * @param {number} x The horizontal x coordinate of the lower left corner of the ellipse encompassing rectangle
     * @param {number} y The horizontal y coordinate of the lower left corner of the ellipse encompassing rectangle
     * @param {number} width overall width of the full ellipse (not considering the angular extents).
     * @param {number} height overall height of the full ellipse (not considering the angular extents).
     * @param {number} start starting angle of the arc in degrees
     * @param {number} extent angular extent of the arc in degrees
     */
    arcTo(x: number, y: number, width: number, height: number, start: number, extent: number): void;
    /**
     * Draw an arc from the current point to the end point.
     *
     * @method PDFNet.ElementBuilder#arcTo2
     * @param {number} xr x radius for the arc
     * @param {number} yr y radius for the arc
     * @param {number} rx x-axis rotation in degrees
     * @param {boolean} isLargeArc indicates if smaller or larger arc is chosen
     *		1 one of the two larger arc sweeps is chosen
     *		0 one of the two smaller arc sweeps is chosen
     * @param {boolean} sweep direction in which arc is drawn (1 clockwise, 0 counterclockwise)
     * @param {number} endX x coordinate of end point
     * @param {number} endY y coordinate of end point
     *
     * @note The Arc is defined the same way as it is specified by SVG or XPS standards. For
     *		further questions please refer to the XPS or SVG standards.
     */
    arcTo2(xr: number, yr: number, rx: number, isLargeArc: boolean, sweep: boolean, endX: number, endY: number): void;
    /**
     * Closes the current subpath.
     * @method PDFNet.ElementBuilder#closePath
     */
    closePath(): void;
  }
  /**
   * ElementReader can be used to parse and process content streams. ElementReader provides a
   * convenient interface used to traverse the Element display list of a page. The display list
   * representing graphical elements (such as text-runs, paths, images, shadings, forms, etc) is
   * accessed using the intrinsic iterator. ElementReader automatically concatenates page contents
   * spanning multiple streams and provides a mechanism to parse contents of sub-display lists
   * (e.g. forms XObjects and Type3 fonts).
   *
   * For a full sample, please refer to ElementReader and ElementReaderAdvTest sample projects.
   * @class
   * @name ElementReader
   * @memberof PDFNet
   */
  class ElementReader {
    /**
     * Constructor for an ElementReader object that can be used to parse and process
     * content streams.
     *
     * @method PDFNet.ElementReader.create
     * @return {Promise<PDFNet.ElementReader>} A promise that resolves to Returns an ElementReader object
     */
    static create(): Promise<PDFNet.ElementReader>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.ElementReader#destroy
     */
    destroy(): void;
    /**
     * begin processing a page.
     *
     * @method PDFNet.ElementReader#beginOnPage
     * @param {PDFNet.Page} page A page to start processing.
     *
     * @param {PDFNet.OCGContext} [ctx] An optional parameter used to specify the Optional Content (OC)
     * Context that should be used when processing the page. When the OCG::Context is specified,
     * Element::IsOCVisible() will return 'true' or 'false' depending on the visibility of the
     * current Optional Content Group (OCG) and the states of flags in the given context.
     *
     * @note When page processing is completed, make sure to call ElementReader.End().
     */
    beginOnPage(page: PDFNet.Page, ctx?: PDFNet.OCGContext): void;
    /**
     * begin processing given content stream. The content stream may be
     * a Form XObject, Type3 glyph stream, pattern stream or any other content stream.
     *
     * @method PDFNet.ElementReader#begin
     * @param {PDFNet.Obj} content_stream A stream object representing the content stream (usually
     * a Form XObject).
     *
     * @param {PDFNet.Obj} [resource_dict] An optional '/Resource' dictionary parameter.
     * If content stream refers to named resources that are not present in
     * the local Resource dictionary, the names are looked up in the supplied
     * resource dictionary.
     *
     * @param {PDFNet.OCGContext} [ctx] An optional parameter used to specify the Optional Content (OC)
     * Context that should be used when processing the page. When the OCG::Context is specified,
     * Element::IsOCVisible() will return 'true' or 'false' depending on the visibility of the
     * current Optional Content Group (OCG) and the states of flags in the given context.
     *
     * @note When page processing is completed, make sure to call ElementReader.End().
     */
    begin(content_stream: PDFNet.Obj, resource_dict?: PDFNet.Obj, ctx?: PDFNet.OCGContext): void;
    /**
     * @method PDFNet.ElementReader#appendResource
     * @param {PDFNet.Obj} res resource dictionary for finding images, fonts, etc.
     */
    appendResource(res: PDFNet.Obj): void;
    /**
     * @method PDFNet.ElementReader#next
     * @return {Promise<PDFNet.Element>} A promise that resolves to a page Element or a 'NULL' element if the end of current-display list was
     * reached. You may use GetType() to determine the type of the returned Element.
     *
     * @note Every call to ElementReader::Next() destroys the current Element.
     * Therefore, an Element becomes invalid after subsequent
     * ElementReader::Next() operation.
     */
    next(): Promise<PDFNet.Element>;
    /**
     * @method PDFNet.ElementReader#current
     * @return {Promise<PDFNet.Element>} A promise that resolves to the current Element or a 'NULL' Element. The current element is the one
     * returned in the last call to Next().
     *
     * @note Every call to ElementReader::Next() destroys the current Element. Therefore, an
     * Element becomes invalid after subsequent ElementReader::Next() operation.
     */
    current(): Promise<PDFNet.Element>;
    /**
     * when the current element is a form XObject you have the option to skip form
     * processing (by not calling FormBegin()) or to open the form stream and
     * continue Element traversal into the form.
     *
     * To open a form XObject display list use FormBegin() method. The Next() returned
     * Element will be the first Element in the form XObject display list. Subsequent calls to Next()
     * will traverse form's display list until NULL is returned. At any point you can
     * close the form sub-list using ElementReader::End() method. After the form display
     * list is closed (using End()) the processing will return to the parent display list
     * at the point where it left off before entering the form XObject.
     * @method PDFNet.ElementReader#formBegin
     */
    formBegin(): void;
    /**
     * a method used to spawn the sub-display list representing the tiling pattern
     * of the current element in the ElementReader. You can call this method at any
     * point as long as the current element is valid.
     *
     * @method PDFNet.ElementReader#patternBegin
     * @param {boolean} fill_pattern If true, the filling pattern of the current element will
     * be spawned; otherwise, the stroking pattern of the current element will be
     * spawned. Note that the graphics state will be inherited from the parent content
     * stream (the content stream in which the pattern is defined as a resource) automatically.
     *
     * @param {boolean} [reset_ctm_tfm] An optional parameter used to indicate whether the pattern's
     * display list should set its initial CTM and transformation matrices to identity matrix.
     * In general, we should leave it to be false.
     *
     * To open a tiling pattern sub-display list use PatternBegin(pattern) method.
     * The Next() returned Element will be the first Element in the pattern display list.
     * Subsequent calls to Next() will traverse pattern's display list until NULL is
     * encountered. At any point you can close the pattern sub-list using
     * ElementReader::End() method. After the pattern display list is closed,
     * the processing will return to the parent display list at the point where
     * pattern display list was spawned.
     */
    patternBegin(fill_pattern: boolean, reset_ctm_tfm?: boolean): void;
    /**
     * Close the current display list.
     *
     * If the current display list is a sub-list created using FormBegin(), PatternBegin(),
     * or Type3FontBegin() methods, the function will end the sub-list and will return
     * processing to the parent display list at the point where it left off before
     * entering the sub-list.
     *
     * @method PDFNet.ElementReader#end
     * @return {Promise<boolean>} A promise that resolves to true if the closed display list is a sub-list or false if it is a root
     * display list.
     */
    end(): Promise<boolean>;
    /**
     * @method PDFNet.ElementReader#getChangesIterator
     * @return {Promise<PDFNet.Iterator>} A promise that resolves to an iterator to the beginning of the list containing identifiers of modified
     * graphics state attributes since the last call to ClearChangeList(). The list can
     * be consulted to determine which graphics states were modified between two
     * Elements. Attributes are ordered in the same way as they are set in the content
     * stream. Duplicate attributes are eliminated.
     */
    getChangesIterator(): Promise<PDFNet.Iterator>;
    /**
     * @method PDFNet.ElementReader#isChanged
     * @return {Promise<boolean>} A promise that resolves to true if given GState attribute was changed since the last call to
     * @param {number} attrib
     * <pre>
     * PDFNet.GState.Attribute = {
     * 	e_transform : 0
     * 	e_rendering_intent : 1
     * 	e_stroke_cs : 2
     * 	e_stroke_color : 3
     * 	e_fill_cs : 4
     * 	e_fill_color : 5
     * 	e_line_width : 6
     * 	e_line_cap : 7
     * 	e_line_join : 8
     * 	e_flatness : 9
     * 	e_miter_limit : 10
     * 	e_dash_pattern : 11
     * 	e_char_spacing : 12
     * 	e_word_spacing : 13
     * 	e_horizontal_scale : 14
     * 	e_leading : 15
     * 	e_font : 16
     * 	e_font_size : 17
     * 	e_text_render_mode : 18
     * 	e_text_rise : 19
     * 	e_text_knockout : 20
     * 	e_text_pos_offset : 21
     * 	e_blend_mode : 22
     * 	e_opacity_fill : 23
     * 	e_opacity_stroke : 24
     * 	e_alpha_is_shape : 25
     * 	e_soft_mask : 26
     * 	e_smoothnes : 27
     * 	e_auto_stoke_adjust : 28
     * 	e_stroke_overprint : 29
     * 	e_fill_overprint : 30
     * 	e_overprint_mode : 31
     * 	e_transfer_funct : 32
     * 	e_BG_funct : 33
     * 	e_UCR_funct : 34
     * 	e_halftone : 35
     * 	e_null : 36
     * }
     * </pre>
     * the GState attribute to test if it has been changed
     * ClearChangeList().
     */
    isChanged(attrib: number): Promise<boolean>;
    /**
     * Clear the list containing identifiers of modified graphics state attributes.
     * The list of modified attributes is then accumulated during a subsequent call(s)
     * to ElementReader.Next().
     * @method PDFNet.ElementReader#clearChangeList
     */
    clearChangeList(): void;
    /**
     * @method PDFNet.ElementReader#getFont
     * @param {string} name string of the name of the SDF/Cos object to get
     * @return {Promise<PDFNet.Obj>} A promise that resolves to sDF/Cos object matching the specified name in the current resource
     * dictionary. For 'Page' the name is looked up in the page's /Resources/<Class>
     * dictionary. For Form XObjects, Patterns, and Type3 fonts that have a content
     * stream within page content stream the specified resource is first looked-up in the
     * resource dictionary of the inner stream. If the resource is not found, the name is
     * looked up in the outer content stream's resource dictionary. The function returns
     * NULL if the resource was not found.
     */
    getFont(name: string): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.ElementReader#getXObject
     * @param {string} name string of the name of the SDF/Cos object to get
     * @note see ElementReader::GetFont
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    getXObject(name: string): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.ElementReader#getShading
     * @param {string} name string of the name of the SDF/Cos object to get
     * @note see ElementReader::GetFont
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    getShading(name: string): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.ElementReader#getColorSpace
     * @param {string} name string of the name of the SDF/Cos object to get
     * @note see ElementReader::GetFont
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    getColorSpace(name: string): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.ElementReader#getPattern
     * @param {string} name string of the name of the SDF/Cos object to get
     * @note see ElementReader::GetFont
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    getPattern(name: string): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.ElementReader#getExtGState
     * @param {string} name string of the name of the SDF/Cos object to get
     * @note see ElementReader::GetFont
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    getExtGState(name: string): Promise<PDFNet.Obj>;
  }
  /**
   * ElementWriter can be used to assemble and write new content to a page, Form XObject,
   * Type3 Glyph stream, pattern stream, or any other content stream.
   * @class
   * @name ElementWriter
   * @memberof PDFNet
   */
  class ElementWriter {
    /**
     * Constructor for an ElementWriter object that can be used to assemble and write
     * new content to a page, Form XObject, pattern stream or any other content stream.
     *
     * @method PDFNet.ElementWriter.create
     * @return {Promise<PDFNet.ElementWriter>} A promise that resolves to Returns an ElementWriter object
     */
    static create(): Promise<PDFNet.ElementWriter>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.ElementWriter#destroy
     */
    destroy(): void;
    /**
     * begin writing to the given page.
     *
     * By default, new content will be appended to the page, as foreground graphics.
     * It is possible to add new page content as background graphics by setting the
     * second parameter in begin method to 'true' (e.g. writer.Begin(page, true)).
     *
     * @method PDFNet.ElementWriter#beginOnPage
     * @param {PDFNet.Page} page The page to write content.
     *
     * @param {number} [placement]
     * <pre>
     * PDFNet.ElementWriter.WriteMode = {
     * 	e_underlay : 0
     * 	e_overlay : 1
     * 	e_replacement : 2
     * }
     * </pre>
     * An optional flag indicating whether the new content should
     * be added as a foreground or background layer to the existing page. By default, the new
     * content will appear on top of the existing graphics.
     *
     * @param {boolean} [page_coord_sys] An optional flag used to select the target coordinate system
     * if true (default), the coordinates are relative to the lower-left corner of the page,
     * otherwise the coordinates are defined in PDF user coordinate system (which may,
     * or may not coincide with the page coordinates).
     *
     * @param {boolean} [compress] An optional flag indicating whether the page content stream
     * should be compressed. This may be useful for debugging content streams. Also
     * some applications need to do a clear text search on strings in the PDF files.
     * By default, all content streams are compressed.
     *
     * @param {PDFNet.Obj} [resources] the resource dictionary in which to store resources for the final page.
     * By default, a new resource dictionary will be created.
     */
    beginOnPage(
      page: PDFNet.Page,
      placement?: number,
      page_coord_sys?: boolean,
      compress?: boolean,
      resources?: PDFNet.Obj,
    ): void;
    /**
     * begin writing an Element sequence to a new stream. Use this function to write
     * Elements to a content stream other than the page. For example, you can create
     * Form XObjects (See Section '4.9 Form XObjects' in PDF Reference for more details)
     * pattern streams, Type3 font glyph streams, etc.
     *
     * @method PDFNet.ElementWriter#begin
     * @param {PDFNet.SDFDoc} doc A low-level SDF/Cos document that will contain the new stream. You can
     * access low-level document using PDFDoc::GetSDFDoc() or Obj::GetDoc() methods.
     *
     * @param {boolean} [compress] An optional flag indicating whether the page content stream
     * should be compressed. This may be useful for debugging content streams. Also
     * some applications need to do a clear text search on strings in the PDF files.
     * By default, all content streams are compressed.
     *
     * @note the newly created content stream object is returned when writing operations
     * are completed (i.e. after the call to ElementWriter::End()).
     */
    begin(doc: PDFNet.SDFDoc, compress?: boolean): void;
    /**
     * begin writing an Element sequence to a stream. Use this function to write
     * Elements to a content stream which will replace an existing content stream in an
     * object passed as a parameter.
     *
     * @method PDFNet.ElementWriter#beginOnObj
     * @param {PDFNet.Obj} stream_obj_to_update A low-level SDF stream object that will contain the new stream.
     * Old stream inside that object will be discarded.
     *
     * @param {boolean} [compress] An optional flag indicating whether the content stream
     * should be compressed. This may be useful for debugging content streams. Also
     * some applications need to do a clear text search on strings in the PDF files.
     * By default, all content streams are compressed.
     *
     * @param {PDFNet.Obj} [resources] the resource dictionary in which to store resources for the final page.
     * By default, a new resource dictionary will be created.
     *
     * @note The content stream object is returned when writing operations
     * are completed (i.e. after the call to ElementWriter::End()).
     */
    beginOnObj(stream_obj_to_update: PDFNet.Obj, compress?: boolean, resources?: PDFNet.Obj): void;
    /**
     * Finish writing to a page
     *
     * @method PDFNet.ElementWriter#end
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a low-level stream object that was used to store Elements.
     */
    end(): Promise<PDFNet.Obj>;
    /**
     * Writes the Element to the content stream.
     * @method PDFNet.ElementWriter#writeElement
     * @param {PDFNet.Element} element The element to write to the content stream.
     */
    writeElement(element: PDFNet.Element): void;
    /**
     * A utility function that surrounds the given Element with a graphics state
     * Save/Restore Element (i.e. in PDF content stream represented as 'q element Q').
     *
     * The function is equivalent to calling WriteElement three times:
     *	 WriteElement(eSave);
     *	 WriteElement(element);
     *	 WriteElement(eRestore);
     *
     * where eSave is 'e_group_begin' and eRestore is 'e_group_end' Element
     *
     * The function is useful when XObjects such as Images and Forms are drawn on
     * the page.
     * @method PDFNet.ElementWriter#writePlacedElement
     * @param {PDFNet.Element} element Element object to enact function on.
     */
    writePlacedElement(element: PDFNet.Element): void;
    /**
     * the Flush method flushes all pending Element writing operations.
     * This method is typically only required to be called when intermixing
     * direct content writing (i.e. WriteBuffer/WriteString) with Element writing.
     * @method PDFNet.ElementWriter#flush
     */
    flush(): void;
    /**
     *
     * @method PDFNet.ElementWriter#writeBuffer
     * @param {string} data
     * @param {number} data_sz
     */
    writeBuffer(data: string, data_sz: number): void;
    /**
     * Writes an arbitrary string to the content stream.
     * Serves the same purpose as WriteBuffer().
     * @method PDFNet.ElementWriter#writeString
     * @param {string} str String to write to the content stream.
     */
    writeString(str: string): void;
    /**
     *
     * @method PDFNet.ElementWriter#setDefaultGState
     * @param {PDFNet.ElementReader} r
     */
    setDefaultGState(r: PDFNet.ElementReader): void;
    /**
     * Write only the graphics state changes applied to this element and skip writing the element itself.
     * This is especially useful when rewriting page content, but with the intention to skip certain elements.
     * @method PDFNet.ElementWriter#writeGStateChanges
     * @param {PDFNet.Element} element The element for which to write graphics state changes.
     */
    writeGStateChanges(element: PDFNet.Element): void;
  }
  /**
   * FDFDoc is a class representing Forms Data Format (FDF) documents.
   * FDF is typically used when submitting form data to a server, receiving
   * the response, and incorporating it into the interactive form. It can also
   * be used to export form data to stand-alone files that can be stored, transmitted
   * electronically, and imported back into the corresponding PDF interactive form.
   * In addition, beginning in PDF 1.3, FDF can be used to define a container for
   * annotations that are separate from the PDF document to which they apply.
   * @class
   * @name FDFDoc
   * @memberof PDFNet
   */
  class FDFDoc {
    /**
     * Default constructor that creates an empty new document.
     * @method PDFNet.FDFDoc.create
     * @return {Promise<PDFNet.FDFDoc>} A promise that resolves to an object of type: "FDFDoc"
     */
    static create(): Promise<PDFNet.FDFDoc>;
    /**
     *
     * @method PDFNet.FDFDoc.createFromStream
     * @param {PDFNet.Filter} stream
     * @return {Promise<PDFNet.FDFDoc>} A promise that resolves to an object of type: "FDFDoc"
     */
    static createFromStream(stream: PDFNet.Filter): Promise<PDFNet.FDFDoc>;
    /**
     * Open a SDF/Cos document from a memory buffer.
     * @method PDFNet.FDFDoc.createFromMemoryBuffer
     * @note the document should be fully loaded in the memory buffer.
     * @note the buffer ownership is not transfered to the Document so the user should
     * clean-up if necessary.
     *
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf a memory buffer containing the serialized document
     * @return {Promise<PDFNet.FDFDoc>} A promise that resolves to an object of type: "FDFDoc"
     */
    static createFromMemoryBuffer(
      buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray,
    ): Promise<PDFNet.FDFDoc>;
    /**
     * Destructor
     * @method PDFNet.FDFDoc#destroy
     */
    destroy(): void;
    /**
     * @method PDFNet.FDFDoc#isModified
     * @return {Promise<boolean>} A promise that resolves to true if document was modified, false otherwise
     */
    isModified(): Promise<boolean>;
    /**
     * Saves the document to a memory buffer.
     *
     * @method PDFNet.FDFDoc#saveMemoryBuffer
     */
    saveMemoryBuffer(): void;
    /**
     * @method PDFNet.FDFDoc#getTrailer
     * @return {Promise<PDFNet.Obj>} A promise that resolves to A dictionary representing the Cos root of the document (document's trailer)
     */
    getTrailer(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.FDFDoc#getRoot
     * @return {Promise<PDFNet.Obj>} A promise that resolves to A dictionary representing the Cos root of the document (/Root entry
     * within the trailer dictionary)
     */
    getRoot(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.FDFDoc#getFDF
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the FDF dictionary located in "/Root" or NULL if dictionary is not present.
     */
    getFDF(): Promise<PDFNet.Obj>;
    /**
     * Get the PDF document file that this FDF file was exported from or is intended
     * to be imported into.
     *
     * @method PDFNet.FDFDoc#getPDFFileName
     * @return {Promise<string>} A promise that resolves to a String with the PDF document file name.
     */
    getPDFFileName(): Promise<string>;
    /**
     * Set the PDF document file that this FDF file was exported from or is intended
     * to be imported into.
     *
     * @method PDFNet.FDFDoc#setPDFFileName
     * @param {string} filepath pathname to the file.
     */
    setPDFFileName(filepath: string): void;
    /**
     * Get the ID entry from "/Root/FDF" dictionary.
     *
     * @method PDFNet.FDFDoc#getID
     * @return {Promise<PDFNet.Obj>} A promise that resolves to An object representing the ID entry in "/Root/FDF" dictionary.
     */
    getID(): Promise<PDFNet.Obj>;
    /**
     * Set the ID entry in "/Root/FDF" dictionary.
     *
     * @method PDFNet.FDFDoc#setID
     * @param {PDFNet.Obj} id ID array object.
     */
    setID(id: PDFNet.Obj): void;
    /**
     * An interactive form (sometimes referred to as an AcroForm) is a
     * collection of fields for gathering information interactively from
     * the user. A FDF document may contain any number of fields appearing
     * on any combination of pages, all of which make up a single, global
     * interactive form spanning the entire document.
     *
     * The following methods are used to access and manipulate Interactive form
     * fields (sometimes referred to as AcroForms).
     *
     * @method PDFNet.FDFDoc#getFieldIteratorBegin
     * @return {Promise<PDFNet.Iterator>} A promise that resolves to an iterator to the first Filed in the document.
     * @note if the document has no AcroForms, HasNext()
     * will return false.
     */
    getFieldIteratorBegin(): Promise<PDFNet.Iterator>;
    /**
     *
     * @method PDFNet.FDFDoc#getFieldIterator
     * @param {string} field_name
     * @return {Promise<PDFNet.Iterator>} A promise that resolves to an object of type: "Iterator"
     */
    getFieldIterator(field_name: string): Promise<PDFNet.Iterator>;
    /**
     * @method PDFNet.FDFDoc#getField
     * @param {string} field_name a string representing the fully qualified name of
     * the field (e.g. "employee.name.first").
     *
     * @return {Promise<PDFNet.FDFField>} A promise that resolves to a FDFField associated with the given field_name or invalid
     * field (null) if the field is not found.
     */
    getField(field_name: string): Promise<PDFNet.FDFField>;
    /**
     *
     * @method PDFNet.FDFDoc#fieldCreate
     * @param {string} field_name
     * @param {number} type
     * <pre>
     * PDFNet.Field.Type = {
     * 	e_button : 0
     * 	e_check : 1
     * 	e_radio : 2
     * 	e_text : 3
     * 	e_choice : 4
     * 	e_signature : 5
     * 	e_null : 6
     * }
     * </pre>
     * @param {PDFNet.Obj} [field_value]
     * @return {Promise<PDFNet.FDFField>} A promise that resolves to an object of type: "FDFField"
     */
    fieldCreate(field_name: string, type: number, field_value?: PDFNet.Obj): Promise<PDFNet.FDFField>;
    /**
     *
     * @method PDFNet.FDFDoc#fieldCreateFromString
     * @param {string} field_name
     * @param {number} type
     * <pre>
     * PDFNet.Field.Type = {
     * 	e_button : 0
     * 	e_check : 1
     * 	e_radio : 2
     * 	e_text : 3
     * 	e_choice : 4
     * 	e_signature : 5
     * 	e_null : 6
     * }
     * </pre>
     * @param {string} field_value
     * @return {Promise<PDFNet.FDFField>} A promise that resolves to an object of type: "FDFField"
     */
    fieldCreateFromString(field_name: string, type: number, field_value: string): Promise<PDFNet.FDFField>;
    /**
     * @method PDFNet.FDFDoc#getSDFDoc
     * @return {Promise<PDFNet.SDFDoc>} A promise that resolves to document's SDF/Cos document
     */
    getSDFDoc(): Promise<PDFNet.SDFDoc>;
    /**
     * Create a new FDFDoc from XFDF input. Input can be either a XFDF file path, or the XFDF data itself.
     * @method PDFNet.FDFDoc.createFromXFDF
     * @param {string} file_name string containing either the file path to a XFDF file, or the XML buffer containing the XFDF.
     * @return {Promise<PDFNet.FDFDoc>} A promise that resolves to a new FDFDoc.
     */
    static createFromXFDF(file_name: string): Promise<PDFNet.FDFDoc>;
    /**
     * Export FDF file as a XFDF string
     * @method PDFNet.FDFDoc#saveAsXFDFAsString
     * @return {Promise<string>} A promise that resolves to a UString containing the XFDF representation of the FDF file
     */
    saveAsXFDFAsString(): Promise<string>;
    /**
     * Merge the annotations from XFDF file into FDF file
     *
     * @method PDFNet.FDFDoc#mergeAnnots
     * @param {string} command_file string containing the xml command file path or xml string of the command
     * @param {string} [permitted_user] optional user name of the permitted user
     */
    mergeAnnots(command_file: string, permitted_user?: string): void;
    /**
     *
     * @method PDFNet.FDFDoc#getFieldIterator
     * @param {string} field_name
     * @return {Promise<PDFNet.Iterator>} A promise that resolves to an object of type: "Iterator"
     */
    getFieldIterator(field_name: string): Promise<PDFNet.Iterator>;
  }
  /**
   * FDFField is an interactive form field in an FDF document
   * @class
   * @name FDFField
   * @memberof PDFNet
   */
  class FDFField {
    /**
     *
     * @method PDFNet.FDFField.create
     * @param {PDFNet.Obj} [field_dict]
     * @param {PDFNet.Obj} [fdf_dict]
     * @return {Promise<PDFNet.FDFField>} A promise that resolves to an object of type: "FDFField"
     */
    static create(field_dict?: PDFNet.Obj, fdf_dict?: PDFNet.Obj): Promise<PDFNet.FDFField>;
    /**
     * @method PDFNet.FDFField#getValue
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the value of the Field (the value of its /V key) or NULL if the
     * value is not specified.
     * The format of field's value varies depending on the field type.
     */
    getValue(): Promise<PDFNet.Obj>;
    /**
     * Sets the value of the FDFField (the value of the field's /V key).
     * @method PDFNet.FDFField#setValue
     * @param {PDFNet.Obj} value the value to set the FDFField to
     * @return the value of the field (the value of its /V key) or NULL if the
     * value is not specified.
     * The format of field's value varies depending on the field type.
     *
     * @note in order to remove/erase the existing value use SetValue(SDF::Null)
     */
    setValue(value: PDFNet.Obj): any;
    /**
     * @method PDFNet.FDFField#getName
     * @return {Promise<string>} A promise that resolves to a string representing the fully qualified name of the field
     * (e.g. "employee.name.first").
     */
    getName(): Promise<string>;
    /**
     * @method PDFNet.FDFField#getPartialName
     * @return {Promise<string>} A promise that resolves to a string representing the partial name of the field (e.g.
     * "first" when "employee.name.first" is fully qualified name).
     */
    getPartialName(): Promise<string>;
    /**
     * @method PDFNet.FDFField#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the object to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * The function returns the specified attribute.
     * @method PDFNet.FDFField#findAttribute
     * @param {string} attrib name of the attribute to find
     * @return {Promise<PDFNet.Obj>} A promise that resolves to return the attribute value if the given attribute name
     * was found or a NULL object if the given attribute name was not found.
     */
    findAttribute(attrib: string): Promise<PDFNet.Obj>;
  }
  /**
   * An interactive form (sometimes referred to as an AcroForm) is a
   * collection of fields for gathering information interactively from
   * the user. A PDF document may contain any number of Fields appearing
   * on any combination of pages, all of which make up a single, global
   * interactive form spanning the entire document.
   *
   * PDFNet fully supports reading, writing, and editing PDF forms and
   * provides many utility methods so that work with forms is simple and
   * efficient. Using PDFNet forms API arbitrary subsets of form fields
   * can be imported or exported from the document, new forms can be
   * created from scratch, and the appearance of existing forms can be
   * modified.
   *
   * In PDFNet Fields are accessed through FieldIterator-s. The list of
   * all Fields present in the document can be traversed as follows:
   *
   * <pre>
   * FieldIterator itr = pdfdoc.GetFieldIterator();
   * for(; itr.HasNext(); itr.Next()) {
   *   Field field = itr.Current();
   *   Console.WriteLine("Field name: {0}", field.GetName());
   *  }
   * </pre>
   *
   * For a full sample, please refer to 'InteractiveForms' sample project.
   *
   * To search field by name use FieldFind method. For example:
   * <pre>
   * FieldIterator itr = pdfdoc.FieldFind("name");
   * if (itr.HasNext()) {
   *   Console.WriteLine("Field name: {0}", itr.Current().GetName());
   * }
   * else { ...field was not found... }
   * </pre>
   *
   * If a given field name was not found or if the end of the field list
   * was reached the iterator HasNext() will return false.
   *
   * If you have a valid iterator you can access the Field using Current() method. For example:
   * Field field = itr.Current();
   *
   * Using Flatten(...) method it is possible to merge field
   * appearances with the page content. Form 'flattening' refers to the
   * operation that changes active form fields into a static area that is
   * part of the PDF document, just like the other text and images in
   * the document. A completely flattened PDF form does not have any
   * widget annotations or interactive fields.
   * @class
   * @name Field
   * @memberof PDFNet
   */
  class Field {
    /**
     * construct a PDF::Field from a SDF dictionary representing a terminal field node.
     * @method PDFNet.Field.create
     * @param {PDFNet.Obj} field_dict the SDF dictionary to construct the field from.
     * @return {Promise<PDFNet.Field>} A promise that resolves to an object of type: "Field"
     */
    static create(field_dict: PDFNet.Obj): Promise<PDFNet.Field>;
    /**
     * @method PDFNet.Field#isValid
     * @return {Promise<boolean>} A promise that resolves to whether this is a valid (non-null) Field. If the
     * function returns false the underlying SDF/Cos object is null and
     * the Field object should be treated as null as well.
     */
    isValid(): Promise<boolean>;
    /**
     * @method PDFNet.Field#getType
     * @return {Promise<number>} A promise that resolves to the field's value, whose type/format varies depending on the field type.
     * See the descriptions of individual field types for further information.
     * @example Return value enum:
     * <pre>
     * PDFNet.Field.Type = {
     * 	e_button : 0
     * 	e_check : 1
     * 	e_radio : 2
     * 	e_text : 3
     * 	e_choice : 4
     * 	e_signature : 5
     * 	e_null : 6
     * }
     * </pre>
     */
    getType(): Promise<number>;
    /**
     * @method PDFNet.Field#getValue
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the value of the Field (the value of its /V key) or NULL if the
     * value is not specified.
     *
     * The format of field's value varies depending on the field type.
     */
    getValue(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Field#getValueAsString
     * @return {Promise<string>} A promise that resolves to a string of the value of the Field (the value of its /V key) or
     * NULL if the value is not specified.
     *
     * The format of field's value varies depending on the field type.
     */
    getValueAsString(): Promise<string>;
    /**
     * @method PDFNet.Field#getDefaultValueAsString
     * @return {Promise<string>} A promise that resolves to a string of the default value to which the field reverts when a reset-form
     * action is executed or NULL if the default value is not specified.
     *
     * The format of field's value varies depending on the field type.
     */
    getDefaultValueAsString(): Promise<string>;
    /**
     * sets the value of the field (i.e. the value of the field's /V key).
     * The format of field's value varies depending on the field type.
     *
     * @method PDFNet.Field#setValueAsString
     * @param {string} value the new field value.
     *
     * @note in order to remove/erase the existing value use pass a SDF::Null
     * object to SetValue().
     *
     * @note <p>In PDF, Field's value is separate from its annotation (i.e. how the
     * field appears on the page). After you modify Field's value you need to
     * refresh Field's appearance using RefreshAppearance() method.
     * </p><p>
     * Alternatively, you can delete "AP" entry from the Widget annotation and set
     * "NeedAppearances" flag in AcroForm dictionary (i.e.
     * doc.GetAcroForm().Put("NeedAppearances", Obj.CreateBool(true)); )
     * This will force viewer application to auto-generate new field appearances
     * every time the document is opened.
     * </p><p>
     * Yet another option is to generate a custom annotation appearance using
     * ElementBuilder and ElementWriter and then set the "AP" entry in the widget
     * dictionary to the new appearance stream. This functionality is useful in
     * applications that need advanced control over how the form fields are rendered.
     * </p>
     * @return {Promise<PDFNet.ViewChangeCollection>} A promise that resolves to an object of type: "ViewChangeCollection"
     */
    setValueAsString(value: string): Promise<PDFNet.ViewChangeCollection>;
    /**
     * Sets the value of the field (i.e. the value of the field's /V key).
     * The format of field's value varies depending on the field type.
     *
     * @method PDFNet.Field#setValue
     * @param {PDFNet.Obj} value the new field value.
     *
     * @note in order to remove/erase the existing value use pass a SDF::Null
     * object to SetValue().
     *
     * @note <p>In PDF, Field's value is separate from its annotation (i.e. how the
     * field appears on the page). After you modify Field's value you need to
     * refresh Field's appearance using RefreshAppearance() method.
     * </p><p>
     * Alternatively, you can delete "AP" entry from the Widget annotation and set
     * "NeedAppearances" flag in AcroForm dictionary (i.e.
     * doc.GetAcroForm().Put("NeedAppearances", Obj.CreateBool(true)); )
     * This will force viewer application to auto-generate new field appearances
     * every time the document is opened.
     * </p><p>
     * Yet another option is to generate a custom annotation appearance using
     * ElementBuilder and ElementWriter and then set the "AP" entry in the widget
     * dictionary to the new appearance stream. This functionality is useful in
     * applications that need advanced control over how the form fields are rendered.
     * </p>
     * @return {Promise<PDFNet.ViewChangeCollection>} A promise that resolves to an object of type: "ViewChangeCollection"
     */
    setValue(value: PDFNet.Obj): Promise<PDFNet.ViewChangeCollection>;
    /**
     * sets the value of a check-box or radio-button field.
     * @method PDFNet.Field#setValueAsBool
     * @param {boolean} value If true, the filed will be set to 'True', if false the field will
     * be set to 'False'.
     *
     * @note This method is usually for check-box and radio button fields.
     * @return {Promise<PDFNet.ViewChangeCollection>} A promise that resolves to an object of type: "ViewChangeCollection"
     */
    setValueAsBool(value: boolean): Promise<PDFNet.ViewChangeCollection>;
    /**
     * Get the Action associated with the selected Field Trigger event.
     *
     * @method PDFNet.Field#getTriggerAction
     * @param {number} trigger
     * <pre>
     * PDFNet.Field.EventType = {
     * 	e_action_trigger_keystroke : 13
     * 	e_action_trigger_format : 14
     * 	e_action_trigger_validate : 15
     * 	e_action_trigger_calculate : 16
     * }
     * </pre>
     * the type of trigger event to get
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the Action Obj if present, otherwise NULL
     */
    getTriggerAction(trigger: number): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Field#getValueAsBool
     * @return {Promise<boolean>} A promise that resolves to field value as a boolean.
     * @note This method is usually for check-box and radio button fields.
     */
    getValueAsBool(): Promise<boolean>;
    /**
     * regenerates the appearance stream for the Widget Annotation containing
     * variable text. Call this method if you modified field's value and would
     * like to update field's appearance.
     *
     * @method PDFNet.Field#refreshAppearance
     * @note If this field contains text, and has been added to a rotated page, the text in
     * the field may be rotated. If RefreshAppearance is called *after* the field is added
     * to a rotated page, then any text will be rotated in the opposite direction of the page
     * rotation. If this method is called *before* the field is added to any rotated page, then
     * no counter rotation will be applied. If you wish to call RefreshAppearance on a field
     * already added to a rotated page, but you don't want the text to be rotated, you can do one
     * of the following; temporarily un-rotate the page, or, temporarily remove the "P" object
     * from the field.
     */
    refreshAppearance(): void;
    /**
     * removes any appearances associated with the field.
     * @method PDFNet.Field#eraseAppearance
     */
    eraseAppearance(): void;
    /**
     * @method PDFNet.Field#getDefaultValue
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the default value to which the field reverts when a reset-form action
     * is executed or NULL if the default value is not specified.
     *
     * The format of field's value varies depending on the field type.
     */
    getDefaultValue(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Field#getName
     * @return {Promise<string>} A promise that resolves to a string representing the fully qualified name of the field
     * (e.g. "employee.name.first").
     */
    getName(): Promise<string>;
    /**
     * @method PDFNet.Field#getPartialName
     * @return {Promise<string>} A promise that resolves to a string representing the partial name of the field (e.g.
     * "first" when "employee.name.first" is fully qualified name).
     */
    getPartialName(): Promise<string>;
    /**
     * modifies the field name.
     *
     * @method PDFNet.Field#rename
     * @param {string} field_name a string representing the fully qualified name of
     * the field (e.g. "employee.name.first").
     */
    rename(field_name: string): void;
    /**
     * @method PDFNet.Field#isAnnot
     * @return {Promise<boolean>} A promise that resolves to true if this Field is a Widget Annotation
     *
     * Determines whether or not this Field is an Annotation.
     */
    isAnnot(): Promise<boolean>;
    /**
     * Sets the signature handler to use for adding a signature to this field. If the signature handler is not found
     * in PDFDoc's signature handlers list, this field will not be signed. To add signature handlers, use PDFDoc.AddSignatureHandler
     * method.
     *
     * If a signature handler is already assigned to this field and this method is called once again, the associate signature
     * handler for this field will be updated with the new handler.
     *
     * @method PDFNet.Field#useSignatureHandler
     * @param {number} signature_handler_id The unique id of the SignatureHandler to use for adding signature in this field.
     *
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the signature dictionary created using the SignatureHandler, or NULL pointer if the signature handler is not found.
     */
    useSignatureHandler(signature_handler_id: number): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Field#getFlag
     * @return {Promise<boolean>} A promise that resolves to the value of given field flag
     * @param {number} flag
     * <pre>
     * PDFNet.Field.Flag = {
     * 	e_read_only : 0
     * 	e_required : 1
     * 	e_no_export : 2
     * 	e_pushbutton_flag : 3
     * 	e_radio_flag : 4
     * 	e_toggle_to_off : 5
     * 	e_radios_in_unison : 6
     * 	e_multiline : 7
     * 	e_password : 8
     * 	e_file_select : 9
     * 	e_no_spellcheck : 10
     * 	e_no_scroll : 11
     * 	e_comb : 12
     * 	e_rich_text : 13
     * 	e_combo : 14
     * 	e_edit : 15
     * 	e_sort : 16
     * 	e_multiselect : 17
     * 	e_commit_on_sel_change : 18
     * }
     * </pre>
     */
    getFlag(flag: number): Promise<boolean>;
    /**
     *
     * @method PDFNet.Field#setFlag
     * @param {number} flag
     * <pre>
     * PDFNet.Field.Flag = {
     * 	e_read_only : 0
     * 	e_required : 1
     * 	e_no_export : 2
     * 	e_pushbutton_flag : 3
     * 	e_radio_flag : 4
     * 	e_toggle_to_off : 5
     * 	e_radios_in_unison : 6
     * 	e_multiline : 7
     * 	e_password : 8
     * 	e_file_select : 9
     * 	e_no_spellcheck : 10
     * 	e_no_scroll : 11
     * 	e_comb : 12
     * 	e_rich_text : 13
     * 	e_combo : 14
     * 	e_edit : 15
     * 	e_sort : 16
     * 	e_multiselect : 17
     * 	e_commit_on_sel_change : 18
     * }
     * </pre>
     * @param {boolean} value
     */
    setFlag(flag: number, value: boolean): void;
    /**
     * @method PDFNet.Field#getJustification
     * @return {Promise<number>} A promise that resolves to the form of quadding (justification) to be used in displaying
     * the text fields.
     * @example Return value enum:
     * <pre>
     * PDFNet.Field.TextJustification = {
     * 	e_left_justified : 0
     * 	e_centered : 1
     * 	e_right_justified : 2
     * }
     * </pre>
     */
    getJustification(): Promise<number>;
    /**
     * sets the justification to be used in displaying the text field.
     * @method PDFNet.Field#setJustification
     * @param {number} j
     * <pre>
     * PDFNet.Field.TextJustification = {
     * 	e_left_justified : 0
     * 	e_centered : 1
     * 	e_right_justified : 2
     * }
     * </pre>
     * enum representing justification to set the text field to, options are e_left_justified, e_centered and e_right_justified
     * @note This method is specific to a text field.
     */
    setJustification(j: number): void;
    /**
     * sets the maximum length of the field's text, in characters.
     * @method PDFNet.Field#setMaxLen
     * @param {number} max_len maximum length of a field's text.
     * @note This method is specific to a text field.
     */
    setMaxLen(max_len: number): void;
    /**
     * @method PDFNet.Field#getMaxLen
     * @return {Promise<number>} A promise that resolves to the maximum length of the field's text, in characters, or a
     * negative number if the length is not limited.
     * @note This method is specific to a text field.
     */
    getMaxLen(): Promise<number>;
    /**
     * @method PDFNet.Field#getDefaultAppearance
     * @return {Promise<PDFNet.GState>} A promise that resolves to the default graphics state that should be used in formatting the
     * text. The state corresponds to /DA entry in the field dictionary.
     */
    getDefaultAppearance(): Promise<PDFNet.GState>;
    /**
     * @method PDFNet.Field#getUpdateRect
     * @return {Promise<PDFNet.Rect>} A promise that resolves to the rectangle that should be refreshed after changing a field.
     */
    getUpdateRect(): Promise<PDFNet.Rect>;
    /**
     * Flatten/Merge existing form field appearances with the page content and
     * remove widget annotation.
     *
     * Form 'flattening' refers to the operation that changes active form fields
     * into a static area that is part of the PDF document, just like the other
     * text and images in the document. A completely flattened PDF form does not
     * have any widget annotations or interactive fields.
     *
     * @method PDFNet.Field#flatten
     * @param {PDFNet.Page} page page object to flatten
     * @note an alternative approach to set the field as read only is using
     * Field.SetFlag(Field::e_read_only, true) method. Unlike Field.SetFlag(...),
     * the result of Flatten() operation can not be programatically reversed.
     */
    flatten(page: PDFNet.Page): void;
    /**
     *
     * @method PDFNet.Field#findInheritedAttribute
     * @param {string} attrib
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    findInheritedAttribute(attrib: string): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Field#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * Returns the total number of options in a list or combo box.
     * @method PDFNet.Field#getOptCount
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     */
    getOptCount(): Promise<number>;
    /**
     * @method PDFNet.Field#getOpt
     * @param {number} index index position of the option to retrieve.
     * @return {Promise<string>} A promise that resolves to the string of the option at the givent index.
     * @note The index must be less than the value returned by GetOptCount().
     */
    getOpt(index: number): Promise<string>;
    /**
     * Returns whether modifying this field would invalidate a digital signature in the document.
     *
     * @method PDFNet.Field#isLockedByDigitalSignature
     * @return {Promise<boolean>} A promise that resolves to whether modifying this field would invalidate a digital signature in the document
     */
    isLockedByDigitalSignature(): Promise<boolean>;
  }
  /**
   * A file attachment annotation contains a reference to a file, which may be
   * embedded in the PDF document.
   * @class
   * @name FileAttachmentAnnot
   * @memberof PDFNet
   */
  class FileAttachmentAnnot {
    /**
     * creates an FileAttachment annotation and initializes it using given Cos/SDF object.
     * d Cos/SDF object used to initialize the FileAttachment annotation
     * @method PDFNet.FileAttachmentAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.FileAttachmentAnnot>} A promise that resolves to an object of type: "FileAttachmentAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.FileAttachmentAnnot>;
    /**
     * The function saves the data referenced by this File Attachment to an
     * external file.
     *
     * If the file is embedded, the function saves the embedded file.
     * If the file is not embedded, the function will copy the external file.
     * If the file is not embedded and the external file can't be found, the function
     * returns false.
     *
     * @method PDFNet.FileAttachmentAnnot#export
     * @param {string} [save_as] An optional parameter indicating the filepath and filename
     * where the data should be saved. If this parameter is not specified the function
     * will attempt to save the file using FileSpec.GetFilePath().
     *
     * @return {Promise<boolean>} A promise that resolves to true is the file was saved successfully, false otherwise.
     */
    export(save_as?: string): Promise<boolean>;
    /**
     *
     * @method PDFNet.FileAttachmentAnnot#createFromAnnot
     * @return {Promise<PDFNet.Annot>} A promise that resolves to an object of type: "Annot"
     */
    createFromAnnot(): Promise<PDFNet.Annot>;
    /**
     * Creates a file attachment annotation.
     *
     * A file attachment annotation contains a reference to a file, which typically
     * is embedded in the PDF file.
     *
     * @method PDFNet.FileAttachmentAnnot.createWithFileSpec
     * @param {PDFNet.SDFDoc} doc A document to which the annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the annotation's bounds, in user space coordinates.
     * @param {PDFNet.FileSpec} fs a file specification object used to initialize the file attachment annotation.
     * @param {number} [icon_name]
     * <pre>
     * PDFNet.FileAttachmentAnnot.Icon = {
     * 	e_Graph : 0
     * 	e_PushPin : 1
     * 	e_Paperclip : 2
     * 	e_Tag : 3
     * 	e_Unknown : 4
     * }
     * </pre>
     * The name of an icon to be used in displaying the annotation, default is PushPin.
     * @note PDF Viewer applications should provide predefined icon appearances for at least
     * the following standard names: Graph, PushPin, Paperclip, Tag. Additional names may
     * be supported as well. Default value: PushPin.
     *
     * @return {Promise<PDFNet.FileAttachmentAnnot>} A promise that resolves to a new file attachment annotation.
     */
    static createWithFileSpec(
      doc: PDFNet.SDFDoc,
      pos: PDFNet.Rect,
      fs: PDFNet.FileSpec,
      icon_name?: number,
    ): Promise<PDFNet.FileAttachmentAnnot>;
    /**
     *
     * @method PDFNet.FileAttachmentAnnot.createDefault
     * @param {PDFNet.SDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @param {string} path
     * @return {Promise<PDFNet.FileAttachmentAnnot>} A promise that resolves to an object of type: "FileAttachmentAnnot"
     */
    static createDefault(doc: PDFNet.SDFDoc, pos: PDFNet.Rect, path: string): Promise<PDFNet.FileAttachmentAnnot>;
    /**
     * @method PDFNet.FileAttachmentAnnot#getFileSpec
     * @return {Promise<PDFNet.FileSpec>} A promise that resolves to the file specification that contains a file reference or the embedded file data stream.
     */
    getFileSpec(): Promise<PDFNet.FileSpec>;
    /**
     * sets the file specification.
     *
     * @method PDFNet.FileAttachmentAnnot#setFileSpec
     * @param {PDFNet.FileSpec} file The file specification to associate with this annotation..
     * The file specification contains a file reference or the embedded file data stream.
     */
    setFileSpec(file: PDFNet.FileSpec): void;
    /**
     * @method PDFNet.FileAttachmentAnnot#getIcon
     * @return {Promise<number>} A promise that resolves to the type the associated icon style.
     * @default e_PushPin
     * @note The annotation dictionary's appearance stream, if present, will take precedence over this entry
     * when displaying the annotation in the viewer.
     * @example Return value enum:
     * <pre>
     * PDFNet.FileAttachmentAnnot.Icon = {
     * 	e_Graph : 0
     * 	e_PushPin : 1
     * 	e_Paperclip : 2
     * 	e_Tag : 3
     * 	e_Unknown : 4
     * }
     * </pre>
     */
    getIcon(): Promise<number>;
    /**
     * sets the icon style associated with FileAttachment annotation.
     * (Optional)
     *
     * @method PDFNet.FileAttachmentAnnot#setIcon
     * @param {number} [type]
     * <pre>
     * PDFNet.FileAttachmentAnnot.Icon = {
     * 	e_Graph : 0
     * 	e_PushPin : 1
     * 	e_Paperclip : 2
     * 	e_Tag : 3
     * 	e_Unknown : 4
     * }
     * </pre>
     * icon style.
     * @default e_PushPin
     * @note The annotation dictionary's appearance stream, if present, will take precedence over this entry
     * when displaying the annotation in the viewer.
     */
    setIcon(type?: number): void;
    /**
     * Returns the name of the icon associated with the FileAttachment annotation.
     *
     * @method PDFNet.FileAttachmentAnnot#getIconName
     * @return {Promise<string>} A promise that resolves to a string denoting the name of the icon.
     *
     * @see GetIcon() GetIconName() returns the icon name as it appears in the annotation dictionary, while GetIcon() returns
     * the same icon name converted to enumeration value.
     * @note The annotation dictionary's appearance stream, if present, will take precedence over this entry
     * when displaying the annotation in the viewer.
     */
    getIconName(): Promise<string>;
    /**
     * sets the name of the icon associated with the FileAttachment annotation.
     * (Optional)
     *
     * @method PDFNet.FileAttachmentAnnot#setIconName
     * @param {string} iname A string.denoting the name of the icon.
     * @note this method should be used to assign non-standard icon type to the annotation.
     * @see SetIcon()
     * @note The annotation dictionary's appearance stream, if present, will take precedence over this entry
     * when displaying the annotation in the viewer.
     */
    setIconName(iname: string): void;
  }
  /**
   * FileSpec corresponds to the PDF file specification object.
   *
   * A PDF file can refer to the contents of another file by using a file specification,
   * which can take either of the following forms:
   *
   * - A simple file specification gives just the name of the target file in
   *   a standard format, independent of the naming conventions of any particular file system.
   *
   * - A full file specification includes information related to one or more specific file
   *   systems.
   *
   * - A URL reference.
   *
   * Although the file designated by a file specification is normally external to the
   * PDF file referring to it, it is also possible to embed the file allowing its contents
   * to be stored or transmitted along with the PDF file. However, embedding a file does not
   * change the presumption that it is external to (or separate from) the PDF file.
   *
   * For more details on file specifications, please refer to Section 3.10, 'File Specifications'
   * in the PDF Reference Manual.
   * @class
   * @name FileSpec
   * @memberof PDFNet
   */
  class FileSpec {
    /**
     * Creates a file specification for the given file. By default, the specified
     * file is embedded in PDF.
     *
     * @method PDFNet.FileSpec.create
     * @param {PDFNet.SDFDoc} doc A document to which the FileSpec should be added. To obtain
     * SDFDoc from PDFDoc use PDFDoc::GetSDFDoc() or Obj::GetDoc().
     *
     * @param {string} path The path to convert into a file specification.
     *
     * @param {boolean} [embed] A flag indicating whether to embed specified in the PDF.
     * By default, all files are embedded.
     *
     * @return {Promise<PDFNet.FileSpec>} A promise that resolves to newly created FileSpec object.
     */
    static create(doc: PDFNet.SDFDoc, path: string, embed?: boolean): Promise<PDFNet.FileSpec>;
    /**
     * Creates a URL file specification.
     *
     * @method PDFNet.FileSpec.createURL
     * @param {PDFNet.SDFDoc} doc A document to which the FileSpec should be added. To obtain
     * SDFDoc from PDFDoc use PDFDoc::GetSDFDoc() or Obj::GetDoc().
     *
     * @param {string} url A uniform resource locator (URL) of the form defined in
     * Internet RFC 1738, Uniform Resource Locators Specification.
     *
     * @return {Promise<PDFNet.FileSpec>} A promise that resolves to newly created FileSpec object.
     */
    static createURL(doc: PDFNet.SDFDoc, url: string): Promise<PDFNet.FileSpec>;
    /**
     *
     * @method PDFNet.FileSpec.createFromObj
     * @param {PDFNet.Obj} f
     * @return {Promise<PDFNet.FileSpec>} A promise that resolves to an object of type: "FileSpec"
     */
    static createFromObj(f: PDFNet.Obj): Promise<PDFNet.FileSpec>;
    /**
     * Assignment operator
     * @method PDFNet.FileSpec#copy
     * @return {Promise<PDFNet.FileSpec>} A promise that resolves to an object of type: "FileSpec"
     */
    copy(): Promise<PDFNet.FileSpec>;
    /**
     *
     * @method PDFNet.FileSpec#compare
     * @param {PDFNet.FileSpec} d
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    compare(d: PDFNet.FileSpec): Promise<boolean>;
    /**
     * @method PDFNet.FileSpec#isValid
     * @return {Promise<boolean>} A promise that resolves to whether this is a valid (non-null) FileSpec. If the
     * function returns false the underlying SDF/Cos object is null or is not valid
     * and the FileSpec object should be treated as null as well.
     */
    isValid(): Promise<boolean>;
    /**
     * The function saves the data referenced by this FileSpec to an external file.
     *
     * @method PDFNet.FileSpec#export
     * @param {string} [save_as] An optional parameter indicating the filepath and filename
     * where the data should be saved. If this parameter is not specified, the function
     * will attempt to save the file using FileSpec.GetFilePath().
     *
     * If the file is embedded, the function saves the embedded file.
     * If the file is not embedded, the function will copy the external file.
     * If the file is not embedded and the external file can't be found, the function
     * returns false.
     *
     * @return {Promise<boolean>} A promise that resolves to true is the file was saved successfully, false otherwise.
     */
    export(save_as?: string): Promise<boolean>;
    /**
     * The function returns data referenced by this FileSpec.
     *
     * @method PDFNet.FileSpec#getFileData
     * @return {Promise<PDFNet.Filter>} A promise that resolves to a stream (filter) containing file data.
     * If the file is embedded, the function returns a stream to the embedded file.
     * If the file is not embedded, the function will return a stream to the external file.
     * If the file is not embedded and the external file can't be found, the function
     * returns NULL.
     */
    getFileData(): Promise<PDFNet.Filter>;
    /**
     * @method PDFNet.FileSpec#getFilePath
     * @return {Promise<string>} A promise that resolves to the file path for this file specification.
     *
     * If the FileSpec is a dictionary, a corresponding platform specific path
     * is returned (DOS, Mac, or Unix). Otherwise the function returns the path represented
     * in the form described in Section 3.10.1, 'File Specification Strings,' or , if the
     * file system is URL, as a uniform resource locator (URL). If the FileSpec is not
     * valid, an empty string is returned.
     */
    getFilePath(): Promise<string>;
    /**
     *
     * @method PDFNet.FileSpec#setDesc
     * @param {string} desc
     */
    setDesc(desc: string): void;
    /**
     * @method PDFNet.FileSpec#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
  }
  /**
   * Provides a generic view of a sequence of bytes.
   *
   * A Filter is the abstract base class of all filters. A filter is an abstraction of
   * a sequence of bytes, such as a file, an input/output device, an inter-process communication
   * pipe, or a TCP/IP socket. The Filter class and its derived classes provide a generic view
   * of these different types of input and output, isolating the programmer from the specific
   * details of the operating system and the underlying devices.
   *
   * Besides providing access to input/output sources Filters can be also to transform the data
   * (e.g. to compress the data stream, to normalize the image data, to encrypt data, etc).
   * Filters can also be attached to each other to form pipelines. For example, a filter used to
   * open an image data file can be attached to a filter that decompresses the data, which is
   * attached to another filter that will normalize the image data.
   *
   * Depending on the underlying data source or repository, filters might support only some of
   * these capabilities. An application can query a stream for its capabilities by using the
   * IsInputFilter() and CanSeek() properties.
   *
   * @note To read or write data to a filter, a user will typically use FilterReader/FilterWriter class.
   * instead of using Filter methods
   *
   * For example:
   * <pre>
   * StdFile file("my_stream.txt", StdFile::e_read_mode);
   * FilterReader reader(file);
   * while (reader.Read(..)) ...
   * </pre>
   * @class
   * @name Filter
   * @memberof PDFNet
   */
  class Filter {
    /**
     *
     * @method PDFNet.Filter#createASCII85Encode
     * @param {number} line_width
     * @param {number} buf_sz
     * @return {Promise<PDFNet.Filter>} A promise that resolves to an object of type: "Filter"
     */
    createASCII85Encode(line_width: number, buf_sz: number): Promise<PDFNet.Filter>;
    /**
     *
     * @method PDFNet.Filter.createMemoryFilter
     * @param {number} buf_sz
     * @param {boolean} is_input
     * @return {Promise<PDFNet.Filter>} A promise that resolves to an object of type: "Filter"
     */
    static createMemoryFilter(buf_sz: number, is_input: boolean): Promise<PDFNet.Filter>;
    /**
     *
     * @method PDFNet.Filter.createImage2RGBFromElement
     * @param {PDFNet.Element} elem
     * @return {Promise<PDFNet.Filter>} A promise that resolves to an object of type: "Filter"
     */
    static createImage2RGBFromElement(elem: PDFNet.Element): Promise<PDFNet.Filter>;
    /**
     *
     * @method PDFNet.Filter.createImage2RGBFromObj
     * @param {PDFNet.Obj} obj
     * @return {Promise<PDFNet.Filter>} A promise that resolves to an object of type: "Filter"
     */
    static createImage2RGBFromObj(obj: PDFNet.Obj): Promise<PDFNet.Filter>;
    /**
     *
     * @method PDFNet.Filter.createImage2RGB
     * @param {PDFNet.Image} img
     * @return {Promise<PDFNet.Filter>} A promise that resolves to an object of type: "Filter"
     */
    static createImage2RGB(img: PDFNet.Image): Promise<PDFNet.Filter>;
    /**
     *
     * @method PDFNet.Filter.createImage2RGBAFromElement
     * @param {PDFNet.Element} elem
     * @param {boolean} premultiply
     * @return {Promise<PDFNet.Filter>} A promise that resolves to an object of type: "Filter"
     */
    static createImage2RGBAFromElement(elem: PDFNet.Element, premultiply: boolean): Promise<PDFNet.Filter>;
    /**
     *
     * @method PDFNet.Filter.createImage2RGBAFromObj
     * @param {PDFNet.Obj} obj
     * @param {boolean} premultiply
     * @return {Promise<PDFNet.Filter>} A promise that resolves to an object of type: "Filter"
     */
    static createImage2RGBAFromObj(obj: PDFNet.Obj, premultiply: boolean): Promise<PDFNet.Filter>;
    /**
     *
     * @method PDFNet.Filter.createImage2RGBA
     * @param {PDFNet.Image} img
     * @param {boolean} premultiply
     * @return {Promise<PDFNet.Filter>} A promise that resolves to an object of type: "Filter"
     */
    static createImage2RGBA(img: PDFNet.Image, premultiply: boolean): Promise<PDFNet.Filter>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.Filter#destroy
     */
    destroy(): void;
    /**
     *
     * @method PDFNet.Filter#attachFilter
     * @param {PDFNet.Filter} attach_filter
     */
    attachFilter(attach_filter: PDFNet.Filter): void;
    /**
     * Release the ownership of the attached filter. After the attached filter is
     * released this filter points to NULL filter.
     *
     * @method PDFNet.Filter#releaseAttachedFilter
     * @return {Promise<PDFNet.Filter>} A promise that resolves to Previously attached filter.
     */
    releaseAttachedFilter(): Promise<PDFNet.Filter>;
    /**
     * @method PDFNet.Filter#getAttachedFilter
     * @return {Promise<PDFNet.Filter>} A promise that resolves to returns attached Filter or a NULL filter if no filter is attached.
     */
    getAttachedFilter(): Promise<PDFNet.Filter>;
    /**
     * @method PDFNet.Filter#getSourceFilter
     * @return {Promise<PDFNet.Filter>} A promise that resolves to returns the first filter in the chain (usually a file filter)
     */
    getSourceFilter(): Promise<PDFNet.Filter>;
    /**
     * @method PDFNet.Filter#getName
     * @return {Promise<string>} A promise that resolves to descriptive name of the filter.
     */
    getName(): Promise<string>;
    /**
     * @method PDFNet.Filter#getDecodeName
     * @return {Promise<string>} A promise that resolves to string representing the name of corresponding decode filter as
     * it should appear in document (e.g. both ASCIIHexDecode and ASCIIHexEncode
     * should return ASCIIHexDecode).
     */
    getDecodeName(): Promise<string>;
    /**
     * @method PDFNet.Filter#begin
     * @return {Promise<number>} A promise that resolves to beginning of the buffer of Size() bytes that can be used to
     * read or write data.
     */
    begin(): Promise<number>;
    /**
     * @method PDFNet.Filter#size
     * @return {Promise<number>} A promise that resolves to the size of buffer returned by Begin(). If the Size() returns 0
     * end of data has been reached.
     */
    size(): Promise<number>;
    /**
     * Moves the Begin() pointer num_bytes forward.
     *
     * @method PDFNet.Filter#consume
     * @param {number} num_bytes number of bytes to consume. num_bytes must be less than or
     * equal to Size().
     */
    consume(num_bytes: number): void;
    /**
     * @method PDFNet.Filter#count
     * @return {Promise<number>} A promise that resolves to the number of bytes consumed since opening the filter or
     *   the last Seek operation
     */
    count(): Promise<number>;
    /**
     * Sets a new counting point for the current filter. All subsequent Consume()
     * operations will increment this counter.
     *
     * Make sure that the output filter is flushed before using SetCount().
     * @method PDFNet.Filter#setCount
     * @param {number} new_count number to set the counting point of the filter to.
     *
     * @return {Promise<number>} A promise that resolves to the value of previous counter
     */
    setCount(new_count: number): Promise<number>;
    /**
     * The functions specifies the length of the data stream. The default
     * implementation doesn't do anything. For some derived filters such
     * as file segment filter it may be useful to override this function
     * in order to limit the stream length.
     *
     * @method PDFNet.Filter#setStreamLength
     * @param {number} bytes the length of stream in bytes
     */
    setStreamLength(bytes: number): void;
    /**
     * Forces any data remaining in the buffer to be written to input or
     * output filter.
     * @method PDFNet.Filter#flush
     */
    flush(): void;
    /**
     * Forces any data remaining in the filter chain to the source or destination.
     * @method PDFNet.Filter#flushAll
     */
    flushAll(): void;
    /**
     * @method PDFNet.Filter#isInputFilter
     * @return {Promise<boolean>} A promise that resolves to boolean indicating whether this is an input filter.
     */
    isInputFilter(): Promise<boolean>;
    /**
     * @method PDFNet.Filter#canSeek
     * @return {Promise<boolean>} A promise that resolves to true if the stream supports seeking; otherwise, false.
     * default is to return false.
     */
    canSeek(): Promise<boolean>;
    /**
     * When overridden in a derived class, sets the position within the current stream.
     *
     * @method PDFNet.Filter#seek
     * @param {number} offset A byte offset relative to origin. If offset is negative,
     *  the new position will precede the position specified by origin by the number
     *  of bytes specified by offset. If offset is zero, the new position will be the
     *  position specified by origin. If offset is positive, the new position will follow
     *  the position specified by origin by the number of bytes specified by offset.
     *
     * @param {number} origin
     * <pre>
     * PDFNet.Filter.ReferencePos = {
     * 	e_begin : 0
     * 	e_end : 2
     * 	e_cur : 1
     * }
     * </pre>
     * A value of type ReferencePos indicating the reference point used
     * to obtain the new position
     *
     * @note After each Seek() operation the number of consumed bytes (i.e.
     * Count()) is set to 0.
     *
     */
    seek(offset: number, origin: number): void;
    /**
     * Reports the current read position in the stream relative to the stream origin.
     *
     * @method PDFNet.Filter#tell
     * @return {Promise<number>} A promise that resolves to The current position in the stream
     */
    tell(): Promise<number>;
    /**
     * Create Filter iterator. Filter iterator similar to a regular filter. However,
     * there can be only one owner of the attached filter.
     *
     * @method PDFNet.Filter#createInputIterator
     * @note Derived classes should make sure that there is only one owner of the
     *   attached stream. Otherwise the attached stream may be deleted several times.
     *
     * @return {Promise<PDFNet.Filter>} A promise that resolves to an object of type: "Filter"
     */
    createInputIterator(): Promise<PDFNet.Filter>;
    /**
     * @method PDFNet.Filter#getFilePath
     * @return {Promise<string>} A promise that resolves to the file path to the underlying file stream.
     * Default implementation returns empty string.
     */
    getFilePath(): Promise<string>;
    /**
     * @method PDFNet.Filter#memoryFilterGetBuffer
     * @note MemoryFilter specific function.
     * @return {Promise<number>} A promise that resolves to a pointer to the beginning of the buffer. Use method Count() to
     * determine the number of bytes written to or read from MemoryFilter.
     */
    memoryFilterGetBuffer(): Promise<number>;
    /**
     * @method PDFNet.Filter#memoryFilterSetAsInputFilter
     * @note MemoryFilter specific function used to change filter mode from output to input.
     * The utility function is useful in cases when and output data buffer should be
     * converted to an input stream.
     *
     * @note The function has no effect on an input MemoryFilter.
     */
    memoryFilterSetAsInputFilter(): void;
    /**
     *
     * @method PDFNet.Filter#memoryFilterReset
     */
    memoryFilterReset(): void;
    /**
     * @method PDFNet.Filter.createFromMemory
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf A memory buffer containing the underlying data.
     *
     * @return {Promise<PDFNet.Filter>} A promise that resolves to a "Filter" created from the buffer
     */
    static createFromMemory(buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<PDFNet.Filter>;
    /**
     * @method PDFNet.Filter.createURLFilter
     * @param {string} url A url from which the data can be downloaded.
     *
     * @return {Promise<PDFNet.Filter>} A promise that resolves to a "Filter" created from the url
     */
    static createURLFilter(url: string): Promise<PDFNet.Filter>;
    /**
     * Constructor for Flate encoder.
     * FlateEncode filter can be used to compress any data stream
     * using Flate (i.e. ZIP) compression method.
     * @method PDFNet.Filter.createFlateEncode
     * @param {PDFNet.Filter} [input_filter = PDFNet.Filter("0")] the input data stream
     * @param {number} [compression_level = -1] compression_level must be a number between 0 and 9: 1 gives best speed,
     * 9 gives best compression, 0 gives no compression at all (the input data is simply
     * copied a block at a time), -1 requests a default compromise between speed
     * and compression (currently equivalent to level 6).
     * @param {number} [ buf_sz = 256] filter buffer size (in bytes).
     * @return {Promise<PDFNet.Filter>} A promise that resolves to an object of type: "Filter" (generated documentation)
     */
    static createFlateEncode(
      input_filter?: PDFNet.Filter,
      compression_level?: number,
      buf_sz?: number,
    ): Promise<PDFNet.Filter>;
  }
  /**
   * FilterReader is a utility class providing a convenient way to read data
   * from an input filter (using Filter directly is not very intuitive).
   *
   * For example:
   * <pre>
   * StdFile file("my_stream.txt", StdFile::e_read_mode);
   * FilterReader reader(file);
   * while (reader.Read(...)) ...
   * </pre>
   * @class
   * @name FilterReader
   * @memberof PDFNet
   */
  class FilterReader {
    /**
     *
     * @method PDFNet.FilterReader.create
     * @param {PDFNet.Filter} filter
     * @return {Promise<PDFNet.FilterReader>} A promise that resolves to an object of type: "FilterReader"
     */
    static create(filter: PDFNet.Filter): Promise<PDFNet.FilterReader>;
    /**
     * Destructor
     * @method PDFNet.FilterReader#destroy
     */
    destroy(): void;
    /**
     * Attaches a filter to the this FilterReader.
     * @method PDFNet.FilterReader#attachFilter
     * @param {PDFNet.Filter} filter filter object to attach
     */
    attachFilter(filter: PDFNet.Filter): void;
    /**
     * @method PDFNet.FilterReader#getAttachedFilter
     * @return {Promise<PDFNet.Filter>} A promise that resolves to The attached Filter or a NULL filter if no filter is attached.
     */
    getAttachedFilter(): Promise<PDFNet.Filter>;
    /**
     * Sets the position within the current stream.
     *
     * @method PDFNet.FilterReader#seek
     * @param {number} offset A byte offset relative to origin. If offset is negative,
     *  the new position will precede the position specified by origin by the number
     *  of bytes specified by offset. If offset is zero, the new position will be the
     *  position specified by origin. If offset is positive, the new position will follow
     *  the position specified by origin by the number of bytes specified by offset.
     *
     * @param {number} origin
     * <pre>
     * PDFNet.Filter.ReferencePos = {
     * 	e_begin : 0
     * 	e_end : 2
     * 	e_cur : 1
     * }
     * </pre>
     * A value of type ReferencePos indicating the reference point used
     * to obtain the new position
     *
     * @note After each Seek() operation the number of consumed bytes (i.e. Count()) is set to 0.
     */
    seek(offset: number, origin: number): void;
    /**
     * Reports the current read position in the stream relative to the stream origin.
     *
     * @method PDFNet.FilterReader#tell
     * @return {Promise<number>} A promise that resolves to The current position in the stream
     */
    tell(): Promise<number>;
    /**
     * @method PDFNet.FilterReader#count
     * @return {Promise<number>} A promise that resolves to the number of bytes consumed since opening the filter or
     * since the last Seek operation.
     */
    count(): Promise<number>;
    /**
     * Forces any data remaining in the buffer to be written to input or output filter.
     * @method PDFNet.FilterReader#flush
     */
    flush(): void;
    /**
     * Forces any data remaining in the filter chain to the source or destination.
     * @method PDFNet.FilterReader#flushAll
     */
    flushAll(): void;
    /**
     * @method PDFNet.FilterReader#get
     * @return {Promise<number>} A promise that resolves to the next character from the stream or EOF (-1) if the end of file is reached.
     */
    get(): Promise<number>;
    /**
     * @method PDFNet.FilterReader#peek
     * @return {Promise<number>} A promise that resolves to the next character without extracting it from the stream or
     *			 or EOF (-1) if the end of file is reached.
     */
    peek(): Promise<number>;
    /**
     * Read data from the attached filter
     * @method PDFNet.FilterReader#read
     * @param {number} buf_size The maximum amount to read
     * @return {Promise<Uint8Array>} A promise that resolves to a Uint8Array containing the data that was read.
     *			the promise will resolve to null if no data was remaining.
     */
    read(buf_size: number): Promise<Uint8Array>;
    /**
     * Read all the remaining data to a buffer from the attached filter
     * @method PDFNet.FilterReader#readAllIntoBuffer
     * @return {Promise<Uint8Array>} A promise that resolves to a Uint8Array containing the data that was read.
     *			the promise will resolve to null if no data was remaining.
     */
    readAllIntoBuffer(): Promise<Uint8Array>;
  }
  /**
   * FilterWriter is a utility class providing a convenient way to write data
   * to an output filter (using Filter directly is not very intuitive).
   *
   * For example:
   * <pre>
   * StdFile outfile("file.dat", StdFile::e_write_mode);
   * FilterWriter fwriter(outfile);
   * fwriter.WriteBuffer(buf, buf_sz);
   * fwriter.Flush();
   * </pre>
   * @class
   * @name FilterWriter
   * @memberof PDFNet
   */
  class FilterWriter {
    /**
     * Constructor
     * @method PDFNet.FilterWriter.create
     * @param {PDFNet.Filter} filter
     * @return {Promise<PDFNet.FilterWriter>} A promise that resolves to an object of type: "FilterWriter"
     */
    static create(filter: PDFNet.Filter): Promise<PDFNet.FilterWriter>;
    /**
     * Destructor
     * @method PDFNet.FilterWriter#destroy
     */
    destroy(): void;
    /**
     * Attaches a filter to the this FilterWriter.
     * @method PDFNet.FilterWriter#attachFilter
     * @param {PDFNet.Filter} filter filter object to attach
     */
    attachFilter(filter: PDFNet.Filter): void;
    /**
     * @method PDFNet.FilterWriter#getAttachedFilter
     * @return {Promise<PDFNet.Filter>} A promise that resolves to The attached Filter or a NULL filter if no filter is attached.
     */
    getAttachedFilter(): Promise<PDFNet.Filter>;
    /**
     * Sets the position within the current stream.
     *
     * @method PDFNet.FilterWriter#seek
     * @param {number} offset A byte offset relative to origin. If offset is negative,
     *  the new position will precede the position specified by origin by the number
     *  of bytes specified by offset. If offset is zero, the new position will be the
     *  position specified by origin. If offset is positive, the new position will follow
     *  the position specified by origin by the number of bytes specified by offset.
     *
     * @param {number} origin
     * <pre>
     * PDFNet.Filter.ReferencePos = {
     * 	e_begin : 0
     * 	e_end : 2
     * 	e_cur : 1
     * }
     * </pre>
     * A value of type ReferencePos indicating the reference point used
     * to obtain the new position
     *
     * @note After each Seek() operation the number of consumed bytes (i.e. Count()) is set to 0.
     */
    seek(offset: number, origin: number): void;
    /**
     * Reports the current read position in the stream relative to the stream origin.
     *
     * @method PDFNet.FilterWriter#tell
     * @return {Promise<number>} A promise that resolves to The current position in the stream
     */
    tell(): Promise<number>;
    /**
     * @method PDFNet.FilterWriter#count
     * @return {Promise<number>} A promise that resolves to the number of bytes consumed since opening the filter or
     * since the last Seek operation.
     */
    count(): Promise<number>;
    /**
     * Forces any data remaining in the buffer to be written to input or output filter.
     * @method PDFNet.FilterWriter#flush
     */
    flush(): void;
    /**
     * Forces any data remaining in the filter chain to the source or destination.
     * @method PDFNet.FilterWriter#flushAll
     */
    flushAll(): void;
    /**
     * Write a single character to the output stream.
     * @method PDFNet.FilterWriter#writeUChar
     * @param {number} ch An unsigned character to write to the output stream.
     */
    writeUChar(ch: number): void;
    /**
     * Write an integer to the output stream.
     * @method PDFNet.FilterWriter#writeInt16
     * @param {number} num An integer to write to the output stream.
     */
    writeInt16(num: number): void;
    /**
     * Write an integer to the output stream.
     * @method PDFNet.FilterWriter#writeUInt16
     * @param {number} num An integer to write to the output stream.
     */
    writeUInt16(num: number): void;
    /**
     * Write an integer to the output stream.
     * @method PDFNet.FilterWriter#writeInt32
     * @param {number} num An integer to write to the output stream.
     */
    writeInt32(num: number): void;
    /**
     * Write an integer to the output stream.
     * @method PDFNet.FilterWriter#writeUInt32
     * @param {number} num An integer to write to the output stream.
     */
    writeUInt32(num: number): void;
    /**
     * Write an integer to the output stream.
     * @method PDFNet.FilterWriter#writeInt64
     * @param {number} num An integer to write to the output stream.
     */
    writeInt64(num: number): void;
    /**
     * Write an integer to the output stream.
     * @method PDFNet.FilterWriter#writeUInt64
     * @param {number} num An integer to write to the output stream.
     */
    writeUInt64(num: number): void;
    /**
     * Write a string to the output stream.
     * @method PDFNet.FilterWriter#writeString
     * @param {string} str A string to write to the output stream.
     */
    writeString(str: string): void;
    /**
     * Write the entire input stream to the output stream (i.e. to this FilterWriter).
     * @method PDFNet.FilterWriter#writeFilter
     * @param {PDFNet.FilterReader} reader A FilterReader attached to an input stream.
     */
    writeFilter(reader: PDFNet.FilterReader): void;
    /**
     * Write out a null terminated 'line' followed by a end of line character
     * default end of line character is carriage return.
     * @method PDFNet.FilterWriter#writeLine
     * @param {string} line string to write out.
     * @param {number} [eol] end of line character. Defaults to carriage return (0x0D).
     */
    writeLine(line: string, eol?: number): void;
    /**
     * @method PDFNet.FilterWriter#writeBuffer
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf buffer object to write out.
     * @return {Promise<number>} A promise that resolves to returns the number of bytes actually written to a stream. This number may
     *   less than buf_size if the stream is corrupted.
     */
    writeBuffer(buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<number>;
  }
  /**
   * Flattener is a optional PDFNet add-on that can be used to simplify and optimize
   * existing PDF's to render faster on devices with lower memory and speeds.
   *
   * PDF documents can frequently contain very complex page description (e.g.
   * thousands of paths, different shadings, color spaces, blend modes, large images
   * etc.) that may not be suitable for interactive viewing on mobile devices.
   * Flattener can be used to speed-up PDF rendering on mobile devices and on the Web
   * by simplifying page content (e.g. flattening complex graphics into images) while
   * maintaining vector text whenever possible.
   *
   * By using the FlattenMode::e_simple option each page in the PDF will be
   * reduced to a single background image, with the remaining text over top in vector
   * format. Some text may still get flattened, in particular any text that is clipped,
   * or underneath, other content that will be flattened.
   *
   * On the other hand the FlattenMode::e_fast will not flatten simple content, such
   * as simple straight lines, nor will it flatten Type3 fonts.
   *
   * @note 'Flattener' is available as a separately licensable add-on to PDFNet
   * core license or for use via Cloud API (http://www.pdftron.com/pdfnet/cloud).
   *
   * @note See 'pdftron.PDF.Optimizer' for alternate approach to optimize PDFs with
   * focus on file size reduction.
   * @class
   * @name Flattener
   * @memberof PDFNet
   */
  class Flattener {
    /**
     * Flattener constructor
     * @method PDFNet.Flattener.create
     * @return {Promise<PDFNet.Flattener>} A promise that resolves to an object of type: "Flattener"
     */
    static create(): Promise<PDFNet.Flattener>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.Flattener#destroy
     */
    destroy(): void;
    /**
     * The output resolution, from 1 to 1000, in Dots Per Inch (DPI) at which to
     * render elements which cannot be directly converted.
     * the default value is 150 Dots Per Inch
     * @method PDFNet.Flattener#setDPI
     * @param {number} dpi the resolution in Dots Per Inch
     */
    setDPI(dpi: number): void;
    /**
     * Used to control how precise or relaxed text flattening is. When some text is
     * preserved (not flattened to image) the visual appearance of the document may be altered.
     * @method PDFNet.Flattener#setThreshold
     * @param {number} threshold
     * <pre>
     * PDFNet.Flattener.Threshold = {
     * 	e_very_strict : 0
     * 	e_strict : 1
     * 	e_default : 2
     * 	e_keep_most : 3
     * 	e_keep_all : 4
     * }
     * </pre>
     * the threshold setting to use.
     */
    setThreshold(threshold: number): void;
    /**
     * Specifies the maximum image size in pixels.
     * @method PDFNet.Flattener#setMaximumImagePixels
     * @param {number} max_pixels the maximum number of pixels an image can have.
     */
    setMaximumImagePixels(max_pixels: number): void;
    /**
     * Specifies whether to leave images in existing compression, or as JPEG.
     * @method PDFNet.Flattener#setPreferJPG
     * @param {boolean} jpg if true PDF will contain all JPEG images.
     */
    setPreferJPG(jpg: boolean): void;
    /**
     * Specifies the compression quality to use when generating JPEG images.
     * @method PDFNet.Flattener#setJPGQuality
     * @param {number} quality the JPEG compression quality, from 0(highest compression) to 100(best quality).
     */
    setJPGQuality(quality: number): void;
    /**
     * Enable or disable path hinting.
     *
     * @method PDFNet.Flattener#setPathHinting
     * @param {boolean} hinting if true path hinting is enabled. Path hinting is used to slightly
     * adjust paths in order to avoid or alleviate artifacts of hair line cracks between
     * certain graphical elements. This option is turned on by default.
     *
     */
    setPathHinting(hinting: boolean): void;
    /**
     * Process each page in the PDF, flattening content that matches the mode criteria.
     * @method PDFNet.Flattener#process
     * @param {PDFNet.PDFDoc} doc the document to flatten.
     * @param {number} mode
     * <pre>
     * PDFNet.Flattener.Mode = {
     * 	e_simple : 0
     * 	e_fast : 1
     * }
     * </pre>
     * indicates the criteria for which elements are flattened.
     */
    process(doc: PDFNet.PDFDoc, mode: number): void;
    /**
     * Process the given page, flattening content that matches the mode criteria.
     * @method PDFNet.Flattener#processPage
     * @param {PDFNet.Page} page the page to flatten.
     * @param {number} mode
     * <pre>
     * PDFNet.Flattener.Mode = {
     * 	e_simple : 0
     * 	e_fast : 1
     * }
     * </pre>
     * indicates the criteria for which elements are flattened.
     */
    processPage(page: PDFNet.Page, mode: number): void;
  }
  /**
   * A font that is used to draw text on a page. It corresponds to a Font Resource
   * in a PDF file. More than one page may reference the same Font object.
   * A Font has a number of attributes, including an array of widths, the character
   * encoding, and the font's resource name.
   *
   * PDF document can contain several different types of fonts and Font class
   * represents a single, flat interface around all PDF font types.
   *
   * There are two main classes of fonts in PDF: simple and composite fonts.
   *
   * Simple fonts are Type1, TrueType, and Type3 fonts. All simple fonts have the
   * following properties:<BR><BR>
   *  - Glyphs in the font are selected by single-byte character codes
   *    obtained from a string that is shown by the text-showing operators.
   *    Logically, these codes index into a table of 256 glyphs; the mapping
   *    from codes to glyphs is called the font's encoding. Each font program
   *    has a built-in encoding. Under some circumstances, the encoding can
   *    be altered by means described in Section 5.5.5 "Character Encoding" in
   *    PDF Reference Manual.<BR><BR>
   *
   *  - Each glyph has a single set of metrics. Therefore simple fonts support
   *    only horizontal writing mode.<BR><BR>
   *
   * A composite font is one whose glyphs are obtained from a font like object
   * called a CIDFont (e.g. CIDType0Font and CIDType0Font). A composite font is
   * represented by a font dictionary whose Subtype value is Type0. The Type 0 font
   * is known as the root font, while its associated CIDFont is called its descendant.
   * CID-keyed fonts provide a convenient and efficient method for defining
   * multiple-byte character encodings and fonts with a large number of glyphs.
   * These capabilities provide great flexibility for representing text in writing
   * systems for languages with large character sets, such as Chinese, Japanese,
   * and Korean (CJK).
   * @class
   * @name Font
   * @memberof PDFNet
   */
  class Font {
    /**
     * create a PDF::Font object from an existing SDF font object that is embedded
     * in the document. If font_dict is null, a non valid font is created.
     * @method PDFNet.Font.createFromObj
     * @param {PDFNet.Obj} [font_dict] The Cos/SDF object to create the Font object with.
     * @return {Promise<PDFNet.Font>} A promise that resolves to an object of type: "Font"
     */
    static createFromObj(font_dict?: PDFNet.Obj): Promise<PDFNet.Font>;
    /**
     * Constructor
     * @method PDFNet.Font.create
     * @param {PDFNet.SDFDoc} doc Document on which to create the font on.
     * @param {number} type
     * <pre>
     * PDFNet.Font.StandardType1Font = {
     * 	e_times_roman : 0
     * 	e_times_bold : 1
     * 	e_times_italic : 2
     * 	e_times_bold_italic : 3
     * 	e_helvetica : 4
     * 	e_helvetica_bold : 5
     * 	e_helvetica_oblique : 6
     * 	e_helvetica_bold_oblique : 7
     * 	e_courier : 8
     * 	e_courier_bold : 9
     * 	e_courier_oblique : 10
     * 	e_courier_bold_oblique : 11
     * 	e_symbol : 12
     * 	e_zapf_dingbats : 13
     * 	e_null : 14
     * }
     * </pre>
     * The type of font to create.
     * <pre>
     * PDFNet.Font.StandardType1Font = {
     * 	e_times_roman : 0
     * 	e_times_bold : 1
     * 	e_times_italic : 2
     * 	e_times_bold_italic : 3
     * 	e_helvetica : 4
     * 	e_helvetica_bold : 5
     * 	e_helvetica_oblique : 6
     * 	e_helvetica_bold_oblique : 7
     * 	e_courier : 8
     * 	e_courier_bold : 9
     * 	e_courier_oblique : 10
     * 	e_courier_bold_oblique : 11
     * 	e_symbol : 12
     * 	e_zapf_dingbats : 13
     * 	e_null : 14
     * }
     * </pre>
     * @return {Promise<PDFNet.Font>} A promise that resolves to an object of type: "Font" (generated documentation)
     */
    static create(doc: PDFNet.SDFDoc, type: number): Promise<PDFNet.Font>;
    /**
     *
     * @method PDFNet.Font.createFromFontDescriptor
     * @param {PDFNet.SDFDoc} doc
     * @param {PDFNet.Font} from
     * @param {string} char_set
     * @return {Promise<PDFNet.Font>} A promise that resolves to an object of type: "Font"
     */
    static createFromFontDescriptor(doc: PDFNet.SDFDoc, from: PDFNet.Font, char_set: string): Promise<PDFNet.Font>;
    /**
     *
     * @method PDFNet.Font.createFromName
     * @param {PDFNet.SDFDoc} doc
     * @param {string} name
     * @param {string} char_set
     * @return {Promise<PDFNet.Font>} A promise that resolves to an object of type: "Font"
     */
    static createFromName(doc: PDFNet.SDFDoc, name: string, char_set: string): Promise<PDFNet.Font>;
    /**
     *
     * @method PDFNet.Font.createAndEmbed
     * @param {PDFNet.SDFDoc} doc
     * @param {number} type
     * <pre>
     * PDFNet.Font.StandardType1Font = {
     * 	e_times_roman : 0
     * 	e_times_bold : 1
     * 	e_times_italic : 2
     * 	e_times_bold_italic : 3
     * 	e_helvetica : 4
     * 	e_helvetica_bold : 5
     * 	e_helvetica_oblique : 6
     * 	e_helvetica_bold_oblique : 7
     * 	e_courier : 8
     * 	e_courier_bold : 9
     * 	e_courier_oblique : 10
     * 	e_courier_bold_oblique : 11
     * 	e_symbol : 12
     * 	e_zapf_dingbats : 13
     * 	e_null : 14
     * }
     * </pre>
     * @return {Promise<PDFNet.Font>} A promise that resolves to an object of type: "Font"
     */
    static createAndEmbed(doc: PDFNet.SDFDoc, type: number): Promise<PDFNet.Font>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.Font#destroy
     */
    destroy(): void;
    /**
     * @method PDFNet.Font#getType
     * @return {Promise<number>} A promise that resolves to font Type
     * @example Return value enum:
     * <pre>
     * PDFNet.Font.Type = {
     * 	e_Type1 : 0
     * 	e_TrueType : 1
     * 	e_MMType1 : 2
     * 	e_Type3 : 3
     * 	e_Type0 : 4
     * 	e_CIDType0 : 5
     * 	e_CIDType2 : 6
     * }
     * </pre>
     */
    getType(): Promise<number>;
    /**
     * @method PDFNet.Font#isSimple
     * @return {Promise<boolean>} A promise that resolves to true for non-CID based fonts such as Type1, TrueType, and Type3
     *
     * All simple fonts have the following properties:<BR><BR>
     *
     * Glyphs in the font are selected by single-byte character codes
     *   obtained from a string that is shown by the text-showing operators.
     *   Logically, these codes index into a table of 256 glyphs; the mapping
     *   from codes to glyphs is called the font's encoding. Each font program
     *   has a built-in encoding. Under some circumstances, the encoding can
     *   be altered by means described in Section 5.5.5 "Character Encoding" in
     *   PDF Reference Manual.<BR><BR>
     *
     * Each glyph has a single set of metrics. Therefore simple fonts support
     *   only horizontal writing mode.<BR><BR>
     */
    isSimple(): Promise<boolean>;
    /**
     *
     * @method PDFNet.Font.getTypeFromObj
     * @param {PDFNet.Obj} font_dict
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     * <pre>
     * PDFNet.Font.Type = {
     * 	e_Type1 : 0
     * 	e_TrueType : 1
     * 	e_MMType1 : 2
     * 	e_Type3 : 3
     * 	e_Type0 : 4
     * 	e_CIDType0 : 5
     * 	e_CIDType2 : 6
     * }
     * </pre>
     */
    static getTypeFromObj(font_dict: PDFNet.Obj): Promise<number>;
    /**
     * @method PDFNet.Font#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a SDF/Cos object of this Font.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Font#getDescriptor
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a SDF/Cos object representing FontDescriptor or NULL is FontDescriptor
     * is not present.
     */
    getDescriptor(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Font#getName
     * @return {Promise<string>} A promise that resolves to the name of a font. The behavior depends on the font type;
     * for a Type 3 font it gets the value of the Name key in a PDF Font resource.
     * For other types it gets the value of the BaseFont key in a PDF font resource.
     */
    getName(): Promise<string>;
    /**
     * @method PDFNet.Font#getFamilyName
     * @return {Promise<string>} A promise that resolves to the face's family name. This is an ASCII string, usually in English,
     * which describes the typeface's family (like 'Times New Roman', 'Bodoni', 'Garamond',
     * etc). This is a least common denominator used to list fonts.
     */
    getFamilyName(): Promise<string>;
    /**
     * @method PDFNet.Font#isFixedWidth
     * @return {Promise<boolean>} A promise that resolves to true if all glyphs have the same width
     */
    isFixedWidth(): Promise<boolean>;
    /**
     * @method PDFNet.Font#isSerif
     * @return {Promise<boolean>} A promise that resolves to true if glyphs have serifs
     */
    isSerif(): Promise<boolean>;
    /**
     * @method PDFNet.Font#isSymbolic
     * @return {Promise<boolean>} A promise that resolves to true if font contains characters outside the Adobe standard Latin character set.
     */
    isSymbolic(): Promise<boolean>;
    /**
     * @method PDFNet.Font#isItalic
     * @return {Promise<boolean>} A promise that resolves to true if glyphs have dominant vertical strokes that are slanted.
     */
    isItalic(): Promise<boolean>;
    /**
     * @method PDFNet.Font#isAllCap
     * @return {Promise<boolean>} A promise that resolves to true if font contains no lowercase letters
     */
    isAllCap(): Promise<boolean>;
    /**
     * @method PDFNet.Font#isForceBold
     * @return {Promise<boolean>} A promise that resolves to true if bold glyphs should be painted with extra pixels at very small text sizes.
     */
    isForceBold(): Promise<boolean>;
    /**
     * @method PDFNet.Font#isHorizontalMode
     * @return {Promise<boolean>} A promise that resolves to true if the font uses horizontal writing mode, false for vertical writing mode.
     */
    isHorizontalMode(): Promise<boolean>;
    /**
     *
     * @method PDFNet.Font#getWidth
     * @param {number} char_code
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     */
    getWidth(char_code: number): Promise<number>;
    /**
     * @method PDFNet.Font#getMaxWidth
     * @return {Promise<number>} A promise that resolves to the maximal advance width, in font units, for all glyphs in this face.
     */
    getMaxWidth(): Promise<number>;
    /**
     * @method PDFNet.Font#getMissingWidth
     * @return {Promise<number>} A promise that resolves to the default width to use for character codes whose widths are
     * not specified in a font dictionary's Widths array.
     */
    getMissingWidth(): Promise<number>;
    /**
     * GetCharCodeIterator represents an iterator interface used to traverse
     * a list of char codes for which there is a glyph outline in the embedded font.
     * @method PDFNet.Font#getCharCodeIterator
     * @return {Promise<PDFNet.Iterator>} A promise that resolves to an object of type: "Iterator"
     */
    getCharCodeIterator(): Promise<PDFNet.Iterator>;
    /**
     * @method PDFNet.Font#getEncoding
     * @return {Promise<string>} A promise that resolves to the font's encoding array (the mapping of character codes to glyphs).
     * The array contains 256 pointers. If a pointer is not NULL, it points to a
     * C string containing the name of the glyph for the code point corresponding
     * to the index. If it is NULL, then the name of the glyph is unchanged from
     * that specified by the font's built-in encoding.
     *
     * For a Type 3 font, all glyph names will be present in the encoding array,
     * and NULL entries correspond to un-encoded code points.
     *
     * @note The Font object is the owner of the array.
     * @note This function is not applicable to composite fonts (e_type0, e_CIDType0,
     * and e_CIDType2) and will throw an exception.
     */
    getEncoding(): Promise<string>;
    /**
     * Tests whether or not the specified font is stored as a font file in a stream
     * embedded in the PDF file.
     *
     * @method PDFNet.Font#isEmbedded
     * @return {Promise<boolean>} A promise that resolves to true if the font is embedded in the file, false otherwise.
     */
    isEmbedded(): Promise<boolean>;
    /**
     * @method PDFNet.Font#getEmbeddedFontName
     * @return {Promise<string>} A promise that resolves to the PostScript font name for the embedded font. If the embedded font
     * name is not available the function returns the empty string .
     */
    getEmbeddedFontName(): Promise<string>;
    /**
     * @method PDFNet.Font#getEmbeddedFont
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the stream object of the embedded font or NULL if there if the
     * font is not embedded.
     * @note This function is not applicable to Type3 font and will throw exception.
     */
    getEmbeddedFont(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Font#getEmbeddedFontBufSize
     * @return {Promise<number>} A promise that resolves to the size of decoded buffer containing embedded font data or 0
     * if this information is not known in advance.
     *
     * @note The size of decoded buffer may not be known in advance for all
     * fonts and may not be correct.
     * @note This function is not applicable to Type3 font and will throw exception.
     */
    getEmbeddedFontBufSize(): Promise<number>;
    /**
     * @method PDFNet.Font#getUnitsPerEm
     * @return {Promise<number>} A promise that resolves to the number of font units per EM square for this face. This is
     * typically 2048 for TrueType fonts, 1000 for Type1 fonts
     *
     * @note Only relevant for scalable formats (such as TrueType and Type1).
     *
     * @note This function is not applicable to Type3 font and will throw an exception.
     * Use GetType3FontMatrix instead.
     */
    getUnitsPerEm(): Promise<number>;
    /**
     * @method PDFNet.Font#getBBox
     * @return {Promise<PDFNet.Rect>} A promise that resolves to a rectangle expressed in the glyph coordinate system, specifying the
     * font bounding box. This is the smallest rectangle enclosing the shape that would
     * result if all of the glyphs of the font were placed with their origins coincident
     * and then filled.
     */
    getBBox(): Promise<PDFNet.Rect>;
    /**
     * The face's ascender is the vertical distance from the baseline to the topmost
     * point of any glyph in the face. This field's value is a positive number, expressed
     * in the glyph coordinate system. For all font types except Type 3, the units of
     * glyph space are one-thousandth of a unit of text space. Some font designs use
     * a value different from 'bbox.yMax'.
     *
     * @method PDFNet.Font#getAscent
     * @note Only relevant for scalable formats.
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     */
    getAscent(): Promise<number>;
    /**
     * The face's descender is the vertical distance from the baseline to the bottommost
     * point of any glyph in the face. This field's value is a negative number expressed
     * in the glyph coordinate system. For all font types except Type 3, the units of
     * glyph space are one-thousandth of a unit of text space. Some font designs use
     * a value different from 'bbox.yMin'.
     *
     * @method PDFNet.Font#getDescent
     * @note Only relevant for scalable formats.
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     */
    getDescent(): Promise<number>;
    /**
     * @method PDFNet.Font#getStandardType1FontType
     * @return {Promise<number>} A promise that resolves to font::e_null if the font is not a standard Type1 font or some
     * other StandardType1Font value for a standard Type1 font.
     */
    getStandardType1FontType(): Promise<number>;
    /**
     * @method PDFNet.Font#isCFF
     * @return {Promise<boolean>} A promise that resolves to true if the embedded font is represented as CFF (Compact Font Format).
     * @note Only Type1 and Type1C fonts can be represented in CFF format
     */
    isCFF(): Promise<boolean>;
    /**
     * @method PDFNet.Font#getType3FontMatrix
     * @return {Promise<PDFNet.Matrix2D>} A promise that resolves to type3 font matrix, mapping glyph space to text space
     * A common practice is to define glyphs in terms of a 1000-unit
     * glyph coordinate system, in which case the font matrix is [0.001 0 0 0.001 0 0].
     *
     * @note Relevant only for a Type3 font.
     */
    getType3FontMatrix(): Promise<PDFNet.Matrix2D>;
    /**
     *
     * @method PDFNet.Font#getType3GlyphStream
     * @param {number} char_code
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    getType3GlyphStream(char_code: number): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Font#getVerticalAdvance
     * @return {Promise<number>} A promise that resolves to vertical advance. vertical advance is a displacement vector for vertical
     * writing mode (i.e. writing mode 1); its horizontal component is always 0.
     *
     * @param {number} char_code character to query for vertical advance
     * @note Use this method only for composite fonts with vertical writing mode
     * (i.e. if Font.IsHorizontalMode() returns false). The method will return 0 as vertical
     * advance for simple fonts or for composite fonts with only horizontal writing mode.
     * @note Relevant only for a Type0 font.
     */
    getVerticalAdvance(char_code: number): Promise<number>;
    /**
     * @method PDFNet.Font#getDescendant
     * @return {Promise<PDFNet.Font>} A promise that resolves to descendant CIDFont.
     *
     * @note Relevant only for a Type0 font.
     */
    getDescendant(): Promise<PDFNet.Font>;
    /**
     *
     * @method PDFNet.Font#mapToCID
     * @param {number} char_code
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     */
    mapToCID(char_code: number): Promise<number>;
    /**
     * The function maps charcode (out_charcode) from char_data buffer to a CID (out_cid) and
     * return the number of bytes representing the CID in the buffer.
     *
     * @method PDFNet.Font#mapToCID2
     * @param {number} char_data the input data buffer containing one or more bytes of input charcode
     * @param {number} char_data_avail the number of bytes in the char_data buffer
     * @return {Promise<number>} A promise that resolves to the number of bytes consumed by out_cid. This number must be less than or equal to
     * char_data_avail
     *
     * @note Relevant only for a Type0 font.
     */
    mapToCID2(char_data: number, char_data_avail: number): Promise<number>;
  }
  /**
   * A FreeText annotation (PDF 1.3) displays text directly on the page.
   * Unlike an ordinary Text annotation, a FreeText annotation has no
   * open or closed state; The content of the FreeText annotation is always
   * visible instead of being displayed in a popup window.
   * @class
   * @name FreeTextAnnot
   * @memberof PDFNet
   */
  class FreeTextAnnot {
    /**
     * creates a FreeText annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.FreeTextAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.FreeTextAnnot>} A promise that resolves to an object of type: "FreeTextAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.FreeTextAnnot>;
    /**
     * creates a FreeText annotation and initializes it using given annotation object.
     * @method PDFNet.FreeTextAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the FreeText annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.FreeTextAnnot>} A promise that resolves to an object of type: "FreeTextAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.FreeTextAnnot>;
    /**
     * Creates a new FreeText annotation in the specified document.
     *
     * @method PDFNet.FreeTextAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the FreeText annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the FreeText annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.FreeTextAnnot>} A promise that resolves to a newly created blank FreeText annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.FreeTextAnnot>;
    /**
     * Returns the default appearance of the FreeText annotation.
     *
     * @method PDFNet.FreeTextAnnot#getDefaultAppearance
     * @return {Promise<string>} A promise that resolves to a string representing the default appearance of the annotation.
     * @note The default appearance string is used to format the text.
     * The annotation dictionary's Appearance entry, if present,
     * will take precedence over this entry.
     * @note this method corresponds to the 'DA' entry in the annotation dictionary.
     */
    getDefaultAppearance(): Promise<string>;
    /**
     * sets the default appearance of the FreeText annotation.
     *
     * @method PDFNet.FreeTextAnnot#setDefaultAppearance
     * @param {string} app_str A string representing the default appearance of the annotation.
     * @note The default appearance string is used to format the text.
     * The annotation dictionary's Appearance entry, if present,
     * will take precedence over this entry.
     * @note this method corresponds to the 'DA' entry in the annotation dictionary.
     */
    setDefaultAppearance(app_str: string): void;
    /**
     * Returns the quading format of the FreeText annotation.
     * (PDF 1.4)
     *
     * @method PDFNet.FreeTextAnnot#getQuaddingFormat
     * @return {Promise<number>} A promise that resolves to a int (code) indicating the quading format of the FreeText annotation.
     * @note The following are the quading formats corresponding to each int code.
     * 0 Left-justified
     * 1 Centered
     * 2 Right-justified
     */
    getQuaddingFormat(): Promise<number>;
    /**
     * Sets the quading format of the FreeText annotation.
     * (Optional; PDF 1.4)
     *
     * @method PDFNet.FreeTextAnnot#setQuaddingFormat
     * @param {number} format A int code indicating the quading format of the FreeText annotation.
     * Default value: 0 (left-justified).
     * @note The int code specifies the form of quadding (justification)
     * that shall be used in displaying the annotation's text:
     * 0 Left-justified
     * 1 Centered
     * 2 Right-justified
     */
    setQuaddingFormat(format: number): void;
    /**
     *
     * @method PDFNet.FreeTextAnnot#getCalloutLinePoints
     * @param {PDFNet.Point} p1
     * @param {PDFNet.Point} p2
     * @param {PDFNet.Point} p3
     */
    getCalloutLinePoints(p1: PDFNet.Point, p2: PDFNet.Point, p3: PDFNet.Point): void;
    /**
     * sets the callout line points of the FreeText annotation.
     * (Optional; meaningful only if IT is FreeTextCallout; PDF 1.6)
     *
     * @method PDFNet.FreeTextAnnot#setCalloutLinePoints
     * @param {PDFNet.Point} p1 The target point. (where the ending style is used)
     * @param {PDFNet.Point} p2 The knee point.
     * @param {PDFNet.Point} p3 The ending point.
     * @note The coordinates are defined in default user space.
     */
    setCalloutLinePoints(p1: PDFNet.Point, p2: PDFNet.Point, p3: PDFNet.Point): void;
    /**
     * sets the callout line points of the FreeText annotation.
     * (Optional; meaningful only if IT is FreeTextCallout; PDF 1.6)
     *
     * @method PDFNet.FreeTextAnnot#setCalloutLinePointsTwo
     * @param {PDFNet.Point} p1 The target point. (where the ending style is used)
     * @param {PDFNet.Point} p2 The ending point.
     * @note The coordinates are defined in default user space.
     */
    setCalloutLinePointsTwo(p1: PDFNet.Point, p2: PDFNet.Point): void;
    /**
     * Returns Intent name of the FreeText annotation.
     * (PDF 1.4)
     *
     * @method PDFNet.FreeTextAnnot#getIntentName
     * @return {Promise<number>} A promise that resolves tos The intent name of the annotation as
     * an entry from the enum "IntentName".
     * @example Return value enum:
     * <pre>
     * PDFNet.FreeTextAnnot.IntentName = {
     * 	e_FreeText : 0
     * 	e_FreeTextCallout : 1
     * 	e_FreeTextTypeWriter : 2
     * 	e_Unknown : 3
     * }
     * </pre>
     */
    getIntentName(): Promise<number>;
    /**
     * Sets the Intent name of the FreeText annotation.
     * (Optional; PDF 1.4)
     *
     * @method PDFNet.FreeTextAnnot#setIntentName
     * @param {number} [mode]
     * <pre>
     * PDFNet.FreeTextAnnot.IntentName = {
     * 	e_FreeText : 0
     * 	e_FreeTextCallout : 1
     * 	e_FreeTextTypeWriter : 2
     * 	e_Unknown : 3
     * }
     * </pre>
     * The intent name of the annotation as
     * an entry from the enum "IntentName".
     */
    setIntentName(mode?: number): void;
    /**
     *
     * @method PDFNet.FreeTextAnnot#setIntentNameDefault
     */
    setIntentNameDefault(): void;
    /**
     * Returns the ending style of the callout line of the FreeText Annotation.
     *
     * @method PDFNet.FreeTextAnnot#getEndingStyle
     * @return {Promise<number>} A promise that resolves to the ending style represented as one of the entries of the enum "EndingStyle"
     * @note The ending style specifies the line ending style that
     * shall be used in drawing the callout line specified in CallOut Line Points
     * (CL). The enum entry shall specify the line ending style for the endpoint
     * defined by the target point(p1) of the CallOut Line Points.
     * Default value: e_None.
     * @example Return value enum:
     * <pre>
     * PDFNet.LineAnnot.EndingStyle = {
     * 	e_Square : 0
     * 	e_Circle : 1
     * 	e_Diamond : 2
     * 	e_OpenArrow : 3
     * 	e_ClosedArrow : 4
     * 	e_Butt : 5
     * 	e_ROpenArrow : 6
     * 	e_RClosedArrow : 7
     * 	e_Slash : 8
     * 	e_None : 9
     * 	e_Unknown : 10
     * }
     * </pre>
     */
    getEndingStyle(): Promise<number>;
    /**
     * Sets the ending style of the callout line of the FreeText Annotation.
     * (Optional; meaningful only if CL is present; PDF 1.6)
     *
     * @method PDFNet.FreeTextAnnot#setEndingStyle
     * @param {number} style
     * <pre>
     * PDFNet.LineAnnot.EndingStyle = {
     * 	e_Square : 0
     * 	e_Circle : 1
     * 	e_Diamond : 2
     * 	e_OpenArrow : 3
     * 	e_ClosedArrow : 4
     * 	e_Butt : 5
     * 	e_ROpenArrow : 6
     * 	e_RClosedArrow : 7
     * 	e_Slash : 8
     * 	e_None : 9
     * 	e_Unknown : 10
     * }
     * </pre>
     * The ending style represented using one of the
     * entries of the enum "EndingStyle"
     * @note The ending style specifies the line ending style that
     * shall be used in drawing the callout line specified in CallOut Line Points
     * (CL). The enum entry shall specify the line ending style for the endpoint
     * defined by the target point(p1) of the CallOut Line Points.
     * Default value: e_None.
     */
    setEndingStyle(style: number): void;
    /**
     * sets the ending style of the callout line of the FreeText Annotation.
     * (Optional; meaningful only if CL is present; PDF 1.6)
     *
     * @method PDFNet.FreeTextAnnot#setEndingStyleName
     * @param {string} est The ending style represented using a string.
     * @note The ending style specifies the line ending style that
     * shall be used in drawing the callout line specified in CallOut Line Points
     * (CL). The enum entry shall specify the line ending style for the endpoint
     * defined by the target point(p1) of the CallOut Line Points.
     * Default value: "None".
     */
    setEndingStyleName(est: string): void;
    /**
     * sets the text color of the FreeText Annotation.
     *
     * @method PDFNet.FreeTextAnnot#setTextColor
     * @param {PDFNet.ColorPt} color ColorPt object representing the color.
     * @param {number} col_comp number of colorant components in ColorPt object.
     *
     * @note Current implementation of this method creates a non-standard
     * entry in the annotation dictionary and uses it to generate the appearance
     * stream. Make sure you call RefreshAppearance() after changing text or
     * line color, and remember that editing the annotation in other PDF
     * applications will produce different appearance.
     */
    setTextColor(color: PDFNet.ColorPt, col_comp: number): void;
    /**
     *
     * @method PDFNet.FreeTextAnnot#getTextColor
     * @param {number} col_comp
     */
    getTextColor(col_comp: number): void;
    /**
     * sets the line and border color of the FreeText Annotation.
     *
     * @method PDFNet.FreeTextAnnot#setLineColor
     * @param {PDFNet.ColorPt} color ColorPt object representing the color.
     * @param {number} col_comp number of colorant components in ColorPt object.
     *
     * @note Current implementation of this method creates a non-standard
     * entry in the annotation dictionary and uses it to generate the appearance
     * stream. Make sure you call RefreshAppearance() after changing text or
     * line color, and remember that editing the annotation in other PDF
     * applications will produce different appearance.
     */
    setLineColor(color: PDFNet.ColorPt, col_comp: number): void;
    /**
     *
     * @method PDFNet.FreeTextAnnot#getLineColor
     * @param {number} col_comp
     */
    getLineColor(col_comp: number): void;
    /**
     * Sets the default appearance font size. A value of zero specifies
     * that the font size should should adjust so that the text uses
     * as much of the FreeText bounding box as possible.
     *
     * @method PDFNet.FreeTextAnnot#setFontSize
     * @param {number} font_size Set the default font size. A value of zero means
     * auto resize font.
     */
    setFontSize(font_size: number): void;
    /**
     * Get the default appearance font size. To get the actual font
     * size used, call RefreshAppearance and then use ElementReader
     * on the content stream of this annotation.
     *
     * @method PDFNet.FreeTextAnnot#getFontSize
     * @return {Promise<number>} A promise that resolves tos the default font size, where a value of zero indicates
     * auto sizing.
     */
    getFontSize(): Promise<number>;
  }
  /**
   * Although PDF is not a programming language it provides several types of function
   * object that represent parameterized classes of functions, including mathematical
   * formulas and sampled representations with arbitrary resolution. Functions are used
   * in various ways in PDF, including device-dependent rasterization information for
   * high-quality printing (halftone spot functions and transfer functions), color
   * transform functions for certain color spaces, and specification of colors as a
   * function of position for smooth shadings. Functions in PDF represent static,
   * self-contained numerical transformations.<br><br>
   *
   * PDF::Function represents a single, flat interface around all PDF function types.
   * @class
   * @name Function
   * @memberof PDFNet
   */
  class Function {
    /**
     *
     * @method PDFNet.Function.create
     * @param {PDFNet.Obj} [funct_dict]
     * @return {Promise<PDFNet.Function>} A promise that resolves to an object of type: "Function"
     */
    static create(funct_dict?: PDFNet.Obj): Promise<PDFNet.Function>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.Function#destroy
     */
    destroy(): void;
    /**
     * @method PDFNet.Function#getType
     * @return {Promise<number>} A promise that resolves to the function type
     * @example Return value enum:
     * <pre>
     * PDFNet.Function.Type = {
     * 	e_sampled : 0
     * 	e_exponential : 2
     * 	e_stitching : 3
     * 	e_postscript : 4
     * }
     * </pre>
     */
    getType(): Promise<number>;
    /**
     * @method PDFNet.Function#getInputCardinality
     * @return {Promise<number>} A promise that resolves to the number of input components required by the function
     */
    getInputCardinality(): Promise<number>;
    /**
     * @method PDFNet.Function#getOutputCardinality
     * @return {Promise<number>} A promise that resolves to the number of output components returned by the function
     */
    getOutputCardinality(): Promise<number>;
    /**
     *
     * @method PDFNet.Function#eval
     * @param {number} inval
     * @param {number} outval
     */
    eval(inval: number, outval: number): void;
    /**
     * @method PDFNet.Function#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the underlying SDF/Cos object
     */
    getSDFObj(): Promise<PDFNet.Obj>;
  }
  /**
   * GState is a class that keeps track of a number of style attributes used to visually
   * define graphical Elements. Each PDF::Element has an associated GState that can be used to
   * query or set various graphics properties.
   *
   * @note current clipping path is not tracked in the graphics state for efficiency
   * reasons. In most cases tracking of the current clipping path is best left to the
   * client.
   * @class
   * @name GState
   * @memberof PDFNet
   */
  class GState {
    /**
     * @method PDFNet.GState#getTransform
     * @return {Promise<PDFNet.Matrix2D>} A promise that resolves to the transformation matrix for this element.
     * @note If you are looking for a matrix that maps coordinates to the initial
     * user space see Element::GetCTM().
     */
    getTransform(): Promise<PDFNet.Matrix2D>;
    /**
     * @method PDFNet.GState#getStrokeColorSpace
     * @return {Promise<PDFNet.ColorSpace>} A promise that resolves to color space used for stroking
     */
    getStrokeColorSpace(): Promise<PDFNet.ColorSpace>;
    /**
     * @method PDFNet.GState#getFillColorSpace
     * @return {Promise<PDFNet.ColorSpace>} A promise that resolves to color space used for filling
     */
    getFillColorSpace(): Promise<PDFNet.ColorSpace>;
    /**
     * @method PDFNet.GState#getStrokeColor
     * @return {Promise<PDFNet.ColorPt>} A promise that resolves to a color value/point represented in the current stroke color space
     */
    getStrokeColor(): Promise<PDFNet.ColorPt>;
    /**
     * @method PDFNet.GState#getStrokePattern
     * @return {Promise<PDFNet.PatternColor>} A promise that resolves to the SDF pattern object of currently selected PatternColorSpace used for stroking.
     */
    getStrokePattern(): Promise<PDFNet.PatternColor>;
    /**
     * @method PDFNet.GState#getFillColor
     * @return {Promise<PDFNet.ColorPt>} A promise that resolves to a color value/point represented in the current fill color space
     */
    getFillColor(): Promise<PDFNet.ColorPt>;
    /**
     * @method PDFNet.GState#getFillPattern
     * @return {Promise<PDFNet.PatternColor>} A promise that resolves to the pattern color of currently selected pattern color space used for filling.
     */
    getFillPattern(): Promise<PDFNet.PatternColor>;
    /**
     * @method PDFNet.GState#getFlatness
     * @return {Promise<number>} A promise that resolves to current value of flatness tolerance
     *
     * Flatness is a number in the range 0 to 100; a value of 0 specifies the output
     * device's default flatness tolerance.
     *
     * The flatness tolerance controls the maximum permitted distance in device pixels
     * between the mathematically correct path and an approximation constructed from
     * straight line segments.
     */
    getFlatness(): Promise<number>;
    /**
     * @method PDFNet.GState#getLineCap
     * @return {Promise<number>} A promise that resolves to currently selected LineCap style
     *
     * The line cap style specifies the shape to be used at the ends of open sub-paths
     * (and dashes, if any) when they are stroked.
     * @example Return value enum:
     * <pre>
     * PDFNet.GState.LineCap = {
     * 	e_butt_cap : 0
     * 	e_round_cap : 1
     * 	e_square_cap : 2
     * }
     * </pre>
     */
    getLineCap(): Promise<number>;
    /**
     * @method PDFNet.GState#getLineJoin
     * @return {Promise<number>} A promise that resolves to currently selected LineJoin style
     *
     * The line join style specifies the shape to be used at the corners of paths that
     * are stroked.
     * @example Return value enum:
     * <pre>
     * PDFNet.GState.LineJoin = {
     * 	e_miter_join : 0
     * 	e_round_join : 1
     * 	e_bevel_join : 2
     * }
     * </pre>
     */
    getLineJoin(): Promise<number>;
    /**
     * @method PDFNet.GState#getLineWidth
     * @return {Promise<number>} A promise that resolves to the thickness of the line used to stroke a path.
     * @note A line width of 0 denotes the thinnest line that can be rendered at device
     * resolution: 1 device pixel wide.
     */
    getLineWidth(): Promise<number>;
    /**
     * @method PDFNet.GState#getMiterLimit
     * @return {Promise<number>} A promise that resolves to current value of miter limit.
     *
     * The miter limit imposes a maximum on the ratio of the miter length to the
     * line width. When the limit is exceeded, the join is converted from a miter
     * to a bevel.
     */
    getMiterLimit(): Promise<number>;
    /**
     * @method PDFNet.GState#getPhase
     * @return {Promise<number>} A promise that resolves to the phase of the currently selected dash pattern. dash phase is expressed in
     * user space units.
     */
    getPhase(): Promise<number>;
    /**
     * @method PDFNet.GState#getCharSpacing
     * @return {Promise<number>} A promise that resolves to currently selected character spacing.
     *
     * The character spacing parameter is a number specified in unscaled text space
     * units. When the glyph for each character in the string is rendered, the character
     * spacing is added to the horizontal or vertical component of the glyph's displacement,
     * depending on the writing mode. See Section 5.2.1 in PDF Reference Manual for details.
     */
    getCharSpacing(): Promise<number>;
    /**
     * @method PDFNet.GState#getWordSpacing
     * @return {Promise<number>} A promise that resolves to currently selected word spacing
     *
     * Word spacing works the same way as character spacing, but applies only to the
     * space character (char code 32). See Section 5.2.2 in PDF Reference Manual for details.
     */
    getWordSpacing(): Promise<number>;
    /**
     * @method PDFNet.GState#getHorizontalScale
     * @return {Promise<number>} A promise that resolves to currently selected horizontal scale
     *
     * The horizontal scaling parameter adjusts the width of glyphs by stretching
     * or compressing them in the horizontal direction. Its value is specified as
     * a percentage of the normal width of the glyphs, with 100 being the normal width.
     * The scaling always applies to the horizontal coordinate in text space, independently
     * of the writing mode. See Section 5.2.3 in PDF Reference Manual for details.
     */
    getHorizontalScale(): Promise<number>;
    /**
     * @method PDFNet.GState#getLeading
     * @return {Promise<number>} A promise that resolves to currently selected leading parameter
     *
     * The leading parameter is measured in unscaled text space units. It specifies
     * the vertical distance between the baselines of adjacent lines of text.
     * See Section 5.2.4 in PDF Reference Manual for details.
     */
    getLeading(): Promise<number>;
    /**
     * @method PDFNet.GState#getFont
     * @return {Promise<PDFNet.Font>} A promise that resolves to currently selected font
     */
    getFont(): Promise<PDFNet.Font>;
    /**
     * @method PDFNet.GState#getFontSize
     * @return {Promise<number>} A promise that resolves to the font size
     */
    getFontSize(): Promise<number>;
    /**
     * @method PDFNet.GState#getTextRenderMode
     * @return {Promise<number>} A promise that resolves to current text rendering mode.
     *
     * The text rendering mode determines whether showing text causes glyph outlines to
     * be stroked, filled, used as a clipping boundary, or some combination of the three.
     * See Section 5.2.5 in PDF Reference Manual for details..
     * @example Return value enum:
     * <pre>
     * PDFNet.GState.TextRenderingMode = {
     * 	e_fill_text : 0
     * 	e_stroke_text : 1
     * 	e_fill_stroke_text : 2
     * 	e_invisible_text : 3
     * 	e_fill_clip_text : 4
     * 	e_stroke_clip_text : 5
     * 	e_fill_stroke_clip_text : 6
     * 	e_clip_text : 7
     * }
     * </pre>
     */
    getTextRenderMode(): Promise<number>;
    /**
     * @method PDFNet.GState#getTextRise
     * @return {Promise<number>} A promise that resolves to current value of text rise
     *
     * Text rise specifies the distance, in unscaled text space units, to move the
     * baseline up or down from its default location. Positive values of text rise
     * move the baseline up
     */
    getTextRise(): Promise<number>;
    /**
     * @method PDFNet.GState#isTextKnockout
     * @return {Promise<boolean>} A promise that resolves to a boolean flag that determines the text element is considered
     * elementary objects for purposes of color compositing in the transparent imaging
     * model.
     */
    isTextKnockout(): Promise<boolean>;
    /**
     * @method PDFNet.GState#getRenderingIntent
     * @return {Promise<number>} A promise that resolves to the color intent to be used for rendering the Element
     * @example Return value enum:
     * <pre>
     * PDFNet.GState.RenderingIntent = {
     * 	e_absolute_colorimetric : 0
     * 	e_relative_colorimetric : 1
     * 	e_saturation : 2
     * 	e_perceptual : 3
     * }
     * </pre>
     */
    getRenderingIntent(): Promise<number>;
    /**
     * A utility function that maps a string representing a rendering intent to
     * RenderingIntent type.
     * @method PDFNet.GState.getRenderingIntentType
     * @param {string} name string that represents the rendering intent to get.
     * @return {Promise<number>} A promise that resolves to the color rendering intent type matching the specified string
     * @example Return value enum:
     * <pre>
     * PDFNet.GState.RenderingIntent = {
     * 	e_absolute_colorimetric : 0
     * 	e_relative_colorimetric : 1
     * 	e_saturation : 2
     * 	e_perceptual : 3
     * }
     * </pre>
     */
    static getRenderingIntentType(name: string): Promise<number>;
    /**
     * @method PDFNet.GState#getBlendMode
     * @return {Promise<number>} A promise that resolves to the current blend mode to be used in the transparent imaging model.
     * Corresponds to the /BM key within the ExtGState's dictionary.
     * @example Return value enum:
     * <pre>
     * PDFNet.GState.BlendMode = {
     * 	e_bl_compatible : 0
     * 	e_bl_normal : 1
     * 	e_bl_multiply : 2
     * 	e_bl_screen : 3
     * 	e_bl_difference : 4
     * 	e_bl_darken : 5
     * 	e_bl_lighten : 6
     * 	e_bl_color_dodge : 7
     * 	e_bl_color_burn : 8
     * 	e_bl_exclusion : 9
     * 	e_bl_hard_light : 10
     * 	e_bl_overlay : 11
     * 	e_bl_soft_light : 12
     * 	e_bl_luminosity : 13
     * 	e_bl_hue : 14
     * 	e_bl_saturation : 15
     * 	e_bl_color : 16
     * }
     * </pre>
     */
    getBlendMode(): Promise<number>;
    /**
     * @method PDFNet.GState#getFillOpacity
     * @return {Promise<number>} A promise that resolves to the opacity value for painting operations other than stroking.
     * Returns the value of the /ca key in the ExtGState dictionary. If the value is not
     * found, the default value of 1 is returned.
     */
    getFillOpacity(): Promise<number>;
    /**
     * @method PDFNet.GState#getStrokeOpacity
     * @return {Promise<number>} A promise that resolves to opacity value for stroke painting operations for paths and glyph outlines.
     * Returns the value of the /CA key in the ExtGState dictionary. If the value is not
     * found, the default value of 1 is returned.
     */
    getStrokeOpacity(): Promise<number>;
    /**
     * @method PDFNet.GState#getAISFlag
     * @return {Promise<boolean>} A promise that resolves to the alpha source flag ('alpha is shape'), specifying whether the
     * current soft mask and alpha constant are to be interpreted as shape values
     * (true) or opacity values (false).
     */
    getAISFlag(): Promise<boolean>;
    /**
     * @method PDFNet.GState#getSoftMask
     * @return {Promise<PDFNet.Obj>} A promise that resolves to associated soft mask. NULL if the soft mask is not selected or
     * SDF dictionary representing the soft mask otherwise.
     */
    getSoftMask(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.GState#getSoftMaskTransform
     * @return {Promise<PDFNet.Matrix2D>} A promise that resolves to the soft mask transform. This is the transformation matrix at the moment the soft
     * mask is established in the graphics state with the gs operator. This information is only
     * relevant when applying the soft mask that may be specified in the graphics state to the
     * current element.
     */
    getSoftMaskTransform(): Promise<PDFNet.Matrix2D>;
    /**
     * @method PDFNet.GState#getStrokeOverprint
     * @return {Promise<boolean>} A promise that resolves to whether overprint is enabled for stroke painting operations.
     * Corresponds to the /OP key within the ExtGState's dictionary.
     */
    getStrokeOverprint(): Promise<boolean>;
    /**
     * @method PDFNet.GState#getFillOverprint
     * @return {Promise<boolean>} A promise that resolves to whether overprint is enabled for fill painting operations.
     * Corresponds to the /op key within the ExtGState's dictionary.
     */
    getFillOverprint(): Promise<boolean>;
    /**
     * @method PDFNet.GState#getOverprintMode
     * @return {Promise<number>} A promise that resolves to the overprint mode used by this graphics state.
     * Corresponds to the /OPM key within the ExtGState's dictionary.
     */
    getOverprintMode(): Promise<number>;
    /**
     * @method PDFNet.GState#getAutoStrokeAdjust
     * @return {Promise<boolean>} A promise that resolves to a flag specifying whether stroke adjustment is enabled in the graphics
     * state. Corresponds to the /SA key within the ExtGState's dictionary.
     */
    getAutoStrokeAdjust(): Promise<boolean>;
    /**
     * @method PDFNet.GState#getSmoothnessTolerance
     * @return {Promise<number>} A promise that resolves to the smoothness tolerance used to control the quality of smooth
     * shading. Corresponds to the /SM key within the ExtGState's dictionary.
     * The allowable error (or tolerance) is expressed as a fraction of the range
     * of the color component, from 0.0 to 1.0.
     */
    getSmoothnessTolerance(): Promise<number>;
    /**
     * @method PDFNet.GState#getTransferFunct
     * @return {Promise<PDFNet.Obj>} A promise that resolves to currently selected transfer function (NULL by default) used during
     * color conversion process. A transfer function adjusts the values of color
     * components to compensate for nonlinear response in an output device and in
     * the human eye. Corresponds to the /TR key within the ExtGState's dictionary.
     */
    getTransferFunct(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.GState#getBlackGenFunct
     * @return {Promise<PDFNet.Obj>} A promise that resolves to currently selected black-generation function (NULL by default) used
     * during conversion between DeviceRGB and DeviceCMYK. Corresponds to the /BG key
     * within the ExtGState's dictionary.
     */
    getBlackGenFunct(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.GState#getUCRFunct
     * @return {Promise<PDFNet.Obj>} A promise that resolves to currently selected undercolor-removal function (NULL by default) used
     * during conversion between DeviceRGB and DeviceCMYK. Corresponds to the /UCR key
     * within the ExtGState's dictionary.
     */
    getUCRFunct(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.GState#getHalftone
     * @return {Promise<PDFNet.Obj>} A promise that resolves to currently selected halftone dictionary or stream (NULL by default).
     * Corresponds to the /HT key within the ExtGState's dictionary.
     * Halftoning is a process by which continuous-tone colors are approximated on an
     * output device that can achieve only a limited number of discrete colors.
     */
    getHalftone(): Promise<PDFNet.Obj>;
    /**
     * Set the transformation matrix associated with this element.
     *
     * @method PDFNet.GState#setTransformMatrix
     * @param {PDFNet.Matrix2D} mtx The new transformation for this text element.
     *
     * @note in PDF associating a transformation matrix with an element
     * ('cm' operator) will also affect all subsequent elements.
     */
    setTransformMatrix(mtx: PDFNet.Matrix2D): void;
    /**
     * Set the transformation matrix associated with this element.
     *
     * A transformation matrix in PDF is specified by six numbers, usually
     * in the form of an array containing six elements. In its most general
     * form, this array is denoted [a b c d h v]; it can represent any linear
     * transformation from one coordinate system to another. For more
     * information about PDF matrices please refer to section 4.2.2 'Common
     * Transformations' in PDF Reference Manual, and to documentation for
     * pdftron::Common::Matrix2D class.
     *
     * @method PDFNet.GState#setTransform
     * @param {number} a horizontal 'scaling' component of the new text matrix.
     * @param {number} b 'rotation' component of the new text matrix.
     * @param {number} c vertical 'scaling' component of the new text matrix.
     * @param {number} d 'rotation' component of the new text matrix.
     * @param {number} h horizontal translation component of the new text matrix.
     * @param {number} v vertical translation component of the new text matrix.
     */
    setTransform(a: number, b: number, c: number, d: number, h: number, v: number): void;
    /**
     * Concatenate the given matrix to the transformation matrix of this element.
     * @method PDFNet.GState#concatMatrix
     * @param {PDFNet.Matrix2D} mtx Matrix2D object to concatenate the current matrix with.
     */
    concatMatrix(mtx: PDFNet.Matrix2D): void;
    /**
     * Concatenate the given matrix expressed in its values to the transformation
     * matrix of this element.
     * @method PDFNet.GState#concat
     * @param {number} a horizontal 'scaling' component of the new text matrix.
     * @param {number} b 'rotation' component of the new text matrix.
     * @param {number} c vertical 'scaling' component of the new text matrix.
     * @param {number} d 'rotation' component of the new text matrix.
     * @param {number} h horizontal translation component of the new text matrix.
     * @param {number} v vertical translation component of the new text matrix.
     */
    concat(a: number, b: number, c: number, d: number, h: number, v: number): void;
    /**
     * Sets the color space used for stroking operations
     * @method PDFNet.GState#setStrokeColorSpace
     * @param {PDFNet.ColorSpace} cs ColorSpace object to use for stroking operations
     */
    setStrokeColorSpace(cs: PDFNet.ColorSpace): void;
    /**
     * Sets the color space used for filling operations
     * @method PDFNet.GState#setFillColorSpace
     * @param {PDFNet.ColorSpace} cs ColorSpace object to use for filling operations
     */
    setFillColorSpace(cs: PDFNet.ColorSpace): void;
    /**
     * Sets the color value/point used for stroking operations.
     * @method PDFNet.GState#setStrokeColorWithColorPt
     * @param {PDFNet.ColorPt} c is the color used for stroking operations
     * @note The color value must be represented in the currently selected color space used
     * for stroking.
     */
    setStrokeColorWithColorPt(c: PDFNet.ColorPt): void;
    /**
     * Set the stroke color to the given tiling pattern.
     * @method PDFNet.GState#setStrokeColorWithPattern
     * @param {PDFNet.PatternColor} pattern SDF pattern object.
     * @note The currently selected stroke color space must be Pattern color space.
     */
    setStrokeColorWithPattern(pattern: PDFNet.PatternColor): void;
    /**
     * Set the stroke color to the given uncolored tiling pattern.
     * @method PDFNet.GState#setStrokeColor
     * @param {PDFNet.PatternColor} pattern pattern (PatternType = 1 and PaintType = 2) object.
     * @param {PDFNet.ColorPt} c is a color in the pattern's underlying color space.
     * @note The currently selected stroke color space must be Pattern color space.
     */
    setStrokeColor(pattern: PDFNet.PatternColor, c: PDFNet.ColorPt): void;
    /**
     * Sets the color value/point used for filling operations.
     * @method PDFNet.GState#setFillColorWithColorPt
     * @param {PDFNet.ColorPt} c the color used for filling operations
     * The color value must be represented in the currently selected color space used
     * for filling.
     */
    setFillColorWithColorPt(c: PDFNet.ColorPt): void;
    /**
     * Set the fill color to the given tiling pattern.
     * @method PDFNet.GState#setFillColorWithPattern
     * @param {PDFNet.PatternColor} pattern New pattern color.
     * @note The currently selected fill color space must be Pattern color space.
     */
    setFillColorWithPattern(pattern: PDFNet.PatternColor): void;
    /**
     * Set the fill color to the given uncolored tiling pattern.
     * @method PDFNet.GState#setFillColor
     * @param {PDFNet.PatternColor} pattern PatternColor (PatternType = 1 and PaintType = 2) object.
     * @param {PDFNet.ColorPt} c is a color in the pattern's underlying color space.
     * @note The currently selected fill color space must be Pattern color space.
     */
    setFillColor(pattern: PDFNet.PatternColor, c: PDFNet.ColorPt): void;
    /**
     * Sets the value of flatness tolerance.
     *
     * @method PDFNet.GState#setFlatness
     * @param {number} flatness is a number in the range 0 to 100; a value of 0 specifies the output
     * device's default flatness tolerance.
     *
     * The flatness tolerance controls the maximum permitted distance in device pixels
     * between the mathematically correct path and an approximation constructed from
     * straight line segments.
     */
    setFlatness(flatness: number): void;
    /**
     * Sets LineCap style property.
     *
     * The line cap style specifies the shape to be used at the ends of open subpaths
     * (and dashes, if any) when they are stroked.
     * @method PDFNet.GState#setLineCap
     * @param {number} cap
     * <pre>
     * PDFNet.GState.LineCap = {
     * 	e_butt_cap : 0
     * 	e_round_cap : 1
     * 	e_square_cap : 2
     * }
     * </pre>
     */
    setLineCap(cap: number): void;
    /**
     * Sets LineJoin style property.
     *
     * The line join style specifies the shape to be used at the corners of paths that
     * are stroked.
     * @method PDFNet.GState#setLineJoin
     * @param {number} join
     * <pre>
     * PDFNet.GState.LineJoin = {
     * 	e_miter_join : 0
     * 	e_round_join : 1
     * 	e_bevel_join : 2
     * }
     * </pre>
     */
    setLineJoin(join: number): void;
    /**
     * Sets the thickness of the line used to stroke a path.
     * @method PDFNet.GState#setLineWidth
     * @param {number} width a non-negative number expressed in user space units.
     * A line width of 0 denotes the thinnest line that can be rendered at device
     * resolution: 1 device pixel wide.
     */
    setLineWidth(width: number): void;
    /**
     * Sets miter limit.
     * @method PDFNet.GState#setMiterLimit
     * @param {number} miter_limit A number that imposes a maximum on the ratio of the miter
     * length to the line width. When the limit is exceeded, the join is converted
     * from a miter to a bevel.
     */
    setMiterLimit(miter_limit: number): void;
    /**
     *
     * @method PDFNet.GState#setDashPattern
     * @param {Array} buf_dash_array
     * @param {number} phase
     */
    setDashPattern(buf_dash_array: any[], phase: number): void;
    /**
     * Sets character spacing.
     * @method PDFNet.GState#setCharSpacing
     * @param {number} char_spacing a number specified in unscaled text space units. When the
     * glyph for each character in the string is rendered, the character spacing is
     * added to the horizontal or vertical component of the glyph's displacement,
     * depending on the writing mode. See Section 5.2.1 in PDF Reference Manual for details.
     */
    setCharSpacing(char_spacing: number): void;
    /**
     * Sets word spacing.
     * @method PDFNet.GState#setWordSpacing
     * @param {number} word_spacing a number specified in unscaled text space units.
     * Word spacing works the same way as character spacing, but applies only to the
     * space character (char code 32). See Section 5.2.2 in PDF Reference Manual for details.
     */
    setWordSpacing(word_spacing: number): void;
    /**
     * Sets horizontal scale.
     * The horizontal scaling parameter adjusts the width of glyphs by stretching
     * or compressing them in the horizontal direction. Its value is specified as
     * a percentage of the normal width of the glyphs, with 100 being the normal width.
     * The scaling always applies to the horizontal coordinate in text space, independently
     * of the writing mode. See Section 5.2.3 in PDF Reference Manual for details.
     * @method PDFNet.GState#setHorizontalScale
     * @param {number} hscale value to set horizontal scale to.
     */
    setHorizontalScale(hscale: number): void;
    /**
     * Sets the leading parameter.
     *
     * The leading parameter is measured in unscaled text space units. It specifies
     * the vertical distance between the baselines of adjacent lines of text.
     * See Section 5.2.4 in PDF Reference Manual for details.
     * @method PDFNet.GState#setLeading
     * @param {number} leading number representing vertical distance between lines of text
     */
    setLeading(leading: number): void;
    /**
     * Sets the font and font size used to draw text.
     * @method PDFNet.GState#setFont
     * @param {PDFNet.Font} font Font to draw the text with
     * @param {number} font_sz size of the font to draw the text with
     */
    setFont(font: PDFNet.Font, font_sz: number): void;
    /**
     * Sets text rendering mode.
     * The text rendering mode determines whether showing text causes glyph outlines to
     * be stroked, filled, used as a clipping boundary, or some combination of the three.
     * See Section 5.2.5 in PDF Reference Manual for details..
     * @method PDFNet.GState#setTextRenderMode
     * @param {number} rmode
     * <pre>
     * PDFNet.GState.TextRenderingMode = {
     * 	e_fill_text : 0
     * 	e_stroke_text : 1
     * 	e_fill_stroke_text : 2
     * 	e_invisible_text : 3
     * 	e_fill_clip_text : 4
     * 	e_stroke_clip_text : 5
     * 	e_fill_stroke_clip_text : 6
     * 	e_clip_text : 7
     * }
     * </pre>
     * the mode that text will rendered with.
     * rmode can take the following values:
     * PDFNet.GState.TextRenderingMode = {
     *	e_fill_text : 0,
     *	e_stroke_text : 1,
     *	e_fill_stroke_text : 2,
     *	e_invisible_text : 3,
     *	e_fill_clip_text : 4,
     *	e_stroke_clip_text : 5,
     *	e_fill_stroke_clip_text : 6,
     *	e_clip_text : 7
     * }
     */
    setTextRenderMode(rmode: number): void;
    /**
     * Sets text rise.
     * Text rise specifies the distance, in unscaled text space units, to move the
     * baseline up or down from its default location. Positive values of text rise
     * move the baseline up
     * @method PDFNet.GState#setTextRise
     * @param {number} rise distance to move baseline up. Negative values move baseline down.
     */
    setTextRise(rise: number): void;
    /**
     * Mark the object as elementary for purposes of color compositing in the
     * transparent imaging model.
     * @method PDFNet.GState#setTextKnockout
     * @param {boolean} knockout Whether an object is elementary or not.
     */
    setTextKnockout(knockout: boolean): void;
    /**
     * Sets the color intent to be used for rendering the Element.
     * @method PDFNet.GState#setRenderingIntent
     * @param {number} intent
     * <pre>
     * PDFNet.GState.RenderingIntent = {
     * 	e_absolute_colorimetric : 0
     * 	e_relative_colorimetric : 1
     * 	e_saturation : 2
     * 	e_perceptual : 3
     * }
     * </pre>
     */
    setRenderingIntent(intent: number): void;
    /**
     * Sets the current blend mode to be used in the transparent imaging model.
     * Corresponds to the /BM key within the ExtGState's dictionary.
     * @method PDFNet.GState#setBlendMode
     * @param {number} BM
     * <pre>
     * PDFNet.GState.BlendMode = {
     * 	e_bl_compatible : 0
     * 	e_bl_normal : 1
     * 	e_bl_multiply : 2
     * 	e_bl_screen : 3
     * 	e_bl_difference : 4
     * 	e_bl_darken : 5
     * 	e_bl_lighten : 6
     * 	e_bl_color_dodge : 7
     * 	e_bl_color_burn : 8
     * 	e_bl_exclusion : 9
     * 	e_bl_hard_light : 10
     * 	e_bl_overlay : 11
     * 	e_bl_soft_light : 12
     * 	e_bl_luminosity : 13
     * 	e_bl_hue : 14
     * 	e_bl_saturation : 15
     * 	e_bl_color : 16
     * }
     * </pre>
     * New blending mode type.
     *
     * <pre>
     * // C#
     * gs.SetBlendMode(GState.BlendMode.e_lighten);
     *
     * // C++
     * gs->SetBlendMode(GState::e_lighten);
     * </pre>
     */
    setBlendMode(BM: number): void;
    /**
     * Sets the opacity value for painting operations other than stroking.
     * Corresponds to the value of the /ca key in the ExtGState dictionary.
     * @method PDFNet.GState#setFillOpacity
     * @param {number} ca value to set fill opacity to
     */
    setFillOpacity(ca: number): void;
    /**
     * Sets opacity value for stroke painting operations for paths and glyph outlines.
     * Corresponds to the value of the /CA key in the ExtGState dictionary.
     * @method PDFNet.GState#setStrokeOpacity
     * @param {number} ca value to set stroke opacity to
     */
    setStrokeOpacity(ca: number): void;
    /**
     * specifies if the alpha is to be interpreted as a shape or opacity mask.
     * The alpha source flag ('alpha is shape'), specifies whether the
     * current soft mask and alpha constant are to be interpreted as shape values
     * (true) or opacity values (false).
     * @method PDFNet.GState#setAISFlag
     * @param {boolean} AIS true for interpretation as shape values or false for opacity values
     */
    setAISFlag(AIS: boolean): void;
    /**
     * Sets the soft mask of the extended graphics state.
     * Corresponds to the /SMask key within the ExtGState's dictionary.
     * @method PDFNet.GState#setSoftMask
     * @param {PDFNet.Obj} SM SDF/Cos black-generation function or name
     */
    setSoftMask(SM: PDFNet.Obj): void;
    /**
     * specifies if overprint is enabled for stroke operations. Corresponds to the /OP
     * key within the ExtGState's dictionary.
     * @method PDFNet.GState#setStrokeOverprint
     * @param {boolean} OP true to enable overprint for stroke, false to disable.
     */
    setStrokeOverprint(OP: boolean): void;
    /**
     * specifies if overprint is enabled for fill operations. Corresponds to the /op
     * key within the ExtGState's dictionary.
     * @method PDFNet.GState#setFillOverprint
     * @param {boolean} op true to enable overprint for fill, false to disable.
     */
    setFillOverprint(op: boolean): void;
    /**
     * Sets the overprint mode. Corresponds to the /OPM key within the ExtGState's
     * dictionary.
     * @method PDFNet.GState#setOverprintMode
     * @param {number} OPM overprint mode.
     */
    setOverprintMode(OPM: number): void;
    /**
     * Specify whether to apply automatic stroke adjustment.
     * Corresponds to the /SA key within the ExtGState's dictionary.
     * @method PDFNet.GState#setAutoStrokeAdjust
     * @param {boolean} SA if true automatic stroke adjustment will be applied.
     */
    setAutoStrokeAdjust(SA: boolean): void;
    /**
     *
     * @method PDFNet.GState#setSmoothnessTolerance
     * @param {number} SM
     */
    setSmoothnessTolerance(SM: number): void;
    /**
     * Sets black-generation function used during conversion between DeviceRGB
     * and DeviceCMYK. Corresponds to the /BG key within the ExtGState's
     * dictionary.
     * @method PDFNet.GState#setBlackGenFunct
     * @param {PDFNet.Obj} BG SDF/Cos black-generation function or name
     */
    setBlackGenFunct(BG: PDFNet.Obj): void;
    /**
     * Sets undercolor-removal function used during conversion between DeviceRGB
     * and DeviceCMYK. Corresponds to the /UCR key within the ExtGState's
     * dictionary.
     * @method PDFNet.GState#setUCRFunct
     * @param {PDFNet.Obj} UCR SDF/Cos undercolor-removal function or name
     */
    setUCRFunct(UCR: PDFNet.Obj): void;
    /**
     * Sets transfer function used during color conversion process. A transfer
     * function adjusts the values of color components to compensate for nonlinear
     * response in an output device and in the human eye. Corresponds to the /TR key
     * within the ExtGState's dictionary.
     * @method PDFNet.GState#setTransferFunct
     * @param {PDFNet.Obj} TR SDF/Cos transfer function, array, or name
     */
    setTransferFunct(TR: PDFNet.Obj): void;
    /**
     * @method PDFNet.GState#setHalftone
     * @return currently selected halftone dictionary or stream (NULL by default).
     * Corresponds to the /HT key within the ExtGState's dictionary.
     * Halftoning is a process by which continuous-tone colors are approximated on an
     * output device that can achieve only a limited number of discrete colors.
     * @param {PDFNet.Obj} HT SDF/Cos halftone dictionary, stream, or name
     */
    setHalftone(HT: PDFNet.Obj): any;
  }
  /**
   * [Missing documentation]
   * @class
   * @name GeometryCollection
   * @memberof PDFNet
   */
  class GeometryCollection {
    /**
     *
     * @method PDFNet.GeometryCollection#snapToNearest
     * @param {number} x
     * @param {number} y
     * @param {number} mode
     * @return {Promise<PDFNet.Point>} A promise that resolves to an object of type: "Point"
     */
    snapToNearest(x: number, y: number, mode: number): Promise<PDFNet.Point>;
    /**
     *
     * @method PDFNet.GeometryCollection#snapToNearestPixel
     * @param {number} x
     * @param {number} y
     * @param {number} dpi
     * @param {number} mode
     * @return {Promise<PDFNet.Point>} A promise that resolves to an object of type: "Point"
     */
    snapToNearestPixel(x: number, y: number, dpi: number, mode: number): Promise<PDFNet.Point>;
    /**
     * Destructor
     * @method PDFNet.GeometryCollection#destroy
     */
    destroy(): void;
  }
  /**
   * 'pdftron.PDF.HTML2PDF' is an optional PDFNet Add-On utility class that can be
   * used to convert HTML web pages into PDF documents by using an external
   * module (html2pdf).
   *
   * The html2pdf modules can be downloaded from http: www.pdftron.com/pdfnet/downloads.html.
   *
   * Users can convert HTML pages to PDF using the following operations:
   * - Simple one line static method to convert a single web page to PDF.
   * - Convert HTML pages from URL or string, plus optional table of contents, in user defined order.
   * - Optionally configure settings for proxy, images, java script, and more for each HTML page.
   * - Optionally configure the PDF output, including page size, margins, orientation, and more.
   * - Optionally add table of contents, including setting the depth and appearance.
   *
   * The following code converts a single webpage to pdf
   *
   * <pre>
   * using namespace pdftron;
   * using namespace PDF;
   *
   * PDFDoc pdfdoc;
   * if ( HTML2PDF::Convert(pdfdoc, "http://www.gutenberg.org/wiki/Main_Page") )
   *		pdfdoc.Save(outputFile, SDF::SDFDoc::e_remove_unused, NULL);
   * </pre>
   *
   * The following code demonstrates how to convert multiple web pages into one pdf,
   * excluding the background, and with lowered image quality to save space.
   *
   * <pre>
   * using namespace pdftron;
   * using namespace PDF;
   *
   * HTML2PDF converter;
   * converter.SetImageQuality(25);
   *
   * HTML2PDF::WebPageSettings settings;
   * settings.SetPrintBackground(false);
   *
   * converter.InsertFromURL("http://www.gutenberg.org/wiki/Main_Page", settings);
   *
   * PDFDoc pdfdoc;
   * if ( converter.Convert(pdfdoc) )
   *		pdfdoc.Save(outputFile, SDF::SDFDoc::e_remove_unused, NULL);
   * </pre>
   * @class
   * @name HTML2PDF
   * @memberof PDFNet
   */
  class HTML2PDF {}
  namespace HTML2PDF {
    /**
     * Proxy settings to be used when loading content from web pages.
     *
     * @note These Proxy settings will only be used if type is not e_default.
     * @class
     * @name HTML2PDF.Proxy
     * @memberof PDFNet
     */
    class Proxy {}
    /**
     * Settings for table of contents.
     * @class
     * @name HTML2PDF.TOCSettings
     * @memberof PDFNet
     */
    class TOCSettings {}
    /**
     * Settings that control how a web page is opened and converted to PDF.
     * @class
     * @name HTML2PDF.WebPageSettings
     * @memberof PDFNet
     */
    class WebPageSettings {}
  }
  /**
   * A Highlight annotation covers a word or a group of contiguous words with partially transparent
   * color.
   * @class
   * @name HighlightAnnot
   * @memberof PDFNet
   */
  class HighlightAnnot {
    /**
     * creates a Highlight annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.HighlightAnnot.createFromObj
     * @param {PDFNet.Obj} d The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.HighlightAnnot>} A promise that resolves to an object of type: "HighlightAnnot"
     */
    static createFromObj(d: PDFNet.Obj): Promise<PDFNet.HighlightAnnot>;
    /**
     * creates a Highlight annotation and initializes it using given annotation object.
     * @method PDFNet.HighlightAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Highlight annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.HighlightAnnot>} A promise that resolves to an object of type: "HighlightAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.HighlightAnnot>;
    /**
     * Creates a new Highlight annotation in the specified document.
     *
     * @method PDFNet.HighlightAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the Highlight annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the Highlight annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.HighlightAnnot>} A promise that resolves to a newly created blank Highlight annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.HighlightAnnot>;
  }
  /**
   * Highlights is used to store the necessary information and perform certain
   * tasks in accordance with Adobe's Highlight standard, whose details can be
   * found at:
   *
   * http://partners.adobe.com/public/developer/en/pdf/HighlightFileFormat.pdf
   *
   * In a nutshell, the Highlights class maintains a set of highlights.
   * Each highlight contains three pieces of information:
   *
   * page: the number of the page this Highlight is on;
   * position: the start position (text offset) of this Highlight;
   * length: the length of this Highlight.
   *
   * Possible use case scenarios for Highlights include:
   *  - Load a Highlight file (in XML format) and highlight the corresponding
   *    texts in the viewer (e.g., if the viewer is implemented using PDFViewCtrl,
   *    it can be achieved simply by calling PDFViewCtrl::SelectByHighlights()
   *    method);
   *  - Save the Highlight information (e.g., constructed by the TextSearch
   *    class) to an XML file for external uses.
   *
   * Note:
   *  - The Highlights class does not maintain the corresponding PDF document for
   *    its highlights. It is the user's responsibility to match them up.
   *  - The Highlights class ensures that each highlight it maintains is
   *    unique (no two highlights have the same page, position and length values).
   *  - The current implementation of Highlights only supports the 'characters'
   *    encoding for 'units' as described in the format; the 'words' encoding is
   *    not supported at this point.
   *
   *
   * For a sample code, please take a look at the TextSearchTest sample project.
   * @class
   * @name Highlights
   * @memberof PDFNet
   */
  class Highlights {
    /**
     * Constructor and destructor.
     * @method PDFNet.Highlights.create
     * @return {Promise<PDFNet.Highlights>} A promise that resolves to an object of type: "Highlights"
     */
    static create(): Promise<PDFNet.Highlights>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.Highlights#destroy
     */
    destroy(): void;
    /**
     * Assignment operator.
     * @method PDFNet.Highlights#copyCtor
     * @return {Promise<PDFNet.Highlights>} A promise that resolves to an object of type: "Highlights"
     */
    copyCtor(): Promise<PDFNet.Highlights>;
    /**
     * Add highlights.
     *
     * @method PDFNet.Highlights#add
     * @param {PDFNet.Highlights} hlts the Highlights instance containing the highlights to be added.
     */
    add(hlts: PDFNet.Highlights): void;
    /**
     * Load the Highlight information from a file. Note that the
     * pre-existing Highlight information is discarded.
     *
     * @method PDFNet.Highlights#load
     * @param {string} file_name the name of the file to load from.
     */
    load(file_name: string): void;
    /**
     * Save the current Highlight information in the class to a file.
     *
     * @method PDFNet.Highlights#save
     * @param {string} file_name the name of the file to save to.
     */
    save(file_name: string): void;
    /**
     * Clear the current Highlight information in the class.
     * @method PDFNet.Highlights#clear
     */
    clear(): void;
    /**
     * Rewind the internal pointer to the first highlight.
     *
     * @method PDFNet.Highlights#begin
     * @param {PDFNet.PDFDoc} doc the PDF document to which the highlights correspond.
     *
     * @note the PDF document can be a dummy document unless GetCurrentQuads()
     * is to be called.
     */
    begin(doc: PDFNet.PDFDoc): void;
    /**
     * Query if there is any subsequent highlight after the current highlight.
     * @method PDFNet.Highlights#hasNext
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    hasNext(): Promise<boolean>;
    /**
     * Move the current highlight to the next highlight.
     * @method PDFNet.Highlights#next
     */
    next(): void;
    /**
     * Get the page number of the current highlight.
     * @method PDFNet.Highlights#getCurrentPageNumber
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     */
    getCurrentPageNumber(): Promise<number>;
    /**
     * Retrieves an array of Quads (each quad contains 4 points) representing the regions that were
     * highlighted.
     * @method PDFNet.Highlights#getCurrentQuads
     * @return {Promise<number>} A promise that resolves to an object of type: "number" (generated documentation)
     */
    getCurrentQuads(): Promise<number>;
  }
  /**
   * Image class provides common methods for working with PDF images.
   *
   * @note PDF::Element contains a similar interface used to access image data.
   * To create the Image object from image PDF::Element, pass the Element's SDF/Cos
   * dictionary to Image constructor (i.e. Image image(element->GetXObject()) )
   * @class
   * @name Image
   * @memberof PDFNet
   */
  class Image {
    /**
     * Create and embed an Image. Embed the raw image data taking into account
     * specified compression hints.
     *
     * By default the function will compress all images using Flate compression.
     * It is possible to fine tune compression or to select a different compression
     * algorithm using 'encoder_hints' object.
     *
     * @method PDFNet.Image.createFromMemory
     * @param {PDFNet.SDFDoc} doc A document to which the image should be added. The 'Doc' object
     * can be obtained using Obj::GetDoc() or PDFDoc::GetSDFDoc().
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf The stream or buffer containing image data. The image data must
     * not be compressed and must follow PDF format for sample representation (please refer
     * to section 4.8.2 'Sample Representation' in PDF Reference Manual for details).
     * @param {number} width The width of the image, in samples.
     * @param {number} height The height of the image, in samples.
     * @param {number} bpc The number of bits used to represent each color component.
     * @param {PDFNet.ColorSpace} color_space The color space in which image samples are represented.
     * @param {PDFNet.Obj} [encoder_hints] An optional parameter that can be used to fine tune
     * compression or to select a different compression algorithm. See Image::Create()
     * for details.
     *
     * @return {Promise<PDFNet.Image>} A promise that resolves to pDF::Image object representing the embedded image.
     */
    static createFromMemory(
      doc: PDFNet.SDFDoc,
      buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray,
      width: number,
      height: number,
      bpc: number,
      color_space: PDFNet.ColorSpace,
      encoder_hints?: PDFNet.Obj,
    ): Promise<PDFNet.Image>;
    /**
     *
     * @method PDFNet.Image.createFromMemory2
     * @param {PDFNet.SDFDoc} doc
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf
     * @param {PDFNet.Obj} [encoder_hints]
     * @return {Promise<PDFNet.Image>} A promise that resolves to an object of type: "Image"
     */
    static createFromMemory2(
      doc: PDFNet.SDFDoc,
      buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray,
      encoder_hints?: PDFNet.Obj,
    ): Promise<PDFNet.Image>;
    /**
     *
     * @method PDFNet.Image.createFromStream
     * @param {PDFNet.SDFDoc} doc
     * @param {PDFNet.FilterReader} image_data
     * @param {number} width
     * @param {number} height
     * @param {number} bpc
     * @param {PDFNet.ColorSpace} color_space
     * @param {PDFNet.Obj} [encoder_hints]
     * @return {Promise<PDFNet.Image>} A promise that resolves to an object of type: "Image"
     */
    static createFromStream(
      doc: PDFNet.SDFDoc,
      image_data: PDFNet.FilterReader,
      width: number,
      height: number,
      bpc: number,
      color_space: PDFNet.ColorSpace,
      encoder_hints?: PDFNet.Obj,
    ): Promise<PDFNet.Image>;
    /**
     *
     * @method PDFNet.Image.createFromStream2
     * @param {PDFNet.SDFDoc} doc
     * @param {PDFNet.Filter} image_data
     * @param {PDFNet.Obj} [encoder_hints]
     * @return {Promise<PDFNet.Image>} A promise that resolves to an object of type: "Image"
     */
    static createFromStream2(
      doc: PDFNet.SDFDoc,
      image_data: PDFNet.Filter,
      encoder_hints?: PDFNet.Obj,
    ): Promise<PDFNet.Image>;
    /**
     * Create and embed an ImageMask. Embed the raw image data taking into account
     * specified compression hints. The ImageMask can be used as a stencil mask for
     * painting in the current color or as an explicit mask specifying which areas of
     * the image to paint and which to mask out. One of the most important uses of
     * stencil masking is for painting character glyphs represented as bitmaps.
     *
     * @method PDFNet.Image.createImageMask
     * @param {PDFNet.SDFDoc} doc A document to which the image should be added. The 'Doc' object
     * can be obtained using Obj::GetDoc() or PDFDoc::GetSDFDoc().
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf The stream or buffer containing image data stored in 1 bit per
     * sample format. The image data must not be compressed and must follow PDF format for
     * sample representation (please refer to section 4.8.2 'Sample Representation' in PDF
     * Reference Manual for details).
     * @param {number} width The width of the image, in samples.
     * @param {number} height The height of the image, in samples.
     * @param {PDFNet.Obj} [encoder_hints] An optional parameter that can be used to fine tune
     * compression or to select a different compression algorithm. See Image::Create()
     * for details.
     *
     * @return {Promise<PDFNet.Image>} A promise that resolves to pDF::Image object representing the embedded ImageMask.
     */
    static createImageMask(
      doc: PDFNet.SDFDoc,
      buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray,
      width: number,
      height: number,
      encoder_hints?: PDFNet.Obj,
    ): Promise<PDFNet.Image>;
    /**
     *
     * @method PDFNet.Image.createImageMaskFromStream
     * @param {PDFNet.SDFDoc} doc
     * @param {PDFNet.FilterReader} image_data
     * @param {number} width
     * @param {number} height
     * @param {PDFNet.Obj} [encoder_hints]
     * @return {Promise<PDFNet.Image>} A promise that resolves to an object of type: "Image"
     */
    static createImageMaskFromStream(
      doc: PDFNet.SDFDoc,
      image_data: PDFNet.FilterReader,
      width: number,
      height: number,
      encoder_hints?: PDFNet.Obj,
    ): Promise<PDFNet.Image>;
    /**
     * create and embed a Soft Mask. Embed the raw image data taking into account
     * specified compression hints.
     * A soft-mask image (see "Soft-Mask Images" in PDF Reference Manual) is
     * used as a source of mask shape or mask opacity values in the transparent
     * imaging model.
     *
     * @method PDFNet.Image.createSoftMask
     * @param {PDFNet.SDFDoc} doc A document to which the image should be added. The 'Doc' object
     * can be obtained using Obj::GetDoc() or PDFDoc::GetSDFDoc().
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf The stream or buffer containing image data represented in
     * DeviceGray color space (i.e. one component per sample). The image data must not
     * be compressed and must follow PDF format for sample representation (please refer
     * to section 4.8.2 'Sample Representation' in PDF Reference Manual for details).
     * @param {number} width The width of the image, in samples.
     * @param {number} height The height of the image, in samples.
     * @param {number} bpc The number of bits used to represent each color component.
     * @param {PDFNet.Obj} [encoder_hints] An optional parameter that can be used to fine tune
     * compression or to select a different compression algorithm. See Image::Create()
     * for details.
     * @note this feature is available only in PDF 1.4 and higher.
     * @return {Promise<PDFNet.Image>} A promise that resolves to an object of type: "Image"
     */
    static createSoftMask(
      doc: PDFNet.SDFDoc,
      buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray,
      width: number,
      height: number,
      bpc: number,
      encoder_hints?: PDFNet.Obj,
    ): Promise<PDFNet.Image>;
    /**
     *
     * @method PDFNet.Image.createSoftMaskFromStream
     * @param {PDFNet.SDFDoc} doc
     * @param {PDFNet.FilterReader} image_data
     * @param {number} width
     * @param {number} height
     * @param {number} bpc
     * @param {PDFNet.Obj} [encoder_hints]
     * @return {Promise<PDFNet.Image>} A promise that resolves to an object of type: "Image"
     */
    static createSoftMaskFromStream(
      doc: PDFNet.SDFDoc,
      image_data: PDFNet.FilterReader,
      width: number,
      height: number,
      bpc: number,
      encoder_hints?: PDFNet.Obj,
    ): Promise<PDFNet.Image>;
    /**
     *
     * @method PDFNet.Image.createDirectFromMemory
     * @param {PDFNet.SDFDoc} doc
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf
     * @param {number} width
     * @param {number} height
     * @param {number} bpc
     * @param {PDFNet.ColorSpace} color_space
     * @param {number} input_format
     * <pre>
     * PDFNet.Image.InputFilter = {
     * 	e_none : 0
     * 	e_jpeg : 1
     * 	e_jp2 : 2
     * 	e_flate : 3
     * 	e_g3 : 4
     * 	e_g4 : 5
     * 	e_ascii_hex : 6
     * }
     * </pre>
     * @return {Promise<PDFNet.Image>} A promise that resolves to an object of type: "Image"
     */
    static createDirectFromMemory(
      doc: PDFNet.SDFDoc,
      buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray,
      width: number,
      height: number,
      bpc: number,
      color_space: PDFNet.ColorSpace,
      input_format: number,
    ): Promise<PDFNet.Image>;
    /**
     *
     * @method PDFNet.Image.createDirectFromStream
     * @param {PDFNet.SDFDoc} doc
     * @param {PDFNet.FilterReader} image_data
     * @param {number} width
     * @param {number} height
     * @param {number} bpc
     * @param {PDFNet.ColorSpace} color_space
     * @param {number} input_format
     * <pre>
     * PDFNet.Image.InputFilter = {
     * 	e_none : 0
     * 	e_jpeg : 1
     * 	e_jp2 : 2
     * 	e_flate : 3
     * 	e_g3 : 4
     * 	e_g4 : 5
     * 	e_ascii_hex : 6
     * }
     * </pre>
     * @return {Promise<PDFNet.Image>} A promise that resolves to an object of type: "Image"
     */
    static createDirectFromStream(
      doc: PDFNet.SDFDoc,
      image_data: PDFNet.FilterReader,
      width: number,
      height: number,
      bpc: number,
      color_space: PDFNet.ColorSpace,
      input_format: number,
    ): Promise<PDFNet.Image>;
    /**
     *
     * @method PDFNet.Image.createFromObj
     * @param {PDFNet.Obj} [image_xobject]
     * @return {Promise<PDFNet.Image>} A promise that resolves to an object of type: "Image"
     */
    static createFromObj(image_xobject?: PDFNet.Obj): Promise<PDFNet.Image>;
    /**
     * Copy Constructor
     * @method PDFNet.Image#copy
     * @return {Promise<PDFNet.Image>} A promise that resolves to an object of type: "Image"
     */
    copy(): Promise<PDFNet.Image>;
    /**
     * @method PDFNet.Image#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the underlying SDF/Cos object
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Image#isValid
     * @return {Promise<boolean>} A promise that resolves to whether this is a valid raster image. If the function returns false the
     * underlying SDF/Cos object is not a valid raster image and this Image object should
     * be treated as null.
     */
    isValid(): Promise<boolean>;
    /**
     * @method PDFNet.Image#getImageData
     * @return {Promise<PDFNet.Filter>} A promise that resolves to a stream (filter) containing decoded image data
     */
    getImageData(): Promise<PDFNet.Filter>;
    /**
     * @method PDFNet.Image#getImageDataSize
     * @return {Promise<number>} A promise that resolves to the size of image data in bytes
     */
    getImageDataSize(): Promise<number>;
    /**
     * @method PDFNet.Image#getImageColorSpace
     * @return {Promise<PDFNet.ColorSpace>} A promise that resolves to the SDF object representing the color space in which image
     * samples are specified or NULL if:
     *  the image is an image mask
     *  or is compressed using JPXDecode with missing ColorSpace entry in image dictionary.
     *
     * The returned color space may be any type of color space except Pattern.
     */
    getImageColorSpace(): Promise<PDFNet.ColorSpace>;
    /**
     * @method PDFNet.Image#getImageWidth
     * @return {Promise<number>} A promise that resolves to the width of the image, in samples.
     */
    getImageWidth(): Promise<number>;
    /**
     * @method PDFNet.Image#getImageHeight
     * @return {Promise<number>} A promise that resolves to the height of the image, in samples.
     */
    getImageHeight(): Promise<number>;
    /**
     * @method PDFNet.Image#getDecodeArray
     * @return {Promise<PDFNet.Obj>} A promise that resolves to decode array or NULL if the parameter is not specified. A decode object is an
     * array of numbers describing how to map image samples into the range of values
     * appropriate for the images color space . If ImageMask is true, the array must be
     * either [0 1] or [1 0]; otherwise, its length must be twice the number of color
     * components required by ColorSpace. Default value depends on the color space,
     * See Table 4.36 in PDF Ref. Manual.
     */
    getDecodeArray(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Image#getBitsPerComponent
     * @return {Promise<number>} A promise that resolves to the number of bits used to represent each color component. Only a
     * single value may be specified; the number of bits is the same for all color
     * components. Valid values are 1, 2, 4, 8, and 16.
     */
    getBitsPerComponent(): Promise<number>;
    /**
     * @method PDFNet.Image#getComponentNum
     * @return {Promise<number>} A promise that resolves to the number of color components per sample.
     */
    getComponentNum(): Promise<number>;
    /**
     * @method PDFNet.Image#isImageMask
     * @return {Promise<boolean>} A promise that resolves to a boolean indicating whether the inline image is to be treated as an image mask.
     */
    isImageMask(): Promise<boolean>;
    /**
     * @method PDFNet.Image#isImageInterpolate
     * @return {Promise<boolean>} A promise that resolves to a boolean indicating whether image interpolation is to be performed.
     */
    isImageInterpolate(): Promise<boolean>;
    /**
     * @method PDFNet.Image#getMask
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an image XObject defining an image mask to be applied to this image (See
     * 'Explicit Masking', 4.8.5), or an array specifying a range of colors
     * to be applied to it as a color key mask (See 'Color Key Masking').
     *
     * If IsImageMask() return true, this method will return NULL.
     */
    getMask(): Promise<PDFNet.Obj>;
    /**
     * set an Explicit Image Mask.
     *
     * @method PDFNet.Image#setMask
     * @param {PDFNet.Image} image_mask An Image object which serves as an explicit mask for the
     * base (this) image. The base image and the image mask need not have the
     * same resolution (Width and Height values), but since all images are defined on
     * the unit square in user space, their boundaries on the page will coincide; that is,
     * they will overlay each other. The image mask indicates which places on the page
     * are to be painted and which are to be masked out (left unchanged). Unmasked areas
     * are painted with the corresponding portions of the base image; masked areas
     * are not.
     *
     * @note image_mask must be a valid image mask (i.e. image_mask.IsImageMask() must
     * return true.
     */
    setMask(image_mask: PDFNet.Image): void;
    /**
     * set a Color Key Mask.
     *
     * @method PDFNet.Image#setMaskWithObj
     * @param {PDFNet.Obj} mask is an Cos/SDF array specifying a range of colors to be masked
     * out. Samples in the image that fall within this range are not painted, allowing
     * the existing background to show through. The effect is similar to that of the
     * video technique known as chroma-key. For details of the array format please
     * refer to section 4.8.5 'Color Key Masking' in PDF Reference Manual.
     *
     * @note the current document takes the ownership of the given SDF object.
     */
    setMaskWithObj(mask: PDFNet.Obj): void;
    /**
     * @method PDFNet.Image#getSoftMask
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an image XObject defining a Soft Mask to be applied to this image
     * (See section 7.5.4 'Soft-Mask Images' in PDF Reference Manual), or NULL
     * if the image does not have the soft mask.
     */
    getSoftMask(): Promise<PDFNet.Obj>;
    /**
     * set a Soft Mask.
     *
     * @method PDFNet.Image#setSoftMask
     * @param {PDFNet.Image} soft_mask is a subsidiary Image object defining a soft-mask image
     * (See section 7.5.4 'Soft-Mask Images' in PDF Reference Manual) to be used
     * as a source of mask shape or mask opacity values in the transparent imaging
     * model. The alpha source parameter in the graphics state determines whether
     * the mask values are interpreted as shape or opacity.
     */
    setSoftMask(soft_mask: PDFNet.Image): void;
    /**
     * @method PDFNet.Image#getImageRenderingIntent
     * @return {Promise<number>} A promise that resolves to the color rendering intent to be used in rendering the image.
     * @example Return value enum:
     * <pre>
     * PDFNet.GState.RenderingIntent = {
     * 	e_absolute_colorimetric : 0
     * 	e_relative_colorimetric : 1
     * 	e_saturation : 2
     * 	e_perceptual : 3
     * }
     * </pre>
     */
    getImageRenderingIntent(): Promise<number>;
    /**
     * Saves this image to the output stream.
     * (0 PNG, 1 TIF, 2 JPEG).
     *
     * @method PDFNet.Image#exportFromStream
     * @param {PDFNet.FilterWriter} writer A pointer to FilterWriter used to write to the
     * output stream. If the parameter is null, nothing will be written
     * to the output stream, but the function returns the format identifier.
     *
     * @return {Promise<number>} A promise that resolves to the number indicating the selected image format:
     * @note see the overloaded Image::Export method for more information.
     */
    exportFromStream(writer: PDFNet.FilterWriter): Promise<number>;
    /**
     * Saves this image to a TIFF output stream.
     *
     * @method PDFNet.Image#exportAsTiffFromStream
     * @param {PDFNet.FilterWriter} writer FilterWriter used to write to the output stream.
     */
    exportAsTiffFromStream(writer: PDFNet.FilterWriter): void;
    /**
     * Saves this image to a PNG output stream.
     *
     * @method PDFNet.Image#exportAsPngFromStream
     * @param {PDFNet.FilterWriter} writer FilterWriter used to write to the output stream.
     */
    exportAsPngFromStream(writer: PDFNet.FilterWriter): void;
    /**
     * This function will fully download the image url as a memory buffer and embed it in the supplied PDFDoc.
     * @method PDFNet.Image.createFromURL
     * @param {PDFNet.PDFDoc} doc the PDF document in which to embed the image
     * @param {string} url The image url to download and embed.
     * @param {number} [encoder_hints]
     * @param {Object} [options] Additional options
     * @param {boolean} options.withCredentials Whether to set the withCredentials property on the XMLHttpRequest
     * @return {Promise<PDFNet.Image>} A promise that resolves to an object of type: "Image"
     */
    static createFromURL(
      doc: PDFNet.PDFDoc,
      url: string,
      encoder_hints?: number,
      options?: {
        withCredentials: boolean;
      },
    ): Promise<PDFNet.Image>;
  }
  /**
   * An ink annotation (PDF 1.3) represents a freehand "scribble" composed
   * of one or more disjoint paths. When opened, it shall display a pop-up
   * window containing the text of the associated note.
   * @class
   * @name InkAnnot
   * @memberof PDFNet
   */
  class InkAnnot {
    /**
     * creates an Ink annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.InkAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.InkAnnot>} A promise that resolves to an object of type: "InkAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.InkAnnot>;
    /**
     * creates an Ink annotation and initializes it using given annotation object.
     * @method PDFNet.InkAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Ink annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.InkAnnot>} A promise that resolves to an object of type: "InkAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.InkAnnot>;
    /**
     * Creates a new Ink annotation in the specified document.
     *
     * @method PDFNet.InkAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the Ink annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the Ink annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.InkAnnot>} A promise that resolves to a newly created blank Ink annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.InkAnnot>;
    /**
     * Returns number of paths in the annotation.
     *
     * @method PDFNet.InkAnnot#getPathCount
     * @return {Promise<number>} A promise that resolves to an integer representing the number of paths in the 'InkList'
     * entry of the annotation dictionary.
     * @note Each path is an array of Point objects specifying points along the path.
     * When drawn, the points shall be connected by straight lines or curves
     * in an implementation-dependent way.
     */
    getPathCount(): Promise<number>;
    /**
     * Returns number of points in a certain stroked path in the InkList.
     *
     * @method PDFNet.InkAnnot#getPointCount
     * @param {number} pathindex path index for each the point count is returned. Index starts at 0.
     * @return {Promise<number>} A promise that resolves to an integer representing the number of points in the stroked path of the Ink list.
     * @see GetPathCount()
     */
    getPointCount(pathindex: number): Promise<number>;
    /**
     * Returns the specific point in a given path.
     *
     * @method PDFNet.InkAnnot#getPoint
     * @param {number} pathindex path index for each the point is returned. Index starts at 0.
     * @param {number} pointindex index of point in the path. Index starts at 0.
     * @return {Promise<PDFNet.Point>} A promise that resolves to a Point object for specified path and point index.
     * @note Each path is an array of Point objects specifying points along the path.
     * When drawn, the points shall be connected by straight lines or curves
     * in an implementation-dependent way.
     */
    getPoint(pathindex: number, pointindex: number): Promise<PDFNet.Point>;
    /**
     * sets the specific point in the Ink List, adding it if needed.
     *
     * @method PDFNet.InkAnnot#setPoint
     * @param {number} pathindex An unsigned integer indicating the index of the path.
     * @param {number} pointindex An unsigned integer indicating the index of the point
     * within the stroked path indicated by the parameter "pathindex".
     * @param {PDFNet.Point} pt A Point object that is to be assigned.
     * @note Ink annotation contains an array of paths.
     * Each path is an array of Point objects specifying points along the path.
     * When drawn, the points shall be connected by straight lines or curves
     * in an implementation-dependent way.
     */
    setPoint(pathindex: number, pointindex: number, pt: PDFNet.Point): void;
    /**
     * Erase a rectangle area formed by pt1pt2 with width
     *
     * @method PDFNet.InkAnnot#erase
     * @param {PDFNet.Point} pt1 A point object that is one end of the eraser segment
     * @param {PDFNet.Point} pt2 A point object that is the other end of the eraser segment
     * @param {number} width The half width of the eraser
     * @return {Promise<boolean>} A promise that resolves to whether an ink stroke was erased
     */
    erase(pt1: PDFNet.Point, pt2: PDFNet.Point, width: number): Promise<boolean>;
    /**
     * Retrieves whether the Ink will draw like a highlighter.
     * @method PDFNet.InkAnnot#getHighlightIntent
     * @return {Promise<boolean>} A promise that resolves to true if the Ink will draw like a highlighter. (multiply blend mode)
     * If false it will draw in normal mode. (normal blend mode)
     */
    getHighlightIntent(): Promise<boolean>;
    /**
     * Enables or disables the Ink drawing like a highlighter.
     * @method PDFNet.InkAnnot#setHighlightIntent
     * @param {boolean} highlight true if the Ink will draw like a highlighter. (multiply blend mode)
     * If false it will draw in normal mode. (normal blend mode)
     */
    setHighlightIntent(highlight: boolean): void;
  }
  /**
   * Supports a simple iteration over a generic collection.
   * @class
   * @name Iterator
   * @memberof PDFNet
   */
  class Iterator {
    /**
     * @method PDFNet.Iterator#hasNext
     * @return {Promise<boolean>} A promise that resolves to true if the iterator can be successfully advanced to the
     * next element; false if the iterator is no longer valid.
     */
    hasNext(): Promise<boolean>;
    /**
     * Advances the iterator to the next element of the collection.
     * @method PDFNet.Iterator#next
     */
    next(): void;
    /**
     * Destructor
     * @method PDFNet.Iterator#destroy
     */
    destroy(): void;
    /**
     * @return {Promise<Object>} A promise that resolves to an object which this iterator points to.
     * @method PDFNet.Iterator#current
     */
    current(): Promise<object>;
  }
  /**
   * [Missing documentation]
   * @class
   * @name KeyStrokeActionResult
   * @memberof PDFNet
   */
  class KeyStrokeActionResult {
    /**
     *
     * @method PDFNet.KeyStrokeActionResult#isValid
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    isValid(): Promise<boolean>;
    /**
     *
     * @method PDFNet.KeyStrokeActionResult#getText
     * @return {Promise<string>} A promise that resolves to an object of type: "string"
     */
    getText(): Promise<string>;
    /**
     * Destructor
     * @method PDFNet.KeyStrokeActionResult#destroy
     */
    destroy(): void;
    /**
     * Copy Constructor
     * @method PDFNet.KeyStrokeActionResult#copy
     * @return {Promise<PDFNet.KeyStrokeActionResult>} A promise that resolves to an object of type: "KeyStrokeActionResult"
     */
    copy(): Promise<PDFNet.KeyStrokeActionResult>;
  }
  /**
   * [Missing documentation]
   * @class
   * @name KeyStrokeEventData
   * @memberof PDFNet
   */
  class KeyStrokeEventData {
    /**
     * Constructor
     * @method PDFNet.KeyStrokeEventData.create
     * @param {string} field_name
     * @param {string} current
     * @param {string} change
     * @param {number} selection_start
     * @param {number} selection_end
     * @return {Promise<PDFNet.KeyStrokeEventData>} A promise that resolves to an object of type: "KeyStrokeEventData"
     */
    static create(
      field_name: string,
      current: string,
      change: string,
      selection_start: number,
      selection_end: number,
    ): Promise<PDFNet.KeyStrokeEventData>;
    /**
     * Destructor
     * @method PDFNet.KeyStrokeEventData#destroy
     */
    destroy(): void;
    /**
     * Copy Constructor
     * @method PDFNet.KeyStrokeEventData#copy
     * @return {Promise<PDFNet.KeyStrokeEventData>} A promise that resolves to an object of type: "KeyStrokeEventData"
     */
    copy(): Promise<PDFNet.KeyStrokeEventData>;
  }
  /**
   * A line annotation (PDF 1.3) is used to display a single straight
   * line on the page. When opened, it should display a pop-up window containing
   * the text of the associated note.
   * @class
   * @name LineAnnot
   * @memberof PDFNet
   */
  class LineAnnot {
    /**
     *
     * @method PDFNet.LineAnnot.createFromObj
     * @param {PDFNet.Obj} [d]
     * @return {Promise<PDFNet.LineAnnot>} A promise that resolves to an object of type: "LineAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.LineAnnot>;
    /**
     * creates a Line annotation and initializes it using given annotation object.
     * @method PDFNet.LineAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Line annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.LineAnnot>} A promise that resolves to an object of type: "LineAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.LineAnnot>;
    /**
     * Creates a new Line annotation in the specified document.
     *
     * @method PDFNet.LineAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.LineAnnot>} A promise that resolves to a newly created blank Line annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.LineAnnot>;
    /**
     * Returns the coordinates of the start of a line.
     *
     * @method PDFNet.LineAnnot#getStartPoint
     * @return {Promise<PDFNet.Point>} A promise that resolves to a point specifying the coordinates of the start of the line.
     */
    getStartPoint(): Promise<PDFNet.Point>;
    /**
     * sets the coordinates of the start of a line.
     * @method PDFNet.LineAnnot#setStartPoint
     * @param {PDFNet.Point} sp  A point specifying the coordinates of the end of the line.
     */
    setStartPoint(sp: PDFNet.Point): void;
    /**
     * Returns the coordinates of the end of a line.
     *
     * @method PDFNet.LineAnnot#getEndPoint
     * @return {Promise<PDFNet.Point>} A promise that resolves to a point specifying the coordinates of the end of the line.
     */
    getEndPoint(): Promise<PDFNet.Point>;
    /**
     * sets the coordinates of the end of a line.
     * @method PDFNet.LineAnnot#setEndPoint
     * @param {PDFNet.Point} ep A point specifying the coordinates of the end of the line.
     */
    setEndPoint(ep: PDFNet.Point): void;
    /**
     * Returns the ending style that applies to the first point of the line.
     *
     * @method PDFNet.LineAnnot#getStartStyle
     * @return {Promise<number>} A promise that resolves to a enum value from the "EndingStyle".
     * @note Default value: e_None.
     * @example Return value enum:
     * <pre>
     * PDFNet.LineAnnot.EndingStyle = {
     * 	e_Square : 0
     * 	e_Circle : 1
     * 	e_Diamond : 2
     * 	e_OpenArrow : 3
     * 	e_ClosedArrow : 4
     * 	e_Butt : 5
     * 	e_ROpenArrow : 6
     * 	e_RClosedArrow : 7
     * 	e_Slash : 8
     * 	e_None : 9
     * 	e_Unknown : 10
     * }
     * </pre>
     */
    getStartStyle(): Promise<number>;
    /**
     * sets the ending style that applies to the first point of the line.
     * (Optional; PDF 1.4.)
     *
     * @method PDFNet.LineAnnot#setStartStyle
     * @param {number} ss
     * <pre>
     * PDFNet.LineAnnot.EndingStyle = {
     * 	e_Square : 0
     * 	e_Circle : 1
     * 	e_Diamond : 2
     * 	e_OpenArrow : 3
     * 	e_ClosedArrow : 4
     * 	e_Butt : 5
     * 	e_ROpenArrow : 6
     * 	e_RClosedArrow : 7
     * 	e_Slash : 8
     * 	e_None : 9
     * 	e_Unknown : 10
     * }
     * </pre>
     * A enum value from the "EndingStyle".
     * @note Default value: e_None.
     */
    setStartStyle(ss: number): void;
    /**
     * Returns the ending style  that applies to the second point of the line.
     *
     * @method PDFNet.LineAnnot#getEndStyle
     * @return {Promise<number>} A promise that resolves to a enum value from the "EndingStyle".
     * @note Default value: e_None.
     * @example Return value enum:
     * <pre>
     * PDFNet.LineAnnot.EndingStyle = {
     * 	e_Square : 0
     * 	e_Circle : 1
     * 	e_Diamond : 2
     * 	e_OpenArrow : 3
     * 	e_ClosedArrow : 4
     * 	e_Butt : 5
     * 	e_ROpenArrow : 6
     * 	e_RClosedArrow : 7
     * 	e_Slash : 8
     * 	e_None : 9
     * 	e_Unknown : 10
     * }
     * </pre>
     */
    getEndStyle(): Promise<number>;
    /**
     * sets the ending style  that applies to the second point of the line.
     * (Optional; PDF 1.4)
     *
     * @method PDFNet.LineAnnot#setEndStyle
     * @param {number} es
     * <pre>
     * PDFNet.LineAnnot.EndingStyle = {
     * 	e_Square : 0
     * 	e_Circle : 1
     * 	e_Diamond : 2
     * 	e_OpenArrow : 3
     * 	e_ClosedArrow : 4
     * 	e_Butt : 5
     * 	e_ROpenArrow : 6
     * 	e_RClosedArrow : 7
     * 	e_Slash : 8
     * 	e_None : 9
     * 	e_Unknown : 10
     * }
     * </pre>
     * A enum value from the "EndingStyle".
     * @note Default value: e_None.
     */
    setEndStyle(es: number): void;
    /**
     * Returns the leader line length of a line.
     *
     * @method PDFNet.LineAnnot#getLeaderLineLength
     * @return {Promise<number>} A promise that resolves to a number denoting the length of the leader line in default user space units.
     * @note Usually if this entry is specified, the line is intended to be a dimension line (see
     * "IT" entry of the annotation dictionary).
     * @note Leader length is length of leader lines in default user space that extend from each endpoint
     * of the line perpendicular to the line itself. A positive value shall mean that the leader lines
     * appear in the direction that is clockwise when traversing the line from its starting point to
     * its ending point (as specified by L); a negative value shall indicate the opposite direction.
     * Default value: 0 (no leader lines)
     */
    getLeaderLineLength(): Promise<number>;
    /**
     * Sets the leader line length of a line.
     * (PDF 1.6)
     *
     * @method PDFNet.LineAnnot#setLeaderLineLength
     * @param {number} length A number denoting the length of the leader line in default user space units.
     * @note Usually if this entry is specified, the line is intended to be a dimension line (see
     * "IT" entry of the annotation dictionary).
     * @note Leader length is length of leader lines in default user space that extend from each endpoint
     * of the line perpendicular to the line itself. A positive value shall mean that the leader lines
     * appear in the direction that is clockwise when traversing the line from its starting point to
     * its ending point (as specified by L); a negative value shall indicate the opposite direction.
     * Default value: 0 (no leader lines)
     */
    setLeaderLineLength(length: number): void;
    /**
     * Returns the leader line extension length of a line.
     *
     * @method PDFNet.LineAnnot#getLeaderLineExtensionLength
     * @return {Promise<number>} A promise that resolves to a number denoting the length of the leader line extension in default user space units.
     * @note The leader line extension length is a non-negative number that shall represents
     * the length of leader line extensions that extend from the line proper 180 degrees from
     * the leader lines.
     * Default value: 0 (no leader line extensions)
     */
    getLeaderLineExtensionLength(): Promise<number>;
    /**
     * Sets the leader line extension length of a line.
     * (PDF 1.6)
     *
     * @method PDFNet.LineAnnot#setLeaderLineExtensionLength
     * @param {number} length A number denoting the length of the leader line extension in default user space units.
     * @note The leader line extension length is a non-negative number that shall represents
     * the length of leader line extensions that extend from the line proper 180 degrees from
     * the leader lines.
     * Default value: 0 (no leader line extensions)
     */
    setLeaderLineExtensionLength(length: number): void;
    /**
     * Returns true if caption is to be shown, otherwise false.
     *
     * @method PDFNet.LineAnnot#getShowCaption
     * @return {Promise<boolean>} A promise that resolves to a boolean value indicating whether the caption will be shown.
     * @note If true, the text specified by the Contents or RCentries shall be replicated as a
     * caption in the appearance of the line. The text shall be rendered in a manner
     * appropriate to the content, taking into account factors such as writing direction.
     * Default value: false.
     */
    getShowCaption(): Promise<boolean>;
    /**
     * Sets the option of whether to show caption.
     *
     * @method PDFNet.LineAnnot#setShowCaption
     * @param {boolean} showCaption A boolean value indicating whether the caption will be shown.
     * @note If true, the text specified by the Contents or RC entries shall be replicated as a
     * caption in the appearance of the line. The text shall be rendered in a manner
     * appropriate to the content, taking into account factors such as writing direction.
     * Default value: false.
     */
    setShowCaption(showCaption: boolean): void;
    /**
     * Returns the intent type of the line.
     *
     * @method PDFNet.LineAnnot#getIntentType
     * @return {Promise<number>} A promise that resolves to an intent type value from the "IntentType" enum.
     * @note Intent type describes the intent of the line annotation. Valid values shall be "e_LineArrow", which means
     * that the annotation is intended to function as an arrow, and "e_LineDimension", which means that the annotation
     * is intended to function as a dimension line.
     * @example Return value enum:
     * <pre>
     * PDFNet.LineAnnot.IntentType = {
     * 	e_LineArrow : 0
     * 	e_LineDimension : 1
     * 	e_null : 2
     * }
     * </pre>
     */
    getIntentType(): Promise<number>;
    /**
     * sets the intent type of the line.
     * (For PDF 1.6)
     *
     * @method PDFNet.LineAnnot#setIntentType
     * @param {number} it
     * <pre>
     * PDFNet.LineAnnot.IntentType = {
     * 	e_LineArrow : 0
     * 	e_LineDimension : 1
     * 	e_null : 2
     * }
     * </pre>
     * An intent type value from the "IntentType" enum.
     * @note Intent type describes the intent of the line annotation. Valid values shall be "e_LineArrow", which means
     * that the annotation is intended to function as an arrow, and "e_LineDimension", which means that the annotation
     * is intended to function as a dimension line.
     */
    setIntentType(it: number): void;
    /**
     * @method PDFNet.LineAnnot#getCapPos
     * @example Return value enum:
     * <pre>
     * PDFNet.LineAnnot.CapPos = {
     * 	e_Inline : 0
     * 	e_Top : 1
     * }
     * </pre>
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     * <pre>
     * PDFNet.LineAnnot.CapPos = {
     * 	e_Inline : 0
     * 	e_Top : 1
     * }
     * </pre>
     */
    getCapPos(): Promise<number>;
    /**
     *
     * @method PDFNet.LineAnnot#setCapPos
     * @param {number} it
     * <pre>
     * PDFNet.LineAnnot.CapPos = {
     * 	e_Inline : 0
     * 	e_Top : 1
     * }
     * </pre>
     */
    setCapPos(it: number): void;
    /**
     * Returns the leader line offset length of a line.
     *
     * @method PDFNet.LineAnnot#getLeaderLineOffset
     * @return {Promise<number>} A promise that resolves to a number denoting the length of the leader line offset in default user space units.
     * @note Leader line offset number is a non-negative number that shall represent the length of the leader
     * line offset, which is the amount of empty space between the endpoints of the
     * annotation and the beginning of the leader lines.
     */
    getLeaderLineOffset(): Promise<number>;
    /**
     * sets the leader line offset length of a line.
     * (PDF 1.7)
     *
     * @method PDFNet.LineAnnot#setLeaderLineOffset
     * @param {number} length A number denoting the length of the leader line offset in default user space units.
     * @note Leader line offset number is a non-negative number that shall represent the length of the leader
     * line offset, which is the amount of empty space between the endpoints of the
     * annotation and the beginning of the leader lines.
     */
    setLeaderLineOffset(length: number): void;
    /**
     * Returns the horizontal offset of the caption.
     *
     * @method PDFNet.LineAnnot#getTextHOffset
     * @return {Promise<number>} A promise that resolves to a number denoting the horizontal offset of the caption in default user space units.
     * @note The horizontal offset specifies the offset of the caption text from the line's midpoint,
     * with a positive value indicating offset to the right and a negative value indicating offset to the left.
     * Default value: 0 (no offset from normal horizontal positioning).
     */
    getTextHOffset(): Promise<number>;
    /**
     * sets the horizontal offset of the caption.
     * (For PDF 1.7 )
     *
     * @method PDFNet.LineAnnot#setTextHOffset
     * @param {number} offset A number denoting the horizontal offset of the caption in default user space units.
     * @note The horizontal offset specifies the offset of the caption text from the line's midpoint,
     * with a positive value indicating offset to the right and a negative value indicating offset to the left.
     * Default value: 0 (no offset from normal horizontal positioning).
     */
    setTextHOffset(offset: number): void;
    /**
     * Returns the vertical offset of the caption.
     *
     * @method PDFNet.LineAnnot#getTextVOffset
     * @return {Promise<number>} A promise that resolves to a number denoting the vertical offset of the caption in default user space units.
     * @note The vertical offset specifies the offset of the caption text perpendicular to the annotation line,
     * with a positive value indicating a shift up and a negative value indicating a shift down.
     * Default value: 0 (no offset from normal vertical positioning).
     */
    getTextVOffset(): Promise<number>;
    /**
     * sets the vertical offset of the caption.
     * (For PDF 1.7 )
     *
     * @method PDFNet.LineAnnot#setTextVOffset
     * @param {number} offset A number denoting the vertical offset of the caption in default user space units.
     * @note The vertical offset specifies the offset of the caption text perpendicular to the annotation line,
     * with a positive value indicating a shift up and a negative value indicating a shift down.
     * Default value: 0 (no offset from normal vertical positioning).
     */
    setTextVOffset(offset: number): void;
  }
  /**
   * A link annotation represents either a hypertext link to a destination elsewhere in the document
   * or an action to be performed.
   * @class
   * @name LinkAnnot
   * @memberof PDFNet
   */
  class LinkAnnot {
    /**
     * creates a Link annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.LinkAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.LinkAnnot>} A promise that resolves to an object of type: "LinkAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.LinkAnnot>;
    /**
     * creates a Link annotation and initializes it using given annotation object.
     * @method PDFNet.LinkAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Link annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.LinkAnnot>} A promise that resolves to an object of type: "LinkAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.LinkAnnot>;
    /**
     * Creates a new Link annotation in the specified document.
     *
     * @method PDFNet.LinkAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the Link annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the Link annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.LinkAnnot>} A promise that resolves to a newly created blank Link annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.LinkAnnot>;
    /**
     * removes this annotation's action.
     * @method PDFNet.LinkAnnot#removeAction
     */
    removeAction(): void;
    /**
     * Returns the Action of the Link Annotation.
     *
     * @method PDFNet.LinkAnnot#getAction
     * @return {Promise<PDFNet.Action>} A promise that resolves to an Action object of the Link annotation.
     * @note The return value is an action that shall be performed when the
     * link annotation is activated
     */
    getAction(): Promise<PDFNet.Action>;
    /**
     * sets the Action of the Link Annotation.
     * (Optional; PDF 1.1 )
     *
     * @method PDFNet.LinkAnnot#setAction
     * @param {PDFNet.Action} action An Action object that shall be associated with this Link annotation.
     * @note The parameter is an action that shall be performed when the
     * link annotation is activated.
     */
    setAction(action: PDFNet.Action): void;
    /**
     * Returns the highlighting mode of this Link annotation.
     *
     * @method PDFNet.LinkAnnot#getHighlightingMode
     * @return {Promise<number>} A promise that resolves to the highLighting mode as a value of the enum "HighlightingMode".
     * @note The annotation's highlighting mode is the visual effect that shall be used when
     * the mouse button is pressed or held down inside its active area.
     * @example Return value enum:
     * <pre>
     * PDFNet.LinkAnnot.HighlightingMode = {
     * 	e_none : 0
     * 	e_invert : 1
     * 	e_outline : 2
     * 	e_push : 3
     * }
     * </pre>
     */
    getHighlightingMode(): Promise<number>;
    /**
     * Sets the highlighting mode for this Link annotation.
     * (Optional; PDF 1.2 )
     *
     * @method PDFNet.LinkAnnot#setHighlightingMode
     * @param {number} value
     * <pre>
     * PDFNet.LinkAnnot.HighlightingMode = {
     * 	e_none : 0
     * 	e_invert : 1
     * 	e_outline : 2
     * 	e_push : 3
     * }
     * </pre>
     * the mode as a value of the enum "HighlightingMode".
     * @note The annotation's highlighting mode is the visual effect that shall be used when
     * the mouse button is pressed or held down inside its active area.
     */
    setHighlightingMode(value: number): void;
    /**
     * Returns the number of QuadPoints in the 'QuadPoints' array of the Link annotation.
     *
     * @method PDFNet.LinkAnnot#getQuadPointCount
     * @return {Promise<number>} A promise that resolves to the number of QuadPoints.
     * @note An array of n QuadPoints specifying the coordinates of n quadrilaterals
     * in default user space that comprise the region in which the link should be active.
     * The coordinates specifying the four vertices of the quadrilateral are in counterclockwise order.
     * For orientation purposes, the bottom of a quadrilateral is the line formed by p1 and p2 of the QuadPoint.
     * QuadPoints shall be ignored if any coordinate in the array lies outside the region specified by Rect.
     */
    getQuadPointCount(): Promise<number>;
    /**
     * Returns the QuadPoint located at a certain index of the QuadPoint array of the Link
     * annotation.
     *
     * @method PDFNet.LinkAnnot#getQuadPoint
     * @param {number} idx The index of the QuadPoint, starts at zero and should be less than the return value of GetQuadPointCount().
     * @return {Promise<PDFNet.QuadPoint>} A promise that resolves to the QuadPoint located at a certain index of the QuadPoint array of the Link annotation.
     * @note An array of n QuadPoints specifying the coordinates of n quadrilaterals
     * in default user space that comprise the region in which the link should be active.
     * The coordinates specifying the four vertices of the quadrilateral are in counterclockwise order.
     * For orientation purposes, the bottom of a quadrilateral is the line formed by p1 and p2 of the QuadPoint.
     * QuadPoints shall be ignored if any coordinate in the array lies outside the region specified by Rect.
     */
    getQuadPoint(idx: number): Promise<PDFNet.QuadPoint>;
    /**
     * set the QuadPoint to be located at a certain index of the QuadPoint array of the Link annotation.
     * (Optional; PDF 1.6 )
     *
     * @method PDFNet.LinkAnnot#setQuadPoint
     * @param {number} idx The index of the QuadPoint, starts at zero and should be less than the return value of GetQuadPointCount().
     * @param {PDFNet.QuadPoint} qp  The QuadPoint to be stored in the annotation.
     * @note An array of n QuadPoints specifying the coordinates of n quadrilaterals
     * in default user space that comprise the region in which the link should be active.
     * The coordinates specifying the four vertices of the quadrilateral are in counterclockwise order.
     * For orientation purposes, the bottom of a quadrilateral is the line formed by p1 and p2 of the QuadPoint.
     * QuadPoints shall be ignored if any coordinate in the array lies outside the region specified by Rect.
     */
    setQuadPoint(idx: number, qp: PDFNet.QuadPoint): void;
  }
  /**
   * [Missing documentation]
   * @class
   * @name ListBoxWidget
   * @memberof PDFNet
   */
  class ListBoxWidget {
    /**
     * Constructor
     * @method PDFNet.ListBoxWidget.create
     * @param {PDFNet.PDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @param {string} [field_name]
     * @return {Promise<PDFNet.ListBoxWidget>} A promise that resolves to an object of type: "ListBoxWidget"
     */
    static create(doc: PDFNet.PDFDoc, pos: PDFNet.Rect, field_name?: string): Promise<PDFNet.ListBoxWidget>;
    /**
     *
     * @method PDFNet.ListBoxWidget.createWithField
     * @param {PDFNet.PDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @param {PDFNet.Field} field
     * @return {Promise<PDFNet.ListBoxWidget>} A promise that resolves to an object of type: "ListBoxWidget"
     */
    static createWithField(doc: PDFNet.PDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.ListBoxWidget>;
    /**
     *
     * @method PDFNet.ListBoxWidget.createFromObj
     * @param {PDFNet.Obj} [obj]
     * @return {Promise<PDFNet.ListBoxWidget>} A promise that resolves to an object of type: "ListBoxWidget"
     */
    static createFromObj(obj?: PDFNet.Obj): Promise<PDFNet.ListBoxWidget>;
    /**
     *
     * @method PDFNet.ListBoxWidget.createFromAnnot
     * @param {PDFNet.Annot} annot
     * @return {Promise<PDFNet.ListBoxWidget>} A promise that resolves to an object of type: "ListBoxWidget"
     */
    static createFromAnnot(annot: PDFNet.Annot): Promise<PDFNet.ListBoxWidget>;
    /**
     *
     * @method PDFNet.ListBoxWidget#addOption
     * @param {string} value
     */
    addOption(value: string): void;
    /**
     *
     * @method PDFNet.ListBoxWidget#addOptions
     * @param {string} options
     * @param {number} options_size
     */
    addOptions(options: string, options_size: number): void;
    /**
     *
     * @method PDFNet.ListBoxWidget#setSelectedOptions
     * @param {string} options
     * @param {number} options_size
     */
    setSelectedOptions(options: string, options_size: number): void;
    /**
     *
     * @method PDFNet.ListBoxWidget#replaceOptions
     * @param {string} options
     * @param {number} options_size
     */
    replaceOptions(options: string, options_size: number): void;
    /**
     *
     * @method PDFNet.ListBoxWidget#removeOption
     * @param {string} value
     */
    removeOption(value: string): void;
  }
  /**
   * Markup is a base class for a number of annotations types that
   * are used to mark up PDF documents. These annotations have text that
   * appears as part of the annotation and may be displayed in other ways by a
   * conforming reader, such as in a Comments pane.
   * Markup annotations may be divided into the following groups:
   * - Free text annotations display text directly on the page.
   *   The annotation's Contents entry specifies the displayed text.
   * - Most other markup annotations have an associated pop-up window
   *   that may contain text. The annotation's Contents entry specifies
   *   the text that shall be displayed when the pop-up window is opened.
   *   These include text, line, square, circle, polygon, polyline,
   *   highlight,underline, squiggly-underline, strikeout, rubber stamp,
   *   caret, ink, and file attachment annotations.
   * - Sound annotations do not have a pop-up window but may also have
   *   associated text specified by the Contents entry.
   * - A subset of markup annotations are intended to markup text of a
   *   document (e.g. highlight, strikeout, jagged, underline) and they
   *   are derived from TextMarkup base class.
   *
   * @note The pop-up annotation type must not appear by itself; it must be
   * associated with a markup annotation that uses it to display text.
   *
   * The meaning of an annotation's Contents entry varies by annotation type.
   * Typically, it is the text that shall be displayed for the annotation or,
   * if the annotation does not display text, an alternate description of the
   * annotation's contents in human-readable form. When separating text into
   * paragraphs, a CARRIAGE RETURN (0Dh) must be used.
   * @class
   * @name MarkupAnnot
   * @memberof PDFNet
   */
  class MarkupAnnot {
    /**
     * creates a markup annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.MarkupAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.MarkupAnnot>} A promise that resolves to an object of type: "MarkupAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.MarkupAnnot>;
    /**
     * creates a markup annotation and initializes it using given annotation object.
     * @method PDFNet.MarkupAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Markup annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.MarkupAnnot>} A promise that resolves to an object of type: "MarkupAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.MarkupAnnot>;
    /**
     * Returns the title of the markup annotation.
     *
     * @method PDFNet.MarkupAnnot#getTitle
     * @return {Promise<string>} A promise that resolves to a string representing the title of the markup annotation,
     * or null is the title is not specified.
     *
     * @note The title is The text label that is displayed in the
     * title bar of the annotation's pop-up window when open and active
     * Markup annotation.
     * This entry is also used to identify the user who added the annotation.
     * It corresponds to the 'T' field of the annotation's dictionary.
     */
    getTitle(): Promise<string>;
    /**
     * sets the title of the markup annotation.
     * (Optional; PDF 1.1)
     *
     * @method PDFNet.MarkupAnnot#setTitle
     * @param {string} title A string.
     * @note The title is The text label that is displayed in the
     * title bar of the annotation's pop-up window when open and active
     * Markup annotation.
     * This entry is also used to identify the user who added the annotation.
     * It corresponds to the 'T' field of the annotation's dictionary.
     */
    setTitle(title: string): void;
    /**
     * sets the title of the markup annotation.
     * (Optional; PDF 1.1)
     *
     * @method PDFNet.MarkupAnnot#setTitleUString
     * @param {string} title A string.
     * @note The title is The text label that is displayed in the
     * title bar of the annotation's pop-up window when open and active
     * Markup annotation.
     * This entry is also used to identify the user who added the annotation.
     * It corresponds to the 'T' field of the annotation's dictionary.
     */
    setTitleUString(title: string): void;
    /**
     * Returns the Popup object associated with this markup annotation.
     *
     * @method PDFNet.MarkupAnnot#getPopup
     * @return {Promise<PDFNet.Annot>} A promise that resolves to a Popup object that is associated with this markup annotation.
     * @note The Popup is An indirect reference to a pop-up annotation for
     * entering or editing the text associated with this annotation.
     */
    getPopup(): Promise<PDFNet.Annot>;
    /**
     * Sets the Popup object associated with this markup annotation.
     * (Optional; PDF 1.3 )
     *
     * @method PDFNet.MarkupAnnot#setPopup
     * @param {PDFNet.Annot} ppup A Popup object that is associated with this markup annotation.
     * @note the Popup is An indirect reference to a pop-up annotation for
     * entering or editing the text associated with this annotation.
     */
    setPopup(ppup: PDFNet.Annot): void;
    /**
     * @method PDFNet.MarkupAnnot#getOpacity
     * @return {Promise<number>} A promise that resolves to the opacity value.
     * Default value: 1.0.
     * @note This value is applied to all visible elements of the annotation in its closed state
     * (including its background and border) but not to the pop-up window that appears when
     * the annotation is opened. When an appearance stream is presented with the annotation,
     * this entry is ignored.(However, if the compliant viewer regenerates
     * the annotation's appearance stream, it may incorporate this Opacity entry
     * into the stream's content.)
     * @note This corresponds to the 'CA' field of the annotation's dictionary.
     */
    getOpacity(): Promise<number>;
    /**
     * Sets the opacity value for the annotation.
     * (Optional; PDF 1.4 )
     *
     * @method PDFNet.MarkupAnnot#setOpacity
     * @param {number} op A number indicating the Markup annotation's opacity value.
     * Default value: 1.0.
     * @note This value is applied to all visible elements of the annotation in its closed state
     * (including its background and border) but not to the pop-up window that appears when
     * the annotation is opened. When an appearance stream is presented with the annotation,
     * this entry is ignored.(However, if the compliant viewer regenerates
     * the annotation's appearance stream, it may incorporate this Opacity entry
     * into the stream's content.)
     * @note This corresponds to the 'CA' field of the annotation's dictionary.
     */
    setOpacity(op: number): void;
    /**
     * Returns the subject of the Markup annotation.
     * (PDF 1.5)
     *
     * @method PDFNet.MarkupAnnot#getSubject
     * @return {Promise<string>} A promise that resolves to a string representing the subject of the Markup annotation.
     * @note The subject is a short piece of text description about the annotation.
     * @note This corresponds to the 'Subj' field of the annotation's dictionary.
     */
    getSubject(): Promise<string>;
    /**
     * Sets subject of the Markup annotation.
     * (Optional; PDF 1.5 )
     *
     * @method PDFNet.MarkupAnnot#setSubject
     * @param {string} contents A string representing the subject of the Markup annotation.
     * @note The subject is a short piece of text description about the annotation.
     * @note This corresponds to the 'Subj' field of the annotation's dictionary.
     */
    setSubject(contents: string): void;
    /**
     * @method PDFNet.MarkupAnnot#getCreationDates
     * @return {Promise<PDFNet.Date>} A promise that resolves to the creation date for the markup annotation.
     *
     * @note This corresponds to the 'CreationDate' field of the markup annotation's dictionary.
     */
    getCreationDates(): Promise<PDFNet.Date>;
    /**
     * @method PDFNet.MarkupAnnot#getBorderEffect
     * @return {Promise<number>} A promise that resolves to the border effect of the markup annotation.
     * Default value: e_None.
     *
     * Beginning with PDF 1.5, some annotations (square, circle, and polygon) may have a 'BE' entry,
     * which is a border effect dictionary that specifies an effect that shall be applied to the border
     * of the annotations. Beginning with PDF 1.6, the free text annotation may also have a BE entry.
     * @note When "e_Cloudy" is chosen,the width and
     * dash array specified by the annotation's BorderStyle entry
     * needs to be taken into consideration.
     * @example Return value enum:
     * <pre>
     * PDFNet.MarkupAnnot.BorderEffect = {
     * 	e_None : 0
     * 	e_Cloudy : 1
     * }
     * </pre>
     */
    getBorderEffect(): Promise<number>;
    /**
     * Sets the border effect of the markup annotation. (Optional; PDF 1.5 )
     *
     * Beginning with PDF 1.5, some annotations (square, circle, and polygon) may have a 'BE' entry,
     * which is a border effect dictionary that specifies an effect that shall be applied to the border
     * of the annotations. Beginning with PDF 1.6, the free text annotation may also have a BE entry.
     * @method PDFNet.MarkupAnnot#setBorderEffect
     * @param {number} [effect]
     * <pre>
     * PDFNet.MarkupAnnot.BorderEffect = {
     * 	e_None : 0
     * 	e_Cloudy : 1
     * }
     * </pre>
     * An entry from the enum "BorderEffect" that
     * represents the border effect of the Markup annotation.
     * Default value: e_None.
     * @note When "e_Cloudy" is chosen,the width and
     * dash array specified by the annotation's BorderStyle entry
     * needs to be taken into consideration.
     */
    setBorderEffect(effect?: number): void;
    /**
     * @method PDFNet.MarkupAnnot#getBorderEffectIntensity
     * @return {Promise<number>} A promise that resolves to a number describing the intensity of the border effect, in the range 0 to 2.
     *
     * Beginning with PDF 1.5, some annotations (square, circle, and polygon) may have a 'BE' entry,
     * which is a border effect dictionary that specifies an effect that shall be applied to the border
     * of the annotations. Beginning with PDF 1.6, the free text annotation may also have a BE entry.
     */
    getBorderEffectIntensity(): Promise<number>;
    /**
     * sets the border effect intensity of the markup annotation.
     * (Optional; valid only if Border effect is Cloudy)
     *
     * Beginning with PDF 1.5, some annotations (square, circle, and polygon) may have a 'BE' entry,
     * which is a border effect dictionary that specifies an effect that shall be applied to the border
     * of the annotations. Beginning with PDF 1.6, the free text annotation may also have a BE entry.
     * @method PDFNet.MarkupAnnot#setBorderEffectIntensity
     * @param {number} [intensity] A number describing the intensity of the border effect, in the
     * range 0 (which is default) to 2.
     * @note this parameter applies only if Border effect is e_Cloudy.
     */
    setBorderEffectIntensity(intensity?: number): void;
    /**
     * Sets the creation date for the markup annotation.
     * (Optional; PDF 1.5 )
     *
     * @method PDFNet.MarkupAnnot#setCreationDates
     * @param {PDFNet.Date} dt A Date object indicating the date the markup annotation is created.
     * @note This corresponds to the 'CreationDate' field of the markup annotation's dictionary.
     */
    setCreationDates(dt: PDFNet.Date): void;
    /**
     * Returns the interior color of the annotation.
     *
     * @method PDFNet.MarkupAnnot#getInteriorColor
     * @return {Promise<PDFNet.ColorPt>} A promise that resolves to a ColorPt object that denotes the color of the annotation.
     * @note The color can be in different color spaces: Gray, RGB, or CMYK.
     * Call "GetInteriorColorCompNum" to access the color space information.
     * @note According to PDF Reference Manual interior color is not the property
     * that is expected for Markup annotations in general, but it applies
     * to many derived annotations (Line,Square,Circle,Polygon,PolyLine,Redaction) and therefore get()/set() methods are
     * provided in the base class Markup. Annotations that do not use interior color
     * will ignore the interior color ('IC' entry), if present in their annotation dictionary.
     * In case no color is specified, CMYK white is returned.
     */
    getInteriorColor(): Promise<PDFNet.ColorPt>;
    /**
     * Returns the number indicating the interior color space of the annotation.
     *
     * @method PDFNet.MarkupAnnot#getInteriorColorCompNum
     * @return {Promise<number>} A promise that resolves to an integer indicating the number of channels forming the color space.
     * 3 corresponds to RGB, 4 corresponds to CMYK, and 1 corresponds to Gray.
     * If the interior is transparent, the return value is 0.
     */
    getInteriorColorCompNum(): Promise<number>;
    /**
     *
     * @method PDFNet.MarkupAnnot#setInteriorColorRGB
     * @param {PDFNet.ColorPt} col
     */
    setInteriorColorRGB(col: PDFNet.ColorPt): void;
    /**
     * Sets the interior color of the Markup annotation.
     *
     * @method PDFNet.MarkupAnnot#setInteriorColor
     * @param {PDFNet.ColorPt} c A ColorPt object that denotes the color of the Markup annotation.
     * @param {number} CompNum An integer indicating the number of channels forming the
     * color space used. It also defines the length of the array to be allocated
     * for storing the entries of c.
     * @note It is necessary to make sure the consistency between the type of
     * parameter c and the value of parameter CompNum. RGB ColorPt corresponds to 3,
     * CMYK ColorPt corresponds to 4, Gray ColorPt corresponds to 1, and transparent
     * corresponds to 0.
     * @note According to PDF Reference Manual interior color is not the property
     * that is expected for Markup annotations in general, but it applies
     * to many derived annotation classes and therefore get()/set() methods are
     * provided in the base class Markup. Annotations that do not use interior color
     * will ignore the interior color ('IC' entry), if present in their annotation dictionary.
     *
     * Entries out of the specified color space array length will be discarded.
     * Missing entries for a specified color space will lead to potential
     * exceptions.
     */
    setInteriorColor(c: PDFNet.ColorPt, CompNum: number): void;
    /**
     * Returns the inner bounding rectangle of the Markup annotation.
     *
     * @method PDFNet.MarkupAnnot#getContentRect
     * @return {Promise<PDFNet.Rect>} A promise that resolves to a rectangle specifying the region where content should be displayed.
     *
     * @note This rectangle can be same as or inside of  the annotation's rectangle.
     * If it is smaller, such a difference may occur in
     * situations where a border effect causes the size of the annotation Rect
     * entry to increase beyond that of the rectangle. For FreeText annotation with
     * a callout, content rectangle specifies an inner region for the text to be displayed.
     * @note According to PDF Reference Manual content rectangle is not the property
     * that is expected for Markup annotations in general, but it applies
     * to many derived annotation classes (FreeText,Square,Circle,Caret) and therefore get()/set() methods are
     * provided in the base class Markup. Annotations that do not use this property
     * will ignore the content rectangle ('RD' entry), if present in their annotation dictionary.
     */
    getContentRect(): Promise<PDFNet.Rect>;
    /**
     * sets the inner bounding rectangle of the Markup annotation. (Optional)
     *
     * @method PDFNet.MarkupAnnot#setContentRect
     * @param {PDFNet.Rect} cr A Rect struct to be assign to the 'RD' entry of the annotation dictionary.
     * @note This rectangle can be same as or inside of  the annotation's rectangle.
     * If it is smaller, such a difference may occur in
     * situations where a border effect causes the size of the annotation Rect
     * entry to increase beyond that of the rectangle. For FreeText annotation with
     * a callout, content rectangle specifies an inner region for the text to be displayed.
     * @note According to PDF Reference Manual content rectangle is not the property
     * that is expected for Markup annotations in general, but it applies
     * to many derived annotation classes (FreeText,Square,Circle,Caret) and therefore get()/set() methods are
     * provided in the base class Markup. Annotations that do not use this property
     * will ignore the content rectangle ('RD' entry), if present in their annotation dictionary.
     */
    setContentRect(cr: PDFNet.Rect): void;
    /**
     * Returns the rectangle difference between overall annotation rectangle and content rectangle.
     *
     * @method PDFNet.MarkupAnnot#getPadding
     * @return {Promise<PDFNet.Rect>} A promise that resolves to a set of four numbers represented as a Rect struct.
     * @note The four numbers of the returning struct specify the difference
     * between two rectangles: the Rect entry of the annotation and the actual
     * bounding box of the underlying rectangle. Such a difference may occur in
     * situations where a border effect causes the size of the annotation Rect
     * entry to increase beyond that of the rectangle.
     * The four numbers of the returning struct correspond to the differences
     * in default user space, between the left, top, right, and bottom of the
     * two above mentioned rectangles.
     * @note GetPadding() and GetContentRectangle() both use 'RD' entry of the
     * annotation dictionary, but represent it to user in different ways.
     * @see GetContentRect()
     */
    getPadding(): Promise<PDFNet.Rect>;
    /**
     * sets the rectangle difference between overall annotation rectangle and content rectangle. (Optional)
     *
     * @method PDFNet.MarkupAnnot#setPadding
     * @param {PDFNet.Rect} rd A set of four numbers represented as a Rect struct
     * @note The four numbers of rd specify the difference
     * between two rectangles: the Rect entry of the annotation and the actual
     * bounding box of the underlying rectangle. Such a difference may occur in
     * situations where a border effect causes the size of the annotation Rect
     * entry to increase beyond that of the rectangle.
     * The four numbers of the rd correspond to the differences
     * in default user space, between the left, top, right, and bottom of the
     * two above mentioned rectangles.
     * @note SetPadding() and SetContentRectangle() both use 'RD' entry of the
     * annotation dictionary. Two methods are provided to give users additional
     * flexibility and ease of use in setting the values of the 'RD' field.
     * @see GetContentRect()
     */
    setPadding(rd: PDFNet.Rect): void;
    /**
     * Rotates the appearance of the Markup annotation.
     *
     * @method PDFNet.MarkupAnnot#rotateAppearance
     * @param {number} angle The new rotation
     * @Note: Apply a rotation to an existing appearance.
     * This rotation will be reflected in the bounding rect of the annot (which
     * will be updated), but not in any other part of the annotation dictionary.
     * This will effectively create a custom appearance for the annotation,
     * and any subsequent calls to `RefreshAppearance` will clear this transformation.
     */
    rotateAppearance(angle: number): void;
  }
  /**
   * 2D Matrix
   *
   * A Matrix2D object represents a 3x3 matrix that, in turn, represents an affine transformation.
   * A Matrix2D object stores only six of the nine numbers in a 3x3 matrix because all 3x3
   * matrices that represent affine transformations have the same third column (0, 0, 1).
   *
   * Affine transformations include rotating, scaling, reflecting, shearing, and translating.
   * In PDFNet, the Matrix2D class provides the foundation for performing affine transformations
   * on vector drawings, images, and text.
   *
   * A transformation matrix specifies the relationship between two coordinate spaces.
   * By modifying a transformation matrix, objects can be scaled, rotated, translated,
   * or transformed in other ways.
   *
   * A transformation matrix in PDF is specified by six numbers, usually in the form
   * of an array containing six elements. In its most general form, this array is denoted
   * [a b c d h v]; The following table lists the arrays that specify the most common
   * transformations:
   *
   *   - Translations are specified as [1 0 0 1 tx ty], where tx and ty are the distances
   *     to translate the origin of the coordinate system in the horizontal and vertical
   *     dimensions, respectively.
   *
   *   - Scaling is obtained by [sx 0 0 sy 0 0]. This scales the coordinates so that 1
   *     unit in the horizontal and vertical dimensions of the new coordinate system is
   *     the same size as sx and sy units, respectively, in the previous coordinate system.
   *
   *   - Rotations are produced by [cos(A) sin(A) -sin(A) cos(A) 0 0], which has the effect
   *     of rotating the coordinate system axes by an angle 'A' counterclockwise.
   *
   *   - Skew is specified by [1 tan(A) tan(B) 1 0 0], which skews the x axis by an angle
   *     A and the y axis by an angle B.
   *
   *  Matrix2D elements are positioned as follows :
   *			| m_a m_b 0 |
   *			| m_c m_d 0 |
   *			| m_h m_v 1 |
   *
   * A single Matrix2D object can store a single transformation or a sequence of transformations.
   * The latter is called a composite transformation. The matrix of a composite transformation is
   * obtained by multiplying (concatenating) the matrices of the individual transformations.
   * Because matrix multiplication is not commutative-the order in which matrices are multiplied
   * is significant. For example, if you first rotate, then scale, then translate, you get a
   * different result than if you first translate, then rotate, then scale.
   *
   * --------------------
   * Since Matrix2D is a struct, it can be created manually by calling "new PDFNet.Matrix2D(m_a, m_b, m_c, m_d, m_h, m_v)"
   * eg. var myfoo = new PDFNet.Matrix2D(1,0,0,1,0,0);
   *
   * Default values for a Matrix2D struct are:
   * m_a = 0
   * m_b = 0
   * m_c = 0
   * m_d = 0
   * m_h = 0
   * m_v = 0
   *
   * @class
   * @name Matrix2D
   * @memberof PDFNet
   */
  class Matrix2D {
    /**
     * Assignment operator.
     * @method PDFNet.Matrix2D#copy
     * @return {Promise<PDFNet.Matrix2D>} A promise that resolves to an object of type: "Matrix2D"
     */
    copy(): Promise<PDFNet.Matrix2D>;
    /**
     * The Set method sets the elements of this matrix.
     *
     * @method PDFNet.Matrix2D#set
     * @param {number} a the matrix element in the first row, first column.
     * @param {number} b the matrix element in the first row, second column.
     * @param {number} c the matrix element in the second row, first column.
     * @param {number} d the matrix element in the second row, second column.
     * @param {number} h the matrix element in the third row, first column.
     * @param {number} v the matrix element in the third row, second column.
     */
    set(a: number, b: number, c: number, d: number, h: number, v: number): void;
    /**
     * the Concat method updates this matrix with the product of itself and another matrix
     * specified through an argument list.
     *
     * @method PDFNet.Matrix2D#concat
     * @param {number} a the matrix element in the first row, first column.
     * @param {number} b the matrix element in the first row, second column.
     * @param {number} c the matrix element in the second row, first column.
     * @param {number} d the matrix element in the second row, second column.
     * @param {number} h the matrix element in the third row, first column.
     * @param {number} v the matrix element in the third row, second column.
     */
    concat(a: number, b: number, c: number, d: number, h: number, v: number): void;
    /**
     * The equality operator determines whether the elements of this matrix are equal to
     * the elements of another matrix.
     *
     * @method PDFNet.Matrix2D#equals
     * @param {PDFNet.Matrix2D} m2 A Matrix object that is compared with this Matrix object.
     * @return {Promise<boolean>} A promise that resolves to a boolean regarding whether two matrices are the same.
     */
    equals(m2: PDFNet.Matrix2D): Promise<boolean>;
    /**
     * @method PDFNet.Matrix2D#inverse
     * @return {Promise<PDFNet.Matrix2D>} A promise that resolves to if this matrix is invertible, the Inverse method returns its inverse matrix.
     */
    inverse(): Promise<PDFNet.Matrix2D>;
    /**
     * The Translate method updates this matrix with the product of itself and a
     * translation matrix (i.e. it is equivalent to this.m_h += h; this.m_v += v).
     *
     * @method PDFNet.Matrix2D#translate
     * @param {number} h the horizontal component of the translation.
     * @param {number} v the vertical component of the translation.
     *
     * @return updated this matrix
     */
    translate(h: number, v: number): any;
    /**
     * The Scale method updates this matrix with the product of itself and a scaling matrix.
     * @method PDFNet.Matrix2D#scale
     * @param {number} h the horizontal scale factor.
     * @param {number} v the vertical scale factor
     *
     * @return updated this matrix
     */
    scale(h: number, v: number): any;
    /**
     * Create zero matrix (0 0 0 0 0 0)
     * @method PDFNet.Matrix2D.createZeroMatrix
     * @return {Promise<PDFNet.Matrix2D>} A promise that resolves to an object of type: "Matrix2D"
     */
    static createZeroMatrix(): Promise<PDFNet.Matrix2D>;
    /**
     * Create identity matrix (1 0 0 1 0 0)
     * @method PDFNet.Matrix2D.createIdentityMatrix
     * @return {Promise<PDFNet.Matrix2D>} A promise that resolves to an object of type: "Matrix2D"
     */
    static createIdentityMatrix(): Promise<PDFNet.Matrix2D>;
    /**
     * @method PDFNet.Matrix2D.createRotationMatrix
     * @return {Promise<PDFNet.Matrix2D>} A promise that resolves to a rotation matrix for a given angle.
     * @param {number} angle the angle of rotation in radians.
     * Positive values specify clockwise rotation.
     */
    static createRotationMatrix(angle: number): Promise<PDFNet.Matrix2D>;
    /**
     * Creates and initializes a Matrix object based on six numbers that define an
     * affine transformation.
     *
     * @method PDFNet.Matrix2D.create
     * @param {number} [a=0] the matrix element in the first row, first column.
     * @param {number} [b=0] the matrix element in the first row, second column.
     * @param {number} [c=0] the matrix element in the second row, first column.
     * @param {number} [d=0] the matrix element in the second row, second column.
     * @param {number} [h=0] the matrix element in the third row, first column.
     * @param {number} [v=0] the matrix element in the third row, second column.
     * @return {Promise<PDFNet.Matrix2D>} A promise that resolves to an object of type: "Matrix2D".
     */
    static create(a?: number, b?: number, c?: number, d?: number, h?: number, v?: number): Promise<PDFNet.Matrix2D>;
    /**
     * Transform/multiply the point (x, y) using this matrix
     * @method PDFNet.Matrix2D#mult
     * @param {number} x x-coordinate of point to transform
     * @param {number} y y-coordinate of point to transform
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a javascript object that contains an x value and y value
     */
    mult(x: number, y: number): Promise<PDFNet.Obj>;
  }
  /**
   * A movie annotation contains animated graphics and sound to be
   * presented on the computer screen and through the speakers. When the
   * annotation is activated, the movie is played.
   * @class
   * @name MovieAnnot
   * @memberof PDFNet
   */
  class MovieAnnot {
    /**
     * creates a Movie annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.MovieAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.MovieAnnot>} A promise that resolves to an object of type: "MovieAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.MovieAnnot>;
    /**
     * creates a Movie annotation and initializes it using given annotation object.
     * @method PDFNet.MovieAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Movie annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.MovieAnnot>} A promise that resolves to an object of type: "MovieAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.MovieAnnot>;
    /**
     * Creates a new Movie annotation in the specified document.
     *
     * @method PDFNet.MovieAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the Movie annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the Movie annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.MovieAnnot>} A promise that resolves to a newly created blank Movie annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.MovieAnnot>;
    /**
     * Returns the title of the Movie Annotation.
     *
     * @method PDFNet.MovieAnnot#getTitle
     * @return {Promise<string>} A promise that resolves to a string representing the title of the Movie Annotation.
     * @note Movie actions may use this title to reference the movie annotation.
     */
    getTitle(): Promise<string>;
    /**
     * sets the title of the Movie Annotation.
     *(Optional)
     *
     * @method PDFNet.MovieAnnot#setTitle
     * @param {string} title A string representing the title of the Movie Annotation.
     * @note Movie actions may use this title to reference the movie annotation.
     */
    setTitle(title: string): void;
    /**
     * Returns the option of whether the Movie is to be played.
     *
     * @method PDFNet.MovieAnnot#isToBePlayed
     * @return {Promise<boolean>} A promise that resolves to a boolean value indicating if the movie is to be played.
     * @note IsToBePlayed is a flag specifying whether to play the movie when the annotation is activated.
     * The movie shall be played using default activation parameters. If the value is false,
     * the movie shall not be played.
     * Default value: true.
     */
    isToBePlayed(): Promise<boolean>;
    /**
     * sets the option of whether the Movie is to be played.
     *(Optional)
     *
     * @method PDFNet.MovieAnnot#setToBePlayed
     * @param {boolean} [isplay] A boolean value telling if the movie is to be played.
     * Default value: true.
     * @note IsToBePlayed is a flag specifying whether to play the movie when the annotation is activated.
     * The movie shall be played using default activation parameters. If the value is false,
     * the movie shall not be played.
     * Default value: true.
     */
    setToBePlayed(isplay?: boolean): void;
  }
  /**
   * A NameTree is a common data structure in PDF. See section 3.8.5 'Name Trees'
   * in PDF Reference Manual for more details.
   *
   * A name tree serves a similar purpose to a dictionary - associating keys and
   * values - but by different means. NameTrees allow efficient storage of very
   * large association collections (string/Obj* maps). A NameTree can have many
   * more entries than a SDF/Cos dictionary can.
   *
   * NameTree-s use SDF/Cos-style strings (not null-terminated C strings), which
   * may use Unicode encoding etc.
   *
   * <pre>
   *   PDFDoc doc("../Data/PDFReference.pdf");
   *   NameTree dests = NameTree::Find(*doc.GetSDFDoc(), "Dests");
   *   if (dests.IsValid()) {
   *     // Traversing the NameTree
   *     UString key;
   *     for (DictIterator i = dests.GetIterator(); i.HasNext(); i.Next())
   *        i.Key().GetAsPDFText(key); // ...
   *   }
   * </pre>
   * @class
   * @name NameTree
   * @memberof PDFNet
   */
  class NameTree {
    /**
     * Retrieves the NameTree inside the '/Root/Names' dictionary with the
     * specified key name, or creates it if it does not exist.
     *
     * @method PDFNet.NameTree.create
     * @param {PDFNet.SDFDoc} doc The document in which the name tree is created.
     * @param {string} name The name of the NameTree to create.
     *
     * @return {Promise<PDFNet.NameTree>} A promise that resolves to the newly created NameTree for the doc or an existing tree with
     * the same key name.
     *
     * @note although it is possible to create a name tree anywhere in the document
     * the convention is that all trees are located under '/Root/Names' dictionary.
     */
    static create(doc: PDFNet.SDFDoc, name: string): Promise<PDFNet.NameTree>;
    /**
     * Retrieves a name tree, with the given key name, from the '/Root/Names'
     * dictionary of the doc.
     *
     * @method PDFNet.NameTree.find
     * @param {PDFNet.SDFDoc} doc The document in which to search for the name.
     * @param {string} name The name of the name tree to find.
     *
     * @return {Promise<PDFNet.NameTree>} A promise that resolves to the requested NameTree. If the requested NameTree exists
     * NameTree.IsValid() will return true, and false otherwise.
     */
    static find(doc: PDFNet.SDFDoc, name: string): Promise<PDFNet.NameTree>;
    /**
     * Create a high level NameTree wrapper around an existing SDF/Cos NameTree.
     * This does not copy the object.
     *
     * @method PDFNet.NameTree.createFromObj
     * @param {PDFNet.Obj} name_tree SDF/Cos root of the NameTree object.
     * @return {Promise<PDFNet.NameTree>} A promise that resolves to an object of type: "NameTree"
     */
    static createFromObj(name_tree: PDFNet.Obj): Promise<PDFNet.NameTree>;
    /**
     * Assignment operator
     * @method PDFNet.NameTree#copy
     * @return {Promise<PDFNet.NameTree>} A promise that resolves to an object of type: "NameTree"
     */
    copy(): Promise<PDFNet.NameTree>;
    /**
     * @method PDFNet.NameTree#isValid
     * @return {Promise<boolean>} A promise that resolves to whether this is a valid (non-null) NameTree. If the
     * function returns false the underlying SDF/Cos object is null and
     * the NameTree object should be treated as null as well.
     */
    isValid(): Promise<boolean>;
    /**
     *
     * @method PDFNet.NameTree#getIterator
     * @param {string} key
     * @return {Promise<PDFNet.DictIterator>} A promise that resolves to an object of type: "DictIterator"
     */
    getIterator(key: string): Promise<PDFNet.DictIterator>;
    /**
     *
     * @method PDFNet.NameTree#getValue
     * @param {string} key
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    getValue(key: string): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.NameTree#getIteratorBegin
     * @return {Promise<PDFNet.DictIterator>} A promise that resolves to an iterator that addresses the first element in the NameTree.
     * The iterator can be used to traverse all entries stored in the NameTree.
     *
     * <pre>
     *  UString key;
     *  for (NameTreeIterator i = dests.GetIterator(); i.HasNext(); i.Next()) {
     *    i.GetKey().GetAsPDFText(key); // ...
     *  }
     * </pre>
     */
    getIteratorBegin(): Promise<PDFNet.DictIterator>;
    /**
     *
     * @method PDFNet.NameTree#put
     * @param {string} key
     * @param {PDFNet.Obj} value
     */
    put(key: string, value: PDFNet.Obj): void;
    /**
     *
     * @method PDFNet.NameTree#eraseKey
     * @param {string} key
     */
    eraseKey(key: string): void;
    /**
     * Removes the NameTree entry pointed by the iterator.
     * @method PDFNet.NameTree#erase
     * @param {PDFNet.DictIterator} pos ditionary iterator object that points to the NameTree entry to be removed.
     */
    erase(pos: PDFNet.DictIterator): void;
    /**
     * @method PDFNet.NameTree#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the object to the underlying SDF/Cos object. If the NameTree.IsValid()
     * returns false the SDF/Cos object is NULL.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
  }
  /**
   * A NumberTree is a common data structure in PDF. See section 3.8.6 'Number Trees'
   * in PDF Reference Manual for more details.
   *
   * A number tree serves a similar purpose to a dictionary - associating keys and
   * values - but by different means. NumberTrees allow efficient storage of very
   * large association collections (number/Obj* maps). A NumberTree can have many
   * more entries than a SDF/Cos dictionary can.
   *
   * Sample code:
   * <pre>
   *   PDFDoc doc("../Data/test.pdf");
   *   NumberTree labels(doc.GetRoot().Get("PageLabels").Value());
   *   if (labels.IsValid()) {
   *     // Traversing the NumberTree
   *     for (NumberTreeIterator i = labels.GetIterator(); i.HasNext(); i.Next())
   *         cout << "Key: " << i.Key().GetNumber() << endl;
   *   }
   * </pre>
   * @class
   * @name NumberTree
   * @memberof PDFNet
   */
  class NumberTree {
    /**
     * Create a high level NumberTree wrapper around an existing SDF/Cos NumberTree.
     * This does not copy the object.
     *
     * @method PDFNet.NumberTree.create
     * @param {PDFNet.Obj} number_tree SDF/Cos root of the NumberTree object.
     * @return {Promise<PDFNet.NumberTree>} A promise that resolves to an object of type: "NumberTree"
     */
    static create(number_tree: PDFNet.Obj): Promise<PDFNet.NumberTree>;
    /**
     * Assignment operator
     * @method PDFNet.NumberTree#copy
     * @return {Promise<PDFNet.NumberTree>} A promise that resolves to an object of type: "NumberTree"
     */
    copy(): Promise<PDFNet.NumberTree>;
    /**
     * @method PDFNet.NumberTree#isValid
     * @return {Promise<boolean>} A promise that resolves to whether this is a valid (non-null) NumberTree. If the
     * function returns false the underlying SDF/Cos object is null and
     * the NumberTree object should be treated as null as well.
     */
    isValid(): Promise<boolean>;
    /**
     * Search for the specified key in the NumberTree.
     *
     * @method PDFNet.NumberTree#getIterator
     * @return {Promise<PDFNet.DictIterator>} A promise that resolves to if the key is present the function returns a NumberTreeIterator the points
     * to the given Key/Value pair. If the key is not found the function returns End()
     * (a non-valid) iterator.
     *
     * @param {number} key the number representing the key to be found.
     *
     * Sample code:
     *   NumberTreeIterator i = dests.Find(5);
     *   if (i.HasNext()) {
     *     cout << "Key: " << i.GetKey()->GetNumber() << endl;
     *     cout << "Value: " << i.GetValue()->GetType() << endl;
     *   }
     *
     */
    getIterator(key: number): Promise<PDFNet.DictIterator>;
    /**
     *
     * @method PDFNet.NumberTree#getValue
     * @param {number} key
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    getValue(key: number): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.NumberTree#getIteratorBegin
     * @return {Promise<PDFNet.DictIterator>} A promise that resolves to an iterator to the first key/value pair (i.e. NNTreeData) in
     * the document. You can use the Next method on the returned iterator to
     * traverse all entries stored under the NumberTree.
     *
     * Sample code:
     * 	 for (NumberTreeIterator i = dests.GetIterator(); i.HasNext(); i.Next())
     * 	   cout << "Key: " << i.GetKey().GetNumber() << endl;
     */
    getIteratorBegin(): Promise<PDFNet.DictIterator>;
    /**
     * Puts a new entry in the name tree. If an entry with this number
     * is already in the tree, it is replaced.
     *
     * @method PDFNet.NumberTree#put
     * @param {number} key A number representing the key of the new entry.
     * @param {PDFNet.Obj} value the value associated with the key. It can be any SDF::Obj.
     */
    put(key: number, value: PDFNet.Obj): void;
    /**
     * Removes the specified object from the tree. Does nothing if no object
     * with that number exists.
     *
     * @method PDFNet.NumberTree#eraseKey
     * @param {number} key A number representing the key of the entry to be removed.
     */
    eraseKey(key: number): void;
    /**
     * Removes the NumberTree entry pointed by the iterator.
     * @method PDFNet.NumberTree#erase
     * @param {PDFNet.DictIterator} pos dictionary iterator object that points to the NumberTree entry to be removed
     */
    erase(pos: PDFNet.DictIterator): void;
    /**
     * @method PDFNet.NumberTree#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the object to the underlying SDF/Cos object. If the NumberTree.IsValid()
     * returns false the SDF/Cos object is NULL.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
  }
  /**
   * optional-content group
   * @class
   * @name OCG
   * @memberof PDFNet
   */
  class OCG {
    /**
     * Constructor
     * @method PDFNet.OCG.create
     * @param {PDFNet.PDFDoc} pdfdoc
     * @param {string} name
     * @return {Promise<PDFNet.OCG>} A promise that resolves to an object of type: "OCG"
     */
    static create(pdfdoc: PDFNet.PDFDoc, name: string): Promise<PDFNet.OCG>;
    /**
     *
     * @method PDFNet.OCG.createFromObj
     * @param {PDFNet.Obj} ocg_dict
     * @return {Promise<PDFNet.OCG>} A promise that resolves to an object of type: "OCG"
     */
    static createFromObj(ocg_dict: PDFNet.Obj): Promise<PDFNet.OCG>;
    /**
     * Copy Constructor
     * @method PDFNet.OCG#copy
     * @return {Promise<PDFNet.OCG>} A promise that resolves to an object of type: "OCG"
     */
    copy(): Promise<PDFNet.OCG>;
    /**
     * @method PDFNet.OCG#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to pointer to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.OCG#isValid
     * @return {Promise<boolean>} A promise that resolves to true if this is a valid (non-null) OCG, false otherwise.
     */
    isValid(): Promise<boolean>;
    /**
     * @method PDFNet.OCG#getName
     * @return {Promise<string>} A promise that resolves to the name of this optional-content group (OCG).
     */
    getName(): Promise<string>;
    /**
     * sets the name of this optional-content group (OCG).
     * @method PDFNet.OCG#setName
     * @param {string} value The new name.
     */
    setName(value: string): void;
    /**
     * @method PDFNet.OCG#getIntent
     * @return {Promise<PDFNet.Obj>} A promise that resolves to oCG intent.
     * An intent is a name object (or an array of name objects) broadly describing the
     * intended use, which can be either "View" or "Design". A group's content is
     * considered to be optional (that is, the group's state is considered in its
     * visibility) if any intent in its list matches an intent of the context. The
     * intent list of the context is usually set from the intent list of the document
     * configuration.
     */
    getIntent(): Promise<PDFNet.Obj>;
    /**
     * Sets the Intent entry in an optional-content group's SDF/Cos dictionary.
     * For more information, see GetIntent().
     * @method PDFNet.OCG#setIntent
     * @param {PDFNet.Obj} value The new Intent entry value (a name object or an array of name objects).
     */
    setIntent(value: PDFNet.Obj): void;
    /**
     * @method PDFNet.OCG#hasUsage
     * @return {Promise<boolean>} A promise that resolves to true if this group is associated with a Usage dictionary, false otherwise.
     */
    hasUsage(): Promise<boolean>;
    /**
     * @method PDFNet.OCG#getUsage
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the usage information associated with the given key in the Usage dictionary
     * for the group, or a NULL if the entry is not present. A Usage dictionary entry
     * provides more specific intended usage information than an intent entry.
     *
     * @param {string} key The usage key in the usage dictionary entry. The possible key values are:
     * CreatorInfo, Language, Export, Zoom, Print, View, User, PageElement.
     */
    getUsage(key: string): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.OCG#getCurrentState
     * @return {Promise<boolean>} A promise that resolves to true if this OCG object is in the ON state in a given context,
     * false otherwise.
     * @param {PDFNet.OCGContext} ctx The context for which to get the group's state.
     */
    getCurrentState(ctx: PDFNet.OCGContext): Promise<boolean>;
    /**
     * sets the current ON-OFF state of the optional-content group (OCG) object in a given context.
     * @method PDFNet.OCG#setCurrentState
     * @param {PDFNet.OCGContext} ctx The context for which to set the group's state.
     * @param {boolean} state The new state.
     */
    setCurrentState(ctx: PDFNet.OCGContext, state: boolean): void;
    /**
     * @method PDFNet.OCG#getInitialState
     * @return {Promise<boolean>} A promise that resolves to the initial state (ON or OFF) of the optional-content group
     * (OCG) object in a given configuration.
     *
     * @param {PDFNet.OCGConfig} cfg The configuration for which to get the group's initial state.
     * @note If the configuration has a BaseState of Unchanged, and the OCG is
     * not listed explicitly in its ON list or OFF list, then the initial state
     * is taken from the OCG's current state in the document's default context.
     */
    getInitialState(cfg: PDFNet.OCGConfig): Promise<boolean>;
    /**
     * sets the initial state (ON or OFF) of the optional-content group (OCG)
     * object in a given configuration.
     *
     * @method PDFNet.OCG#setInitialState
     * @param {PDFNet.OCGConfig} cfg The configuration for which to set the group's initial state.
     * @param {boolean} state The new initial state, true if the state is ON, false if it is OFF.
     */
    setInitialState(cfg: PDFNet.OCGConfig, state: boolean): void;
    /**
     * @method PDFNet.OCG#isLocked
     * @return {Promise<boolean>} A promise that resolves to true if this OCG is locked in a given configuration, false otherwise.
     * The on/off state of a locked OCG cannot be toggled by the user through the user interface.
     * @param {PDFNet.OCGConfig} cfg The OC configuration.
     */
    isLocked(cfg: PDFNet.OCGConfig): Promise<boolean>;
    /**
     * Sets the locked state of an OCG in a given configuration. The on/off state of a
     * locked OCG cannot be toggled by the user through the user interface.
     *
     * @method PDFNet.OCG#setLocked
     * @param {PDFNet.OCGConfig} cfg IN/OUT The optional-content configuration.
     * @param {boolean} state true if the OCG should be locked, false otherwise.
     */
    setLocked(cfg: PDFNet.OCGConfig, state: boolean): void;
  }
  /**
   * The OCGConfig object represents an optional-content (OC) configuration
   * structure (see section 4.10.3 in PDF Reference), used to persist a set
   * of visibility states and other optional-content information in a PDF file
   * A document has a default configuration, saved in the D entry in the
   * 'OCProperties' dictionary (that can be obtained using [PDFDoc].getOCConfig()),
   * and can have a list of other configurations, saved as an array in the
   * 'Configs' entry in the OCProperties dictionary.
   * <p>
   * Configurations are typically used to initialize the OCG ON-OFF states for
   * an optional-content context (OCGContext). The OCG order in the configuration
   * is the order in which the groups appear in the Layers panel of a PDF viewer.
   * The configuration can also define a set of mutually exclusive OCGs, called a
   * radio button group.
   * </p>
   * @class
   * @name OCGConfig
   * @memberof PDFNet
   */
  class OCGConfig {
    /**
     * Creates a new optional-content configuration from an existing SDF/Cos object.
     * @method PDFNet.OCGConfig.createFromObj
     * @param {PDFNet.Obj} dict SDF object to create optional-content configuration from.
     * @return {Promise<PDFNet.OCGConfig>} A promise that resolves to an object of type: "OCGConfig"
     */
    static createFromObj(dict: PDFNet.Obj): Promise<PDFNet.OCGConfig>;
    /**
     * Creates a new optional-content configuration object in the document.
     * @method PDFNet.OCGConfig.create
     * @param {PDFNet.PDFDoc} pdfdoc The document in which the new OCG::Config will be created.
     * @param {boolean} default_config If true, the configuration will be set as the
     * default OCG configuration (i.e. listed as a D entry under 'OCProperties'
     * dictionary).
     * @return {Promise<PDFNet.OCGConfig>} A promise that resolves to the newly created configuration object.
     */
    static create(pdfdoc: PDFNet.PDFDoc, default_config: boolean): Promise<PDFNet.OCGConfig>;
    /**
     * Copy Constructor
     * @method PDFNet.OCGConfig#copy
     * @return {Promise<PDFNet.OCGConfig>} A promise that resolves to an object of type: "OCGConfig"
     */
    copy(): Promise<PDFNet.OCGConfig>;
    /**
     * @method PDFNet.OCGConfig#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to pointer to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.OCGConfig#getOrder
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the Obj array that specifies the order of optional content (OC) groups
     * in this configuration or NULL if the configuration does not contain any OCGs.
     * The order of OCGs in the array is used to represent the order in which the
     * group names are displayed in the Layers panel of a PDF viewer application.
     * For more information, please refer to Section 4.10.3 in the PDF Reference.
     */
    getOrder(): Promise<PDFNet.Obj>;
    /**
     * Sets the user interface display order of optional-content groups (OCGs) in
     * this configuration. This is the order in which the group names are displayed
     * in the Layers panel of a PDF viewer.
     *
     * @method PDFNet.OCGConfig#setOrder
     * @param {PDFNet.Obj} value The SDF/Cos object containing the OCG order array.
     * For more information, please refer to section 4.10.3 in the PDF Reference.
     */
    setOrder(value: PDFNet.Obj): void;
    /**
     * @method PDFNet.OCGConfig#getName
     * @return {Promise<string>} A promise that resolves to the name of an optional-content configuration (suitable for
     * presentation in a user interface).
     */
    getName(): Promise<string>;
    /**
     * sets the name of an optional-content configuration (suitable for presentation
     * in a user interface). The method stores the specified string as the Name entry
     * in the configuration's SDF/Cos dictionary.
     * @method PDFNet.OCGConfig#setName
     * @param {string} value The new name string.
     */
    setName(value: string): void;
    /**
     * @method PDFNet.OCGConfig#getCreator
     * @return {Promise<string>} A promise that resolves to the creator property of an optional-content configuration. The string
     * is used to represent the name of the application or feature that created this
     * configuration.
     */
    getCreator(): Promise<string>;
    /**
     * sets the creator property of an optional-content configuration. Stores the
     * specified string as the Creator entry in the configuration's SDF/Cos dictionary.
     * @method PDFNet.OCGConfig#setCreator
     * @param {string} value The new creator string.
     */
    setCreator(value: string): void;
    /**
     * @method PDFNet.OCGConfig#getInitBaseState
     * @return {Promise<string>} A promise that resolves to the base initialization state. This state is used to initialize the states
     * of all the OCGs in a document when this configuration is applied. The value of this entry
     * must be one of the following names:
     *  <li>ON: The states of all groups are turned ON. </li>
     *  <li>OFF: The states of all groups are turned OFF.</li>
     *  <li>Unchanged: The states of all groups are left unchanged.</li>
     *
     * <p> After base initialization, the contents of the ON and OFF arrays are processed, overriding
     * the state of the groups included in the arrays.</p>
     * @note: If BaseState is present in the document's default configuration dictionary, its value must
     * be "ON".
     * @default ON.
     */
    getInitBaseState(): Promise<string>;
    /**
     * sets the base initialization state. For more info, please see GetInitBaseState().
     * @method PDFNet.OCGConfig#setInitBaseState
     * @param {string} [value] new base state ("ON", "OFF", or "Unchanged").
     */
    setInitBaseState(value?: string): void;
    /**
     * @method PDFNet.OCGConfig#getInitOnStates
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the "ON" initialization array from the configuration dictionary or
     * NULL if the array is not present. The returned object is an array of optional
     * content groups whose state should be set to ON when this configuration is applied.
     * Note: If the BaseState entry is ON, this entry is redundant.
     */
    getInitOnStates(): Promise<PDFNet.Obj>;
    /**
     * sets the 'ON' initialization array in the configuration dictionary.
     * @method PDFNet.OCGConfig#setInitOnStates
     * @param {PDFNet.Obj} value the initialization array to be used
     * @note For more info, please see SetInitOnStates() and section 4.10.3 in PDF Reference.
     */
    setInitOnStates(value: PDFNet.Obj): void;
    /**
     * @method PDFNet.OCGConfig#getInitOffStates
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the "OFF" initialization array from the configuration dictionary or
     * NULL if the array is not present. The returned object is an array of optional
     * content groups whose state should be set to OFF when this configuration is applied.
     * Note: If the BaseState entry is OFF, this entry is redundant.
     */
    getInitOffStates(): Promise<PDFNet.Obj>;
    /**
     * sets the 'OFF' initialization array in the configuration dictionary.
     * @method PDFNet.OCGConfig#setInitOffStates
     * @param {PDFNet.Obj} value the initialization array to be used.
     * @note For more info, please see SetInitOffStates() and section 4.10.3 in PDF Reference.
     */
    setInitOffStates(value: PDFNet.Obj): void;
    /**
     * @method PDFNet.OCGConfig#getIntent
     * @return {Promise<PDFNet.Obj>} A promise that resolves to oCG configuration intent. An intent is a name object (or an array of name
     * objects) broadly describing the intended use, which can be either "View" or "Design".
     * A group's content is considered to be optional (that is, the group's state is considered
     * in its visibility) if any intent in its list matches an intent of the context. The
     * intent list of the context is usually set from the intent list of the document
     * configuration. If the configuration has no Intent entry, the default value of
     * "View" is used.
     */
    getIntent(): Promise<PDFNet.Obj>;
    /**
     * Sets the Intent entry in an optional-content configuration's SDF/Cos dictionary.
     * For more information, see GetIntent().
     * @method PDFNet.OCGConfig#setIntent
     * @param {PDFNet.Obj} value The new Intent entry value (a name object or an array of name objects).
     */
    setIntent(value: PDFNet.Obj): void;
    /**
     * @method PDFNet.OCGConfig#getLockedOCGs
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the list of locked OCGs or NULL if there are no locked OCGs.
     * The on/off state of a locked OCG cannot be toggled by the user through the
     * user interface.
     */
    getLockedOCGs(): Promise<PDFNet.Obj>;
    /**
     * sets the array of locked OCGs. The on/off state of a locked OCG cannot be
     * toggled by the user through the user interface.
     *
     * @method PDFNet.OCGConfig#setLockedOCGs
     * @param {PDFNet.Obj} value An SDF/Cos array of OCG objects to be locked in this
     * configuration, or an empty array if the configuration should not contain
     * locked OCGs. The default is the empty array.
     */
    setLockedOCGs(value: PDFNet.Obj): void;
  }
  /**
     * <p>
     * The OCGContext object represents an optional-content context in a document, within which
     * document objects such as words or annotations are visible or hidden. The context keeps track
     * of the ON-OFF states of all of the optional-content groups (OCGs) in a document. Content is
     * or is not visible with respect to the OCG states stored in a specific context. Unlike other
     * objects in OCG namespace, the OCGContext does not correspond to any explicit PDF structure.
     * </p><p>
     * Each PDFView has a default context (PDF::GetOCGContext()) that it uses for on-screen drawing
     * and that determines the default state for any drawing. The context has flags that control
     * whether to draw content that is marked as optional, and whether to draw content that is not
     * marked as optional.
     * </p><p>
     * When enumerating page content, OCGContext can be passed as a parameter in ElementReader.Begin()
     * method. When using PDFDraw, PDFRasterizer, or PDFView class to render PDF pages use
     ( PDFDraw::SetOCGContext() method to select an OC context.
     * </p><p>
     * There can be more than one Context object, representing different combinations of OCG states.
     * You can change the states of OCGs within any context. You can build contexts with your own
     * combination of OCG states, and issue drawing or enumeration commands using that context.
     * For example, you can pass an optional-content context to ElementReader.Begin(). You can save
     * the resulting state information as part of the configuration (e.g. using Config::SetInit methods),
     * but the context itself has no corresponding PDF representation, and is not saved.
     * </p>
     * @class
     * @name OCGContext
     * @memberof PDFNet
     */
  class OCGContext {
    /**
     * create a context object that represents an optional-content state of the
     * document from a given configuration.
     *
     * @method PDFNet.OCGContext.createFromConfig
     * @param {PDFNet.OCGConfig} cfg A configuration from which to take initial OCG states.
     * @return {Promise<PDFNet.OCGContext>} A promise that resolves to an object of type: "OCGContext"
     */
    static createFromConfig(cfg: PDFNet.OCGConfig): Promise<PDFNet.OCGContext>;
    /**
     * Copy Constructor
     * @method PDFNet.OCGContext#copy
     * @return {Promise<PDFNet.OCGContext>} A promise that resolves to an object of type: "OCGContext"
     */
    copy(): Promise<PDFNet.OCGContext>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.OCGContext#destroy
     */
    destroy(): void;
    /**
     * @method PDFNet.OCGContext#getState
     * @return {Promise<boolean>} A promise that resolves to the ON-OFF states (true or false) for the given optional-content
     * group (OCG) in this OC context.
     *
     * @param {PDFNet.OCG} grp The optional-content group (OCG) that is queried.
     */
    getState(grp: PDFNet.OCG): Promise<boolean>;
    /**
     * sets the ON-OFF states for the given optional-content group (OCG) in this
     * context.
     * @method PDFNet.OCGContext#setState
     * @param {PDFNet.OCG} grp The optional-content group (OCG) that is queried.
     * @param {boolean} state true for 'ON' and false for 'OFF'.
     */
    setState(grp: PDFNet.OCG, state: boolean): void;
    /**
     * sets the sates of all OCGs in the context to ON or OFF.
     * @method PDFNet.OCGContext#resetStates
     * @param {boolean} all_on A flag used to specify whether the OCG states should be set
     * to ON (if true), or OFF (if false).
     */
    resetStates(all_on: boolean): void;
    /**
     * Sets the non-OC status for this context. Content that is not marked
     * as optional content is drawn (or element.IsOCVisible()) when 'draw_non_OC'
     * is true, and not drawn/visible otherwise.
     *
     * @method PDFNet.OCGContext#setNonOCDrawing
     * @param {boolean} draw_non_OC A flag specifying whether the content that is not
     * marked as optional should be treated as visible.
     */
    setNonOCDrawing(draw_non_OC: boolean): void;
    /**
     * @method PDFNet.OCGContext#getNonOCDrawing
     * @return {Promise<boolean>} A promise that resolves to the non-OC status for this context. The flag indicates whether the
     * content that is not marked as optional should be treated as visible.
     * For more information, please see SetNonOCDrawing().
     */
    getNonOCDrawing(): Promise<boolean>;
    /**
     * sets the drawing and enumeration type for this context. This type, together
     * with the visibility determined by the OCG and OCMD states, controls whether
     * content that is marked as optional content is drawn or enumerated.
     *
     * @method PDFNet.OCGContext#setOCDrawMode
     * @param {number} oc_draw_mode
     * <pre>
     * PDFNet.OCGContext.OCDrawMode = {
     * 	e_VisibleOC : 0
     * 	e_AllOC : 1
     * 	e_NoOC : 2
     * }
     * </pre>
     * A flag specifying the visibility of optional content.
     */
    setOCDrawMode(oc_draw_mode: number): void;
    /**
     * @method PDFNet.OCGContext#getOCMode
     * @return {Promise<number>} A promise that resolves to the drawing and enumeration type for this context.
     * For more information, please see SetOCMode() and OCG::Context::OCDrawMode.
     * @example Return value enum:
     * <pre>
     * PDFNet.OCGContext.OCDrawMode = {
     * 	e_VisibleOC : 0
     * 	e_AllOC : 1
     * 	e_NoOC : 2
     * }
     * </pre>
     */
    getOCMode(): Promise<number>;
  }
  /**
   * The OCMD object represents an Optional Content Membership Dictionary (OCMD)
   * that allows the visibility of optional content to depend on the states in a
   * set of optional-content groups (OCG::Group). The object directly corresponds
   * to the OCMD dictionary (Section 4.10.1 'Optional Content Groups' in PDF
   * Reference).
   * <p>
   * An OCMD collects a set of OCGs. It sets a visibility policy, so that
   * content in the member groups is visible only when all groups are ON
   * or OFF, or when any of the groups is ON or OFF. This makes it possible
   * to set up complex dependencies among groups. For example, an object can be
   * visible only if some other conditions are met (such as if another layer is
   * visible).
   * </p>
   * @class
   * @name OCMD
   * @memberof PDFNet
   */
  class OCMD {
    /**
     *
     * @method PDFNet.OCMD.createFromObj
     * @param {PDFNet.Obj} ocmd_dict
     * @return {Promise<PDFNet.OCMD>} A promise that resolves to an object of type: "OCMD"
     */
    static createFromObj(ocmd_dict: PDFNet.Obj): Promise<PDFNet.OCMD>;
    /**
     * Creates a new optional-content membership dictionary (OCMD) object in the
     * given document for the given groups and visibility policy.
     *
     * @method PDFNet.OCMD.create
     * @param {PDFNet.PDFDoc} pdfdoc The document in which the new OCMD will be created.
     * @param {PDFNet.Obj} ocgs An array of optional-content groups (OCGs) to be members of the dictionary.
     * @param {number} vis_policy
     * <pre>
     * PDFNet.OCMD.VisibilityPolicyType = {
     * 	e_AllOn : 0
     * 	e_AnyOn : 1
     * 	e_AnyOff : 2
     * 	e_AllOff : 3
     * }
     * </pre>
     * The visibility policy that determines the visibility of content with respect
     * to the ON-OFF state of OCGs listed in the dictionary.
     *
     * @return {Promise<PDFNet.OCMD>} A promise that resolves to the newly created OCG::OCMD object.
     */
    static create(pdfdoc: PDFNet.PDFDoc, ocgs: PDFNet.Obj, vis_policy: number): Promise<PDFNet.OCMD>;
    /**
     * Copy Constructor
     * @method PDFNet.OCMD#copy
     * @return {Promise<PDFNet.OCMD>} A promise that resolves to an object of type: "OCMD"
     */
    copy(): Promise<PDFNet.OCMD>;
    /**
     * @method PDFNet.OCMD#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to pointer to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * Returns the optional-content groups listed under 'OCGs' entry in the object
     * dictionary.
     *
     * @method PDFNet.OCMD#getOCGs
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a dictionary (for a single OCG::Group object), an SDF::Obj array
     * (for multiple OCG::Group objects) or NULL (for an empty OCMD).
     */
    getOCGs(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.OCMD#getVisibilityExpression
     * @return {Promise<PDFNet.Obj>} A promise that resolves to if the PDOCMD has a visibility expression entry, return the
     * SDF::Obj array object representing the expression, otherwise returns NULL.
     */
    getVisibilityExpression(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.OCMD#isValid
     * @return {Promise<boolean>} A promise that resolves to true if this is a valid (non-null) OCMD, false otherwise.
     */
    isValid(): Promise<boolean>;
    /**
     * @method PDFNet.OCMD#isCurrentlyVisible
     * @return {Promise<boolean>} A promise that resolves to true if content tagged with this OCMD is visible in the given
     * context, false if it is hidden.
     * <p>
     * Based on the optional-content groups listed in the dictionary, the current
     * ON-OFF state of those groups within the specified context, and the
     * dictionary's visibility policy, test whether the content tagged with
     * this dictionary would be visible.
     *
     * @param {PDFNet.OCGContext} ctx The context in which the visibility of content is tested.
     */
    isCurrentlyVisible(ctx: PDFNet.OCGContext): Promise<boolean>;
    /**
     * Returns the optional-content membership dictionary's visibility policy, which
     * determines the visibility of content with respect to the ON-OFF state of
     * OCGs listed in the dictionary.
     *
     * @method PDFNet.OCMD#getVisibilityPolicy
     * @return {Promise<number>} A promise that resolves to the visibility policy.
     * @example Return value enum:
     * <pre>
     * PDFNet.OCMD.VisibilityPolicyType = {
     * 	e_AllOn : 0
     * 	e_AnyOn : 1
     * 	e_AnyOff : 2
     * 	e_AllOff : 3
     * }
     * </pre>
     */
    getVisibilityPolicy(): Promise<number>;
    /**
     * Sets the optional-content membership dictionary's visibility policy, which
     * determines the visibility of content with respect to the ON-OFF state of
     * OCGs listed in the dictionary.
     * @method PDFNet.OCMD#setVisibilityPolicy
     * @param {number} vis_policy
     * <pre>
     * PDFNet.OCMD.VisibilityPolicyType = {
     * 	e_AllOn : 0
     * 	e_AnyOn : 1
     * 	e_AnyOff : 2
     * 	e_AllOff : 3
     * }
     * </pre>
     * New visibility policy.
     */
    setVisibilityPolicy(vis_policy: number): void;
  }
  /**
   * Obj is a concrete class for all SDF/Cos objects. Obj hierarchy implements the
   * composite design pattern. As a result, you can invoke a member function of any
   * 'derived' object through Obj interface. If the member function is not supported
   * (e.g. if you invoke Obj::GetNumber() on a boolean object) an Exception will be
   * thrown.
   *
   * You can use GetType() or obl.Is???() member functions to find out type-information at
   * run time, however most of the time the type can be inferred from the PDF specification.
   * Therefore when you call Doc::GetTrailer() you can assume that returned object is
   * a dictionary. If there is any ambiguity use Is???() methods.
   *
   * Objects can't be shared across documents, however you can use Doc::ImportObj()
   * to copy objects from one document to another.
   *
   * Objects can be shared within a document provided that they are created as indirect.
   * Indirect objects are the ones that are referenced in cross-reference table.
   * To create an object as indirect use doc.CreateIndirect???() (where ? is the
   * Object type).
   * @class
   * @name Obj
   * @memberof PDFNet
   */
  class Obj {
    /**
     * @method PDFNet.Obj#getType
     * @return {Promise<number>} A promise that resolves to the object type.
     * @note this method can be invoked on any Obj.
     * @example Return value enum:
     * <pre>
     * PDFNet.Obj.Type = {
     * 	e_null : 0
     * 	e_bool : 1
     * 	e_number : 2
     * 	e_name : 3
     * 	e_string : 4
     * 	e_dict : 5
     * 	e_array : 6
     * 	e_stream : 7
     * }
     * </pre>
     */
    getType(): Promise<number>;
    /**
     * @method PDFNet.Obj#getDoc
     * @return {Promise<PDFNet.SDFDoc>} A promise that resolves to the document to which this object belongs.
     * @note this method can be invoked on any Obj.
     */
    getDoc(): Promise<PDFNet.SDFDoc>;
    /**
     * The function writes the Obj to the output stream
     * @method PDFNet.Obj#write
     * @param {PDFNet.FilterWriter} stream the input stream where the Obj will be written
     * @note this method can be invoked on any Obj.
     */
    write(stream: PDFNet.FilterWriter): void;
    /**
     * @method PDFNet.Obj#isEqual
     * @return {Promise<boolean>} A promise that resolves to true if two Obj's point to the same object.
     * This method does not compare object content. For this operation use
     * IsEqualValue() instead.
     * @param {PDFNet.Obj} to Obj to compare to
     */
    isEqual(to: PDFNet.Obj): Promise<boolean>;
    /**
     * @method PDFNet.Obj#isBool
     * @return {Promise<boolean>} A promise that resolves to true if this is a Bool object, false otherwise.
     * @note this method can be invoked on any Obj.
     */
    isBool(): Promise<boolean>;
    /**
     * @method PDFNet.Obj#getBool
     * @return {Promise<boolean>} A promise that resolves to bool value if this is Bool.
     */
    getBool(): Promise<boolean>;
    /**
     * @method PDFNet.Obj#setBool
     * @param {boolean} b bool value used to set Bool object.
     */
    setBool(b: boolean): void;
    /**
     * @method PDFNet.Obj#isNumber
     * @return {Promise<boolean>} A promise that resolves to true if this is a Number object, false otherwise.
     * @note this method can be invoked on any Obj.
     */
    isNumber(): Promise<boolean>;
    /**
     * @method PDFNet.Obj#getNumber
     * @return {Promise<number>} A promise that resolves to value, if this is Number.
     */
    getNumber(): Promise<number>;
    /**
     * @method PDFNet.Obj#setNumber
     * @param {number} n value used to set Number object.
     */
    setNumber(n: number): void;
    /**
     * @method PDFNet.Obj#isNull
     * @return {Promise<boolean>} A promise that resolves to true if this is a Null object, false otherwise.
     * @note this method can be invoked on any Obj.
     */
    isNull(): Promise<boolean>;
    /**
     * @method PDFNet.Obj#isString
     * @return {Promise<boolean>} A promise that resolves to true if this is a Str (String) object, false otherwise.
     * @note this method can be invoked on any Obj.
     */
    isString(): Promise<boolean>;
    /**
     * @method PDFNet.Obj#getBuffer
     * @return {Promise<number>} A promise that resolves to a pointer to the string buffer. Please note that the string may not
     * be NULL terminated and that it may not be represented in ASCII or Unicode
     * encoding. For more information on SDF/Cos String objects, please refer to
     * section 3.2.3 'String Objects' in PDF Reference Manual.
     *
     * @note if SDF/Cos String object is represented as 'PDF Text' (Section 3.8.1
     * 'Text Strings' in PDF Reference) you can use GetAsPDFText method to obtain
     * Unicode representation of the string.
     *
     * @note use Size() member function in order to obtain the number of bytes in string buffer.
     */
    getBuffer(): Promise<number>;
    /**
     *
     * @method PDFNet.Obj#setString
     * @param {string} value
     */
    setString(value: string): void;
    /**
     * Sets the string object value.
     * @method PDFNet.Obj#setUString
     * @param {string} value A Unicode string value.
     */
    setUString(value: string): void;
    /**
     * @method PDFNet.Obj#isName
     * @return {Promise<boolean>} A promise that resolves to true if this is Name, false otherwise.
     * @note this method can be invoked on any Obj.
     */
    isName(): Promise<boolean>;
    /**
     * @method PDFNet.Obj#getName
     * @return {Promise<string>} A promise that resolves to string representing the Name object.
     */
    getName(): Promise<string>;
    /**
     * @method PDFNet.Obj#setName
     * @param {string} name value used to set Name object.
     */
    setName(name: string): void;
    /**
     * @method PDFNet.Obj#isIndirect
     * @return {Promise<boolean>} A promise that resolves to true if this is Indirect object (i.e. object referenced in the
     * cross-reference table), false otherwise.
     * @note this method can be invoked on any Obj.
     */
    isIndirect(): Promise<boolean>;
    /**
     * @method PDFNet.Obj#getObjNum
     * @return {Promise<number>} A promise that resolves to object number. If this is not an Indirect object, object number of
     * a containing indirect object is returned.
     * @note this method can be invoked on any Obj.
     */
    getObjNum(): Promise<number>;
    /**
     * @method PDFNet.Obj#getGenNum
     * @return {Promise<number>} A promise that resolves to generation number. If this is not an Indirect object, generation number of
     * a containing indirect object is returned.
     * @note this method can be invoked on any Obj.
     */
    getGenNum(): Promise<number>;
    /**
     * @method PDFNet.Obj#getOffset
     * @return {Promise<number>} A promise that resolves to object offset from the beginning of the file. If this is not an Indirect object,
     * offset of a containing indirect object is returned.
     * @note this method can be invoked on any Obj.
     */
    getOffset(): Promise<number>;
    /**
     * @method PDFNet.Obj#isFree
     * @return {Promise<boolean>} A promise that resolves to true if the object is in use or is marked as free.
     * @note this method can be invoked on any Obj.
     */
    isFree(): Promise<boolean>;
    /**
     * Set the object mark. Mark is a boolean value that can be associated with every
     * indirect object. This is especially useful when an object graph should be
     * traversed and an operation should be performed on each node only once.
     * @method PDFNet.Obj#setMark
     * @param {boolean} mark boolean value that the object's mark should be set to.
     * @note this method can be invoked on any Obj.
     */
    setMark(mark: boolean): void;
    /**
     * @method PDFNet.Obj#isMarked
     * @return {Promise<boolean>} A promise that resolves to true if the object is marked.
     * @note this method can be invoked on any Obj.
     */
    isMarked(): Promise<boolean>;
    /**
     * @method PDFNet.Obj#isLoaded
     * @return {Promise<boolean>} A promise that resolves to true if the object is loaded in memory.
     * @note this method can be invoked on any Obj.
     */
    isLoaded(): Promise<boolean>;
    /**
     * @method PDFNet.Obj#isContainer
     * @return {Promise<boolean>} A promise that resolves to true if this is a Container (a dictionary, array, or a stream),
     * false otherwise.
     * @note this method can be invoked on any Obj.
     */
    isContainer(): Promise<boolean>;
    /**
     * @method PDFNet.Obj#size
     * @return {Promise<number>} A promise that resolves to the 'size' of the object. The definition of 'size' depends on
     * the object type. In particular:
     *  For a dictionary or a stream object, the method will return the
     *    number of key/value pairs in the dictionary.
     *  For an array object the method will return the number of Obj
     *    entries in the array.
     *  For a string object the method will return the number of bytes
     *    in the string buffer.
     *  For any other object the method will always return 1.
     *
     * @note this method can be invoked on any Obj.
     */
    size(): Promise<number>;
    /**
     * @method PDFNet.Obj#getDictIterator
     * @return {Promise<PDFNet.DictIterator>} A promise that resolves to an iterator that addresses the first element in the dictionary.
     * <pre>
     *  DictIterator itr = dict.GetDictIterator();
     *  while (itr.HasNext()) {
     *      Obj key = itr.Key();
     *      Obj value = itr.Value();
     *      // ...
     *      itr.Next()
     *   }
     * </pre>
     */
    getDictIterator(): Promise<PDFNet.DictIterator>;
    /**
     * @method PDFNet.Obj#isDict
     * @return {Promise<boolean>} A promise that resolves to true if this is a dictionary (i.e. Dict), false otherwise.
     * @note this method can be invoked on any Obj.
     */
    isDict(): Promise<boolean>;
    /**
     * Search the dictionary for a given key.
     *
     * @method PDFNet.Obj#find
     * @param {string} key a key to search for in the dictionary
     *
     * @return {Promise<PDFNet.DictIterator>} A promise that resolves to the iterator to the matching key/value pair or invalid iterator
     * (i.e. itr.HasNext()==fase) if the if the dictionary does not contain the given key.
     *
     * @note A dictionary entry whose value is Obj::Null is equivalent to an absent entry.
     * <pre>
     *  DictIterator itr = info_dict.Find("Info");
     *  if (itr.HasNext()) {
     *    Obj info = itr.Value();
     *    if (info.IsDict())
     *      info.PutString("Producer", "PDFTron PDFNet SDK");
     * }
     * </pre>
     */
    find(key: string): Promise<PDFNet.DictIterator>;
    /**
     * Search the dictionary for a given key.
     *
     * @method PDFNet.Obj#findObj
     * @param {string} key a key to search for in the dictionary
     * @return {Promise<PDFNet.Obj>} A promise that resolves to nULL if the dictionary does not contain the specified key.
     * Otherwise return the corresponding value.
     * @note A dictionary entry whose value is Obj::Null is equivalent to an absent entry.
     */
    findObj(key: string): Promise<PDFNet.Obj>;
    /**
     * Search the dictionary for a given key and throw an exception if the key is not found.
     *
     * @method PDFNet.Obj#get
     * @param {string} key a key to search for in the dictionary
     * @return {Promise<PDFNet.DictIterator>} A promise that resolves to obj::Null object if the value matching specified key is a Obj::Null object.
     * otherwise return the iterator to the matching key/value pair.
     */
    get(key: string): Promise<PDFNet.DictIterator>;
    /**
     * Inserts a <key, Obj::Type::e_name> pair in the dictionary.
     *
     * @method PDFNet.Obj#putName
     * @param {string} key The key of the value to set.
     * @param {string} name The value of the Obj::Type::e_name object to be inserted into
     * the dictionary.
     *
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created name object.
     * @note If a dictionary already contains an entry with the same key, the old entry
     * will be deleted and all DictIterators to this entry will be invalidated.
     */
    putName(key: string, name: string): Promise<PDFNet.Obj>;
    /**
     * Inserts a <key, Obj::Type::e_array> pair in the dictionary.
     *
     * @method PDFNet.Obj#putArray
     * @param {string} key The key of the value to set.
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created array object.
     *
     * @note If a dictionary already contains an entry with the same key, the old entry
     * will be deleted and all DictIterators to this entry will be invalidated.
     */
    putArray(key: string): Promise<PDFNet.Obj>;
    /**
     * Inserts a <key, Obj::Type::e_bool> pair in the dictionary.
     *
     * @method PDFNet.Obj#putBool
     * @param {string} key The key of the value to set.
     * @param {boolean} value The value of the Obj::Type::e_bool object to be inserted into
     * the dictionary.
     *
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created boolean object.
     * @note If a dictionary already contains an entry with the same key, the old entry
     * will be deleted and all DictIterators to this entry will be invalidated.
     */
    putBool(key: string, value: boolean): Promise<PDFNet.Obj>;
    /**
     * Inserts a <key, Obj::Type::e_dict> pair in the dictionary.
     *
     * @method PDFNet.Obj#putDict
     * @param {string} key The key of the value to set.
     *
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created dictionary.
     * @note If a dictionary already contains an entry with the same key, the old entry
     * will be deleted and all DictIterators to this entry will be invalidated.
     */
    putDict(key: string): Promise<PDFNet.Obj>;
    /**
     * Inserts a <key, Obj::Type::e_number> pair in the dictionary.
     *
     * @method PDFNet.Obj#putNumber
     * @param {string} key The key of the value to set.
     * @param {number} value The value of the Obj::Type::e_number object to be inserted into
     * the dictionary.
     *
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created number object.
     * @note If a dictionary already contains an entry with the same key, the old entry
     * will be deleted and all DictIterators to this entry will be invalidated.
     */
    putNumber(key: string, value: number): Promise<PDFNet.Obj>;
    /**
     * Inserts a <key, Obj::Type::e_string> pair in the dictionary.
     *
     * @method PDFNet.Obj#putString
     * @param {string} key The key of the value to set.
     * @param {string} value The value of the Obj::Type::e_string object to be inserted into
     * the dictionary.
     *
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created string object.
     * @note If a dictionary already contains an entry with the same key, the old entry
     * will be deleted and all DictIterators to this entry will be invalidated.
     */
    putString(key: string, value: string): Promise<PDFNet.Obj>;
    /**
     * Inserts a <key, Obj::Type::e_string> pair in the dictionary.
     *
     * @method PDFNet.Obj#putStringWithSize
     * @param {string} key The key of the value to set.
     * @param {string} value The buffer used to set the value of the Obj::Type::e_string
     * object to be inserted into the dictionary.
     * @param {number} size The number of bytes to copy from the 'value' buffer parameter.
     *
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created string object.
     * @note If a dictionary already contains an entry with the same key, the old entry
     * will be deleted and all DictIterators to this entry will be invalidated.
     */
    putStringWithSize(key: string, value: string, size: number): Promise<PDFNet.Obj>;
    /**
     * Inserts a <key, Obj::Type::e_string> pair in the dictionary.
     *
     * @method PDFNet.Obj#putText
     * @param {string} key The key of the value to set.
     * @param {string} t The value of the Obj::Type::e_string object to be inserted into
     * the dictionary.
     * @note PutText will create the string object as a 'PDF Text' object.
     *
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created string object.
     * @note If a dictionary already contains an entry with the same key, the old entry
     * will be deleted and all DictIterators to this entry will be invalidated.
     */
    putText(key: string, t: string): Promise<PDFNet.Obj>;
    /**
     * Inserts a <key, Obj::Type::e_null> pair in the dictionary.
     * @method PDFNet.Obj#putNull
     * @param {string} key The key of the value to set.
     * @note The effect of calling this method is essentially the same as dict.Erase(key) .
     */
    putNull(key: string): void;
    /**
     * Inserts a <key, Obj> pair in the dictionary.
     * @method PDFNet.Obj#put
     * @param {string} key The key of the value to set.
     * @param {PDFNet.Obj} input_obj The value to be inserted into the dictionary. If 'obj' is
     * indirect (i.e. is a shared) object it will be inserted by reference,
     * otherwise the object will be cloned and then inserted into the dictionary.
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly inserted object.
     */
    put(key: string, input_obj: PDFNet.Obj): Promise<PDFNet.Obj>;
    /**
     * Inserts a <key, [x1,y1,x2,y2]> pair in the dictionary.
     *
     * @method PDFNet.Obj#putRect
     * @param {string} key The key of the value to set.
     * @param {number} x1 The bottom left x value of the rect to be inserted
     * @param {number} y1 The bottom left y value of the rect to be inserted
     * @param {number} x2 The top right x value of the rect to be inserted
     * @param {number} y2 The top right y value of the rect to be inserted
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created array object.
     *
     * @note If a dictionary already contains an entry with the same key, the old entry
     * will be deleted and all DictIterators to this entry will be invalidated.
     */
    putRect(key: string, x1: number, y1: number, x2: number, y2: number): Promise<PDFNet.Obj>;
    /**
     * Inserts a <key, [a,b,c,d,h,v]> pair in the dictionary.
     *
     * @method PDFNet.Obj#putMatrix
     * @param {string} key The key of the value to set.
     * @param {PDFNet.Matrix2D} mtx A matrix used to set the values in an array of six numbers.
     * The resulting array will be inserted into the dictionary.
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created array object.
     *
     * @note If a dictionary already contains an entry with the same key, the old entry
     * will be deleted and all DictIterators to this entry will be invalidated.
     */
    putMatrix(key: string, mtx: PDFNet.Matrix2D): Promise<PDFNet.Obj>;
    /**
     * Removes an element in the dictionary that matches the given key.
     * @method PDFNet.Obj#eraseFromKey
     * @param {string} key A string representing the key value of the element to remove.
     */
    eraseFromKey(key: string): void;
    /**
     * Removes an element in the dictionary from specified position.
     * @method PDFNet.Obj#erase
     * @param {PDFNet.DictIterator} pos A dictionary iterator indicating the position of the element to remove.
     */
    erase(pos: PDFNet.DictIterator): void;
    /**
     * Change the key value of a dictionary entry.
     * The key can't be renamed if another key with the same name already exists
     * in the dictionary. In this case Rename returns false.
     * @method PDFNet.Obj#rename
     * @param {string} old_key A string representing the key value to be changed.
     * @param {string} new_key A string representing the key value that the old key is changed into.
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    rename(old_key: string, new_key: string): Promise<boolean>;
    /**
     * @method PDFNet.Obj#isArray
     * @return {Promise<boolean>} A promise that resolves to true if this is an Array, false otherwise.
     * @note this method can be invoked on any Obj.
     */
    isArray(): Promise<boolean>;
    /**
     * @method PDFNet.Obj#getAt
     * @param {number} index The array element to obtain. The first element in an array has an index of zero.
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    getAt(index: number): Promise<PDFNet.Obj>;
    /**
     * Inserts an Obj::Type::e_name object in the array.
     * @method PDFNet.Obj#insertName
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created name object.
     *
     * @param {number} pos The location in the array to insert the object . The object is inserted
     *          before the specified location. The first element in an array has a pos of
     *	        zero. If pos >= Array->Length(), appends obj to array.
     * @param {string} name The value of the Obj::Type::e_name object to be inserted.
     *
     */
    insertName(pos: number, name: string): Promise<PDFNet.Obj>;
    /**
     * Inserts an Obj::Type::e_array object in the array.
     * @method PDFNet.Obj#insertArray
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created array object.
     *
     * @param {number} pos The location in the array to insert the object . The object is inserted
     *          before the specified location. The first element in an array has a pos of
     *	        zero. If pos >= Array->Length(), appends obj to array.
     *
     */
    insertArray(pos: number): Promise<PDFNet.Obj>;
    /**
     * Inserts an Obj::Type::e_bool object in the array.
     * @method PDFNet.Obj#insertBool
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created boolean object.
     *
     * @param {number} pos The location in the array to insert the object . The object is inserted
     *          before the specified location. The first element in an array has a pos of
     *	        zero. If pos >= Array->Length(), appends obj to array.
     * @param {boolean} value The value of the Obj::Type::e_bool object to be inserted.
     *
     */
    insertBool(pos: number, value: boolean): Promise<PDFNet.Obj>;
    /**
     * Inserts an Obj::Type::e_dict object in the array.
     * @method PDFNet.Obj#insertDict
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created dictionary object.
     *
     * @param {number} pos The location in the array to insert the object . The object is inserted
     *          before the specified location. The first element in an array has a pos of
     *	        zero. If pos >= Array->Length(), appends obj to array.
     *
     */
    insertDict(pos: number): Promise<PDFNet.Obj>;
    /**
     * Inserts an Obj::Type::e_number object in the array.
     * @method PDFNet.Obj#insertNumber
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created number object.
     *
     * @param {number} pos The location in the array to insert the object . The object is inserted
     *          before the specified location. The first element in an array has a pos of
     *	        zero. If pos >= Array->Length(), appends obj to array.
     * @param {number} value The value of the Obj::Type::e_number object to be inserted.
     *
     */
    insertNumber(pos: number, value: number): Promise<PDFNet.Obj>;
    /**
     * Inserts an Obj::Type::e_string object in the array.
     * @method PDFNet.Obj#insertString
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created string object.
     *
     * @param {number} pos The location in the array to insert the object . The object is inserted
     *          before the specified location. The first element in an array has a pos of
     *	        zero. If pos >= Array->Length(), appends obj to array.
     * @param {string} value The value of the Obj::Type::e_string object to be inserted.
     *
     */
    insertString(pos: number, value: string): Promise<PDFNet.Obj>;
    /**
     * Inserts an Obj::Type::e_string object in the array.
     * @method PDFNet.Obj#insertStringWithSize
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created string object.
     *
     * @param {number} pos The location in the array to insert the object . The object is inserted
     *          before the specified location. The first element in an array has a pos of
     *	        zero. If pos >= Array->Length(), appends obj to array.
     * @param {string} value The buffer used to set the value of the Obj::Type::e_string
     * object to be inserted.
     * @param {number} size The number of bytes to copy from the 'value' buffer parameter.
     *
     */
    insertStringWithSize(pos: number, value: string, size: number): Promise<PDFNet.Obj>;
    /**
     * Inserts an Obj::Type::e_string object in the array.
     * @method PDFNet.Obj#insertText
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created string object.
     *
     * @param {number} pos The location in the array to insert the object . The object is inserted
     *          before the specified location. The first element in an array has a pos of
     *	        zero. If pos >= Array->Length(), appends obj to array.
     * @param {string} t The value of the Obj::Type::e_string object to be inserted.
     *
     * @note InsertText will create the string object as a 'PDF Text' object.
     */
    insertText(pos: number, t: string): Promise<PDFNet.Obj>;
    /**
     * Inserts an Obj::Type::e_null object in the array.
     * @method PDFNet.Obj#insertNull
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created null object.
     * @param {number} pos The location in the array to insert the object . The object is inserted
     *          before the specified location. The first element in an array has a pos of
     *	        zero. If pos >= Array->Length(), appends obj to array.
     */
    insertNull(pos: number): Promise<PDFNet.Obj>;
    /**
     * Inserts an existing Obj in this array.
     * @method PDFNet.Obj#insert
     * @param {number} pos The location in the array to insert the object . The object is inserted
     *          before the specified location. The first element in an array has a pos of
     *	        zero. If pos >= Array->Length(), appends obj to array.
     * @param {PDFNet.Obj} input_obj The value to be inserted into the dictionary. If 'obj' is
     * indirect (i.e. is a shared) object it will be inserted by reference,
     * otherwise the object will be cloned and then inserted.
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly inserted object.
     */
    insert(pos: number, input_obj: PDFNet.Obj): Promise<PDFNet.Obj>;
    /**
     * Inserts an array of 4 numbers in this array.
     * @method PDFNet.Obj#insertRect
     * @param {number} pos The location in the array to insert the object . The object is inserted
     *          before the specified location. The first element in an array has a pos of
     *	        zero. If pos >= Array->Length(), appends obj to array.
     *
     * @param {number} x1 The bottom left x value of the rect to be inserted
     * @param {number} y1 The bottom left y value of the rect to be inserted
     * @param {number} x2 The top right x value of the rect to be inserted
     * @param {number} y2 The top right y value of the rect to be inserted
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created array object.
     */
    insertRect(pos: number, x1: number, y1: number, x2: number, y2: number): Promise<PDFNet.Obj>;
    /**
     * Inserts an array of 6 numbers in this array.
     * @method PDFNet.Obj#insertMatrix
     * @param {number} pos The location in the array to insert the object . The object is inserted
     *          before the specified location. The first element in an array has a pos of
     *	        zero. If pos >= Array->Length(), appends obj to array.
     *
     * @param {PDFNet.Matrix2D} mtx A matrix used to set the values in an array of six numbers.
     * The resulting array will be then inserted in this array.
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly created array object.
     */
    insertMatrix(pos: number, mtx: PDFNet.Matrix2D): Promise<PDFNet.Obj>;
    /**
     * Appends a new Obj::Type::e_name object at the end of the array.
     * @method PDFNet.Obj#pushBackName
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the new array object.
     * @param {string} name The value of the Obj::Type::e_name object.
     */
    pushBackName(name: string): Promise<PDFNet.Obj>;
    /**
     * Appends a new Obj::Type::e_array object at the end of the array.
     * @method PDFNet.Obj#pushBackArray
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the new array object.
     */
    pushBackArray(): Promise<PDFNet.Obj>;
    /**
     * Appends a new Obj::Type::e_bool object at the end of the array.
     * @method PDFNet.Obj#pushBackBool
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the new boolean object.
     * @param {boolean} value The value of the Obj::Type::e_bool object.
     */
    pushBackBool(value: boolean): Promise<PDFNet.Obj>;
    /**
     * Appends a new Obj::Type::e_dict object at the end of the array.
     * @method PDFNet.Obj#pushBackDict
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the new dictionary object.
     */
    pushBackDict(): Promise<PDFNet.Obj>;
    /**
     * Appends a new Obj::Type::e_number object at the end of the array.
     * @method PDFNet.Obj#pushBackNumber
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the new number object.
     * @param {number} value The value of the Obj::Type::e_number object.
     */
    pushBackNumber(value: number): Promise<PDFNet.Obj>;
    /**
     * Appends a new Obj::Type::e_string object at the end of the array.
     * @method PDFNet.Obj#pushBackString
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the new string object.
     * @param {string} value The value of the Obj::Type::e_string object.
     */
    pushBackString(value: string): Promise<PDFNet.Obj>;
    /**
     * Appends a new Obj::Type::e_string object at the end of the array.
     * @method PDFNet.Obj#pushBackStringWithSize
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the new string object.
     * @param {string} value The buffer used to set the value of the Obj::Type::e_string
     * object to be inserted.
     * @param {number} size The number of bytes to copy from the 'value' buffer parameter.
     */
    pushBackStringWithSize(value: string, size: number): Promise<PDFNet.Obj>;
    /**
     * Appends a new Obj::Type::e_string object at the end of the array.
     * @method PDFNet.Obj#pushBackText
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the new string object.
     * @param {string} t The value of the Obj::Type::e_string object to be inserted.
     * @note InsertText will create the string object as a 'PDF Text' object.
     */
    pushBackText(t: string): Promise<PDFNet.Obj>;
    /**
     * Appends a new Obj::Type::e_null object at the end of the array.
     * @method PDFNet.Obj#pushBackNull
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the new null object.
     */
    pushBackNull(): Promise<PDFNet.Obj>;
    /**
     * Appends an existing Obj at the end of the array.
     * @method PDFNet.Obj#pushBack
     * @param {PDFNet.Obj} input_obj The value to be inserted into the dictionary. If 'obj' is
     * indirect (i.e. is a shared) object it will be inserted by reference,
     * otherwise the object will be cloned and then appended.
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly appended object.
     */
    pushBack(input_obj: PDFNet.Obj): Promise<PDFNet.Obj>;
    /**
     * Appends an array of 4 numbers at the end of the array.
     * @method PDFNet.Obj#pushBackRect
     * @param {number} x1 The bottom left x value of the rect to be inserted
     * @param {number} y1 The bottom left y value of the rect to be inserted
     * @param {number} x2 The top right x value of the rect to be inserted
     * @param {number} y2 The top right y value of the rect to be inserted
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly appended array object.
     */
    pushBackRect(x1: number, y1: number, x2: number, y2: number): Promise<PDFNet.Obj>;
    /**
     * Appends an array of 6 numbers at the end of the array.
     * @method PDFNet.Obj#pushBackMatrix
     * @param {PDFNet.Matrix2D} mtx A matrix used to set the values in an array of six numbers.
     * The resulting array will be then inserted in this array.
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a newly appended array object.
     */
    pushBackMatrix(mtx: PDFNet.Matrix2D): Promise<PDFNet.Obj>;
    /**
     * Checks whether the position is within the array bounds and then removes it from the
     * array and moves each subsequent element to the slot with the next smaller index and
     * decrements the arrays length by 1.
     *
     * @method PDFNet.Obj#eraseAt
     * @param {number} pos The index for the array member to remove. Array indexes start at 0.
     */
    eraseAt(pos: number): void;
    /**
     * @method PDFNet.Obj#isStream
     * @return {Promise<boolean>} A promise that resolves to true if this is a Stream, false otherwise.
     * @note this method can be invoked on any Obj.
     */
    isStream(): Promise<boolean>;
    /**
     * @method PDFNet.Obj#getRawStreamLength
     * @return {Promise<number>} A promise that resolves to the length of the raw/encoded stream equal to the Length parameter
     */
    getRawStreamLength(): Promise<number>;
    /**
     *
     * @method PDFNet.Obj#setStreamData
     * @param {string} data
     * @param {number} data_size
     */
    setStreamData(data: string, data_size: number): void;
    /**
     *
     * @method PDFNet.Obj#setStreamDataWithFilter
     * @param {string} data
     * @param {number} data_size
     * @param {PDFNet.Filter} [filter_chain]
     */
    setStreamDataWithFilter(data: string, data_size: number, filter_chain?: PDFNet.Filter): void;
    /**
     * @method PDFNet.Obj#getRawStream
     * @param {boolean} decrypt If true decrypt the stream if the stream is encrypted.
     * @return {Promise<PDFNet.Filter>} A promise that resolves to A filter to the encoded stream
     */
    getRawStream(decrypt: boolean): Promise<PDFNet.Filter>;
    /**
     * @method PDFNet.Obj#getDecodedStream
     * @return {Promise<PDFNet.Filter>} A promise that resolves to A filter to the decoded stream
     */
    getDecodedStream(): Promise<PDFNet.Filter>;
    /**
     * Convert the SDF/Cos String object to 'PDF Text String' (a Unicode string).
     *
     * PDF Text Strings are not used to represent page content, however they
     * are used in text annotations, bookmark names, article names, document
     * information etc. These strings are encoded in either PDFDocEncoding or
     * Unicode character encoding. For more information on PDF Text Strings,
     * please refer to section 3.8.1 'Text Strings' in PDF Reference.
     * @method PDFNet.Obj#getAsPDFText
     * @note Not all SDF/Cos String objects are used to represent 'PDF Text'.
     * PDF Reference indicates (on a case by case basis ) where an SDF/Cos String
     * object can be used as 'PDF Text'.
     *
     * @return {Promise<string>} A promise that resolves to the Unicode string of the SDF/Cos String object
     */
    getAsPDFText(): Promise<string>;
  }
  /**
   * ObjSet is a lightweight container that can hold a collection of SDF objects.
   * @class
   * @name ObjSet
   * @memberof PDFNet
   */
  class ObjSet {
    /**
     * Constructor
     * @method PDFNet.ObjSet.create
     * @return {Promise<PDFNet.ObjSet>} A promise that resolves to an object of type: "ObjSet"
     */
    static create(): Promise<PDFNet.ObjSet>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.ObjSet#destroy
     */
    destroy(): void;
    /**
     * Create a new name object in this object set.
     * @method PDFNet.ObjSet#createName
     * @param {string} name The name of the object to create
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createName(name: string): Promise<PDFNet.Obj>;
    /**
     * Create a new array object in this object set.
     * @method PDFNet.ObjSet#createArray
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createArray(): Promise<PDFNet.Obj>;
    /**
     * Create a new boolean object in this object set.
     * @method PDFNet.ObjSet#createBool
     * @param {boolean} value The boolean value of the object to create
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createBool(value: boolean): Promise<PDFNet.Obj>;
    /**
     * Create a new dictionary object in this object set.
     * @method PDFNet.ObjSet#createDict
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createDict(): Promise<PDFNet.Obj>;
    /**
     * Create a new null object in this object set.
     * @method PDFNet.ObjSet#createNull
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createNull(): Promise<PDFNet.Obj>;
    /**
     * Create a new number object in this object set.
     * @method PDFNet.ObjSet#createNumber
     * @param {number} value numeric value of the number object to create.
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createNumber(value: number): Promise<PDFNet.Obj>;
    /**
     *
     * @method PDFNet.ObjSet#createString
     * @param {string} value
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createString(value: string): Promise<PDFNet.Obj>;
    /**
     *
     * @method PDFNet.ObjSet#createFromJson
     * @param {string} json
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createFromJson(json: string): Promise<PDFNet.Obj>;
  }
  /**
   * [Missing documentation]
   * @class
   * @name OwnedBitmap
   * @memberof PDFNet
   */
  class OwnedBitmap {}
  /**
   * PDFACompliance class is used to validate PDF documents for PDF/A (ISO 19005:1/2/3)
   * compliance or to convert existing PDF files to PDF/A compliant documents.
   *
   * The conversion option analyzes the content of existing PDF files and performs
   * a sequence of modifications in order to produce a PDF/A compliant document.
   * Features that are not suitable for long-term archiving (such as encryption,
   * obsolete compression schemes, missing fonts, or device-dependent color) are
   * replaced with their PDF/A compliant equivalents. Because the conversion process
   * applies only necessary changes to the source file, the information loss is
   * minimal. Also, because the converter provides a detailed report for each change,
   * it is simple to inspect changes and to determine whether the conversion loss
   * is acceptable.
   *
   * The validation option in PDF/A Manager can be used to quickly determine whether
   * a PDF file fully complies with the PDF/A specification according to the
   * international standard ISO 19005:1/2/3. For files that are not compliant, the
   * validation option can be used to produce a detailed report of compliance
   * violations as well as a list of relevant error objects.
   *
   * Key Functions:
   * - Checks if a PDF file is compliant with PDF/A (ISO 19005:1/2/3) specification.
   * - Converts any PDF to a PDF/A compliant document.
   * - Supports PDF/A-1a, PDF/A-1b, PDF/A-2b
   * - Produces a detailed report of compliance violations and associated PDF objects.
   * - Keeps the required changes a minimum, preserving the consistency of the original.
   * - Tracks all changes to allow for automatic assessment of data loss.
   * - Allows user to customize compliance checks or omit specific changes.
   * - Preserves tags, logical structure, and color information in existing PDF documents.
   * - Offers automatic font substitution, embedding, and subsetting options.
   * - Supports automation and batch operation. PDF/A Converter is designed to be used
   *   in unattended mode in high throughput server or batch environments
   * @class
   * @name PDFACompliance
   * @memberof PDFNet
   */
  class PDFACompliance {
    /**
     * Frees the native memory of the object.
     * @method PDFNet.PDFACompliance#destroy
     */
    destroy(): void;
    /**
     * @method PDFNet.PDFACompliance#getErrorCount
     * @return {Promise<number>} A promise that resolves to the number of compliance violations.
     */
    getErrorCount(): Promise<number>;
    /**
     * @method PDFNet.PDFACompliance#getError
     * @return {Promise<number>} A promise that resolves to the error identifier.
     * @param {number} idx The index in the array of error code identifiers.
     * The array is indexed starting from zero.
     *
     * @example Return value enum:
     * <pre>
     * PDFNet.PDFACompliance.ErrorCode = {
     * 	e_PDFA0_1_0 : 10
     * 	e_PDFA0_1_1 : 11
     * 	e_PDFA0_1_2 : 12
     * 	e_PDFA0_1_3 : 13
     * 	e_PDFA0_1_4 : 14
     * 	e_PDFA0_1_5 : 15
     * 	e_PDFA1_2_1 : 121
     * 	e_PDFA1_2_2 : 122
     * 	e_PDFA1_3_1 : 131
     * 	e_PDFA1_3_2 : 132
     * 	e_PDFA1_3_3 : 133
     * 	e_PDFA1_3_4 : 134
     * 	e_PDFA1_4_1 : 141
     * 	e_PDFA1_4_2 : 142
     * 	e_PDFA1_6_1 : 161
     * 	e_PDFA1_7_1 : 171
     * 	e_PDFA1_7_2 : 172
     * 	e_PDFA1_7_3 : 173
     * 	e_PDFA1_7_4 : 174
     * 	e_PDFA1_8_1 : 181
     * 	e_PDFA1_8_2 : 182
     * 	e_PDFA1_8_3 : 183
     * 	e_PDFA1_8_4 : 184
     * 	e_PDFA1_8_5 : 185
     * 	e_PDFA1_8_6 : 186
     * 	e_PDFA1_10_1 : 1101
     * 	e_PDFA1_11_1 : 1111
     * 	e_PDFA1_11_2 : 1112
     * 	e_PDFA1_12_1 : 1121
     * 	e_PDFA1_12_2 : 1122
     * 	e_PDFA1_12_3 : 1123
     * 	e_PDFA1_12_4 : 1124
     * 	e_PDFA1_12_5 : 1125
     * 	e_PDFA1_12_6 : 1126
     * 	e_PDFA1_13_1 : 1131
     * 	e_PDFA2_2_1 : 221
     * 	e_PDFA2_3_2 : 232
     * 	e_PDFA2_3_3 : 233
     * 	e_PDFA2_3_3_1 : 2331
     * 	e_PDFA2_3_3_2 : 2332
     * 	e_PDFA2_3_4_1 : 2341
     * 	e_PDFA2_4_1 : 241
     * 	e_PDFA2_4_2 : 242
     * 	e_PDFA2_4_3 : 243
     * 	e_PDFA2_4_4 : 244
     * 	e_PDFA2_5_1 : 251
     * 	e_PDFA2_5_2 : 252
     * 	e_PDFA2_6_1 : 261
     * 	e_PDFA2_7_1 : 271
     * 	e_PDFA2_8_1 : 281
     * 	e_PDFA2_9_1 : 291
     * 	e_PDFA2_10_1 : 2101
     * 	e_PDFA3_2_1 : 321
     * 	e_PDFA3_3_1 : 331
     * 	e_PDFA3_3_2 : 332
     * 	e_PDFA3_3_3_1 : 3331
     * 	e_PDFA3_3_3_2 : 3332
     * 	e_PDFA3_4_1 : 341
     * 	e_PDFA3_5_1 : 351
     * 	e_PDFA3_5_2 : 352
     * 	e_PDFA3_5_3 : 353
     * 	e_PDFA3_5_4 : 354
     * 	e_PDFA3_5_5 : 355
     * 	e_PDFA3_5_6 : 356
     * 	e_PDFA3_6_1 : 361
     * 	e_PDFA3_7_1 : 371
     * 	e_PDFA3_7_2 : 372
     * 	e_PDFA3_7_3 : 373
     * 	e_PDFA4_1 : 41
     * 	e_PDFA4_2 : 42
     * 	e_PDFA4_3 : 43
     * 	e_PDFA4_4 : 44
     * 	e_PDFA4_5 : 45
     * 	e_PDFA4_6 : 46
     * 	e_PDFA5_2_1 : 521
     * 	e_PDFA5_2_2 : 522
     * 	e_PDFA5_2_3 : 523
     * 	e_PDFA5_2_4 : 524
     * 	e_PDFA5_2_5 : 525
     * 	e_PDFA5_2_6 : 526
     * 	e_PDFA5_2_7 : 527
     * 	e_PDFA5_2_8 : 528
     * 	e_PDFA5_2_9 : 529
     * 	e_PDFA5_2_10 : 5210
     * 	e_PDFA5_2_11 : 5211
     * 	e_PDFA5_3_1 : 531
     * 	e_PDFA5_3_2_1 : 5321
     * 	e_PDFA5_3_2_2 : 5322
     * 	e_PDFA5_3_2_3 : 5323
     * 	e_PDFA5_3_2_4 : 5324
     * 	e_PDFA5_3_2_5 : 5325
     * 	e_PDFA5_3_3_1 : 5331
     * 	e_PDFA5_3_3_2 : 5332
     * 	e_PDFA5_3_3_3 : 5333
     * 	e_PDFA5_3_3_4 : 5334
     * 	e_PDFA5_3_4_0 : 5340
     * 	e_PDFA5_3_4_1 : 5341
     * 	e_PDFA5_3_4_2 : 5342
     * 	e_PDFA5_3_4_3 : 5343
     * 	e_PDFA6_1_1 : 611
     * 	e_PDFA6_1_2 : 612
     * 	e_PDFA6_2_1 : 621
     * 	e_PDFA6_2_2 : 622
     * 	e_PDFA6_2_3 : 623
     * 	e_PDFA7_2_1 : 721
     * 	e_PDFA7_2_2 : 722
     * 	e_PDFA7_2_3 : 723
     * 	e_PDFA7_2_4 : 724
     * 	e_PDFA7_2_5 : 725
     * 	e_PDFA7_3_1 : 731
     * 	e_PDFA7_3_2 : 732
     * 	e_PDFA7_3_3 : 733
     * 	e_PDFA7_3_4 : 734
     * 	e_PDFA7_3_5 : 735
     * 	e_PDFA7_3_6 : 736
     * 	e_PDFA7_3_7 : 737
     * 	e_PDFA7_3_8 : 738
     * 	e_PDFA7_3_9 : 739
     * 	e_PDFA7_5_1 : 751
     * 	e_PDFA7_8_1 : 781
     * 	e_PDFA7_8_2 : 782
     * 	e_PDFA7_8_3 : 783
     * 	e_PDFA7_8_4 : 784
     * 	e_PDFA7_8_5 : 785
     * 	e_PDFA7_8_6 : 786
     * 	e_PDFA7_8_7 : 787
     * 	e_PDFA7_8_8 : 788
     * 	e_PDFA7_8_9 : 789
     * 	e_PDFA7_8_10 : 7810
     * 	e_PDFA7_8_11 : 7811
     * 	e_PDFA7_8_12 : 7812
     * 	e_PDFA7_8_13 : 7813
     * 	e_PDFA7_8_14 : 7814
     * 	e_PDFA7_8_15 : 7815
     * 	e_PDFA7_8_16 : 7816
     * 	e_PDFA7_8_17 : 7817
     * 	e_PDFA7_8_18 : 7818
     * 	e_PDFA7_8_19 : 7819
     * 	e_PDFA7_8_20 : 7820
     * 	e_PDFA7_8_21 : 7821
     * 	e_PDFA7_8_22 : 7822
     * 	e_PDFA7_8_23 : 7823
     * 	e_PDFA7_8_24 : 7824
     * 	e_PDFA7_8_25 : 7825
     * 	e_PDFA7_8_26 : 7826
     * 	e_PDFA7_8_27 : 7827
     * 	e_PDFA7_8_28 : 7828
     * 	e_PDFA7_8_29 : 7829
     * 	e_PDFA7_8_30 : 7830
     * 	e_PDFA7_8_31 : 7831
     * 	e_PDFA7_11_1 : 7111
     * 	e_PDFA7_11_2 : 7112
     * 	e_PDFA7_11_3 : 7113
     * 	e_PDFA7_11_4 : 7114
     * 	e_PDFA7_11_5 : 7115
     * 	e_PDFA9_1 : 91
     * 	e_PDFA9_2 : 92
     * 	e_PDFA9_3 : 93
     * 	e_PDFA9_4 : 94
     * 	e_PDFA3_8_1 : 381
     * 	e_PDFA8_2_2 : 822
     * 	e_PDFA8_3_3_1 : 8331
     * 	e_PDFA8_3_3_2 : 8332
     * 	e_PDFA8_3_4_1 : 8341
     * 	e_PDFA1_2_3 : 123
     * 	e_PDFA1_10_2 : 1102
     * 	e_PDFA1_10_3 : 1103
     * 	e_PDFA1_12_10 : 11210
     * 	e_PDFA1_13_5 : 1135
     * 	e_PDFA2_3_10 : 2310
     * 	e_PDFA2_4_2_10 : 24220
     * 	e_PDFA2_4_2_11 : 24221
     * 	e_PDFA2_4_2_12 : 24222
     * 	e_PDFA2_4_2_13 : 24223
     * 	e_PDFA2_5_10 : 2510
     * 	e_PDFA2_5_11 : 2511
     * 	e_PDFA2_5_12 : 2512
     * 	e_PDFA2_8_3_1 : 2831
     * 	e_PDFA2_8_3_2 : 2832
     * 	e_PDFA2_8_3_3 : 2833
     * 	e_PDFA2_8_3_4 : 2834
     * 	e_PDFA2_8_3_5 : 2835
     * 	e_PDFA2_10_20 : 21020
     * 	e_PDFA2_10_21 : 21021
     * 	e_PDFA11_0_0 : 11000
     * 	e_PDFA6_2_11_8 : 62118
     * 	e_PDFA8_1 : 81
     * 	e_PDFA_3E1 : 1
     * 	e_PDFA_3E2 : 2
     * 	e_PDFA_3E3 : 3
     * 	e_PDFA_LAST : 4
     * }
     * </pre>
     */
    getError(idx: number): Promise<number>;
    /**
     * @method PDFNet.PDFACompliance#getRefObjCount
     * @return {Promise<number>} A promise that resolves to the number of object references associated with a given error.
     * @param {number} id
     * <pre>
     * PDFNet.PDFACompliance.ErrorCode = {
     * 	e_PDFA0_1_0 : 10
     * 	e_PDFA0_1_1 : 11
     * 	e_PDFA0_1_2 : 12
     * 	e_PDFA0_1_3 : 13
     * 	e_PDFA0_1_4 : 14
     * 	e_PDFA0_1_5 : 15
     * 	e_PDFA1_2_1 : 121
     * 	e_PDFA1_2_2 : 122
     * 	e_PDFA1_3_1 : 131
     * 	e_PDFA1_3_2 : 132
     * 	e_PDFA1_3_3 : 133
     * 	e_PDFA1_3_4 : 134
     * 	e_PDFA1_4_1 : 141
     * 	e_PDFA1_4_2 : 142
     * 	e_PDFA1_6_1 : 161
     * 	e_PDFA1_7_1 : 171
     * 	e_PDFA1_7_2 : 172
     * 	e_PDFA1_7_3 : 173
     * 	e_PDFA1_7_4 : 174
     * 	e_PDFA1_8_1 : 181
     * 	e_PDFA1_8_2 : 182
     * 	e_PDFA1_8_3 : 183
     * 	e_PDFA1_8_4 : 184
     * 	e_PDFA1_8_5 : 185
     * 	e_PDFA1_8_6 : 186
     * 	e_PDFA1_10_1 : 1101
     * 	e_PDFA1_11_1 : 1111
     * 	e_PDFA1_11_2 : 1112
     * 	e_PDFA1_12_1 : 1121
     * 	e_PDFA1_12_2 : 1122
     * 	e_PDFA1_12_3 : 1123
     * 	e_PDFA1_12_4 : 1124
     * 	e_PDFA1_12_5 : 1125
     * 	e_PDFA1_12_6 : 1126
     * 	e_PDFA1_13_1 : 1131
     * 	e_PDFA2_2_1 : 221
     * 	e_PDFA2_3_2 : 232
     * 	e_PDFA2_3_3 : 233
     * 	e_PDFA2_3_3_1 : 2331
     * 	e_PDFA2_3_3_2 : 2332
     * 	e_PDFA2_3_4_1 : 2341
     * 	e_PDFA2_4_1 : 241
     * 	e_PDFA2_4_2 : 242
     * 	e_PDFA2_4_3 : 243
     * 	e_PDFA2_4_4 : 244
     * 	e_PDFA2_5_1 : 251
     * 	e_PDFA2_5_2 : 252
     * 	e_PDFA2_6_1 : 261
     * 	e_PDFA2_7_1 : 271
     * 	e_PDFA2_8_1 : 281
     * 	e_PDFA2_9_1 : 291
     * 	e_PDFA2_10_1 : 2101
     * 	e_PDFA3_2_1 : 321
     * 	e_PDFA3_3_1 : 331
     * 	e_PDFA3_3_2 : 332
     * 	e_PDFA3_3_3_1 : 3331
     * 	e_PDFA3_3_3_2 : 3332
     * 	e_PDFA3_4_1 : 341
     * 	e_PDFA3_5_1 : 351
     * 	e_PDFA3_5_2 : 352
     * 	e_PDFA3_5_3 : 353
     * 	e_PDFA3_5_4 : 354
     * 	e_PDFA3_5_5 : 355
     * 	e_PDFA3_5_6 : 356
     * 	e_PDFA3_6_1 : 361
     * 	e_PDFA3_7_1 : 371
     * 	e_PDFA3_7_2 : 372
     * 	e_PDFA3_7_3 : 373
     * 	e_PDFA4_1 : 41
     * 	e_PDFA4_2 : 42
     * 	e_PDFA4_3 : 43
     * 	e_PDFA4_4 : 44
     * 	e_PDFA4_5 : 45
     * 	e_PDFA4_6 : 46
     * 	e_PDFA5_2_1 : 521
     * 	e_PDFA5_2_2 : 522
     * 	e_PDFA5_2_3 : 523
     * 	e_PDFA5_2_4 : 524
     * 	e_PDFA5_2_5 : 525
     * 	e_PDFA5_2_6 : 526
     * 	e_PDFA5_2_7 : 527
     * 	e_PDFA5_2_8 : 528
     * 	e_PDFA5_2_9 : 529
     * 	e_PDFA5_2_10 : 5210
     * 	e_PDFA5_2_11 : 5211
     * 	e_PDFA5_3_1 : 531
     * 	e_PDFA5_3_2_1 : 5321
     * 	e_PDFA5_3_2_2 : 5322
     * 	e_PDFA5_3_2_3 : 5323
     * 	e_PDFA5_3_2_4 : 5324
     * 	e_PDFA5_3_2_5 : 5325
     * 	e_PDFA5_3_3_1 : 5331
     * 	e_PDFA5_3_3_2 : 5332
     * 	e_PDFA5_3_3_3 : 5333
     * 	e_PDFA5_3_3_4 : 5334
     * 	e_PDFA5_3_4_0 : 5340
     * 	e_PDFA5_3_4_1 : 5341
     * 	e_PDFA5_3_4_2 : 5342
     * 	e_PDFA5_3_4_3 : 5343
     * 	e_PDFA6_1_1 : 611
     * 	e_PDFA6_1_2 : 612
     * 	e_PDFA6_2_1 : 621
     * 	e_PDFA6_2_2 : 622
     * 	e_PDFA6_2_3 : 623
     * 	e_PDFA7_2_1 : 721
     * 	e_PDFA7_2_2 : 722
     * 	e_PDFA7_2_3 : 723
     * 	e_PDFA7_2_4 : 724
     * 	e_PDFA7_2_5 : 725
     * 	e_PDFA7_3_1 : 731
     * 	e_PDFA7_3_2 : 732
     * 	e_PDFA7_3_3 : 733
     * 	e_PDFA7_3_4 : 734
     * 	e_PDFA7_3_5 : 735
     * 	e_PDFA7_3_6 : 736
     * 	e_PDFA7_3_7 : 737
     * 	e_PDFA7_3_8 : 738
     * 	e_PDFA7_3_9 : 739
     * 	e_PDFA7_5_1 : 751
     * 	e_PDFA7_8_1 : 781
     * 	e_PDFA7_8_2 : 782
     * 	e_PDFA7_8_3 : 783
     * 	e_PDFA7_8_4 : 784
     * 	e_PDFA7_8_5 : 785
     * 	e_PDFA7_8_6 : 786
     * 	e_PDFA7_8_7 : 787
     * 	e_PDFA7_8_8 : 788
     * 	e_PDFA7_8_9 : 789
     * 	e_PDFA7_8_10 : 7810
     * 	e_PDFA7_8_11 : 7811
     * 	e_PDFA7_8_12 : 7812
     * 	e_PDFA7_8_13 : 7813
     * 	e_PDFA7_8_14 : 7814
     * 	e_PDFA7_8_15 : 7815
     * 	e_PDFA7_8_16 : 7816
     * 	e_PDFA7_8_17 : 7817
     * 	e_PDFA7_8_18 : 7818
     * 	e_PDFA7_8_19 : 7819
     * 	e_PDFA7_8_20 : 7820
     * 	e_PDFA7_8_21 : 7821
     * 	e_PDFA7_8_22 : 7822
     * 	e_PDFA7_8_23 : 7823
     * 	e_PDFA7_8_24 : 7824
     * 	e_PDFA7_8_25 : 7825
     * 	e_PDFA7_8_26 : 7826
     * 	e_PDFA7_8_27 : 7827
     * 	e_PDFA7_8_28 : 7828
     * 	e_PDFA7_8_29 : 7829
     * 	e_PDFA7_8_30 : 7830
     * 	e_PDFA7_8_31 : 7831
     * 	e_PDFA7_11_1 : 7111
     * 	e_PDFA7_11_2 : 7112
     * 	e_PDFA7_11_3 : 7113
     * 	e_PDFA7_11_4 : 7114
     * 	e_PDFA7_11_5 : 7115
     * 	e_PDFA9_1 : 91
     * 	e_PDFA9_2 : 92
     * 	e_PDFA9_3 : 93
     * 	e_PDFA9_4 : 94
     * 	e_PDFA3_8_1 : 381
     * 	e_PDFA8_2_2 : 822
     * 	e_PDFA8_3_3_1 : 8331
     * 	e_PDFA8_3_3_2 : 8332
     * 	e_PDFA8_3_4_1 : 8341
     * 	e_PDFA1_2_3 : 123
     * 	e_PDFA1_10_2 : 1102
     * 	e_PDFA1_10_3 : 1103
     * 	e_PDFA1_12_10 : 11210
     * 	e_PDFA1_13_5 : 1135
     * 	e_PDFA2_3_10 : 2310
     * 	e_PDFA2_4_2_10 : 24220
     * 	e_PDFA2_4_2_11 : 24221
     * 	e_PDFA2_4_2_12 : 24222
     * 	e_PDFA2_4_2_13 : 24223
     * 	e_PDFA2_5_10 : 2510
     * 	e_PDFA2_5_11 : 2511
     * 	e_PDFA2_5_12 : 2512
     * 	e_PDFA2_8_3_1 : 2831
     * 	e_PDFA2_8_3_2 : 2832
     * 	e_PDFA2_8_3_3 : 2833
     * 	e_PDFA2_8_3_4 : 2834
     * 	e_PDFA2_8_3_5 : 2835
     * 	e_PDFA2_10_20 : 21020
     * 	e_PDFA2_10_21 : 21021
     * 	e_PDFA11_0_0 : 11000
     * 	e_PDFA6_2_11_8 : 62118
     * 	e_PDFA8_1 : 81
     * 	e_PDFA_3E1 : 1
     * 	e_PDFA_3E2 : 2
     * 	e_PDFA_3E3 : 3
     * 	e_PDFA_LAST : 4
     * }
     * </pre>
     * error code identifier (obtained using GetError() method).
     */
    getRefObjCount(id: number): Promise<number>;
    /**
     * @method PDFNet.PDFACompliance#getRefObj
     * @return {Promise<number>} A promise that resolves to a specific object reference associated with a given error type.
     * The return value is a PDF object identifier (i.e. object number for
     * 'pdftron.SDF.Obj)) for the that is associated with the error.
     *
     * @param {number} id
     * <pre>
     * PDFNet.PDFACompliance.ErrorCode = {
     * 	e_PDFA0_1_0 : 10
     * 	e_PDFA0_1_1 : 11
     * 	e_PDFA0_1_2 : 12
     * 	e_PDFA0_1_3 : 13
     * 	e_PDFA0_1_4 : 14
     * 	e_PDFA0_1_5 : 15
     * 	e_PDFA1_2_1 : 121
     * 	e_PDFA1_2_2 : 122
     * 	e_PDFA1_3_1 : 131
     * 	e_PDFA1_3_2 : 132
     * 	e_PDFA1_3_3 : 133
     * 	e_PDFA1_3_4 : 134
     * 	e_PDFA1_4_1 : 141
     * 	e_PDFA1_4_2 : 142
     * 	e_PDFA1_6_1 : 161
     * 	e_PDFA1_7_1 : 171
     * 	e_PDFA1_7_2 : 172
     * 	e_PDFA1_7_3 : 173
     * 	e_PDFA1_7_4 : 174
     * 	e_PDFA1_8_1 : 181
     * 	e_PDFA1_8_2 : 182
     * 	e_PDFA1_8_3 : 183
     * 	e_PDFA1_8_4 : 184
     * 	e_PDFA1_8_5 : 185
     * 	e_PDFA1_8_6 : 186
     * 	e_PDFA1_10_1 : 1101
     * 	e_PDFA1_11_1 : 1111
     * 	e_PDFA1_11_2 : 1112
     * 	e_PDFA1_12_1 : 1121
     * 	e_PDFA1_12_2 : 1122
     * 	e_PDFA1_12_3 : 1123
     * 	e_PDFA1_12_4 : 1124
     * 	e_PDFA1_12_5 : 1125
     * 	e_PDFA1_12_6 : 1126
     * 	e_PDFA1_13_1 : 1131
     * 	e_PDFA2_2_1 : 221
     * 	e_PDFA2_3_2 : 232
     * 	e_PDFA2_3_3 : 233
     * 	e_PDFA2_3_3_1 : 2331
     * 	e_PDFA2_3_3_2 : 2332
     * 	e_PDFA2_3_4_1 : 2341
     * 	e_PDFA2_4_1 : 241
     * 	e_PDFA2_4_2 : 242
     * 	e_PDFA2_4_3 : 243
     * 	e_PDFA2_4_4 : 244
     * 	e_PDFA2_5_1 : 251
     * 	e_PDFA2_5_2 : 252
     * 	e_PDFA2_6_1 : 261
     * 	e_PDFA2_7_1 : 271
     * 	e_PDFA2_8_1 : 281
     * 	e_PDFA2_9_1 : 291
     * 	e_PDFA2_10_1 : 2101
     * 	e_PDFA3_2_1 : 321
     * 	e_PDFA3_3_1 : 331
     * 	e_PDFA3_3_2 : 332
     * 	e_PDFA3_3_3_1 : 3331
     * 	e_PDFA3_3_3_2 : 3332
     * 	e_PDFA3_4_1 : 341
     * 	e_PDFA3_5_1 : 351
     * 	e_PDFA3_5_2 : 352
     * 	e_PDFA3_5_3 : 353
     * 	e_PDFA3_5_4 : 354
     * 	e_PDFA3_5_5 : 355
     * 	e_PDFA3_5_6 : 356
     * 	e_PDFA3_6_1 : 361
     * 	e_PDFA3_7_1 : 371
     * 	e_PDFA3_7_2 : 372
     * 	e_PDFA3_7_3 : 373
     * 	e_PDFA4_1 : 41
     * 	e_PDFA4_2 : 42
     * 	e_PDFA4_3 : 43
     * 	e_PDFA4_4 : 44
     * 	e_PDFA4_5 : 45
     * 	e_PDFA4_6 : 46
     * 	e_PDFA5_2_1 : 521
     * 	e_PDFA5_2_2 : 522
     * 	e_PDFA5_2_3 : 523
     * 	e_PDFA5_2_4 : 524
     * 	e_PDFA5_2_5 : 525
     * 	e_PDFA5_2_6 : 526
     * 	e_PDFA5_2_7 : 527
     * 	e_PDFA5_2_8 : 528
     * 	e_PDFA5_2_9 : 529
     * 	e_PDFA5_2_10 : 5210
     * 	e_PDFA5_2_11 : 5211
     * 	e_PDFA5_3_1 : 531
     * 	e_PDFA5_3_2_1 : 5321
     * 	e_PDFA5_3_2_2 : 5322
     * 	e_PDFA5_3_2_3 : 5323
     * 	e_PDFA5_3_2_4 : 5324
     * 	e_PDFA5_3_2_5 : 5325
     * 	e_PDFA5_3_3_1 : 5331
     * 	e_PDFA5_3_3_2 : 5332
     * 	e_PDFA5_3_3_3 : 5333
     * 	e_PDFA5_3_3_4 : 5334
     * 	e_PDFA5_3_4_0 : 5340
     * 	e_PDFA5_3_4_1 : 5341
     * 	e_PDFA5_3_4_2 : 5342
     * 	e_PDFA5_3_4_3 : 5343
     * 	e_PDFA6_1_1 : 611
     * 	e_PDFA6_1_2 : 612
     * 	e_PDFA6_2_1 : 621
     * 	e_PDFA6_2_2 : 622
     * 	e_PDFA6_2_3 : 623
     * 	e_PDFA7_2_1 : 721
     * 	e_PDFA7_2_2 : 722
     * 	e_PDFA7_2_3 : 723
     * 	e_PDFA7_2_4 : 724
     * 	e_PDFA7_2_5 : 725
     * 	e_PDFA7_3_1 : 731
     * 	e_PDFA7_3_2 : 732
     * 	e_PDFA7_3_3 : 733
     * 	e_PDFA7_3_4 : 734
     * 	e_PDFA7_3_5 : 735
     * 	e_PDFA7_3_6 : 736
     * 	e_PDFA7_3_7 : 737
     * 	e_PDFA7_3_8 : 738
     * 	e_PDFA7_3_9 : 739
     * 	e_PDFA7_5_1 : 751
     * 	e_PDFA7_8_1 : 781
     * 	e_PDFA7_8_2 : 782
     * 	e_PDFA7_8_3 : 783
     * 	e_PDFA7_8_4 : 784
     * 	e_PDFA7_8_5 : 785
     * 	e_PDFA7_8_6 : 786
     * 	e_PDFA7_8_7 : 787
     * 	e_PDFA7_8_8 : 788
     * 	e_PDFA7_8_9 : 789
     * 	e_PDFA7_8_10 : 7810
     * 	e_PDFA7_8_11 : 7811
     * 	e_PDFA7_8_12 : 7812
     * 	e_PDFA7_8_13 : 7813
     * 	e_PDFA7_8_14 : 7814
     * 	e_PDFA7_8_15 : 7815
     * 	e_PDFA7_8_16 : 7816
     * 	e_PDFA7_8_17 : 7817
     * 	e_PDFA7_8_18 : 7818
     * 	e_PDFA7_8_19 : 7819
     * 	e_PDFA7_8_20 : 7820
     * 	e_PDFA7_8_21 : 7821
     * 	e_PDFA7_8_22 : 7822
     * 	e_PDFA7_8_23 : 7823
     * 	e_PDFA7_8_24 : 7824
     * 	e_PDFA7_8_25 : 7825
     * 	e_PDFA7_8_26 : 7826
     * 	e_PDFA7_8_27 : 7827
     * 	e_PDFA7_8_28 : 7828
     * 	e_PDFA7_8_29 : 7829
     * 	e_PDFA7_8_30 : 7830
     * 	e_PDFA7_8_31 : 7831
     * 	e_PDFA7_11_1 : 7111
     * 	e_PDFA7_11_2 : 7112
     * 	e_PDFA7_11_3 : 7113
     * 	e_PDFA7_11_4 : 7114
     * 	e_PDFA7_11_5 : 7115
     * 	e_PDFA9_1 : 91
     * 	e_PDFA9_2 : 92
     * 	e_PDFA9_3 : 93
     * 	e_PDFA9_4 : 94
     * 	e_PDFA3_8_1 : 381
     * 	e_PDFA8_2_2 : 822
     * 	e_PDFA8_3_3_1 : 8331
     * 	e_PDFA8_3_3_2 : 8332
     * 	e_PDFA8_3_4_1 : 8341
     * 	e_PDFA1_2_3 : 123
     * 	e_PDFA1_10_2 : 1102
     * 	e_PDFA1_10_3 : 1103
     * 	e_PDFA1_12_10 : 11210
     * 	e_PDFA1_13_5 : 1135
     * 	e_PDFA2_3_10 : 2310
     * 	e_PDFA2_4_2_10 : 24220
     * 	e_PDFA2_4_2_11 : 24221
     * 	e_PDFA2_4_2_12 : 24222
     * 	e_PDFA2_4_2_13 : 24223
     * 	e_PDFA2_5_10 : 2510
     * 	e_PDFA2_5_11 : 2511
     * 	e_PDFA2_5_12 : 2512
     * 	e_PDFA2_8_3_1 : 2831
     * 	e_PDFA2_8_3_2 : 2832
     * 	e_PDFA2_8_3_3 : 2833
     * 	e_PDFA2_8_3_4 : 2834
     * 	e_PDFA2_8_3_5 : 2835
     * 	e_PDFA2_10_20 : 21020
     * 	e_PDFA2_10_21 : 21021
     * 	e_PDFA11_0_0 : 11000
     * 	e_PDFA6_2_11_8 : 62118
     * 	e_PDFA8_1 : 81
     * 	e_PDFA_3E1 : 1
     * 	e_PDFA_3E2 : 2
     * 	e_PDFA_3E3 : 3
     * 	e_PDFA_LAST : 4
     * }
     * </pre>
     * error code identifier (obtained using GetError() method).
     * @param {number} err_idx The index in the array of object references.
     * The array is indexed starting from zero.
     *
     */
    getRefObj(id: number, err_idx: number): Promise<number>;
    /**
     * @method PDFNet.PDFACompliance.getPDFAErrorMessage
     * @param {number} id
     * <pre>
     * PDFNet.PDFACompliance.ErrorCode = {
     * 	e_PDFA0_1_0 : 10
     * 	e_PDFA0_1_1 : 11
     * 	e_PDFA0_1_2 : 12
     * 	e_PDFA0_1_3 : 13
     * 	e_PDFA0_1_4 : 14
     * 	e_PDFA0_1_5 : 15
     * 	e_PDFA1_2_1 : 121
     * 	e_PDFA1_2_2 : 122
     * 	e_PDFA1_3_1 : 131
     * 	e_PDFA1_3_2 : 132
     * 	e_PDFA1_3_3 : 133
     * 	e_PDFA1_3_4 : 134
     * 	e_PDFA1_4_1 : 141
     * 	e_PDFA1_4_2 : 142
     * 	e_PDFA1_6_1 : 161
     * 	e_PDFA1_7_1 : 171
     * 	e_PDFA1_7_2 : 172
     * 	e_PDFA1_7_3 : 173
     * 	e_PDFA1_7_4 : 174
     * 	e_PDFA1_8_1 : 181
     * 	e_PDFA1_8_2 : 182
     * 	e_PDFA1_8_3 : 183
     * 	e_PDFA1_8_4 : 184
     * 	e_PDFA1_8_5 : 185
     * 	e_PDFA1_8_6 : 186
     * 	e_PDFA1_10_1 : 1101
     * 	e_PDFA1_11_1 : 1111
     * 	e_PDFA1_11_2 : 1112
     * 	e_PDFA1_12_1 : 1121
     * 	e_PDFA1_12_2 : 1122
     * 	e_PDFA1_12_3 : 1123
     * 	e_PDFA1_12_4 : 1124
     * 	e_PDFA1_12_5 : 1125
     * 	e_PDFA1_12_6 : 1126
     * 	e_PDFA1_13_1 : 1131
     * 	e_PDFA2_2_1 : 221
     * 	e_PDFA2_3_2 : 232
     * 	e_PDFA2_3_3 : 233
     * 	e_PDFA2_3_3_1 : 2331
     * 	e_PDFA2_3_3_2 : 2332
     * 	e_PDFA2_3_4_1 : 2341
     * 	e_PDFA2_4_1 : 241
     * 	e_PDFA2_4_2 : 242
     * 	e_PDFA2_4_3 : 243
     * 	e_PDFA2_4_4 : 244
     * 	e_PDFA2_5_1 : 251
     * 	e_PDFA2_5_2 : 252
     * 	e_PDFA2_6_1 : 261
     * 	e_PDFA2_7_1 : 271
     * 	e_PDFA2_8_1 : 281
     * 	e_PDFA2_9_1 : 291
     * 	e_PDFA2_10_1 : 2101
     * 	e_PDFA3_2_1 : 321
     * 	e_PDFA3_3_1 : 331
     * 	e_PDFA3_3_2 : 332
     * 	e_PDFA3_3_3_1 : 3331
     * 	e_PDFA3_3_3_2 : 3332
     * 	e_PDFA3_4_1 : 341
     * 	e_PDFA3_5_1 : 351
     * 	e_PDFA3_5_2 : 352
     * 	e_PDFA3_5_3 : 353
     * 	e_PDFA3_5_4 : 354
     * 	e_PDFA3_5_5 : 355
     * 	e_PDFA3_5_6 : 356
     * 	e_PDFA3_6_1 : 361
     * 	e_PDFA3_7_1 : 371
     * 	e_PDFA3_7_2 : 372
     * 	e_PDFA3_7_3 : 373
     * 	e_PDFA4_1 : 41
     * 	e_PDFA4_2 : 42
     * 	e_PDFA4_3 : 43
     * 	e_PDFA4_4 : 44
     * 	e_PDFA4_5 : 45
     * 	e_PDFA4_6 : 46
     * 	e_PDFA5_2_1 : 521
     * 	e_PDFA5_2_2 : 522
     * 	e_PDFA5_2_3 : 523
     * 	e_PDFA5_2_4 : 524
     * 	e_PDFA5_2_5 : 525
     * 	e_PDFA5_2_6 : 526
     * 	e_PDFA5_2_7 : 527
     * 	e_PDFA5_2_8 : 528
     * 	e_PDFA5_2_9 : 529
     * 	e_PDFA5_2_10 : 5210
     * 	e_PDFA5_2_11 : 5211
     * 	e_PDFA5_3_1 : 531
     * 	e_PDFA5_3_2_1 : 5321
     * 	e_PDFA5_3_2_2 : 5322
     * 	e_PDFA5_3_2_3 : 5323
     * 	e_PDFA5_3_2_4 : 5324
     * 	e_PDFA5_3_2_5 : 5325
     * 	e_PDFA5_3_3_1 : 5331
     * 	e_PDFA5_3_3_2 : 5332
     * 	e_PDFA5_3_3_3 : 5333
     * 	e_PDFA5_3_3_4 : 5334
     * 	e_PDFA5_3_4_0 : 5340
     * 	e_PDFA5_3_4_1 : 5341
     * 	e_PDFA5_3_4_2 : 5342
     * 	e_PDFA5_3_4_3 : 5343
     * 	e_PDFA6_1_1 : 611
     * 	e_PDFA6_1_2 : 612
     * 	e_PDFA6_2_1 : 621
     * 	e_PDFA6_2_2 : 622
     * 	e_PDFA6_2_3 : 623
     * 	e_PDFA7_2_1 : 721
     * 	e_PDFA7_2_2 : 722
     * 	e_PDFA7_2_3 : 723
     * 	e_PDFA7_2_4 : 724
     * 	e_PDFA7_2_5 : 725
     * 	e_PDFA7_3_1 : 731
     * 	e_PDFA7_3_2 : 732
     * 	e_PDFA7_3_3 : 733
     * 	e_PDFA7_3_4 : 734
     * 	e_PDFA7_3_5 : 735
     * 	e_PDFA7_3_6 : 736
     * 	e_PDFA7_3_7 : 737
     * 	e_PDFA7_3_8 : 738
     * 	e_PDFA7_3_9 : 739
     * 	e_PDFA7_5_1 : 751
     * 	e_PDFA7_8_1 : 781
     * 	e_PDFA7_8_2 : 782
     * 	e_PDFA7_8_3 : 783
     * 	e_PDFA7_8_4 : 784
     * 	e_PDFA7_8_5 : 785
     * 	e_PDFA7_8_6 : 786
     * 	e_PDFA7_8_7 : 787
     * 	e_PDFA7_8_8 : 788
     * 	e_PDFA7_8_9 : 789
     * 	e_PDFA7_8_10 : 7810
     * 	e_PDFA7_8_11 : 7811
     * 	e_PDFA7_8_12 : 7812
     * 	e_PDFA7_8_13 : 7813
     * 	e_PDFA7_8_14 : 7814
     * 	e_PDFA7_8_15 : 7815
     * 	e_PDFA7_8_16 : 7816
     * 	e_PDFA7_8_17 : 7817
     * 	e_PDFA7_8_18 : 7818
     * 	e_PDFA7_8_19 : 7819
     * 	e_PDFA7_8_20 : 7820
     * 	e_PDFA7_8_21 : 7821
     * 	e_PDFA7_8_22 : 7822
     * 	e_PDFA7_8_23 : 7823
     * 	e_PDFA7_8_24 : 7824
     * 	e_PDFA7_8_25 : 7825
     * 	e_PDFA7_8_26 : 7826
     * 	e_PDFA7_8_27 : 7827
     * 	e_PDFA7_8_28 : 7828
     * 	e_PDFA7_8_29 : 7829
     * 	e_PDFA7_8_30 : 7830
     * 	e_PDFA7_8_31 : 7831
     * 	e_PDFA7_11_1 : 7111
     * 	e_PDFA7_11_2 : 7112
     * 	e_PDFA7_11_3 : 7113
     * 	e_PDFA7_11_4 : 7114
     * 	e_PDFA7_11_5 : 7115
     * 	e_PDFA9_1 : 91
     * 	e_PDFA9_2 : 92
     * 	e_PDFA9_3 : 93
     * 	e_PDFA9_4 : 94
     * 	e_PDFA3_8_1 : 381
     * 	e_PDFA8_2_2 : 822
     * 	e_PDFA8_3_3_1 : 8331
     * 	e_PDFA8_3_3_2 : 8332
     * 	e_PDFA8_3_4_1 : 8341
     * 	e_PDFA1_2_3 : 123
     * 	e_PDFA1_10_2 : 1102
     * 	e_PDFA1_10_3 : 1103
     * 	e_PDFA1_12_10 : 11210
     * 	e_PDFA1_13_5 : 1135
     * 	e_PDFA2_3_10 : 2310
     * 	e_PDFA2_4_2_10 : 24220
     * 	e_PDFA2_4_2_11 : 24221
     * 	e_PDFA2_4_2_12 : 24222
     * 	e_PDFA2_4_2_13 : 24223
     * 	e_PDFA2_5_10 : 2510
     * 	e_PDFA2_5_11 : 2511
     * 	e_PDFA2_5_12 : 2512
     * 	e_PDFA2_8_3_1 : 2831
     * 	e_PDFA2_8_3_2 : 2832
     * 	e_PDFA2_8_3_3 : 2833
     * 	e_PDFA2_8_3_4 : 2834
     * 	e_PDFA2_8_3_5 : 2835
     * 	e_PDFA2_10_20 : 21020
     * 	e_PDFA2_10_21 : 21021
     * 	e_PDFA11_0_0 : 11000
     * 	e_PDFA6_2_11_8 : 62118
     * 	e_PDFA8_1 : 81
     * 	e_PDFA_3E1 : 1
     * 	e_PDFA_3E2 : 2
     * 	e_PDFA_3E3 : 3
     * 	e_PDFA_LAST : 4
     * }
     * </pre>
     * error code identifier (obtained using GetError() method).
     * @return {Promise<string>} A promise that resolves to a descriptive error message for the given error identifier.
     */
    static getPDFAErrorMessage(id: number): Promise<string>;
    /**
     * serializes the converted PDF/A document to a file on disk.
     * @method PDFNet.PDFACompliance#saveAsFromFileName
     * @note This method assumes that the first parameter passed in PDFACompliance
     * constructor (i.e. the convert parameter) is set to 'true'.
     * @param {string} file_path the output file name.
     * @param {boolean} [linearized] An optional flag used to specify whether the the resulting
     * PDF/A document should be web-optimized (linearized).
     */
    saveAsFromFileName(file_path: string, linearized?: boolean): void;
    /**
     * Serializes the converted PDF/A document to a memory buffer.
     * @method PDFNet.PDFACompliance#saveAsFromBuffer
     * @note This method assumes that the first parameter passed in PDFACompliance
     * constructor (i.e. the convert parameter) is set to 'true'.
     * @param {boolean} [linearized] An optional flag used to specify whether the the resulting
     * PDF/A document should be web-optimized (linearized).
     */
    saveAsFromBuffer(linearized?: boolean): void;
    /**
     * Perform PDF/A validation or PDF/A conversion on the input PDF document
     * which is stored in a memory buffer.
     * @method PDFNet.PDFACompliance.createFromUrl
     * @param {boolean} convert A flag used to instruct PDF/A processor to perform PDF/A
     * conversion (if 'true') or PDF/A validation (if 'false'). After PDF/A conversion
     * you can save the resulting document using Save() method(s).
     * @param {string} url A url from which the serialized PDF document can be downloaded.
     * @param {string} [pwd=""] A parameter that can be used to specify the password for encrypted PDF documents (typically only useful in the conversion mode).
     * @param {number} [conform=PDFNet.PDFACompliance.Conformance.e_Level1B]
     * <pre>
     * PDFNet.PDFACompliance.Conformance = {
     *   e_Level1A : 1,
     *   e_Level1B : 2,
     *   e_Level2A : 3,
     *   e_Level2B : 4,
     *   e_Level2U : 5,
     *   e_Level3A : 6,
     *   e_Level3B : 7,
     *   e_Level3U : 8
     * }
     * </pre>
     * The PDF conformance level defined in PDFNet.PDFACompliance.Conformance.
     * @param {Int32Array} [excep = new Int32Array(0)] Exceptions to ignore.
     * @param {number} [max_ref_objs = 10] The maximum number of object references per error condition.
     * @param {boolean} [first_stop = false]
     */
    static createFromUrl(
      convert: boolean,
      url: string,
      pwd?: string,
      conform?: number,
      excep?: Int32Array,
      max_ref_objs?: number,
      first_stop?: boolean,
    ): void;
    /**
     * Perform PDF/A validation or PDF/A conversion on the input PDF document
     * which is stored in a memory buffer.
     * @method PDFNet.PDFACompliance.createFromBuffer
     * @param {boolean} convert A flag used to instruct PDF/A processor to perform PDF/A
     * conversion (if 'true') or PDF/A validation (if 'false'). After PDF/A conversion
     * you can save the resulting document using Save() method(s).
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf A memory buffer containing the serialized PDF document.
     * @param {string} [pwd=""] A parameter that can be used to specify the password for encrypted PDF documents (typically only useful in the conversion mode).
     * @param {number} [conform=PDFNet.PDFACompliance.Conformance.e_Level1B]
     * <pre>
     * PDFNet.PDFACompliance.Conformance = {
     *   e_Level1A : 1,
     *   e_Level1B : 2,
     *   e_Level2A : 3,
     *   e_Level2B : 4,
     *   e_Level2U : 5,
     *   e_Level3A : 6,
     *   e_Level3B : 7,
     *   e_Level3U : 8
     * }
     * </pre>
     * The PDF conformance level defined in PDFNet.PDFACompliance.Conformance.
     * @param {Int32Array} [excep = new Int32Array(0)] Exceptions to ignore.
     * @param {number} [max_ref_objs = 10] The maximum number of object references per error condition.
     * @param {boolean} [first_stop = false]
     * @return {Promise<PDFNet.PDFACompliance>} A promise that resolves to a PDFACompliance object
     */
    static createFromBuffer(
      convert: boolean,
      buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray,
      pwd?: string,
      conform?: number,
      excep?: Int32Array,
      max_ref_objs?: number,
      first_stop?: boolean,
    ): Promise<PDFNet.PDFACompliance>;
  }
  /** Note: PDFDC is deprecated. Please use PDFDCEx instead.
   * PDFDC is a utility class used to represent a PDF Device Context (DC).
   *
   * Windows developers can use standard GDI or GDI+ API-s to write on PDFDC
   * and to generate PDF documents based on their existing drawing functions.
   * PDFDC can also be used to implement file conversion from any printable
   * file format to PDF.
   *
   * PDFDC class can be used in many ways to translate from GDI to PDF:
   *  - To translate a single GDI drawing into a single page PDF document.
   *  - To translate a single GDI drawing into an object which can be reused
   *    many times throughout a PDF document (i.e. as a Form XObject).
   *  - To translate many GDI drawings into single page or multipage PDF document.
   *  ...
   *
   * Very few code changes are required to perform the translation from GDI to
   * PDF as PDFDC provides a GDI Device Context handle which can be passed to
   * all GDI function requiring an HDC.  PDFDC does not use a "Virtual Printer"
   * approach so the translation should be of both high quality and speed.
   * Unfortunately this also means that StartDoc, EndDoc, StartPage and EndPage
   * cannot be called with an HDC created with PDFDC::Begin.
   *
   * For more advanced translations or creations of PDF documents, such as security
   * handling, the use of other PDFNet classes will be required.
   *
   * An example use of PDFDC can be found in PDFDCTest.cpp:
   *
   * <pre>
   * // Start with a PDFDoc to put the picture into, and a PDFDC to translate GDI to PDF
   * PDFDoc pdfdoc;
   * PDFDC pdfDc;
   *
   * // Create a page to put the GDI content onto
   * Page page = pdfdoc.PageCreate();
   *
   * // Begin the translation from GDI to PDF.
   * // Provide the page to place the picture onto, and the bounding box for the content.
   * // We're going to scale the GDI content to fill the page while preserving the aspect
   * // ratio.
   * // Get back a GDI Device Context
   * HDC hDC = pdfDc.Begin( page, page.GetCropBox() );
   *
   *
   * ... perform GDI drawing ...
   *
   * // Complete the translation
   * pdfDc.End();
   *
   * // Add the page to the document
   * pdfdoc.PagePushBack(page);
   *
   * // Save the PDF document
   * pdfdoc.Save("PDFDC_is_cool.pdf", SDF::SDFDoc::e_remove_unused, NULL);
   * </pre>
   * @class
   * @name PDFDC
   * @memberof PDFNet
   */
  class PDFDC {}
  /**
   * PDFDCEX is a utility class used to represent a PDF Device Context (DC).
   *
   * Windows developers can use standard GDI or GDI+ API-s to write on PDFDCEX
   * and to generate PDF documents based on their existing drawing functions.
   * PDFDCEX can also be used to implement file conversion from any printable
   * file format to PDF.
   *
   * PDFDCEX class can be used in many ways to translate from GDI to PDF:
   *  - To translate a single GDI drawing into a single page PDF document.
   *  - To translate a single GDI drawing into an object which can be reused
   *    many times throughout a PDF document (i.e. as a Form XObject).
   *  - To translate many GDI drawings into single page or multipage PDF document.
   *  ...
   *
   * Very few code changes are required to perform the translation from GDI to
   * PDF as PDFDCEX provides a GDI Device Context handle which can be passed to
   * all GDI function requiring an HDC.  PDFDCEX does use a "Virtual Printer"
   * approach so the translation should be of both high quality and speed.
   *
   * For more advanced translations or creations of PDF documents, such as security
   * handling, the use of other PDFNet classes will be required.
   *
   * An example use of PDFDCEX can be found in PDFDCTest.cpp:
   *
   * <pre>
   * // Start with a PDFDoc to put the picture into, and a PDFDCEX to translate GDI to PDF
   * PDFDoc pdfdoc;
   * PDFDCEX pdfdcex;
   *
   * // Begin the translation from GDI to PDF, provide the PDFDoc to append the translated
   * // GDI drawing to and get back a GDI Device Context
   * HDC hDC = pdfdcex.Begin(pdfdoc);
   * ::StartPage(hDC);
   *
   * ... perform GDI drawing ...
   *
   * ::EndPage(hDC);
   * // Complete the translation
   * pdfdcex.EndDoc();
   *
   * // Save the PDF document
   * pdfdoc.Save("PDFDCEX_is_cool.pdf", SDF::SDFDoc::e_remove_unused, NULL);
   * </pre>
   * @class
   * @name PDFDCEX
   * @memberof PDFNet
   */
  class PDFDCEX {}
  /**
   * PDFDoc is a high-level class describing a single PDF (Portable Document
   * Format) document. Most applications using PDFNet will use this class to
   * open existing PDF documents, or to create new PDF documents from scratch.
   *
   * The class offers a number of entry points into the document. For example,
   *  - To access pages use pdfdoc.GetPageIterator() or pdfdoc.PageFind(page_num).
   *  - To access form fields use pdfdoc.GetFieldIterator() or pdfdoc.FieldFind(name).
   *  - To access document's meta-data use pdfdoc.GetDocInfo().
   *  - To access the outline tree use pdfdoc.GetFirstBookmark().
   *  - To access low-level Document Catalog use pdfdoc.GetRoot().
   *  ...
   *
   * The class also offers utility methods to slit and merge PDF pages,
   * to create new pages, to flatten forms, to change security settings, etc.
   * @class
   * @name PDFDoc
   * @memberof PDFNet
   */
  class PDFDoc {
    /**
     * Get the Action associated with the selected Doc Trigger event.
     *
     * @method PDFNet.PDFDoc#getTriggerAction
     * @param {number} trigger
     * <pre>
     * PDFNet.PDFDoc.EventType = {
     * 	e_action_trigger_doc_will_close : 17
     * 	e_action_trigger_doc_will_save : 18
     * 	e_action_trigger_doc_did_save : 19
     * 	e_action_trigger_doc_will_print : 20
     * 	e_action_trigger_doc_did_print : 21
     * }
     * </pre>
     * the type of trigger event to get
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the Action Obj if present, otherwise NULL
     */
    getTriggerAction(trigger: number): Promise<PDFNet.Obj>;
    /**
     * Default constructor. Creates an empty new document.
     * @method PDFNet.PDFDoc.create
     * @return {Promise<PDFNet.PDFDoc>} A promise that resolves to an object of type: "PDFDoc"
     */
    static create(): Promise<PDFNet.PDFDoc>;
    /**
     *
     * @method PDFNet.PDFDoc.createFromFilter
     * @param {PDFNet.Filter} stream
     * @return {Promise<PDFNet.PDFDoc>} A promise that resolves to an object of type: "PDFDoc"
     */
    static createFromFilter(stream: PDFNet.Filter): Promise<PDFNet.PDFDoc>;
    /**
     * Open a SDF/Cos document from a memory buffer.
     * @method PDFNet.PDFDoc.createFromBuffer
     * @note the document should be fully loaded in the memory buffer.
     * @note the buffer ownership is not transfered to the document so the user should
     * clean-up any allocated memory if necessary.
     *
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf a memory buffer containing the serialized document
     * @return {Promise<PDFNet.PDFDoc>} A promise that resolves to an object of type: "PDFDoc"
     */
    static createFromBuffer(buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<PDFNet.PDFDoc>;
    /**
     *
     * @method PDFNet.PDFDoc.createFromLayoutEls
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf
     * @return {Promise<PDFNet.PDFDoc>} A promise that resolves to an object of type: "PDFDoc"
     */
    static createFromLayoutEls(buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<PDFNet.PDFDoc>;
    /**
     * Copy Constructor
     * @method PDFNet.PDFDoc#createShallowCopy
     * @return {Promise<PDFNet.PDFDoc>} A promise that resolves to an object of type: "PDFDoc"
     */
    createShallowCopy(): Promise<PDFNet.PDFDoc>;
    /**
     * Destructor
     * @method PDFNet.PDFDoc#destroy
     */
    destroy(): void;
    /**
     * @method PDFNet.PDFDoc#isEncrypted
     * @return {Promise<boolean>} A promise that resolves to true if the document is/was originally encrypted false otherwise.
     */
    isEncrypted(): Promise<boolean>;
    /**
     * Initializes document's SecurityHandler using the supplied
     * password. This version of InitSecurityHandler() assumes that
     * document uses Standard security and that a password is specified
     * directly.
     *
     * This function should be called immediately after an encrypted
     * document is opened. The function does not have any side effects on
     * documents that are not encrypted.
     *
     * If the security handler was successfully initialized, it can be later
     * obtained using GetSecurityHandler() method.
     *
     * @method PDFNet.PDFDoc#initStdSecurityHandler
     * @return {Promise<boolean>} A promise that resolves to true if the given password successfully unlocked the document,
     * false otherwise.
     *
     * @param {string} password Specifies the password used to open the document without
     * any user feedback. If you would like to dynamically obtain the password,
     * you need to derive a custom class from StdSecurityHandler() and use
     * InitSecurityHandler() without any parameters. See EncTest sample
     * for example code.
     *
     * @param {number} password_sz An optional parameter used to specify the size of
     * the password buffer, in bytes. If the 'password_sz' is 0, or if the parameter
     * is not specified, the function assumes that the string is null terminated.
     *
     * @remark Deprecated. Use versions that accepts UString or buffer instead.
     */
    initStdSecurityHandler(password: string, password_sz: number): Promise<boolean>;
    /**
     * Initializes document's SecurityHandler using the supplied
     * password. This version of InitSecurityHandler() assumes that
     * document uses Standard security and that a password is specified
     * directly.
     *
     * This function should be called immediately after an encrypted
     * document is opened. The function does not have any side effects on
     * documents that are not encrypted.
     *
     * If the security handler was successfully initialized, it can be later
     * obtained using GetSecurityHandler() method.
     *
     * @method PDFNet.PDFDoc#initStdSecurityHandlerUString
     * @param {string} password Specifies the password used to open the document without
     * any user feedback. If you would like to dynamically obtain the password,
     * you need to derive a custom class from StdSecurityHandler() and use
     * InitSecurityHandler() without any parameters. See EncTest sample
     * for example code.
     *
     * @return {Promise<boolean>} A promise that resolves to true if the given password successfully unlocked the document,
     * false otherwise.
     */
    initStdSecurityHandlerUString(password: string): Promise<boolean>;
    /**
     * Initializes document's SecurityHandler using the supplied
     * password. This version of InitSecurityHandler() assumes that
     * document uses Standard security and that a password is specified
     * directly.
     *
     * This function should be called immediately after an encrypted
     * document is opened. The function does not have any side effects on
     * documents that are not encrypted.
     *
     * If the security handler was successfully initialized, it can be later
     * obtained using GetSecurityHandler() method.
     *
     * @method PDFNet.PDFDoc#initStdSecurityHandlerBuffer
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} password_buf Specifies the password used to open the document without
     * any user feedback. If you would like to dynamically obtain the password,
     * you need to derive a custom class from StdSecurityHandler() and use
     * InitSecurityHandler() without any parameters. See EncTest sample
     * for example code.
     *
     * @return {Promise<boolean>} A promise that resolves to true if the given password successfully unlocked the document,
     * false otherwise.
     *
     */
    initStdSecurityHandlerBuffer(
      password_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray,
    ): Promise<boolean>;
    /**
     * @method PDFNet.PDFDoc#getSecurityHandler
     * @return {Promise<PDFNet.SecurityHandler>} A promise that resolves to currently selected SecurityHandler.
     *
     * @note InitSecurityHandler() should be called before GetSecurityHandler()
     * in order to initialize the handler.
     *
     * @note Returned security handler can be modified in order to change the
     * security settings of the existing document. Changes to the current handler
     * will not invalidate the access to the original file and will take effect
     * during document Save().
     *
     * @note If the security handler is modified, document will perform a full save
     * even if e_incremental was given as a flag in Save() method.
     */
    getSecurityHandler(): Promise<PDFNet.SecurityHandler>;
    /**
     *
     * @method PDFNet.PDFDoc#setSecurityHandler
     * @param {PDFNet.SecurityHandler} handler
     */
    setSecurityHandler(handler: PDFNet.SecurityHandler): void;
    /**
     * This function removes document security.
     * @method PDFNet.PDFDoc#removeSecurity
     */
    removeSecurity(): void;
    /**
     * @method PDFNet.PDFDoc#getDocInfo
     * @return {Promise<PDFNet.PDFDocInfo>} A promise that resolves to the class representing document information metadata.
     * (i.e. entries in the document information dictionary).
     */
    getDocInfo(): Promise<PDFNet.PDFDocInfo>;
    /**
     * @method PDFNet.PDFDoc#getViewPrefs
     * @return {Promise<PDFNet.PDFDocViewPrefs>} A promise that resolves to viewer preferences for this document.
     *
     * PDFDocViewPrefs is a high-level utility class that can be
     * used to control the way the document is to be presented on
     * the screen or in print.
     */
    getViewPrefs(): Promise<PDFNet.PDFDocViewPrefs>;
    /**
     * Call this function to determine whether the document has been modified since
     * it was last saved.
     *
     * @method PDFNet.PDFDoc#isModified
     * @return {Promise<boolean>} A promise that resolves to true if document was modified, false otherwise
     */
    isModified(): Promise<boolean>;
    /**
     * Checks whether or not the underlying file has an XRef table that had to be repaired
     * when the file was opened. If the document had an invalid XRef table when opened,
     * PDFNet will have repaired the XRef table for its working representation of the document.
     *
     * @method PDFNet.PDFDoc#hasRepairedXRef
     * @return {Promise<boolean>} A promise that resolves to true if document was found to be corrupted, and was repaired, during
     * opening and has not been saved since.
     *
     * @note If this function returns true, it is not possible to incrementally save the document
     * (see http://www.pdftron.com/kb_corrupt_xref)
     */
    hasRepairedXRef(): Promise<boolean>;
    /**
     * Call this function to determine whether the document is represented in
     * linearized (fast web view) format.
     *
     * @method PDFNet.PDFDoc#isLinearized
     * @return {Promise<boolean>} A promise that resolves to true if document is stored in fast web view format, false otherwise.
     *
     * @note any changes to the document can invalidate linearization. The function will
     * return 'true' only if the original document is linearized and if it is not
     * modified.
     *
     * In order to provide good performance over relatively slow communication links,
     * PDFNet can generate PDF documents with linearized objects and hint tables that
     * can allow a PDF viewer application to download and view one page of a PDF file
     * at a time, rather than requiring the entire file (including fonts and images) to
     * be downloaded before any of it can be viewed.
     *
     * To save a document in linearized (fast web view) format you only need to pass
     * 'Doc.SaveOptions.e_linearized' flag in the Save method.
     */
    isLinearized(): Promise<boolean>;
    /**
     * Saves the document to a memory buffer.
     *
     * @method PDFNet.PDFDoc#saveMemoryBuffer
     * @param {number} flags A bit field composed of an OR of SDFDoc::SaveOptions values. Note that
     * this method ignores e_incremental flag.
     * @return {Promise<Uint8Array>} A promise that resolves to a Uint8Array containing file data.
     * @note Save will modify the PDFDoc object's internal representation.  As such,
     *			  the user should acquire a write lock before calling save.
     */
    saveMemoryBuffer(flags: number): Promise<Uint8Array>;
    /**
     * Saves the document to a stream.
     *
     * @method PDFNet.PDFDoc#saveStream
     * @param {PDFNet.Filter} stream The output stream where to write data.
     * @param {number} flags A bit field composed of an OR of the SDFDoc::SaveOptions values.
     *
     * @note Save will modify the PDFDoc object's internal representation.  As such,
     *			  the user should acquire a write lock before calling save.
     *
     * @note If the original pdf has a corrupt xref table (see HasRepairedXref), then
     * it can not be saved using the e_incremental flag.
     */
    saveStream(stream: PDFNet.Filter, flags: number): void;
    /**
     * Use the Next() method on the returned iterator to traverse all pages in the document.
     * For example:
     * <pre>
     *   PageIterator itr = pdfdoc.GetPageIterator();
     *   while (itr.HasNext()) { //  Read every page
     *      Page page = itr.Current();
     *      // ...
     *      itr.Next()
     *   }
     * </pre>
     *
     * For full sample code, please take a look at ElementReader, PDFPageTest and PDFDraw sample projects.
     * @method PDFNet.PDFDoc#getPageIterator
     * @return {Promise<PDFNet.Iterator>} A promise that resolves to an iterator to the first page in the document.
     * @param {number} [page_number] page to set the iterator on. 1 corresponds to the first page.
     */
    getPageIterator(page_number?: number): Promise<PDFNet.Iterator>;
    /**
     * @method PDFNet.PDFDoc#getPage
     * @param {number} page_number the page number in document's page sequence. Page numbers
     * in document's page sequence are indexed from 1.
     *
     * @return {Promise<PDFNet.Page>} A promise that resolves to a Page corresponding to a given page number, or null (invalid page)
     * if the document does not contain the given page number.
     *
     * For example:
     * <pre>
     *   Page page = pdfdoc.GetPage(page_num);
     *   if (page == null) return; //  Page not found
     * </pre>
     */
    getPage(page_number: number): Promise<PDFNet.Page>;
    /**
     * @method PDFNet.PDFDoc#pageRemove
     * @param {PDFNet.Iterator} page_itr the PageIterator to the page that should be removed
     * A PageIterator for the given page can be obtained using PDFDoc::Find(page_num)
     * or using direct iteration through document's page sequence.
     */
    pageRemove(page_itr: PDFNet.Iterator): void;
    /**
     * Insert/Import a single page at a specific location in the page sequence.
     *
     * @method PDFNet.PDFDoc#pageInsert
     * @param {PDFNet.Iterator} where The location in the page sequence indicating where to insert
     * the page. The page is inserted before the specified location.
     *
     * @param {PDFNet.Page} page A page to insert.
     * @note Invalidates all PageIterators pointing to the document.
     */
    pageInsert(where: PDFNet.Iterator, page: PDFNet.Page): void;
    /**
     * Inserts a range of pages from specified PDFDoc
     *
     * @method PDFNet.PDFDoc#insertPages
     * @param {number} insert_before_page_number the destination of the insertion. If less than or equal to 1,
     * the pages are added to the beginning of the document. If larger than the number of pages
     * in the destination document, the pages are appended to the document.
     * @param {PDFNet.PDFDoc} src_doc source PDFDoc to insert from
     * @param {number} start_page start of the page number to insert
     * @param {number} end_page end of the page number to insert
     * @param {number} flag
     * <pre>
     * PDFNet.PDFDoc.InsertFlag = {
     * 	e_none : 0
     * 	e_insert_bookmark : 1
     * }
     * </pre>
     * specifies insert options
     */
    insertPages(
      insert_before_page_number: number,
      src_doc: PDFNet.PDFDoc,
      start_page: number,
      end_page: number,
      flag: number,
    ): void;
    /**
     * Inserts a range of pages from specified PDFDoc using PageSet
     *
     * @method PDFNet.PDFDoc#insertPageSet
     * @param {number} insert_before_page_number the destination of the insertion. If less than or equal to 1,
     * the pages are added to the beginning of the document. If larger than the number of pages
     * in the destination document, the pages are appended to the document.
     * @param {PDFNet.PDFDoc} src_doc source PDFDoc to insert from
     * @param {PDFNet.PageSet} source_page_set a collection of the page number to insert
     * @param {number} flag
     * <pre>
     * PDFNet.PDFDoc.InsertFlag = {
     * 	e_none : 0
     * 	e_insert_bookmark : 1
     * }
     * </pre>
     * specifies insert options
     */
    insertPageSet(
      insert_before_page_number: number,
      src_doc: PDFNet.PDFDoc,
      source_page_set: PDFNet.PageSet,
      flag: number,
    ): void;
    /**
     * Moves a range of pages from specified PDFDoc. Pages are deleted from source document after move.
     *
     * @method PDFNet.PDFDoc#movePages
     * @param {number} move_before_page_number the destination of the move. If less than or equal to 1,
     * the pages are moved to the beginning of the document. If larger than the number of pages
     * in the destination document, the pages are moved to the end of the document.
     * @param {PDFNet.PDFDoc} src_doc source PDFDoc to move from
     * @param {number} start_page start of the page number to move
     * @param {number} end_page end of the page number to move
     * @param {number} flag
     * <pre>
     * PDFNet.PDFDoc.InsertFlag = {
     * 	e_none : 0
     * 	e_insert_bookmark : 1
     * }
     * </pre>
     * specifies insert options
     * @note MovePages function does not save src_doc. It merely delete pages in memeory. For permanent changes,
     * PDFDoc::Save should be used to save src_doc after function exists.
     */
    movePages(
      move_before_page_number: number,
      src_doc: PDFNet.PDFDoc,
      start_page: number,
      end_page: number,
      flag: number,
    ): void;
    /**
     * Moves a range of pages from specified PDFDoc. Pages are deleted from source document after move.
     *
     * @method PDFNet.PDFDoc#movePageSet
     * @param {number} move_before_page_number the destination of the move. If less than or equal to 1,
     * the pages are moved to the beginning of the document. If larger than the number of pages
     * in the destination document, the pages are moved to the end of the document.
     * @param {PDFNet.PDFDoc} src_doc source PDFDoc to move from
     * @param {PDFNet.PageSet} source_page_set a collection of the page number to move
     * @param {number} flag
     * <pre>
     * PDFNet.PDFDoc.InsertFlag = {
     * 	e_none : 0
     * 	e_insert_bookmark : 1
     * }
     * </pre>
     * specifies insert options
     * @note MovePages function does not save src_doc. It merely delete pages in memeory. For permanent changes,
     * PDFDoc::Save should be used to save src_doc after function exists.
     */
    movePageSet(
      move_before_page_number: number,
      src_doc: PDFNet.PDFDoc,
      source_page_set: PDFNet.PageSet,
      flag: number,
    ): void;
    /**
     * Adds a page to the beginning of a document's page sequence.
     * @method PDFNet.PDFDoc#pagePushFront
     * @param {PDFNet.Page} page a page to prepend to the document
     * Invalidates all PageIterators pointing to the document.
     */
    pagePushFront(page: PDFNet.Page): void;
    /**
     * Adds a page to the end of a document's page sequence.
     * @method PDFNet.PDFDoc#pagePushBack
     * @param {PDFNet.Page} page a page to append to the document
     * @note Invalidates all PageIterators pointing to the document.
     */
    pagePushBack(page: PDFNet.Page): void;
    /**
     * Create a new, empty page in the document. You can use PageWriter to fill the
     * page with new content. Finally the page should be inserted at specific
     * place within document page sequence using PageInsert/PagePushFront/PagePushBack
     * methods.
     *
     * @method PDFNet.PDFDoc#pageCreate
     * @return {Promise<PDFNet.Page>} A promise that resolves to a new, empty page.
     *
     * @note the new page still does not belong to document page sequence and should be
     * subsequently placed at a specific location within the sequence.
     *
     * @param {PDFNet.Rect} [media_box] A rectangle, expressed in default user space units, defining
     * the boundaries of the physical medium on which the page is intended to be
     * displayed or printed. A user space units is 1/72 of an inch. If media_box is
     * not specified the default dimensions of the page are 8.5 x 11 inches (or
     * 8.5*72, 11*72 units).
     *
     * <p>The following is a listing of some standard U.S. page sizes:</p>
     *  <ul>
     *    <li>Letter    = Rect(0, 0, 612, 792)
     *    <li>Legal	    = Rect(0, 0, 612, 1008)
     *    <li>Ledger	= Rect(0, 0, 1224, 792)
     *    <li>Tabloid   = Rect(0, 0, 792, 1224)
     *    <li>Executive	= Rect(0, 0, 522, 756)
     * </ul>
     *
     * <p>The following is a listing of ISO standard page sizes:</p>
     *  <ul>
     *    <li> 4A0 = Rect(0, 0, 4768, 6741)
     *    <li> 2A0 = Rect(0, 0, 3370, 4768)
     *    <li> A0 =  Rect(0, 0, 2384, 3370)
     *    <li> A1 =  Rect(0, 0, 1684, 2384)
     *    <li> A2 =  Rect(0, 0, 1191, 1684)
     *    <li> A3 =  Rect(0, 0, 842,  1191)
     *    <li> A4 =  Rect(0, 0, 595,  842)
     *    <li> A5 =  Rect(0, 0, 420,  595)
     *    <li> A6 =  Rect(0, 0, 298,  420)
     *    <li> A7 =  Rect(0, 0, 210,  298)
     *    <li> A8 =  Rect(0, 0, 147,  210)
     *    <li> A9 =  Rect(0, 0, 105,  147)
     *    <li> A10 = Rect(0, 0, 74,   105)
     *    <li> B0 =  Rect(0, 0, 2835, 4008)
     *    <li> B1 =  Rect(0, 0, 2004, 2835)
     *    <li> B2 =  Rect(0, 0, 1417, 2004)
     *    <li> B3 =  Rect(0, 0, 1001, 1417)
     *    <LI> B4 =  Rect(0, 0, 709,  1001)
     *    <LI> B5 =  Rect(0, 0, 499,  709)
     *    <LI> B6 =  Rect(0, 0, 354,  499)
     *    <LI> B7 =  Rect(0, 0, 249,  354)
     *    <LI> B8 =  Rect(0, 0, 176,  249)
     *    <LI> B9 =  Rect(0, 0, 125,  176)
     *    <li> B10 = Rect(0, 0, 88,   125)
     *    <li> C0 =  Rect(0, 0, 2599, 3677)
     *    <li> C1 =  Rect(0, 0, 1837, 2599)
     *    <li> C2 =  Rect(0, 0, 1298, 1837)
     *    <li> C3 =  Rect(0, 0, 918,  1298)
     *    <li> C4 =  Rect(0, 0, 649,  918)
     *    <li> C5 =  Rect(0, 0, 459,  649)
     *    <li> C6 =  Rect(0, 0, 323,  459)
     *    <li> C7 =  Rect(0, 0, 230,  323)
     *    <li> C8 =  Rect(0, 0, 162,  230)
     *    <li> C9 =  Rect(0, 0, 113,  162)
     *    <li>C10 =  Rect(0, 0, 79,   113)
     * </ul>
     */
    pageCreate(media_box?: PDFNet.Rect): Promise<PDFNet.Page>;
    /**
     * @method PDFNet.PDFDoc#getFirstBookmark
     * @return {Promise<PDFNet.Bookmark>} A promise that resolves to the first Bookmark from the document's outline tree. If the
     * Bookmark tree is empty the underlying SDF/Cos Object is null and returned
     * Bookmark is not valid (i.e. Bookmark::IsValid() returns false).
     */
    getFirstBookmark(): Promise<PDFNet.Bookmark>;
    /**
     * Adds/links the specified Bookmark to the root level of document's outline tree.
     * @method PDFNet.PDFDoc#addRootBookmark
     * @param {PDFNet.Bookmark} root_bookmark Bookmark to Add/link
     * @note parameter 'root_bookmark' must not be linked (must not be belong) to
     * a bookmark tree.
     */
    addRootBookmark(root_bookmark: PDFNet.Bookmark): void;
    /**
     * @method PDFNet.PDFDoc#getTrailer
     * @return {Promise<PDFNet.Obj>} A promise that resolves to A dictionary representing the Cos root of the document (document's trailer)
     */
    getTrailer(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.PDFDoc#getRoot
     * @return {Promise<PDFNet.Obj>} A promise that resolves to A dictionary representing the Cos root of the document (/Root entry
     * within the trailer dictionary)
     */
    getRoot(): Promise<PDFNet.Obj>;
    /**
     *
     * @method PDFNet.PDFDoc#jsContextInitialize
     */
    jsContextInitialize(): void;
    /**
     * @method PDFNet.PDFDoc#getPages
     * @return {Promise<PDFNet.Obj>} A promise that resolves to A dictionary representing the root of the low level page-tree
     */
    getPages(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.PDFDoc#getPageCount
     * @return {Promise<number>} A promise that resolves to the number of pages in the document.
     */
    getPageCount(): Promise<number>;
    /**
     * An interactive form (sometimes referred to as an AcroForm) is a
     * collection of fields for gathering information interactively from
     * the user. A PDF document may contain any number of fields appearing
     * on any combination of pages, all of which make up a single, global
     * interactive form spanning the entire document.
     *
     * The following methods are used to access and manipulate Interactive form
     * fields (sometimes referred to as AcroForms).
     *
     * @method PDFNet.PDFDoc#getFieldIteratorBegin
     * @return {Promise<PDFNet.Iterator>} A promise that resolves to an iterator to the first Field in the document.
     *
     * The list of all Fields present in the document can be traversed as follows:
     * <pre>
     * FieldIterator itr = pdfdoc.GetFieldIterator();
     * for(; itr.HasNext(); itr.Next()) {
     *   Field field = itr.Current();
     *   Console.WriteLine("Field name: {0}", field.GetName());
     *  }
     * </pre>
     *
     * For a full sample, please refer to 'InteractiveForms' sample project.
     */
    getFieldIteratorBegin(): Promise<PDFNet.Iterator>;
    /**
     * An interactive form (sometimes referred to as an AcroForm) is a
     * collection of fields for gathering information interactively from
     * the user. A PDF document may contain any number of fields appearing
     * on any combination of pages, all of which make up a single, global
     * interactive form spanning the entire document.
     *
     * The following methods are used to access and manipulate Interactive form
     * fields (sometimes referred to as AcroForms).
     *
     * @method PDFNet.PDFDoc#getFieldIterator
     * @param {string} field_name String representing the name of the field to get.
     * @return {Promise<PDFNet.Iterator>} A promise that resolves to an iterator to the first Field in the document.
     *
     * The list of all Fields present in the document can be traversed as follows:
     * <pre>
     * var itr = yield doc.GetFieldIterator();
     * for(itr; yield itr.hasNext(); itr.next()) {
     *   var field = itr.current();
     *   console.log("Field name: " + yield field.getName());
     *  }
     * </pre>
     *
     * For a full sample, please refer to 'InteractiveForms' sample project.
     */
    getFieldIterator(field_name: string): Promise<PDFNet.Iterator>;
    /**
     * @method PDFNet.PDFDoc#getField
     * @param {string} field_name a string representing the fully qualified name of
     * the field (e.g. "employee.name.first").
     *
     * @return {Promise<PDFNet.Field>} A promise that resolves to a FieldIterator referring to an interactive Field
     * or to invalid field if the field name was not found. If a given field name was
     * not found itr.HasNext() will return false. For example:
     *
     * <pre>
     * FieldIterator itr = pdfdoc.FieldFind("name");
     * if (itr.HasNext()) {
     *   Console.WriteLine("Field name: {0}", itr.Current().GetName());
     * }
     * else { ...field was not found... }
     * </pre>
     */
    getField(field_name: string): Promise<PDFNet.Field>;
    /**
     *
     * @method PDFNet.PDFDoc#fieldCreate
     * @param {string} field_name
     * @param {number} type
     * <pre>
     * PDFNet.Field.Type = {
     * 	e_button : 0
     * 	e_check : 1
     * 	e_radio : 2
     * 	e_text : 3
     * 	e_choice : 4
     * 	e_signature : 5
     * 	e_null : 6
     * }
     * </pre>
     * @param {PDFNet.Obj} [field_value]
     * @param {PDFNet.Obj} [def_field_value]
     * @return {Promise<PDFNet.Field>} A promise that resolves to an object of type: "Field"
     */
    fieldCreate(
      field_name: string,
      type: number,
      field_value?: PDFNet.Obj,
      def_field_value?: PDFNet.Obj,
    ): Promise<PDFNet.Field>;
    /**
     *
     * @method PDFNet.PDFDoc#fieldCreateFromStrings
     * @param {string} field_name
     * @param {number} type
     * <pre>
     * PDFNet.Field.Type = {
     * 	e_button : 0
     * 	e_check : 1
     * 	e_radio : 2
     * 	e_text : 3
     * 	e_choice : 4
     * 	e_signature : 5
     * 	e_null : 6
     * }
     * </pre>
     * @param {string} field_value
     * @param {string} [def_field_value]
     * @return {Promise<PDFNet.Field>} A promise that resolves to an object of type: "Field"
     */
    fieldCreateFromStrings(
      field_name: string,
      type: number,
      field_value: string,
      def_field_value?: string,
    ): Promise<PDFNet.Field>;
    /**
     * Regenerates the appearance stream for every widget annotation in the document
     * Call this method if you modified field's value and would like to update
     * field's appearances.
     * @method PDFNet.PDFDoc#refreshFieldAppearances
     */
    refreshFieldAppearances(): void;
    /**
     * Flatten all annotations in the document.
     * @method PDFNet.PDFDoc#flattenAnnotations
     * @param {boolean} [forms_only] if false flatten all annotations, otherwise flatten
     * only form fields.
     */
    flattenAnnotations(forms_only?: boolean): void;
    /**
     *
     * @method PDFNet.PDFDoc#flattenAnnotationsAdvanced
     * @param {number} flags
     */
    flattenAnnotationsAdvanced(flags: number): void;
    /**
     * @method PDFNet.PDFDoc#getAcroForm
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the AcroForm dictionary located in "/Root" or NULL if dictionary is not present.
     */
    getAcroForm(): Promise<PDFNet.Obj>;
    /**
     * Extract form data and/or annotations to FDF
     * @method PDFNet.PDFDoc#fdfExtract
     * @param {number} [flag]
     * <pre>
     * PDFNet.PDFDoc.ExtractFlag = {
     * 	e_forms_only : 0
     * 	e_annots_only : 1
     * 	e_both : 2
     * }
     * </pre>
     * specifies extract options
     * @return {Promise<PDFNet.FDFDoc>} A promise that resolves to a pointer to the newly created FDF file with an interactive data.
     */
    fdfExtract(flag?: number): Promise<PDFNet.FDFDoc>;
    /**
     * Extract form data and/or annotations to FDF
     * @method PDFNet.PDFDoc#fdfExtractPageSet
     * @param {PDFNet.PageSet} pages_to_extract The set of pages for which to extract interactive data.
     * @param {number} [flag]
     * <pre>
     * PDFNet.PDFDoc.ExtractFlag = {
     * 	e_forms_only : 0
     * 	e_annots_only : 1
     * 	e_both : 2
     * }
     * </pre>
     * specifies extract options
     * @return {Promise<PDFNet.FDFDoc>} A promise that resolves to a pointer to the newly created FDF file with an interactive data.
     */
    fdfExtractPageSet(pages_to_extract: PDFNet.PageSet, flag?: number): Promise<PDFNet.FDFDoc>;
    /**
     * Import form data from FDF file to PDF interactive form.
     * @method PDFNet.PDFDoc#fdfMerge
     * @param {PDFNet.FDFDoc} fdf_doc a reference to the FDF file
     */
    fdfMerge(fdf_doc: PDFNet.FDFDoc): void;
    /**
     * Replace existing form and annotation data with those imported from the FDF file.
     * Since this method avoids updating annotations unnecessarily it is ideal for incremental save.
     * @method PDFNet.PDFDoc#fdfUpdate
     * @param {PDFNet.FDFDoc} fdf_doc a reference to the FDF file
     */
    fdfUpdate(fdf_doc: PDFNet.FDFDoc): void;
    /**
     * @method PDFNet.PDFDoc#getOpenAction
     * @return {Promise<PDFNet.Action>} A promise that resolves to action that is triggered when the document is opened.
     * The returned action can be either a destination or some other kind
     * of Action (see Section 8.5, 'Actions' in PDF Reference Manual).
     *
     * @note if the document does not nave associated action the returned Action
     * will be null (i.e. Action.IsValid() returns false)
     */
    getOpenAction(): Promise<PDFNet.Action>;
    /**
     * Sets the Action that will be triggered when the document is opened.
     *
     * @method PDFNet.PDFDoc#setOpenAction
     * @param {PDFNet.Action} action A new Action that will be triggered when the document is opened.
     * An example of such action is a GoTo Action that takes the user to a given
     * location in the document.
     */
    setOpenAction(action: PDFNet.Action): void;
    /**
     * Associates a file attachment with the document.
     *
     * The file attachment will be displayed in the user interface of a viewer application
     * (in Acrobat this is File Attachment tab). The function differs from
     * Annot.CreateFileAttachment() because it associates the attachment with the
     * whole document instead of an annotation on a specific page.
     *
     * @method PDFNet.PDFDoc#addFileAttachment
     * @param {string} file_key A key/name under which the attachment will be stored.
     * @param {PDFNet.FileSpec} embedded_file Embedded file stream
     *
     * @note Another way to associate a file attachment with the document is using SDF::NameTree:
     * <pre>
     *   SDF::NameTree names = SDF::NameTree::Create(doc, "EmbeddedFiles");
     *   names.Put(file_key, file_keysz, embedded_file.GetSDFObj());
     * </pre>
     */
    addFileAttachment(file_key: string, embedded_file: PDFNet.FileSpec): void;
    /**
     * @method PDFNet.PDFDoc#getPageLabel
     * @return {Promise<PDFNet.PageLabel>} A promise that resolves to the PageLabel that is in effect for the given page.
     * If there is no label object in effect, this method returns an
     * invalid page label object.
     *
     * @param {number} page_num The page number. Because PDFNet indexes pages
     * starting from 1, page_num must be larger than 0.
     */
    getPageLabel(page_num: number): Promise<PDFNet.PageLabel>;
    /**
     *
     * @method PDFNet.PDFDoc#setPageLabel
     * @param {number} page_num
     * @param {PDFNet.PageLabel} label
     */
    setPageLabel(page_num: number, label: PDFNet.PageLabel): void;
    /**
     * removes the page label that is attached to the specified page,
     * effectively merging the specified range with the previous page
     * label sequence.
     *
     * @method PDFNet.PDFDoc#removePageLabel
     * @param {number} page_num The page from which the page label is removed.
     * Because PDFNet indexes pages starting from 1, page_num must be
     * larger than 0.
     */
    removePageLabel(page_num: number): void;
    /**
     * @method PDFNet.PDFDoc#getStructTree
     * @return {Promise<PDFNet.STree>} A promise that resolves to the document's logical structure tree root.
     */
    getStructTree(): Promise<PDFNet.STree>;
    /**
     * @method PDFNet.PDFDoc#hasOC
     * @return {Promise<boolean>} A promise that resolves to true if the optional content (OC) feature is associated with
     * the document. The document is considered to have optional content if
     * there is an OCProperties dictionary in the document's catalog, and
     * that dictionary has one or more entries in the OCGs array.
     */
    hasOC(): Promise<boolean>;
    /**
     * @method PDFNet.PDFDoc#getOCGs
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the Obj array that contains optional-content groups (OCGs) for
     * the document, or NULL if the document does not contain any OCGs. The
     * order of the groups is not guaranteed to be the creation order, and is
     * not the same as the display order.
     */
    getOCGs(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.PDFDoc#getOCGConfig
     * @return {Promise<PDFNet.OCGConfig>} A promise that resolves to the default optional-content configuration for the document
     * from the OCProperties D entry.
     */
    getOCGConfig(): Promise<PDFNet.OCGConfig>;
    /**
     *
     * @method PDFNet.PDFDoc#createIndirectName
     * @param {string} name
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createIndirectName(name: string): Promise<PDFNet.Obj>;
    /**
     * This method creates an SDF/Cos indirect array object
     *
     * Unlike direct objects, indirect objects can be referenced by more than one
     * object (i.e. indirect objects can be shared).
     * @method PDFNet.PDFDoc#createIndirectArray
     * @return {Promise<PDFNet.Obj>} A promise that resolves to returns a new indirect array object.
     */
    createIndirectArray(): Promise<PDFNet.Obj>;
    /**
     * This method creates an SDF/Cos indirect boolean object
     *
     * Unlike direct objects, indirect objects can be referenced by more than one
     * object (i.e. indirect objects can be shared).
     * @method PDFNet.PDFDoc#createIndirectBool
     * @return {Promise<PDFNet.Obj>} A promise that resolves to returns a new indirect boolean object.
     * @param {boolean} value the value with which to create the boolean object.
     */
    createIndirectBool(value: boolean): Promise<PDFNet.Obj>;
    /**
     * This method creates an SDF/Cos indirect dict object
     *
     * Unlike direct objects, indirect objects can be referenced by more than one
     * object (i.e. indirect objects can be shared).
     * @method PDFNet.PDFDoc#createIndirectDict
     * @return {Promise<PDFNet.Obj>} A promise that resolves to returns a new indirect dict object.
     */
    createIndirectDict(): Promise<PDFNet.Obj>;
    /**
     * This method creates an SDF/Cos indirect null object
     *
     * Unlike direct objects, indirect objects can be referenced by more than one
     * object (i.e. indirect objects can be shared).
     * @method PDFNet.PDFDoc#createIndirectNull
     * @return {Promise<PDFNet.Obj>} A promise that resolves to returns a new indirect null object.
     */
    createIndirectNull(): Promise<PDFNet.Obj>;
    /**
     * This method creates an SDF/Cos indirect number object
     *
     * Unlike direct objects, indirect objects can be referenced by more than one
     * object (i.e. indirect objects can be shared).
     * @method PDFNet.PDFDoc#createIndirectNumber
     * @return {Promise<PDFNet.Obj>} A promise that resolves to returns a new indirect number object.
     * @param {number} value the value with which to create the number object.
     */
    createIndirectNumber(value: number): Promise<PDFNet.Obj>;
    /**
     * This method creates an SDF/Cos indirect string object
     *
     * Unlike direct objects, indirect objects can be referenced by more than one
     * object (i.e. indirect objects can be shared).
     * @method PDFNet.PDFDoc#createIndirectString
     * @return {Promise<PDFNet.Obj>} A promise that resolves to returns a new indirect string object.
     * @param {number} value Unsigned char pointer with which to create the string object.
     * @param {number} buf_size length of string.
     */
    createIndirectString(value: number, buf_size: number): Promise<PDFNet.Obj>;
    /**
     * This method creates an SDF/Cos indirect string object
     *
     * Unlike direct objects, indirect objects can be referenced by more than one
     * object (i.e. indirect objects can be shared).
     * @method PDFNet.PDFDoc#createIndirectStringFromUString
     * @return {Promise<PDFNet.Obj>} A promise that resolves to returns a new indirect string object.
     * @param {string} str reference to string with which to create the string object.
     */
    createIndirectStringFromUString(str: string): Promise<PDFNet.Obj>;
    /**
     *
     * @method PDFNet.PDFDoc#createIndirectStreamFromFilter
     * @param {PDFNet.FilterReader} data
     * @param {PDFNet.Filter} [filter_chain]
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createIndirectStreamFromFilter(data: PDFNet.FilterReader, filter_chain?: PDFNet.Filter): Promise<PDFNet.Obj>;
    /**
     *
     * @method PDFNet.PDFDoc#createIndirectStream
     * @param {string} data
     * @param {number} data_size
     * @param {PDFNet.Filter} [filter_chain]
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createIndirectStream(data: string, data_size: number, filter_chain?: PDFNet.Filter): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.PDFDoc#getSDFDoc
     * @return {Promise<PDFNet.SDFDoc>} A promise that resolves to document's SDF/Cos document
     */
    getSDFDoc(): Promise<PDFNet.SDFDoc>;
    /**
     * addHighlights is used to highlight text in a document using 'Adobe's Highlight
     * File Format' (Technical Note #5172 ). The method will parse the character offset data
     * and modify the current document by adding new highlight annotations.
     *
     * @method PDFNet.PDFDoc#addHighlights
     * @param {string} hilite a string representing the filename for the highlight file or
     * or a data buffer containing XML data.
     *
     */
    addHighlights(hilite: string): void;
    /**
     * @method PDFNet.PDFDoc#isTagged
     * @return {Promise<boolean>} A promise that resolves to true if this document is marked as Tagged PDF, false otherwise.
     */
    isTagged(): Promise<boolean>;
    /**
     * Indicates whether this documents contains any digital signatures.
     * @method PDFNet.PDFDoc#hasSignatures
     * @return {Promise<boolean>} A promise that resolves to true if a digital signature is found in this PDFDoc.
     */
    hasSignatures(): Promise<boolean>;
    /**
     * Adds a signature handler to the signature manager.
     *
     * @method PDFNet.PDFDoc#addSignatureHandler
     * @param {PDFNet.SignatureHandler} signature_handler The signature handler instance to add to the signature manager.
     *
     * @return {Promise<number>} A promise that resolves to a unique ID representing the SignatureHandler within the SignatureManager.
     */
    addSignatureHandler(signature_handler: PDFNet.SignatureHandler): Promise<number>;
    /**
     *
     * @method PDFNet.PDFDoc#addStdSignatureHandlerFromBuffer
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} pkcs12_buffer
     * @param {string} pkcs12_pass
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     */
    addStdSignatureHandlerFromBuffer(
      pkcs12_buffer: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray,
      pkcs12_pass: string,
    ): Promise<number>;
    /**
     * Removes a signature handler from the signature manager.
     *
     * @method PDFNet.PDFDoc#removeSignatureHandler
     * @param {number} signature_handler_id The unique id of the signature handler to remove.
     */
    removeSignatureHandler(signature_handler_id: number): void;
    /**
     * Gets the associated signature handler instance from the signature manager by looking it up with the handler name.
     *
     * @method PDFNet.PDFDoc#getSignatureHandler
     * @param {number} signature_handler_id The unique id of the signature handler to get.
     *
     * @return {Promise<PDFNet.SignatureHandler>} A promise that resolves to the signature handler instance if found, otherwise NULL.
     */
    getSignatureHandler(signature_handler_id: number): Promise<PDFNet.SignatureHandler>;
    /**
     * Generates thumbnail images for all the pages in this PDF document.
     * @method PDFNet.PDFDoc#generateThumbnails
     * @param {number} size The maximum dimension (width or height) that thumbnails will have.
     */
    generateThumbnails(size: number): void;
    /**
     * Add a page representing the difference between two pdf pages to this document.
     *
     * @method PDFNet.PDFDoc#appendVisualDiff
     * @param {PDFNet.Page} p1 one of the two pages for comparing
     * @param {PDFNet.Page} p2 the other page for comparing
     * @param {PDFNet.DiffOptions} opts options for comparison results. This parameter is supposed to be an object,
     * which can be generated by 'PDFNet.createDiffOptions()'. If this parameter is set to null, default settings will be used.
     */
    appendVisualDiff(p1: PDFNet.Page, p2: PDFNet.Page, opts: PDFNet.DiffOptions): void;
    /**
     *
     * @method PDFNet.PDFDoc#getGeometryCollectionForPage
     * @param {number} page_num
     * @return {Promise<PDFNet.GeometryCollection>} A promise that resolves to an object of type: "GeometryCollection"
     */
    getGeometryCollectionForPage(page_num: number): Promise<PDFNet.GeometryCollection>;
    /**
     * @method PDFNet.PDFDoc#getUndoManager
     * @return {Promise<PDFNet.UndoManager>} A promise that resolves to the UndoManager object (one-to-one mapped to document)
     */
    getUndoManager(): Promise<PDFNet.UndoManager>;
    /**
     * Creates an unsigned digital signature form field inside the document.
     *
     * @method PDFNet.PDFDoc#createDigitalSignatureField
     * @param {string} [in_sig_field_name] The fully-qualified name to give the digital signature field. If one is not provided, a unique name is created automatically.
     *
     * @return {Promise<PDFNet.DigitalSignatureField>} A promise that resolves to a DigitalSignatureField object representing the created digital signature field.
     */
    createDigitalSignatureField(in_sig_field_name?: string): Promise<PDFNet.DigitalSignatureField>;
    /**
     *
     * @method PDFNet.PDFDoc#getDigitalSignatureField
     * @param {string} field_name
     * @return {Promise<PDFNet.DigitalSignatureField>} A promise that resolves to an object of type: "DigitalSignatureField"
     */
    getDigitalSignatureField(field_name: string): Promise<PDFNet.DigitalSignatureField>;
    /**
     * Retrieves an iterator that iterates over digital signature fields.
     *
     * @method PDFNet.PDFDoc#getDigitalSignatureFieldIteratorBegin
     * @return {Promise<PDFNet.Iterator>} A promise that resolves to an iterator that iterates over digital signature fields.
     */
    getDigitalSignatureFieldIteratorBegin(): Promise<PDFNet.Iterator>;
    /**
     * Retrieves the most restrictive document permissions locking level from
     * all of the signed digital signatures in the document.
     *
     * @method PDFNet.PDFDoc#getDigitalSignaturePermissions
     * @return {Promise<number>} A promise that resolves to an enumerated value representing the most restrictive document permission level found in the document.
     * @example Return value enum:
     * <pre>
     * PDFNet.DigitalSignatureField.DocumentPermissions = {
     * 	e_no_changes_allowed : 1
     * 	e_formfilling_signing_allowed : 2
     * 	e_annotating_formfilling_signing_allowed : 3
     * 	e_unrestricted : 4
     * }
     * </pre>
     */
    getDigitalSignaturePermissions(): Promise<number>;
    /**
     * WebViewer only - Ensures that a particular page of the pdf document is finished loading
     * before reading or writing from it. Recommended to be called before
     * runGeneratorWithCleanup/WithoutCleanup is called. If the page(s) to be edited cannot be known
     * until during the execution of the PDFNetJS script, all operations will need to be unlocked
     * with PDFNet.finishOperation() and [PDFDoc].unlock() before [PDFDoc].requirePage() can be called,
     * and relocked again with PDFNet.beginOperation() and [PDFDoc].lock()
     *
     * <pre>
     * doc.unlock();
     * yield PDFNet.finishOperation();
     * yield doc.requirePage(pageCounter);
     * yield PDFNet.beginOperation();
     * doc.lock();
     * </pre>
     *
     * @method PDFNet.PDFDoc#requirePage
     * @param {number} page_number - The page to ensure completion of.
     */
    requirePage(page_number: number): void;
    /**
     * An interactive form (sometimes referred to as an AcroForm) is a
     * collection of fields for gathering information interactively from
     * the user. A PDF document may contain any number of fields appearing
     * on any combination of pages, all of which make up a single, global
     * interactive form spanning the entire document.
     *
     * The following methods are used to access and manipulate Interactive form
     * fields (sometimes referred to as AcroForms).
     *
     * @method PDFNet.PDFDoc#getFieldIterator
     * @param {string} field_name String representing the name of the field to get.
     * @return {Promise<PDFNet.Iterator>} A promise that resolves to an iterator to the first Field in the document.
     *
     * The list of all Fields present in the document can be traversed as follows:
     * <pre>
     * var itr = yield doc.GetFieldIterator();
     * for(itr; yield itr.hasNext(); itr.next()) {
     *   var field = itr.current();
     *   console.log("Field name: " + yield field.getName());
     *  }
     * </pre>
     *
     * For a full sample, please refer to 'InteractiveForms' sample project.
     */
    getFieldIterator(field_name: string): Promise<PDFNet.Iterator>;
    /**
     * Open a PDF document from a url. This function will fully download the file as a memory buffer and create a PDFDoc object.
     * @method PDFNet.PDFDoc.createFromURL
     * @param {string} url The url from which to download the file
     * @param {Object} [options] Additional options
     * @param {boolean} options.withCredentials Whether to set the withCredentials property on the XMLHttpRequest
     * @return {Promise<PDFNet.PDFDoc>} A promise that resolves to an object of type: "PDFDoc".
     */
    static createFromURL(
      url: string,
      options?: {
        withCredentials: boolean;
      },
    ): Promise<PDFNet.PDFDoc>;
    /**
     * Initializes document's SecurityHandler. This version of InitSecurityHandler()
     * works with Standard and Custom PDF security and can be used in situations where
     * the password is obtained dynamically via user feedback. See EncTest sample for
     * example code.
     *
     * This function should be called immediately after an encrypted
     * document is opened. The function does not have any side effects on
     * documents that are not encrypted.
     *
     * If the security handler was successfully initialized it can be later obtained
     * using GetSecurityHandler() method.
     *
     * @method PDFNet.PDFDoc#initSecurityHandler
     * @return {Promise<boolean>} A promise that resolves to true if the SecurityHandler was successfully initialized (this
     * may include authentication data collection, verification etc.),
     * false otherwise.
     */
    initSecurityHandler(): Promise<boolean>;
    /**
     * Adds a standard (built-in) signature handler to the signature manager. This method will use cryptographic
     * algorithm based on Adobe.PPKLite/adbe.pkcs7.detached filter to sign a PDF.
     * @method PDFNet.PDFDoc#addStdSignatureHandlerFromURL
     * @param {string} pkcs12_file The private key certificate store to use.
     * @param {string} pkcs12_pass The passphrase for the provided private key.
     *
     * @return {Promise<number>} A promise that resolves to a unique ID representing the SignatureHandler within the SignatureManager.
     */
    addStdSignatureHandlerFromURL(pkcs12_file: string, pkcs12_pass: string): Promise<number>;
    /**
     * The function imports a list of pages to this document. Although a list of pages
     * can be imported using repeated calls to PageInsert(), PageImport will not import
     * duplicate copies of resources that are shared across pages (such as fonts, images,
     * colorspaces etc). Therefore this method is recommended when a page import list
     * consists of several pages that share the same resources.
     * @method PDFNet.PDFDoc#importPages
     * @param {PDFNet.Page[]} page_arr A list of pages to import. All pages should belong to the same source document.
     * @param {number} [import_bookmarks] An optional flag specifying whether any bookmark items
     * pointing to pages in the import list should be merged with the target (i.e. this)
     * document.
     *
     * @return {Promise<PDFNet.Page>} A promise that resolves to a list of imported pages. Note that imported pages are not placed in the
     * document page sequence. This can be done using methods such as PageInsert(),
     * PagePushBack(), etc.
     */
    importPages(page_arr: PDFNet.Page[], import_bookmarks?: number): Promise<PDFNet.Page>;
    /**
     * Locks the document to prevent competing threads from accessing the document
     * at the same time. Threads attempting to access the document will wait in
     * suspended state until the thread that owns the lock calls doc.Unlock().
     * @method PDFNet.PDFDoc#lock
     */
    lock(): void;
    /**
     * Removes the lock from the document.
     * @method PDFNet.PDFDoc#unlock
     */
    unlock(): void;
    /**
     * Locks the document to prevent competing write threads (using Lock()) from accessing the document
     * at the same time. Other reader threads however, will be allowed to access the document.
     * Threads attempting to obtain write access to the document will wait in
     * suspended state until the thread that owns the lock calls doc.UnlockRead().
     * Note: To avoid deadlocks obtaining a write lock while holding
     * a read lock is not permitted and will throw an exception. If this situation is encountered
     * please either unlock the read lock before the write lock is obtained
     * or acquire a write lock (rather than read lock) in the first place.
     * @method PDFNet.PDFDoc#lockRead
     */
    lockRead(): void;
    /**
     * Removes the read lock from the document.
     * @method PDFNet.PDFDoc#unlockRead
     */
    unlockRead(): void;
    /**
     * Try locking the document.
     * @method PDFNet.PDFDoc#tryLock
     * @return {Promise<boolean>} A promise that resolves to true if the document is locked for multi-threaded access, false otherwise.
     */
    tryLock(): Promise<boolean>;
    /**
     * Try locking the document, waiting no longer than specified number of milliseconds.
     * @method PDFNet.PDFDoc#timedLock
     * @param {number} milliseconds max number of milliseconds to wait for the document to lock
     * @return {Promise<boolean>} A promise that resolves to true if the document is locked for multi-threaded access, false otherwise.
     */
    timedLock(milliseconds: number): Promise<boolean>;
    /**
     * Tries to obtain a read lock the document and returns true if the lock was
     * successfully acquired
     * @method PDFNet.PDFDoc#tryLockRead
     * @return {Promise<boolean>} A promise that resolves to true if the document is locked for multi-threaded access, false otherwise.
     */
    tryLockRead(): Promise<boolean>;
    /**
     * Tries to obtain a read lock the document for <milliseconds> duration, and returns
     * true if the lock was successfully acquired
     * @method PDFNet.PDFDoc#timedLockRead
     * @param {number} milliseconds duration to obtain a read lock for.
     * @return {Promise<boolean>} A promise that resolves to true if the document is locked for multi-threaded access, false otherwise.
     */
    timedLockRead(milliseconds: number): Promise<boolean>;
  }
  /**
   * PDFDocInfo is a high-level utility class that can be used
   * to read and modify document's metadata.
   * @class
   * @name PDFDocInfo
   * @memberof PDFNet
   */
  class PDFDocInfo {
    /**
     * @method PDFNet.PDFDocInfo#getTitle
     * @return {Promise<string>} A promise that resolves to the document's title.
     */
    getTitle(): Promise<string>;
    /**
     * @method PDFNet.PDFDocInfo#getTitleObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to sDF/Cos string object representing document's title.
     */
    getTitleObj(): Promise<PDFNet.Obj>;
    /**
     * Set document's title.
     * @method PDFNet.PDFDocInfo#setTitle
     * @param {string} title New title of the document.
     */
    setTitle(title: string): void;
    /**
     * @method PDFNet.PDFDocInfo#getAuthor
     * @return {Promise<string>} A promise that resolves to the name of the person who created the document.
     */
    getAuthor(): Promise<string>;
    /**
     * @method PDFNet.PDFDocInfo#getAuthorObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to sDF/Cos string object representing document's author.
     */
    getAuthorObj(): Promise<PDFNet.Obj>;
    /**
     * Set the author of the document.
     * @method PDFNet.PDFDocInfo#setAuthor
     * @param {string} author The name of the person who created the document.
     */
    setAuthor(author: string): void;
    /**
     * @method PDFNet.PDFDocInfo#getSubject
     * @return {Promise<string>} A promise that resolves to the subject of the document.
     */
    getSubject(): Promise<string>;
    /**
     * @method PDFNet.PDFDocInfo#getSubjectObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to sDF/Cos string object representing document's subject.
     */
    getSubjectObj(): Promise<PDFNet.Obj>;
    /**
     * Set the subject of the document
     * @method PDFNet.PDFDocInfo#setSubject
     * @param {string} subject The subject of the document.
     */
    setSubject(subject: string): void;
    /**
     * @method PDFNet.PDFDocInfo#getKeywords
     * @return {Promise<string>} A promise that resolves to keywords associated with the document.
     */
    getKeywords(): Promise<string>;
    /**
     * @method PDFNet.PDFDocInfo#getKeywordsObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to sDF/Cos string object representing document's keywords.
     */
    getKeywordsObj(): Promise<PDFNet.Obj>;
    /**
     * Set keywords associated with the document.
     * @method PDFNet.PDFDocInfo#setKeywords
     * @param {string} Keywords Keywords associated with the document.
     */
    setKeywords(Keywords: string): void;
    /**
     * @method PDFNet.PDFDocInfo#getCreator
     * @return {Promise<string>} A promise that resolves to if the document was converted to PDF from another
     * format, the name of the application that created the original
     * document from which it was converted.
     */
    getCreator(): Promise<string>;
    /**
     * @method PDFNet.PDFDocInfo#getCreatorObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to sDF/Cos string object representing document's creator.
     */
    getCreatorObj(): Promise<PDFNet.Obj>;
    /**
     * Set document's creator.
     * @method PDFNet.PDFDocInfo#setCreator
     * @param {string} creator The name of the application that created
     * the original document.
     */
    setCreator(creator: string): void;
    /**
     * @method PDFNet.PDFDocInfo#getProducer
     * @return {Promise<string>} A promise that resolves to if the document was converted to PDF from another format,
     * the name of the application (for example, Distiller) that
     * converted it to PDF.
     */
    getProducer(): Promise<string>;
    /**
     * @method PDFNet.PDFDocInfo#getProducerObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to sDF/Cos string object representing document's producer.
     */
    getProducerObj(): Promise<PDFNet.Obj>;
    /**
     * Set document's producer.
     * @method PDFNet.PDFDocInfo#setProducer
     * @param {string} producer The name of the application that generated PDF.
     */
    setProducer(producer: string): void;
    /**
     * @method PDFNet.PDFDocInfo#getCreationDate
     * @return {Promise<PDFNet.Date>} A promise that resolves to the date and time the document was created,
     * in human-readable form.
     */
    getCreationDate(): Promise<PDFNet.Date>;
    /**
     * Set document's creation date.
     * @method PDFNet.PDFDocInfo#setCreationDate
     * @param {PDFNet.Date} creation_date The date and time the document was created.
     */
    setCreationDate(creation_date: PDFNet.Date): void;
    /**
     * @method PDFNet.PDFDocInfo#getModDate
     * @return {Promise<PDFNet.Date>} A promise that resolves to the date and time the document was most recently
     * modified, in human-readable form.
     */
    getModDate(): Promise<PDFNet.Date>;
    /**
     * Set document's modification date.
     * @method PDFNet.PDFDocInfo#setModDate
     * @param {PDFNet.Date} mod_date The date and time the document was most
     * recently modified.
     */
    setModDate(mod_date: PDFNet.Date): void;
    /**
     * @method PDFNet.PDFDocInfo#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to document's SDF/Cos 'Info' dictionary or NULL if
     * the info dictionary is not available.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     *
     * @method PDFNet.PDFDocInfo.create
     * @param {PDFNet.Obj} tr
     * @return {Promise<PDFNet.PDFDocInfo>} A promise that resolves to an object of type: "PDFDocInfo"
     */
    static create(tr: PDFNet.Obj): Promise<PDFNet.PDFDocInfo>;
    /**
     * Copy Constructor
     * @method PDFNet.PDFDocInfo#copy
     * @return {Promise<PDFNet.PDFDocInfo>} A promise that resolves to an object of type: "PDFDocInfo"
     */
    copy(): Promise<PDFNet.PDFDocInfo>;
  }
  /**
   * PDFDocViewPrefs is a high-level utility class that can be
   * used to control the way the document is to be presented on
   * the screen or in print.
   *
   * PDFDocViewPrefs class corresponds to PageMode, PageLayout, and
   * ViewerPreferences entries in the document's catalog. For more
   * details please refer to section 8.1 'Viewer Preferences' in
   * PDF Reference Manual.
   * @class
   * @name PDFDocViewPrefs
   * @memberof PDFNet
   */
  class PDFDocViewPrefs {
    /**
     * A utility method used to set the fist page displayed after
     * the document is opened. This method is equivalent to
     * PDFDoc::SetOpenAction(goto_action).
     *
     * If OpenAction is not specified the document should be
     * opened to the top of the first page at the default magnification
     * factor.
     *
     * @method PDFNet.PDFDocViewPrefs#setInitialPage
     * @param {PDFNet.Destination} dest A value specifying the page destination to be
     * displayed when the document is opened.
     *
     * Example:
     * <pre>
     * Destination dest = Destination::CreateFit(page);
     * pdfdoc.GetViewPrefs().SetInitialPage(dest);
     * </pre>
     */
    setInitialPage(dest: PDFNet.Destination): void;
    /**
     * Sets PageMode property and change the value of the
     * PageMode key in the Catalog dictionary.
     *
     * @method PDFNet.PDFDocViewPrefs#setPageMode
     * @param {number} mode
     * <pre>
     * PDFNet.PDFDocViewPrefs.PageMode = {
     * 	e_UseNone : 0
     * 	e_UseThumbs : 1
     * 	e_UseBookmarks : 2
     * 	e_FullScreen : 3
     * 	e_UseOC : 4
     * 	e_UseAttachments : 5
     * }
     * </pre>
     * New PageMode setting. Default value is e_UseNone.
     */
    setPageMode(mode: number): void;
    /**
     * @method PDFNet.PDFDocViewPrefs#getPageMode
     * @return {Promise<number>} A promise that resolves to the value of currently selected PageMode property.
     * @example Return value enum:
     * <pre>
     * PDFNet.PDFDocViewPrefs.PageMode = {
     * 	e_UseNone : 0
     * 	e_UseThumbs : 1
     * 	e_UseBookmarks : 2
     * 	e_FullScreen : 3
     * 	e_UseOC : 4
     * 	e_UseAttachments : 5
     * }
     * </pre>
     */
    getPageMode(): Promise<number>;
    /**
     * Sets PageLayout property and change the value of the
     * PageLayout key in the Catalog dictionary.
     *
     * @method PDFNet.PDFDocViewPrefs#setLayoutMode
     * @param {number} mode
     * <pre>
     * PDFNet.PDFDocViewPrefs.PageLayout = {
     * 	e_Default : 0
     * 	e_SinglePage : 1
     * 	e_OneColumn : 2
     * 	e_TwoColumnLeft : 3
     * 	e_TwoColumnRight : 4
     * 	e_TwoPageLeft : 5
     * 	e_TwoPageRight : 6
     * }
     * </pre>
     * New PageLayout setting. Default value is
     * e_SinglePage.
     */
    setLayoutMode(mode: number): void;
    /**
     * @method PDFNet.PDFDocViewPrefs#getLayoutMode
     * @return {Promise<number>} A promise that resolves to the value of currently selected PageLayout property.
     * @example Return value enum:
     * <pre>
     * PDFNet.PDFDocViewPrefs.PageLayout = {
     * 	e_Default : 0
     * 	e_SinglePage : 1
     * 	e_OneColumn : 2
     * 	e_TwoColumnLeft : 3
     * 	e_TwoColumnRight : 4
     * 	e_TwoPageLeft : 5
     * 	e_TwoPageRight : 6
     * }
     * </pre>
     */
    getLayoutMode(): Promise<number>;
    /**
     * sets the value of given ViewerPref property.
     *
     * @method PDFNet.PDFDocViewPrefs#setPref
     * @param {number} pref
     * <pre>
     * PDFNet.PDFDocViewPrefs.ViewerPref = {
     * 	e_HideToolbar : 0
     * 	e_HideMenubar : 1
     * 	e_HideWindowUI : 2
     * 	e_FitWindow : 3
     * 	e_CenterWindow : 4
     * 	e_DisplayDocTitle : 5
     * }
     * </pre>
     * the ViewerPref property type to modify.
     * @param {boolean} value The new value for the property.
     */
    setPref(pref: number, value: boolean): void;
    /**
     * @method PDFNet.PDFDocViewPrefs#getPref
     * @return {Promise<boolean>} A promise that resolves to the value of given ViewerPref property.
     * @param {number} pref
     * <pre>
     * PDFNet.PDFDocViewPrefs.ViewerPref = {
     * 	e_HideToolbar : 0
     * 	e_HideMenubar : 1
     * 	e_HideWindowUI : 2
     * 	e_FitWindow : 3
     * 	e_CenterWindow : 4
     * 	e_DisplayDocTitle : 5
     * }
     * </pre>
     * the ViewerPref property type to query.
     */
    getPref(pref: number): Promise<boolean>;
    /**
     * set the document's page mode, specifying how to display the
     * document on exiting full-screen mode.
     *
     * @method PDFNet.PDFDocViewPrefs#setNonFullScreenPageMode
     * @param {number} mode
     * <pre>
     * PDFNet.PDFDocViewPrefs.PageMode = {
     * 	e_UseNone : 0
     * 	e_UseThumbs : 1
     * 	e_UseBookmarks : 2
     * 	e_FullScreen : 3
     * 	e_UseOC : 4
     * 	e_UseAttachments : 5
     * }
     * </pre>
     * PageMode used after exiting full-screen mode.
     * Default value: e_UseNone.
     *
     * @note This entry is meaningful only if the value of the
     * PageMode is set to e_FullScreen; it is ignored otherwise.
     */
    setNonFullScreenPageMode(mode: number): void;
    /**
     * @method PDFNet.PDFDocViewPrefs#getNonFullScreenPageMode
     * @return {Promise<number>} A promise that resolves to the PageMode used after exiting full-screen mode.
     * @note This entry is meaningful only if the value of the
     * PageMode is set to e_FullScreen; it is ignored otherwise.
     * @example Return value enum:
     * <pre>
     * PDFNet.PDFDocViewPrefs.PageMode = {
     * 	e_UseNone : 0
     * 	e_UseThumbs : 1
     * 	e_UseBookmarks : 2
     * 	e_FullScreen : 3
     * 	e_UseOC : 4
     * 	e_UseAttachments : 5
     * }
     * </pre>
     */
    getNonFullScreenPageMode(): Promise<number>;
    /**
     * sets the predominant reading order for text.
     *
     * This flag has no direct effect on the document's contents
     * or page numbering but can be used to determine the relative
     * positioning of pages when displayed side by side or
     * printed n-up.
     *
     * @method PDFNet.PDFDocViewPrefs#setDirection
     * @param {boolean} left_to_right true if the predominant reading
     * order for text is from left to right and false if it is
     * right to left (including vertical writing systems, such
     * as Chinese, Japanese, and Korean).
     * Default value: left_to_right is true.
     */
    setDirection(left_to_right: boolean): void;
    /**
     * @method PDFNet.PDFDocViewPrefs#getDirection
     * @return {Promise<boolean>} A promise that resolves to true is the predominant reading order for text
     * is left to right, false otherwise. See SetDirection() for
     * more information.
     */
    getDirection(): Promise<boolean>;
    /**
     * Sets the page boundary representing the area of a page
     * to be displayed when viewing the document on the screen.
     *
     * @method PDFNet.PDFDocViewPrefs#setViewArea
     * @param {number} box
     * <pre>
     * PDFNet.Page.Box = {
     * 	e_media : 0
     * 	e_crop : 1
     * 	e_bleed : 2
     * 	e_trim : 3
     * 	e_art : 4
     * }
     * </pre>
     * page boundary displayed when viewing the document
     * on the screen. By default, PDF viewers will display the
     * crop-box.
     */
    setViewArea(box: number): void;
    /**
     * @method PDFNet.PDFDocViewPrefs#getViewArea
     * @return {Promise<number>} A promise that resolves to the page boundary representing the area of a page
     * to be displayed when viewing the document on the screen.
     * @example Return value enum:
     * <pre>
     * PDFNet.Page.Box = {
     * 	e_media : 0
     * 	e_crop : 1
     * 	e_bleed : 2
     * 	e_trim : 3
     * 	e_art : 4
     * }
     * </pre>
     */
    getViewArea(): Promise<number>;
    /**
     * sets the page boundary to which the contents of a page are
     * to be clipped when viewing the document on the screen.
     *
     * @method PDFNet.PDFDocViewPrefs#setViewClip
     * @param {number} box
     * <pre>
     * PDFNet.Page.Box = {
     * 	e_media : 0
     * 	e_crop : 1
     * 	e_bleed : 2
     * 	e_trim : 3
     * 	e_art : 4
     * }
     * </pre>
     * screen clip region. The default value is
     * page crop-box.
     */
    setViewClip(box: number): void;
    /**
     * @method PDFNet.PDFDocViewPrefs#getViewClip
     * @return {Promise<number>} A promise that resolves to the page boundary to which the contents of a page
     * are to be clipped when viewing the document on the screen.
     * @example Return value enum:
     * <pre>
     * PDFNet.Page.Box = {
     * 	e_media : 0
     * 	e_crop : 1
     * 	e_bleed : 2
     * 	e_trim : 3
     * 	e_art : 4
     * }
     * </pre>
     */
    getViewClip(): Promise<number>;
    /**
     * sets the page boundary representing the area of a page to
     * be rendered when printing the document.
     *
     * @method PDFNet.PDFDocViewPrefs#setPrintArea
     * @param {number} box
     * <pre>
     * PDFNet.Page.Box = {
     * 	e_media : 0
     * 	e_crop : 1
     * 	e_bleed : 2
     * 	e_trim : 3
     * 	e_art : 4
     * }
     * </pre>
     * printing region. The default value is page
     * crop-box.
     */
    setPrintArea(box: number): void;
    /**
     * @method PDFNet.PDFDocViewPrefs#getPrintArea
     * @return {Promise<number>} A promise that resolves to the page boundary representing the area of a page
     * to be rendered when printing the document.
     * @example Return value enum:
     * <pre>
     * PDFNet.Page.Box = {
     * 	e_media : 0
     * 	e_crop : 1
     * 	e_bleed : 2
     * 	e_trim : 3
     * 	e_art : 4
     * }
     * </pre>
     */
    getPrintArea(): Promise<number>;
    /**
     * sets the page boundary to which the contents of a page are
     * to be clipped when printing the document.
     *
     * @method PDFNet.PDFDocViewPrefs#setPrintClip
     * @param {number} box
     * <pre>
     * PDFNet.Page.Box = {
     * 	e_media : 0
     * 	e_crop : 1
     * 	e_bleed : 2
     * 	e_trim : 3
     * 	e_art : 4
     * }
     * </pre>
     * printing clip region. The default value is page
     * crop-box.
     */
    setPrintClip(box: number): void;
    /**
     * @method PDFNet.PDFDocViewPrefs#getPrintClip
     * @return {Promise<number>} A promise that resolves to the page boundary to which the contents of a page
     * are to be clipped when printing the document.
     * @example Return value enum:
     * <pre>
     * PDFNet.Page.Box = {
     * 	e_media : 0
     * 	e_crop : 1
     * 	e_bleed : 2
     * 	e_trim : 3
     * 	e_art : 4
     * }
     * </pre>
     */
    getPrintClip(): Promise<number>;
    /**
     * @method PDFNet.PDFDocViewPrefs#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to document's SDF/Cos 'ViewerPreferences' dictionary
     * or NULL if the object is not present.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     *
     * @method PDFNet.PDFDocViewPrefs.create
     * @param {PDFNet.Obj} tr
     * @return {Promise<PDFNet.PDFDocViewPrefs>} A promise that resolves to an object of type: "PDFDocViewPrefs"
     */
    static create(tr: PDFNet.Obj): Promise<PDFNet.PDFDocViewPrefs>;
    /**
     * Copy Constructor
     * @method PDFNet.PDFDocViewPrefs#copy
     * @return {Promise<PDFNet.PDFDocViewPrefs>} A promise that resolves to an object of type: "PDFDocViewPrefs"
     */
    copy(): Promise<PDFNet.PDFDocViewPrefs>;
  }
  /**
   * PDFDraw contains methods for converting PDF pages to images and to Bitmap objects.
   * Utility methods are provided to export PDF pages to various raster formats as well
   * as to convert pages to GDI+ bitmaps for further manipulation or drawing.
   *
   * @note This class is available on all platforms supported by PDFNet.
   * @class
   * @name PDFDraw
   * @memberof PDFNet
   */
  class PDFDraw {
    /**
     * sets the Optional Content Group (OCG) context that should be used when
     * rendering the page. This function can be used to selectively render optional
     * content (such as PDF layers) based on the states of optional content groups
     * in the given context.
     *
     * @method PDFNet.PDFDraw#setOCGContext
     * @param {PDFNet.OCGContext} ctx Optional Content Group (OCG) context, or NULL if the rasterizer
     * should render all content on the page.
     */
    setOCGContext(ctx: PDFNet.OCGContext): void;
    /**
     * PdFDraw constructor and destructor
     *
     * @method PDFNet.PDFDraw.create
     * @param {number} [dpi] Default resolution used to rasterize pages. If the parameter is not
     * specified, the initial resolution is 92 dots per inch. DPI parameter can be
     * modified at any time using PDFDraw::SetDPI() method.
     * @return {Promise<PDFNet.PDFDraw>} A promise that resolves to an object of type: "PDFDraw"
     */
    static create(dpi?: number): Promise<PDFNet.PDFDraw>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.PDFDraw#destroy
     */
    destroy(): void;
    /**
     * Sets the core graphics library used for rasterization and
     * rendering. Using this method it is possible to quickly switch
     * between different implementations. By default, PDFDraw uses
     * the built-in, platform independent rasterizer.
     *
     * @method PDFNet.PDFDraw#setRasterizerType
     * @param {number} type
     * <pre>
     * PDFNet.PDFRasterizer.Type = {
     * 	e_BuiltIn : 0
     * 	e_GDIPlus : 1
     * }
     * </pre>
     * Rasterizer type.
     *
     * @note This method is deprecated, since the GDI+ rasterizer itself is deprecated and will be removed in a future version of PDFNet.
     * It is strongly recommended to use the built-in rasterizer and to use the XPS print path where vector conversion is needed.
     */
    setRasterizerType(type: number): void;
    /**
     * Sets the output image resolution.
     *
     * DPI stands for Dots Per Inch. This parameter is used to specify the output
     * image size and quality. A typical screen resolution for monitors these days is
     * 92 DPI, but printers could use 200 DPI or more.
     *
     * @method PDFNet.PDFDraw#setDPI
     * @param {number} dpi value to set the image resolution to. Higher value = higher resolution.
     * @note The size of resulting image is a function of DPI and the dimensions of
     * the source PDF page. For example, if DPI is 92 and page is 8 inches wide, the
     * output bitmap will have 92*8 = 736 pixels per line. If you know the dimensions
     * of the destination bitmap, but don't care about DPI of the image you can use
     * pdfdraw.SetImageSize() instead.
     *
     * @note if you would like to rasterize extremely large bitmaps (e.g. with
     * resolutions of 2000 DPI or more) it is not practical to use PDFDraw directly
     * because of the memory required to store the entire image. In this case, you
     * can use PDFRasterizer directly to generate the rasterized image in stripes or
     * tiles.
     */
    setDPI(dpi: number): void;
    /**
     * SetImageSize can be used instead of SetDPI() to adjust page  scaling so that
     * image fits into a buffer of given dimensions.
     *
     * If this function is used, DPI will be calculated dynamically for each
     * page so that every page fits into the buffer of given dimensions.
     *
     * @method PDFNet.PDFDraw#setImageSize
     * @param {number} width The width of the image, in pixels/samples.
     * @param {number} height The height of the image, in pixels/samples.
     * @param {boolean} [preserve_aspect_ratio] True to preserve the aspect ratio, false
     * otherwise. By default, preserve_aspect_ratio is true.
     */
    setImageSize(width: number, height: number, preserve_aspect_ratio?: boolean): void;
    /**
     * Selects the page box/region to rasterize.
     *
     * @method PDFNet.PDFDraw#setPageBox
     * @param {number} region
     * <pre>
     * PDFNet.Page.Box = {
     * 	e_media : 0
     * 	e_crop : 1
     * 	e_bleed : 2
     * 	e_trim : 3
     * 	e_art : 4
     * }
     * </pre>
     * Page box to rasterize. By default, PDFDraw will rasterize
     * page crop box.
     */
    setPageBox(region: number): void;
    /**
     * clip the render region to the provided rect (in page space)
     *
     * @method PDFNet.PDFDraw#setClipRect
     * @param {PDFNet.Rect} rect clipping rect. By default, PDFDraw will rasterize
     * the entire page box.
     */
    setClipRect(rect: PDFNet.Rect): void;
    /**
     * Flips the vertical (i.e. Y) axis of the image.
     *
     * @method PDFNet.PDFDraw#setFlipYAxis
     * @param {boolean} flip_y true to flip the Y axis, false otherwise. For compatibility with
     * most raster formats 'flip_y' is true by default.
     */
    setFlipYAxis(flip_y: boolean): void;
    /**
     * Sets the rotation value for this page.
     *
     * @method PDFNet.PDFDraw#setRotate
     * @note This method is used only for drawing purposes and it does not modify
     * the document (unlike Page::SetRotate()).
     *
     * @param {number} angle
     * <pre>
     * PDFNet.Page.Rotate = {
     * 	e_0 : 0
     * 	e_90 : 1
     * 	e_180 : 2
     * 	e_270 : 3
     * }
     * </pre>
     * Rotation value to be set for a given page. Must be one
     * of the Page::Rotate values.
     */
    setRotate(angle: number): void;
    /**
     * Enable or disable annotation and forms rendering. By default, all annotations
     * and form fields are rendered.
     *
     * @method PDFNet.PDFDraw#setDrawAnnotations
     * @param {boolean} render_annots True to draw annotations, false otherwise.
     */
    setDrawAnnotations(render_annots: boolean): void;
    /**
     * Enable or disable highlighting form fields. Default is disabled.
     *
     * @method PDFNet.PDFDraw#setHighlightFields
     * @param {boolean} highlight true to highlight, false otherwise.
     */
    setHighlightFields(highlight: boolean): void;
    /**
     * Enable or disable anti-aliasing.
     *
     * Anti-Aliasing is a technique used to improve the visual
     * quality of images when displaying them on low resolution
     * devices (for example, low DPI computer monitors).
     * @method PDFNet.PDFDraw#setAntiAliasing
     * @param {boolean} enable_aa if true anti-aliasing will be enabled.
     * @default Anti-aliasing is enabled by default.
     */
    setAntiAliasing(enable_aa: boolean): void;
    /**
     * Enable or disable path hinting.
     *
     * @method PDFNet.PDFDraw#setPathHinting
     * @param {boolean} enable_hinting if true path hinting will be enabled. Path hinting is used
     * to slightly adjust paths in order to avoid or alleviate artifacts of hair line
     * cracks between certain graphical elements. This option is turned on by default.
     *
     */
    setPathHinting(enable_hinting: boolean): void;
    /**
     * Set thin line adjustment parameters.
     *
     * @method PDFNet.PDFDraw#setThinLineAdjustment
     * @param {boolean} grid_fit if true (horizontal/vertical) thin lines will be snapped to
     * integer pixel positions. This helps make thin lines look sharper and clearer. This
     * option is turned off by default and it only works if path hinting is enabled.
     *
     * @param {boolean} stroke_adjust if true auto stroke adjustment is enabled. Currently, this would
     * make lines with sub-pixel width to be one-pixel wide. This option is turned on by default.
     */
    setThinLineAdjustment(grid_fit: boolean, stroke_adjust: boolean): void;
    /**
     * Sets the gamma factor used for anti-aliased rendering.
     *
     * @method PDFNet.PDFDraw#setGamma
     * @param {number} exp is the exponent value of gamma function. Typical values
     * are in the range from 0.1 to 3.
     *
     * Gamma correction can be used to improve the quality of anti-aliased
     * image output and can (to some extent) decrease the appearance common
     * anti-aliasing artifacts (such as pixel width lines between polygons).
     *
     * @note Gamma correction is used only in the built-in rasterizer.
     */
    setGamma(exp: number): void;
    /**
     * tells the rasterizer to render the page 'print' mode. Certain page elements
     * (such as annotations or OCG-s) are meant to be visible either on the screen or
     * on the printed paper but not both. A common example, is the "Submit" button on
     * electronic forms.
     *
     * @method PDFNet.PDFDraw#setPrintMode
     * @param {boolean} is_printing set to true if the page should be rendered in print mode.
     * @default By default, print mode flag is set to false.
     */
    setPrintMode(is_printing: boolean): void;
    /**
     * sets the page color to transparent.
     *
     * @method PDFNet.PDFDraw#setPageTransparent
     * @default By default, PDFDraw assumes that the page is imposed directly on an
     * opaque white surface. Some applications may need to impose the page on a different
     * backdrop. In this case any pixels that are not covered during rendering will
     * be transparent.
     *
     * @param {boolean} is_transparent If true, page's backdrop color will be transparent.
     * If false, the page's backdrop will be a opaque white.
     *
     * @note If page transparency is enabled, the alpha channel will be preserved when
     * the image is exported as PNG, TIFF(when in RGB space), or RAW.
     */
    setPageTransparent(is_transparent: boolean): void;
    /**
     * sets the default color of the page backdrop.
     *
     * @method PDFNet.PDFDraw#setDefaultPageColor
     * @default By default, the page color is white.
     *
     * @param {number} r the red component of the page backdrop color.
     * @param {number} g the green component of the page backdrop color.
     * @param {number} b the blue component of the page backdrop color.
     *
     * @note Only when the page backdrop is not set to transparent (SetPageTransparent), default
     * page color is used.
     */
    setDefaultPageColor(r: number, g: number, b: number): void;
    /**
     * enable or disable support for overprint and overprint simulation.
     * Overprint is a device dependent feature and the results will vary depending on
     * the output color space and supported colorants (i.e. CMYK, CMYK+spot, RGB, etc).
     *
     * @method PDFNet.PDFDraw#setOverprint
     * @default By default overprint is only enabled for PDF/X files.
     *
     * @param {number} op
     * <pre>
     * PDFNet.PDFRasterizer.OverprintPreviewMode = {
     * 	e_op_off : 0
     * 	e_op_on : 1
     * 	e_op_pdfx_on : 2
     * }
     * </pre>
     * e_op_on: always enabled; e_op_off: always disabled; e_op_pdfx_on: enabled for PDF/X files only.
     */
    setOverprint(op: number): void;
    /**
     * Enable or disable image smoothing.
     *
     * The rasterizer allows a tradeoff between rendering quality and rendering speed.
     * This function can be used to indicate the preference between rendering speed and quality.
     *
     * @method PDFNet.PDFDraw#setImageSmoothing
     * @note image smoothing option has effect only if the source image has higher resolution
     * that the output resolution of the image on the rasterized page. PDFNet automatically
     * controls at what resolution/zoom factor, 'image smoothing' needs to take effect.
     *
     * @param {boolean} [smoothing_enabled] True to enable image smoothing, false otherwise.
     * @param {boolean} [hq_image_resampling] True to use a higher quality (but slower) smoothing algorithm
     * @default image smoothing is enabled and hq_image_resampling is false.
     */
    setImageSmoothing(smoothing_enabled?: boolean, hq_image_resampling?: boolean): void;
    /**
     * enables or disables caching. Caching can improve the rendering performance in cases
     * where the same page will be drawn multiple times.
     *
     * @method PDFNet.PDFDraw#setCaching
     * @param {boolean} [enabled] if true PDFRasterizer will cache frequently used graphics objects.
     */
    setCaching(enabled?: boolean): void;
    /**
     * Set the color post processing transformation.
     * This transform is applied to the rasterized bitmap as the final step
     * in the rasterization process, and is applied directly to the resulting
     * bitmap (disregarding any color space information). Color post
     * processing only supported for RGBA output.
     *
     * @method PDFNet.PDFDraw#setColorPostProcessMode
     * @param {number} mode
     * <pre>
     * PDFNet.PDFRasterizer.ColorPostProcessMode = {
     * 	e_postprocess_none : 0
     * 	e_postprocess_invert : 1
     * }
     * </pre>
     * is the specific transform to be applied
     */
    setColorPostProcessMode(mode: number): void;
  }
  /**
   * PDFRasterizer is a low-level PDF rasterizer.
   *
   * The main purpose of this class is to convert PDF pages to raster
   * images (or bitmaps).
   *
   * @note PDFRasterizer is a relatively low-level class. If you need to
   * convert PDF page to an image format or a Bitmap, consider
   * using PDFNet.PDFDraw. Similarly, if you are building an interactive
   * PDF viewing application you may want to use PDFNet.PDFView instead.
   * @class
   * @name PDFRasterizer
   * @memberof PDFNet
   */
  class PDFRasterizer {
    /**
     * PdFRasterizer constructor and destructor
     * @method PDFNet.PDFRasterizer.create
     * @param {number} [type]
     * <pre>
     * PDFNet.PDFRasterizer.Type = {
     * 	e_BuiltIn : 0
     * 	e_GDIPlus : 1
     * }
     * </pre>
     * @return {Promise<PDFNet.PDFRasterizer>} A promise that resolves to an object of type: "PDFRasterizer"
     */
    static create(type?: number): Promise<PDFNet.PDFRasterizer>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.PDFRasterizer#destroy
     */
    destroy(): void;
    /**
     *
     * @method PDFNet.PDFRasterizer#getChunkRendererPath
     * @param {PDFNet.Page} page
     * @param {string} file_path
     * @param {number} width
     * @param {number} height
     * @param {boolean} demult
     * @param {PDFNet.Matrix2D} device_mtx
     * @param {PDFNet.Rect} clip
     * @param {PDFNet.Rect} scrl_clp_regions
     * @param {boolean} cancel
     * @return {Promise<PDFNet.ChunkRenderer>} A promise that resolves to an object of type: "ChunkRenderer"
     */
    getChunkRendererPath(
      page: PDFNet.Page,
      file_path: string,
      width: number,
      height: number,
      demult: boolean,
      device_mtx: PDFNet.Matrix2D,
      clip: PDFNet.Rect,
      scrl_clp_regions: PDFNet.Rect,
      cancel: boolean,
    ): Promise<PDFNet.ChunkRenderer>;
    /**
     * Enable or disable annotation and forms rendering. By default, annotations and forms
     * are rendered.
     *
     * @method PDFNet.PDFRasterizer#setDrawAnnotations
     * @param {boolean} render_annots True to draw annotations, false otherwise.
     */
    setDrawAnnotations(render_annots: boolean): void;
    /**
     * Enable or disable highlighting form fields. Default is disabled.
     *
     * @method PDFNet.PDFRasterizer#setHighlightFields
     * @param {boolean} highlight true to highlight, false otherwise.
     */
    setHighlightFields(highlight: boolean): void;
    /**
     *
     * @method PDFNet.PDFRasterizer#setAntiAliasing
     * @param {boolean} enable_aa
     */
    setAntiAliasing(enable_aa: boolean): void;
    /**
     * Enable or disable path hinting.
     *
     * @method PDFNet.PDFRasterizer#setPathHinting
     * @param {boolean} enable_hinting if true path hinting is enabled. Path hinting is used to slightly
     * adjust paths in order to avoid or alleviate artifacts of hair line cracks between
     * certain graphical elements. This option is turned on by default.
     *
     */
    setPathHinting(enable_hinting: boolean): void;
    /**
     * Set thin line adjustment parameters.
     *
     * @method PDFNet.PDFRasterizer#setThinLineAdjustment
     * @param {boolean} grid_fit if true (horizontal/vertical) thin lines will be snapped to
     * integer pixel positions. This helps make thin lines look sharper and clearer. This
     * option is turned off by default and it only works if path hinting is enabled.
     *
     * @param {boolean} stroke_adjust if true auto stroke adjustment is enabled. Currently, this would
     * make lines with sub-pixel width to be one-pixel wide. This option is turned on by default.
     */
    setThinLineAdjustment(grid_fit: boolean, stroke_adjust: boolean): void;
    /**
     * sets the gamma factor used for anti-aliased rendering.
     *
     * @method PDFNet.PDFRasterizer#setGamma
     * @param {number} expgamma is the exponent value of gamma function. Typical values
     * are in the range from 0.1 to 3.
     *
     * Gamma correction can be used to improve the quality of anti-aliased
     * image output and can (to some extent) decrease the appearance common
     * anti-aliasing artifacts (such as pixel width lines between polygons).
     *
     * @note Gamma correction is used only in the built-in rasterizer.
     */
    setGamma(expgamma: number): void;
    /**
     * sets the Optional Content Group (OCG) context that should be used when
     *  rendering the page. This function can be used to selectively render optional
     * content (such as PDF layers) based on the states of optional content groups
     * in the given context.
     *
     * @method PDFNet.PDFRasterizer#setOCGContext
     * @param {PDFNet.OCGContext} ctx Optional Content Group (OCG) context, or NULL if the rasterizer
     * should render all content on the page.
     */
    setOCGContext(ctx: PDFNet.OCGContext): void;
    /**
     * tells the rasterizer to render the page 'print' mode. Certain page elements
     * (such as annotations or OCG-s) are meant to be visible either on the screen or
     * on the printed paper but not both. A common example, is the "Submit" button on
     * electronic forms.
     *
     * @method PDFNet.PDFRasterizer#setPrintMode
     * @param {boolean} is_printing set to true is the page should be rendered in print mode.
     * @default By default, print mode flag is set to false.
     */
    setPrintMode(is_printing: boolean): void;
    /**
     * Enable or disable image smoothing.
     *
     * The rasterizer allows a tradeoff between rendering quality and rendering speed.
     * This function can be used to indicate the preference between rendering speed and quality.
     *
     * @method PDFNet.PDFRasterizer#setImageSmoothing
     * @note image smoothing option has effect only if the source image has higher resolution
     * that the output resolution of the image on the rasterized page. PDFNet automatically
     * controls at what resolution/zoom factor, 'image smoothing' needs to take effect.
     *
     * @param {boolean} [smoothing_enabled] True to enable image smoothing, false otherwise.
     * @param {boolean} [hq_image_resampling] True to use a higher quality (but slower) smoothing algorithm
     * @default image smoothing is enabled and hq_image_resampling is false.
     */
    setImageSmoothing(smoothing_enabled?: boolean, hq_image_resampling?: boolean): void;
    /**
     * enable or disable support for overprint and overprint simulation.
     * Overprint is a device dependent feature and the results will vary depending on
     * the output color space and supported colorants (i.e. CMYK, CMYK+spot, RGB, etc).
     *
     * @method PDFNet.PDFRasterizer#setOverprint
     * @default By default overprint is only enabled for PDF/X files.
     *
     * @param {number} op
     * <pre>
     * PDFNet.PDFRasterizer.OverprintPreviewMode = {
     * 	e_op_off : 0
     * 	e_op_on : 1
     * 	e_op_pdfx_on : 2
     * }
     * </pre>
     * e_op_on: always enabled; e_op_off: always disabled; e_op_pdfx_on: enabled for PDF/X files only.
     */
    setOverprint(op: number): void;
    /**
     * enables or disables caching. Caching can improve the rendering performance in cases
     * where the same page will be drawn multiple times.
     *
     * @method PDFNet.PDFRasterizer#setCaching
     * @param {boolean} [enabled] if true PDFRasterizer will cache frequently used graphics objects.
     */
    setCaching(enabled?: boolean): void;
    /**
     *
     * @method PDFNet.PDFRasterizer#setAnnotationState
     * @param {PDFNet.Annot} annot
     * @param {number} new_view_state
     * <pre>
     * PDFNet.Annot.State = {
     * 	e_normal : 0
     * 	e_rollover : 1
     * 	e_down : 2
     * }
     * </pre>
     */
    setAnnotationState(annot: PDFNet.Annot, new_view_state: number): void;
    /**
     * Sets the core graphics library used for rasterization and
     * rendering. Using this method it is possible to quickly switch
     * between different implementations. By default, PDFNet uses a
     * built-in, high-quality, and platform independent rasterizer.
     *
     * @method PDFNet.PDFRasterizer#setRasterizerType
     * @param {number} type
     * <pre>
     * PDFNet.PDFRasterizer.Type = {
     * 	e_BuiltIn : 0
     * 	e_GDIPlus : 1
     * }
     * </pre>
     * Rasterizer type.
     *
     * @note This method is deprecated, since the GDI+ rasterizer itself is deprecated and will be removed in a future version of PDFNet.
     * It is strongly recommended to use the built-in rasterizer and to use the XPS print path where vector conversion is needed.
     */
    setRasterizerType(type: number): void;
    /**
     * @method PDFNet.PDFRasterizer#getRasterizerType
     * @return {Promise<number>} A promise that resolves to the type of current rasterizer.
     * @note This method is deprecated, since the GDI+ rasterizer itself is deprecated and will be removed in a future version of PDFNet.
     * It is strongly recommended to use the built-in rasterizer and to use the XPS print path where vector conversion is needed.
     * @example Return value enum:
     * <pre>
     * PDFNet.PDFRasterizer.Type = {
     * 	e_BuiltIn : 0
     * 	e_GDIPlus : 1
     * }
     * </pre>
     */
    getRasterizerType(): Promise<number>;
    /**
     * Set the color post processing transformation.
     * This transform is applied to the rasterized bitmap as the final step
     * in the rasterization process, and is applied directly to the resulting
     * bitmap (disregarding any color space information). Color post
     * processing only supported for RGBA output.
     *
     * @method PDFNet.PDFRasterizer#setColorPostProcessMode
     * @param {number} mode
     * <pre>
     * PDFNet.PDFRasterizer.ColorPostProcessMode = {
     * 	e_postprocess_none : 0
     * 	e_postprocess_invert : 1
     * }
     * </pre>
     * is the specific transform to be applied
     */
    setColorPostProcessMode(mode: number): void;
    /**
     * @method PDFNet.PDFRasterizer#getColorPostProcessMode
     * @return {Promise<number>} A promise that resolves to the current color post processing mode.
     * @example Return value enum:
     * <pre>
     * PDFNet.PDFRasterizer.ColorPostProcessMode = {
     * 	e_postprocess_none : 0
     * 	e_postprocess_invert : 1
     * }
     * </pre>
     */
    getColorPostProcessMode(): Promise<number>;
    /**
     *
     * @method PDFNet.PDFRasterizer#enableDisplayListCaching
     * @param {boolean} enabled
     */
    enableDisplayListCaching(enabled: boolean): void;
    /**
     *  this function is typically called for progressive rendering, in which
     *  we don't want to stop the main rendering thread. Since the rendering thread may
     *  modify separation channels, we don't consider separations in progressive rendering.
     * @method PDFNet.PDFRasterizer#updateBuffer
     */
    updateBuffer(): void;
    /**
     *
     * @method PDFNet.PDFRasterizer#rasterizeAnnot
     * @param {PDFNet.Annot} annot
     * @param {PDFNet.Page} page
     * @param {PDFNet.Matrix2D} device_mtx
     * @param {boolean} demult
     * @param {boolean} cancel
     * @return {Promise<PDFNet.OwnedBitmap>} A promise that resolves to an object of type: "OwnedBitmap"
     */
    rasterizeAnnot(
      annot: PDFNet.Annot,
      page: PDFNet.Page,
      device_mtx: PDFNet.Matrix2D,
      demult: boolean,
      cancel: boolean,
    ): Promise<PDFNet.OwnedBitmap>;
  }
  /**
   * PDFView is a utility class that can be used for interactive rendering of PDF documents.
   *
   * In .NET environment PDFView is derived from System.Windows.Forms.Control and it can be
   * used like a regular form (see PDFViewForm.cs in PDFView sample for C# for a concrete
   * example).
   *
   * PDFView implements some essential features such as double-buffering, multi-threaded
   * rendering, scrolling, zooming, and page navigation that are essential in interactive
   * rendering applications (e.g. in client PDF viewing and editing applications).
   *
   * PDFView defines several coordinate spaces and it is important to understand their
   * differences:
   *
   * - Page Space refers to the space in which a PDF page is defined. It is determined by
   * a page itself and the origin is at the lower-left corner of the page. Note that Page
   * Space is independent of how a page is viewed in PDFView and each page has its own Page
   * space.
   *
   * - Canvas Space refers to the tightest axis-aligned bounding box of all the pages given
   * the current page presentation mode in PDFView. For example, if the page presentation
   * mode is e_single_continuous, all the pages are arranged vertically with one page in each
   * row, and therefore the Canvas Space is rectangle with possibly large height value. For
   * this reason, Canvas Space is also, like Page Space, independent of the zoom factor. Also
   * note that since PDFView adds gaps between adjacent pages, the Canvas Space is larger than
   * the space occupied by all the pages. The origin of the Canvas Space is located at the
   * upper-left corner.
   *
   * - Screen Space (or Client Space) is the space occupied by PDFView and its origin is at
   * the upper-left corner. Note that the virtual size of this space can extend beyond the
   * visible region.
   *
   * - Scrollable Space is the virtual space within which PDFView can scroll. It is determined
   * by the Canvas Space and the current zoom factor. Roughly speaking, the dimensions of the
   * Scrollable Space is the dimensions of the Canvas Space timed by the zoom. Therefore, a large
   * zoom factor will result in a larger Scrollable region given the same Canvas region. For this
   * reason, Scrollable Space might also be referred to as Zoomed Canvas Space. Note that since
   * PDFView adds gaps between pages in Canvas Space and these gaps are not scaled when rendered,
   * the scrollable range is not exactly what the zoom factor times the Canvas range. For
   * functions such as SetHScrollPos(), SetVScrollPos(), GetCanvasHeight(), and
   * GetCanvasWidth(), it is the Scrollable Space that is involved.
   *
   * @note PDFView is available on all platforms supported by PDFNet.
   * @class
   * @name PDFView
   * @memberof PDFNet
   */
  class PDFView {}
  /**
   * PDFViewCtrl is a utility class that can be used for interactive rendering of PDF documents.
   *
   * In .NET environment PDFViewCtrl is derived from System.Windows.Forms.Control and it can be
   * used like a regular form (see PDFViewForm.cs in PDFView sample for C# for a concrete
   * example).
   *
   * Unlike PDFView, PDFViewCtrl is a control that implements a number of tool modes,
   * dialog boxes like find and password, has some built-in form filling capabilities
   * and a navigation panel for bookmarks, thumbview and layer views.
   *
   * PDFViewCtrl defines several coordinate spaces and it is important to understand their
   * differences:
   *
   * - Page Space refers to the space in which a PDF page is defined. It is determined by
   * a page itself and the origin is at the lower-left corner of the page. Note that Page
   * Space is independent of how a page is viewed in PDFView and each page has its own Page
   * space.
   *
   * - Canvas Space refers to the tightest axis-aligned bounding box of all the pages given
   * the current page presentation mode in PDFView. For example, if the page presentation
   * mode is e_single_continuous, all the pages are arranged vertically with one page in each
   * row, and therefore the Canvas Space is rectangle with possibly large height value. For
   * this reason, Canvas Space is also, like Page Space, independent of the zoom factor. Also
   * note that since PDFView adds gaps between adjacent pages, the Canvas Space is larger than
   * the space occupied by all the pages. The origin of the Canvas Space is located at the
   * upper-left corner.
   *
   * - Screen Space (or Client Space) is the space occupied by PDFView and its origin is at
   * the upper-left corner. Note that the virtual size of this space can extend beyond the
   * visible region.
   *
   * - Scrollable Space is the virtual space within which PDFView can scroll. It is determined
   * by the Canvas Space and the current zoom factor. Roughly speaking, the dimensions of the
   * Scrollable Space is the dimensions of the Canvas Space timed by the zoom. Therefore, a large
   * zoom factor will result in a larger Scrollable region given the same Canvas region. For this
   * reason, Scrollable Space might also be referred to as Zoomed Canvas Space. Note that since
   * PDFView adds gaps between pages in Canvas Space and these gaps are not scaled when rendered,
   * the scrollable range is not exactly what the zoom factor times the Canvas range. For
   * functions such as SetHScrollPos(), SetVScrollPos(), GetCanvasHeight(), and
   * GetCanvasWidth(), it is the Scrollable Space that is involved.
   *
   * @class
   * @name PDFViewCtrl
   * @memberof PDFNet
   */
  class PDFViewCtrl {}
  /**
   * Page is a high-level class representing PDF page object (see 'Page Objects' in
   * Section 3.6.2, 'Page Tree,' in PDF Reference Manual).
   *
   * Among other associated objects, a page object contains:
   *  - A series of objects representing the objects drawn on the page (See Element and
   *    ElementReader class for examples of how to extract page content).
   *  - A list of resources used in drawing the page
   *  - Annotations
   *  - Beads, private metadata, optional thumbnail image, etc.
   * @class
   * @name Page
   * @memberof PDFNet
   */
  class Page {
    /**
     * Initialize a page using an existing low-level Cos/SDF page object.
     *
     * @method PDFNet.Page.create
     * @param {PDFNet.Obj} [page_dict] a low-level (SDF/Cos) page dictionary.
     *
     * @note This constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     *
     * @note Because PDF::PDFDoc provides a complete high-level interface for Page creation
     * and traversal this constructor is rarely used.
     * @return {Promise<PDFNet.Page>} A promise that resolves to an object of type: "Page"
     */
    static create(page_dict?: PDFNet.Obj): Promise<PDFNet.Page>;
    /**
     * Copy Constructor
     * @method PDFNet.Page#copy
     * @return {Promise<PDFNet.Page>} A promise that resolves to an object of type: "Page"
     */
    copy(): Promise<PDFNet.Page>;
    /**
     * @method PDFNet.Page#isValid
     * @return {Promise<boolean>} A promise that resolves to true if this is a valid (non-null) page, false otherwise.
     * If the function returns false the underlying SDF/Cos object is null
     * or is not valid.
     */
    isValid(): Promise<boolean>;
    /**
     * @method PDFNet.Page#getIndex
     * @return {Promise<number>} A promise that resolves to the Page number indication the position of this Page in document's page sequence.
     * Document's page sequence is indexed from 1. Page number 0 means that the page is not part
     * of document's page sequence or that the page is not valid.
     */
    getIndex(): Promise<number>;
    /**
     * Get the Action associated with the selected Page Trigger event.
     *
     * @method PDFNet.Page#getTriggerAction
     * @param {number} trigger
     * <pre>
     * PDFNet.Page.EventType = {
     * 	e_action_trigger_page_open : 11
     * 	e_action_trigger_page_close : 12
     * }
     * </pre>
     * the type of trigger event to get
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the Action Obj if present, otherwise NULL
     */
    getTriggerAction(trigger: number): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Page#getBox
     * @return {Promise<PDFNet.Rect>} A promise that resolves to the box specified for the page object intersected with the media box.
     *
     * @param {number} type
     * <pre>
     * PDFNet.Page.Box = {
     * 	e_media : 0
     * 	e_crop : 1
     * 	e_bleed : 2
     * 	e_trim : 3
     * 	e_art : 4
     * }
     * </pre>
     * The type of the page bounding box. Possible values are: e_media, e_crop,
     * e_bleed, e_trim, and e_art.
     *
     * If the value for 'type' is e_crop, this call is equivalent to GetCropBox().
     * If the value for 'type' is e_media, this call is equivalent to GetMediaBox().
     */
    getBox(type: number): Promise<PDFNet.Rect>;
    /**
     * Sets the page bounding box specified by 'page_region' for this page.
     *
     * @method PDFNet.Page#setBox
     * @param {number} type
     * <pre>
     * PDFNet.Page.Box = {
     * 	e_media : 0
     * 	e_crop : 1
     * 	e_bleed : 2
     * 	e_trim : 3
     * 	e_art : 4
     * }
     * </pre>
     * The type of the page bounding box. Possible values are: e_media, e_crop,
     * e_bleed, e_trim, and e_art.
     * @param {PDFNet.Rect} box A rectangle specifying the coordinates to set for the box. The coordinates are
     * specified in user space units.
     */
    setBox(type: number, box: PDFNet.Rect): void;
    /**
     * @method PDFNet.Page#getCropBox
     * @return {Promise<PDFNet.Rect>} A promise that resolves to the crop box for this page. The page dimensions are specified in user space
     * coordinates.
     *
     * The crop box is the region of the page to display and print.
     * @note this method is equivalent to GetBox(Page::e_crop)
     */
    getCropBox(): Promise<PDFNet.Rect>;
    /**
     * Sets the crop box for this page. The crop box is the region of the page to
     * display and print.
     *
     * @method PDFNet.Page#setCropBox
     * @param {PDFNet.Rect} box the new crop box for this page. The page dimensions are specified in user space
     * coordinates.
     *
     * The crop box defines the region to which the contents of the page are to be clipped (cropped)
     * when displayed or printed.
     *
     * @note this method is equivalent to SetBox(Page::e_crop)
     */
    setCropBox(box: PDFNet.Rect): void;
    /**
     * @method PDFNet.Page#getMediaBox
     * @return {Promise<PDFNet.Rect>} A promise that resolves to the media box for this page. The page dimensions are specified in user space
     * coordinates.
     *
     * The media box defines the boundaries of the physical medium on which the page is to
     * be printed. It may include any extended area surrounding the finished page for bleed,
     * printing marks, or other such purposes.
     *
     * @note this method is equivalent to GetBox(Page::e_media)
     */
    getMediaBox(): Promise<PDFNet.Rect>;
    /**
     * Sets the media box for this page.
     *
     * @method PDFNet.Page#setMediaBox
     * @param {PDFNet.Rect} box the new media box for this page. The page dimensions are specified in user space
     * coordinates.
     *
     * The media box defines the boundaries of the physical medium on which the page is to
     * be printed. It may include any extended area surrounding the finished page for bleed,
     * printing marks, or other such purposes.
     *
     * @note this method is equivalent to SetBox(Page::e_media)
     */
    setMediaBox(box: PDFNet.Rect): void;
    /**
     * @method PDFNet.Page#getVisibleContentBox
     * @return {Promise<PDFNet.Rect>} A promise that resolves to the bounding box for this page. The page dimensions are specified in user space
     * coordinates.
     *
     * The bounding box is defined as the smallest rectangle that includes all the visible content on the page.
     */
    getVisibleContentBox(): Promise<PDFNet.Rect>;
    /**
     * @method PDFNet.Page#getRotation
     * @return {Promise<number>} A promise that resolves to the rotation value for this page.
     * @example Return value enum:
     * <pre>
     * PDFNet.Page.Rotate = {
     * 	e_0 : 0
     * 	e_90 : 1
     * 	e_180 : 2
     * 	e_270 : 3
     * }
     * </pre>
     */
    getRotation(): Promise<number>;
    /**
     * Sets the rotation value for this page.
     *
     * @method PDFNet.Page#setRotation
     * @param {number} angle
     * <pre>
     * PDFNet.Page.Rotate = {
     * 	e_0 : 0
     * 	e_90 : 1
     * 	e_180 : 2
     * 	e_270 : 3
     * }
     * </pre>
     * Rotation value to be set for a given page. Must be one
     * of the Page::Rotate values.
     */
    setRotation(angle: number): void;
    /**
     * Rotate r0 clockwise by r1
     *
     * @method PDFNet.Page.addRotations
     * @param {number} r0
     * <pre>
     * PDFNet.Page.Rotate = {
     * 	e_0 : 0
     * 	e_90 : 1
     * 	e_180 : 2
     * 	e_270 : 3
     * }
     * </pre>
     * first rotation.
     * @param {number} r1
     * <pre>
     * PDFNet.Page.Rotate = {
     * 	e_0 : 0
     * 	e_90 : 1
     * 	e_180 : 2
     * 	e_270 : 3
     * }
     * </pre>
     * second rotation.
     * @return {Promise<number>} A promise that resolves to returns r0 + r1
     * @example Return value enum:
     * <pre>
     * PDFNet.Page.Rotate = {
     * 	e_0 : 0
     * 	e_90 : 1
     * 	e_180 : 2
     * 	e_270 : 3
     * }
     * </pre>
     */
    static addRotations(r0: number, r1: number): Promise<number>;
    /**
     * Rotate r0 counter clockwise by r1.
     *
     * @method PDFNet.Page.subtractRotations
     * @param {number} r0
     * <pre>
     * PDFNet.Page.Rotate = {
     * 	e_0 : 0
     * 	e_90 : 1
     * 	e_180 : 2
     * 	e_270 : 3
     * }
     * </pre>
     * first rotation.
     * @param {number} r1
     * <pre>
     * PDFNet.Page.Rotate = {
     * 	e_0 : 0
     * 	e_90 : 1
     * 	e_180 : 2
     * 	e_270 : 3
     * }
     * </pre>
     * second rotation.
     * @return {Promise<number>} A promise that resolves to returns r0 r1
     * @example Return value enum:
     * <pre>
     * PDFNet.Page.Rotate = {
     * 	e_0 : 0
     * 	e_90 : 1
     * 	e_180 : 2
     * 	e_270 : 3
     * }
     * </pre>
     */
    static subtractRotations(r0: number, r1: number): Promise<number>;
    /**
     * Convert a rotation to a number.
     *
     * @method PDFNet.Page.rotationToDegree
     * @param {number} r
     * <pre>
     * PDFNet.Page.Rotate = {
     * 	e_0 : 0
     * 	e_90 : 1
     * 	e_180 : 2
     * 	e_270 : 3
     * }
     * </pre>
     * rotation to convert to number
     * @return {Promise<number>} A promise that resolves to one of four numbers; 0, 90, 180 or 270.
     */
    static rotationToDegree(r: number): Promise<number>;
    /**
     * Convert a number that represents rotation in degrees to a rotation enum.
     *
     * @method PDFNet.Page.degreeToRotation
     * @param {number} r degree to convert to rotation. Valid numbers are multiples of 90.
     * @return {Promise<number>} A promise that resolves to one of four angles; e_0, e_90, e_180 or e_270. Returns e_0 if input is
     * not a multiple 90.
     * @example Return value enum:
     * <pre>
     * PDFNet.Page.Rotate = {
     * 	e_0 : 0
     * 	e_90 : 1
     * 	e_180 : 2
     * 	e_270 : 3
     * }
     * </pre>
     */
    static degreeToRotation(r: number): Promise<number>;
    /**
     * @method PDFNet.Page#getPageWidth
     * @return {Promise<number>} A promise that resolves to the width for the given page region/box taking into account page
     * rotation attribute (i.e. /Rotate entry in page dictionary).
     *
     * @param {number} [box_type]
     * <pre>
     * PDFNet.Page.Box = {
     * 	e_media : 0
     * 	e_crop : 1
     * 	e_bleed : 2
     * 	e_trim : 3
     * 	e_art : 4
     * }
     * </pre>
     * indicates the page box/region to query for width.
     */
    getPageWidth(box_type?: number): Promise<number>;
    /**
     * @method PDFNet.Page#getPageHeight
     * @return {Promise<number>} A promise that resolves to the height for the given page region/box taking into account page
     * rotation attribute (i.e. /Rotate entry in page dictionary).
     *
     * @param {number} [box_type]
     * <pre>
     * PDFNet.Page.Box = {
     * 	e_media : 0
     * 	e_crop : 1
     * 	e_bleed : 2
     * 	e_trim : 3
     * 	e_art : 4
     * }
     * </pre>
     * indicates the page box/region to query for height.
     */
    getPageHeight(box_type?: number): Promise<number>;
    /**
     * @method PDFNet.Page#getDefaultMatrix
     * @return {Promise<PDFNet.Matrix2D>} A promise that resolves to the matrix that transforms user space coordinates to rotated and cropped coordinates.
     * The origin of this space is the bottom-left of the rotated, cropped page.
     *
     * @param {boolean} [flip_y] this parameter can be used to mirror the page. if 'flip_y' is true the Y
     * axis is not flipped and it is increasing, otherwise Y axis is decreasing.
     *
     * @param {number} [box_type]
     * <pre>
     * PDFNet.Page.Box = {
     * 	e_media : 0
     * 	e_crop : 1
     * 	e_bleed : 2
     * 	e_trim : 3
     * 	e_art : 4
     * }
     * </pre>
     * an optional parameter used to specify the page box/region that the matrix
     * should map to. By default, the function transforms user space coordinates to cropped
     * coordinates.
     *
     * @param {number} [angle]
     * <pre>
     * PDFNet.Page.Rotate = {
     * 	e_0 : 0
     * 	e_90 : 1
     * 	e_180 : 2
     * 	e_270 : 3
     * }
     * </pre>
     * an optional parameter used to specify page rotation in addition to the
     * rotation specified in the page dictionary. This parameter is usually used to rotate the
     * page without modifying the document itself.
     */
    getDefaultMatrix(flip_y?: boolean, box_type?: number, angle?: number): Promise<PDFNet.Matrix2D>;
    /**
     * Returns SDF/Cos array containing annotation dictionaries. See Section 8.4 in
     * the PDF Reference for a description of the annotation array.
     *
     * @method PDFNet.Page#getAnnots
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an array of annotation dictionaries representing annotations
     * associated with the page or NULL if page dictionary is not specified.
     */
    getAnnots(): Promise<PDFNet.Obj>;
    /**
     * Returns the number of annotations on a page. Widget annotations (form fields) are
     * included in the count.
     *
     * @method PDFNet.Page#getNumAnnots
     * @return {Promise<number>} A promise that resolves to the number of annotations on a page.
     */
    getNumAnnots(): Promise<number>;
    /**
     * Returns the annotation on the page.
     *
     * @method PDFNet.Page#getAnnot
     * @return {Promise<PDFNet.Annot>} A promise that resolves to annotation object. If the index is out of range returned Annot object
     * is not valid (i.e. annot.IsValid() returns false).
     *
     * @param {number} index The index of the annotation to get on a page. The first annotation
     * on a page has an index of zero.
     */
    getAnnot(index: number): Promise<PDFNet.Annot>;
    /**
     * Adds an annotation at the specified location in a page's annotation array.
     *
     * @method PDFNet.Page#annotInsert
     * @param {number} pos The location in the array to insert the object. The object is inserted
     * before the specified location. The first element in an array has a pos of zero.
     * If pos >= GetNumAnnots(), the method appends the annotation to the array.
     * @param {PDFNet.Annot} annot The annotation to add.
     */
    annotInsert(pos: number, annot: PDFNet.Annot): void;
    /**
     * Adds an annotation to the end of a page's annotation array.
     * @method PDFNet.Page#annotPushBack
     * @param {PDFNet.Annot} annot The annotation to prepend in a page's annotation array.
     */
    annotPushBack(annot: PDFNet.Annot): void;
    /**
     * Adds an annotation to the beginning of a page's annotation array.
     * @method PDFNet.Page#annotPushFront
     * @param {PDFNet.Annot} annot The annotation to append in a page's annotation array.
     */
    annotPushFront(annot: PDFNet.Annot): void;
    /**
     * Removes the given annotation from the page.
     * @method PDFNet.Page#annotRemove
     * @note Removing the annotation invalidates the given Annot object.
     * @param {PDFNet.Annot} annot The annotation to remove.
     */
    annotRemove(annot: PDFNet.Annot): void;
    /**
     * Removes the annotation at a given location.
     * @method PDFNet.Page#annotRemoveByIndex
     * @note Removing the annotation invalidates any associated Annot object.
     * @param {number} index A zero based index of the annotation to remove.
     */
    annotRemoveByIndex(index: number): void;
    /**
     * A utility method used to scale physical dimensions of the page including
     * all page content.
     *
     * @method PDFNet.Page#scale
     * @param {number} scale A number greater than 0 which is used as a scale factor.
     *  For example, calling page.Scale(0.5) will reduce physical dimensions of the
     *  page to half its original size, whereas page.Scale(2) will double the physical
     * dimensions of the page and will rescale all page content appropriately.
     *
     * @note Unlike SetUserUnitSize(unit_size) which is only supported in PDF 1.6
     * (i.e. Acrobat 7) and above, page.Scale(sc) supports all PDF versions.
     */
    scale(scale: number): void;
    /**
     * Flatten/Merge existing form field appearances with the page content and
     * remove widget annotation.
     *
     * Form 'flattening' refers to the operation that changes active form fields
     * into a static area that is part of the PDF document, just like the other
     * text and images in the document. A completely flattened PDF form does not
     * have any widget annotations or interactive fields.
     * @method PDFNet.Page#flattenField
     * @param {PDFNet.Field} field_to_flatten field to flatten
     * @note An alternative approach to set the field as read only is using
     * Field.SetFlag(Field::e_read_only, true) method. Unlike Field.SetFlag(...),
     * the result of FlattenField() operation can not be programatically reversed.
     */
    flattenField(field_to_flatten: PDFNet.Field): void;
    /**
     * tests whether this page has a transition.
     * @method PDFNet.Page#hasTransition
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    hasTransition(): Promise<boolean>;
    /**
     * Returns the UserUnit value for the page. A UserUnit is a positive number giving
     * the size of default user space units, in multiples of 1/72 inch.
     *
     * @method PDFNet.Page#getUserUnitSize
     * @return {Promise<number>} A promise that resolves to the UserUnit value for the page. If the key is not present in the
     * page dictionary the default of 1.0 is returned.
     */
    getUserUnitSize(): Promise<number>;
    /**
     * Sets the UserUnit value for a page.
     *
     * @method PDFNet.Page#setUserUnitSize
     * @param {number} unit_size A positive number giving the size of default user space
     * units, in multiples of 1/72 inch.
     *
     * @note This is a PDF 1.6 feature. See the implementation note 171 in
     * PDF Reference for details.
     */
    setUserUnitSize(unit_size: number): void;
    /**
     * @method PDFNet.Page#getResourceDict
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a pointer to the page resource dictionary.
     */
    getResourceDict(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Page#getContents
     * @return {Promise<PDFNet.Obj>} A promise that resolves to nULL if page is empty, otherwise a single stream or an array of streams.
     */
    getContents(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Page#getThumb
     * @return {Promise<PDFNet.Obj>} A promise that resolves to object representing the Image thumbnail.
     */
    getThumb(): Promise<PDFNet.Obj>;
    /**
     * Returns the page dictionary.
     *
     * @method PDFNet.Page#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the object to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * Some of the page attributes are designated as inheritable.
     * If such an attribute is omitted from a page object, its value is inherited
     * from an ancestor node in the page tree. If the attribute is a required one,
     * a value must be supplied in an ancestor node; if it is optional and no
     * inherited value is specified, the default value should be used.
     *
     * The function walks up the page inheritance tree in search for specified
     * attribute.
     * @method PDFNet.Page#findInheritedAttribute
     * @param {string} attrib A string representing the attribute to search for.
     * @return {Promise<PDFNet.Obj>} A promise that resolves to if the attribute was found return a pointer to the value. Otherwise
     * the function return NULL.
     *
     *	Resources dictionary (Required; inheritable)
     *  MediaBox rectangle (Required; inheritable)
     *  CropBox rectangle (Optional; inheritable)
     *  Rotate integer (Optional; inheritable)
     */
    findInheritedAttribute(attrib: string): Promise<PDFNet.Obj>;
  }
  /**
   * PDF page labels can be used to describe a page. This is used to
   * allow for non-sequential page numbering or the addition of arbitrary
   * labels for a page (such as the inclusion of Roman numerals at the
   * beginning of a book). PDFNet PageLabel object can be used to specify
   * the numbering style to use (for example, upper- or lower-case Roman,
   * decimal, and so forth), the starting number for the first page,
   * and an arbitrary prefix to be pre-appended to each number (for
   * example, "A-" to generate "A-1", "A-2", "A-3", and so forth.)
   *
   * PageLabel corresponds to the PDF Page Label object (Section 8.3.1,
   * 'Page Labels' in the PDF Reference Manual.
   *
   * Each page in a PDF document is identified by an integer page index
   * that expresses the page's relative position within the document.
   * In addition, a document may optionally define page labels to identify
   * each page visually on the screen or in print. Page labels and page
   * indices need not coincide: the indices are fixed, running consecutively
   * through the document starting from 1 for the first page, but the
   * labels can be specified in any way that is appropriate for the particular
   * document. For example, if the document begins with 12 pages of front
   * matter numbered in roman numerals and the remainder of the document is
   * numbered in Arabic, the first page would have a page index of 1 and a
   * page label of i, the twelfth page would have index 12 and label xii,
   * and the thirteenth page would have index 13 and label 1.
   *
   * For purposes of page labeling, a document can be divided into labeling
   * ranges, each of which is a series of consecutive pages using the same
   * numbering system. Pages within a range are numbered sequentially in
   * ascending order. A page's label consists of a numeric portion based
   * on its position within its labeling range, optionally preceded by a
   * label prefix denoting the range itself. For example, the pages in an
   * appendix might be labeled with decimal numeric portions prefixed with
   * the string "A-" and the resulting page labels would be "A-1", "A-2",
   *
   * @note
   * There is no default numbering style; if no 'S' (Style) entry is present,
   * page labels consist solely of a label prefix with no numeric portion.
   * For example, if the 'P' entry (Prefix) specifies the label prefix
   * "Appendix", each page is simply labeled "Appendix" with no page number.
   * If the 'P' entry is also missing or empty, the page label is an empty
   * string.
   *
   * Sample code (See PableLabelsTest sample project for examples):
   * <pre>
   * // Create a page labeling scheme that starts with the first page in
   * // the document (page 1) and is using uppercase roman numbering
   * // style.
   * doc.SetPageLabel(1, PageLabel::Create(doc, PageLabel::e_roman_uppercase, "My Prefix ", 1));
   *
   * // Create a page labeling scheme that starts with the fourth page in
   * // the document and is using decimal Arabic numbering style.
   * // Also the numeric portion of the first label should start with number
   * // 4 (otherwise the first label would be "My Prefix 1").
   * PageLabel L2 = PageLabel::Create(doc, PageLabel::e_decimal, "My Prefix ", 4);
   * doc.SetPageLabel(4, L2);
   *
   * // Create a page labeling scheme that starts with the seventh page in
   * // the document and is using alphabetic numbering style. The numeric
   * // portion of the first label should start with number 1.
   * PageLabel L3 = PageLabel::Create(doc, PageLabel::e_alphabetic_uppercase, "My Prefix ", 1);
   * doc.SetPageLabel(7, L3);
   *
   * // Read page labels from an existing PDF document.
   * PageLabel label;
   * for (int i=1; i<=doc.GetPageCount(); ++i) {
   * label = doc.GetPageLabel(i);
   * if (label.IsValid()) {
   *   UString title = label.GetLabelTitle(i);
   * }
   *
   * </pre>
   * @class
   * @name PageLabel
   * @memberof PDFNet
   */
  class PageLabel {
    /**
     * Creates a new PageLabel.
     *
     * @method PDFNet.PageLabel.create
     * @param {PDFNet.SDFDoc} doc A document to which the page label is added.
     * @param {number} style
     * <pre>
     * PDFNet.PageLabel.Style = {
     * 	e_decimal : 0
     * 	e_roman_uppercase : 1
     * 	e_roman_lowercase : 2
     * 	e_alphabetic_uppercase : 3
     * 	e_alphabetic_lowercase : 4
     * 	e_none : 5
     * }
     * </pre>
     * The numbering style for the label.
     * @param {string} [prefix] The string used to prefix the numeric portion of the
     * page label.
     * @param {number} [start_at] the value to use when generating the numeric portion of the first
     * label in this range; must be greater than or equal to 1.
     *
     * @return {Promise<PDFNet.PageLabel>} A promise that resolves to newly created PageLabel object.
     */
    static create(doc: PDFNet.SDFDoc, style: number, prefix?: string, start_at?: number): Promise<PDFNet.PageLabel>;
    /**
     *
     * @method PDFNet.PageLabel.createFromObj
     * @param {PDFNet.Obj} [l]
     * @param {number} [first_page]
     * @param {number} [last_page]
     * @return {Promise<PDFNet.PageLabel>} A promise that resolves to an object of type: "PageLabel"
     */
    static createFromObj(l?: PDFNet.Obj, first_page?: number, last_page?: number): Promise<PDFNet.PageLabel>;
    /**
     *
     * @method PDFNet.PageLabel#compare
     * @param {PDFNet.PageLabel} d
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    compare(d: PDFNet.PageLabel): Promise<boolean>;
    /**
     * @method PDFNet.PageLabel#isValid
     * @return {Promise<boolean>} A promise that resolves to whether this is a valid (non-null) PageLabel. If the
     * function returns false the underlying SDF/Cos object is null or is
     * not valid and the PageLabel object should be treated as null as well.
     */
    isValid(): Promise<boolean>;
    /**
     *
     * @method PDFNet.PageLabel#getLabelTitle
     * @param {number} page_num
     * @return {Promise<string>} A promise that resolves to an object of type: "string"
     */
    getLabelTitle(page_num: number): Promise<string>;
    /**
     * Sets the numbering style for the label.
     *
     * @method PDFNet.PageLabel#setStyle
     * @param {number} style
     * <pre>
     * PDFNet.PageLabel.Style = {
     * 	e_decimal : 0
     * 	e_roman_uppercase : 1
     * 	e_roman_lowercase : 2
     * 	e_alphabetic_uppercase : 3
     * 	e_alphabetic_lowercase : 4
     * 	e_none : 5
     * }
     * </pre>
     * the numbering style for the label.
     *
     * You may use label style to customize the page numbering schemes
     * used throughout a document. There are three numbering formats:
     *  decimal (often used for normal page ranges)
     *  roman (often used for front matter such as a preface)
     *  alphabetic (often used for back matter such as appendices)
     *
     * @note
     * There is no default numbering style; if no 'S' (Style) entry is present,
     * page labels consist solely of a label prefix with no numeric portion.
     */
    setStyle(style: number): void;
    /**
     * @method PDFNet.PageLabel#getStyle
     * @return {Promise<number>} A promise that resolves to page numbering style.
     * @example Return value enum:
     * <pre>
     * PDFNet.PageLabel.Style = {
     * 	e_decimal : 0
     * 	e_roman_uppercase : 1
     * 	e_roman_lowercase : 2
     * 	e_alphabetic_uppercase : 3
     * 	e_alphabetic_lowercase : 4
     * 	e_none : 5
     * }
     * </pre>
     */
    getStyle(): Promise<number>;
    /**
     * @method PDFNet.PageLabel#getPrefix
     * @return {Promise<string>} A promise that resolves to the string used to prefix the numeric portion of
     * the page label
     */
    getPrefix(): Promise<string>;
    /**
     * @method PDFNet.PageLabel#setPrefix
     * @param {string} prefix the string used to prefix the numeric portion of
     * the page label.
     */
    setPrefix(prefix: string): void;
    /**
     * @method PDFNet.PageLabel#getStart
     * @return {Promise<number>} A promise that resolves to the value to use when generating the numeric portion of
     * the first label in this range; must be greater than or equal to 1.
     */
    getStart(): Promise<number>;
    /**
     * @method PDFNet.PageLabel#setStart
     * @param {number} start_at the value to use when generating the numeric
     * portion of the first label in this range; must be greater than
     * or equal to 1.
     */
    setStart(start_at: number): void;
    /**
     * @method PDFNet.PageLabel#getFirstPageNum
     * @return {Promise<number>} A promise that resolves to the first page in the range associated with this label
     * or -1 if the label is not associated with any page.
     */
    getFirstPageNum(): Promise<number>;
    /**
     * @method PDFNet.PageLabel#getLastPageNum
     * @return {Promise<number>} A promise that resolves to the last page in the range associated with this label
     * or -1 if the label is not associated with any page.
     */
    getLastPageNum(): Promise<number>;
    /**
     * @method PDFNet.PageLabel#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the pointer to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
  }
  /**
   * PageSet is a container of page numbers ordered following a linear sequence.
   * The page numbers are integers and must be greater than zero. Duplicates are allowed.
   *
   * (NOTE: This is not a mathematical set)
   * @class
   * @name PageSet
   * @memberof PDFNet
   */
  class PageSet {
    /**
     * Default constructor. Constructs 'PageSet' with no pages
     * @method PDFNet.PageSet.create
     * @return {Promise<PDFNet.PageSet>} A promise that resolves to an object of type: "PageSet"
     */
    static create(): Promise<PDFNet.PageSet>;
    /**
     *
     * @method PDFNet.PageSet.createSinglePage
     * @param {number} one_page
     * @return {Promise<PDFNet.PageSet>} A promise that resolves to an object of type: "PageSet"
     */
    static createSinglePage(one_page: number): Promise<PDFNet.PageSet>;
    /**
     *
     * @method PDFNet.PageSet.createRange
     * @param {number} range_start
     * @param {number} range_end
     * @return {Promise<PDFNet.PageSet>} A promise that resolves to an object of type: "PageSet"
     */
    static createRange(range_start: number, range_end: number): Promise<PDFNet.PageSet>;
    /**
     *
     * @method PDFNet.PageSet.createFilteredRange
     * @param {number} range_start
     * @param {number} range_end
     * @param {number} [filter]
     * <pre>
     * PDFNet.PageSet.Filter = {
     * 	e_all : 0
     * 	e_even : 1
     * 	e_odd : 2
     * }
     * </pre>
     * @return {Promise<PDFNet.PageSet>} A promise that resolves to an object of type: "PageSet"
     */
    static createFilteredRange(range_start: number, range_end: number, filter?: number): Promise<PDFNet.PageSet>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.PageSet#destroy
     */
    destroy(): void;
    /**
     * Add a value to the sequence.
     *
     * @method PDFNet.PageSet#addPage
     * @param {number} one_page The page number being added
     */
    addPage(one_page: number): void;
    /**
     * Add a range of values to the sequence. Reverse ordering is legal.
     *
     * @method PDFNet.PageSet#addRange
     * @param {number} range_start The starting value in the range
     * @param {number} range_end The ending value in the range
     * @param {number} [filter]
     * <pre>
     * PDFNet.PageSet.Filter = {
     * 	e_all : 0
     * 	e_even : 1
     * 	e_odd : 2
     * }
     * </pre>
     *
     *		-e_all: Default, includes all pages in the range
     *		-e_odd: Includes odd numbers in the range (discards even numbers)
     *		-e_even: Includes even numbers in the range (discards odd numbers)
     */
    addRange(range_start: number, range_end: number, filter?: number): void;
  }
  /**
   * Patterns are quite general, and have many uses; for example, they can be used
   * to create various graphical textures, such as weaves, brick walls, sunbursts,
   * and similar geometrical and chromatic effects.
   * Patterns are specified in a special family of color spaces named Pattern, whose
   * 'color values' are PatternColor objects instead of the numeric component values
   * used with other spaces. Therefore PatternColor is to pattern color space what is
   * ColorPt to all other color spaces.
   *
   * A tiling pattern consists of a small graphical figure called a pattern cell.
   * Painting with the pattern replicates the cell at fixed horizontal and vertical
   * intervals to fill an area. The effect is as if the figure were painted on the
   * surface of a clear glass tile, identical copies of which were then laid down
   * in an array covering the area and trimmed to its boundaries. This is called
   * tiling the area.
   *
   * The pattern cell can include graphical elements such as filled areas, text,
   * and sampled images. Its shape need not be rectangular, and the spacing of
   * tiles can differ from the dimensions of the cell itself.
   *
   * The order in which individual tiles (instances of the cell) are painted is
   * unspecified and unpredictable; it is inadvisable for the figures on adjacent
   * tiles to overlap.
   * @class
   * @name PatternColor
   * @memberof PDFNet
   */
  class PatternColor {
    /**
     *
     * @method PDFNet.PatternColor.create
     * @param {PDFNet.Obj} pattern
     * @return {Promise<PDFNet.PatternColor>} A promise that resolves to an object of type: "PatternColor"
     */
    static create(pattern: PDFNet.Obj): Promise<PDFNet.PatternColor>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.PatternColor#destroy
     */
    destroy(): void;
    /**
     *
     * @method PDFNet.PatternColor.getTypeFromObj
     * @param {PDFNet.Obj} pattern
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     * <pre>
     * PDFNet.PatternColor.Type = {
     * 	e_uncolored_tiling_pattern : 0
     * 	e_colored_tiling_pattern : 1
     * 	e_shading : 2
     * 	e_null : 3
     * }
     * </pre>
     */
    static getTypeFromObj(pattern: PDFNet.Obj): Promise<number>;
    /**
     * @method PDFNet.PatternColor#getType
     * @return {Promise<number>} A promise that resolves to the pattern type
     * @example Return value enum:
     * <pre>
     * PDFNet.PatternColor.Type = {
     * 	e_uncolored_tiling_pattern : 0
     * 	e_colored_tiling_pattern : 1
     * 	e_shading : 2
     * 	e_null : 3
     * }
     * </pre>
     */
    getType(): Promise<number>;
    /**
     * @method PDFNet.PatternColor#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the underlying SDF/Cos object
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.PatternColor#getMatrix
     * @return {Promise<PDFNet.Matrix2D>} A promise that resolves to pattern matrix, a transformation matrix that maps the pattern's
     * internal coordinate system to the default coordinate system of the pattern's
     * parent content stream (the content stream in which the pattern is defined as
     * a resource). The concatenation of the pattern matrix with that of the parent content
     * stream establishes the pattern coordinate space, within which all graphics objects
     * in the pattern are interpreted.
     */
    getMatrix(): Promise<PDFNet.Matrix2D>;
    /**
     * @method PDFNet.PatternColor#getShading
     * @return {Promise<PDFNet.Shading>} A promise that resolves to the shading object defining the shading pattern's gradient fill.
     *
     * @note for patterns other than Shading this method throws an exception.
     */
    getShading(): Promise<PDFNet.Shading>;
    /**
     * @method PDFNet.PatternColor#getTilingType
     * @return {Promise<number>} A promise that resolves to the tiling type identifier that controls adjustments to the spacing
     * of tiles relative to the device pixel grid:
     *
     * @note for patterns other than Tiling this method throws an exception.
     * @example Return value enum:
     * <pre>
     * PDFNet.PatternColor.TilingType = {
     * 	e_constant_spacing : 0
     * 	e_no_distortion : 1
     * 	e_constant_spacing_fast_fill : 2
     * }
     * </pre>
     */
    getTilingType(): Promise<number>;
    /**
     * @method PDFNet.PatternColor#getBBox
     * @return {Promise<PDFNet.Rect>} A promise that resolves to a rectangle in the pattern coordinate system giving the
     * coordinates of the left, bottom, right, and top edges, respectively,
     * of the pattern cell's bounding box. These boundaries are used to clip
     * the pattern cell.
     *
     * @note for patterns other than Tiling this method throws an exception.
     */
    getBBox(): Promise<PDFNet.Rect>;
    /**
     * @method PDFNet.PatternColor#getXStep
     * @return {Promise<number>} A promise that resolves to the desired horizontal spacing between pattern cells, measured
     * in the pattern coordinate system.
     *
     * @note that XStep and YStep may differ from the dimensions of the pattern
     * cell implied by the BBox entry. This allows tiling with irregularly shaped
     * figures. XStep and YStep may be either positive or negative, but not zero.
     *
     * @note for patterns other than Tiling this method throws an exception.
     */
    getXStep(): Promise<number>;
    /**
     * @method PDFNet.PatternColor#getYStep
     * @return {Promise<number>} A promise that resolves to the desired vertical spacing between pattern cells, measured in
     * the pattern coordinate system.
     *
     * @note for patterns other than Tiling this method throws an exception.
     */
    getYStep(): Promise<number>;
  }
  /**
   * This header defines classes for the Polygon and PolyLine annotations.
   * Polygon annotations (PDF 1.5) display closed polygons on the page.
   * Such polygons may have any number of vertices connected by straight lines.
   * Polyline annotations (PDF 1.5) are similar to polygons, except that the
   * first and last vertex are not implicitly connected.
   * @class
   * @name PolyLineAnnot
   * @memberof PDFNet
   */
  class PolyLineAnnot {
    /**
     * creates a PolyLine annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.PolyLineAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.PolyLineAnnot>} A promise that resolves to an object of type: "PolyLineAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.PolyLineAnnot>;
    /**
     * creates a PolyLine annotation and initializes it using given annotation object.
     * @method PDFNet.PolyLineAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the PolyLine annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.PolyLineAnnot>} A promise that resolves to an object of type: "PolyLineAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.PolyLineAnnot>;
    /**
     * Creates a new PolyLine annotation in the specified document.
     *
     * @method PDFNet.PolyLineAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the PolyLine annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the PolyLine annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.PolyLineAnnot>} A promise that resolves to a newly created blank PolyLine annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.PolyLineAnnot>;
    /**
     * Returns the number of vertices in the Vertices array.
     *
     * @method PDFNet.PolyLineAnnot#getVertexCount
     * @return {Promise<number>} A promise that resolves to the number of vertices.
     * @note The Vertices are the points between which the lines are drawn.
     * The viewer can draw either the straight lines or the smoothly connecting ones.
     */
    getVertexCount(): Promise<number>;
    /**
     * Returns the vertex(as a Point object) corresponding to the index
     * within the Vertices array.
     *
     * @method PDFNet.PolyLineAnnot#getVertex
     * @param {number} idx The index of the vertex, should be less than the value returned by GetVertexCount().
     * @return {Promise<PDFNet.Point>} A promise that resolves to a Point object corresponding to the vertex in the specified index position.
     * @note The Vertices are the points between which the lines are drawn.
     * The viewer can draw either the straight lines or the smoothly connecting ones.
     */
    getVertex(idx: number): Promise<PDFNet.Point>;
    /**
     * sets the vertex(in Point object form) corresponding to the index
     * within the Vertices array.
     *
     * @method PDFNet.PolyLineAnnot#setVertex
     * @param {number} idx The index of the vertex.
     * @param {PDFNet.Point} pt A Point object corresponding to the vertex to be added to the array.
     * @note The Vertices are the points between which the lines are drawn.
     * The viewer can draw either the straight lines or the smoothly connecting ones.
     */
    setVertex(idx: number, pt: PDFNet.Point): void;
    /**
     * @method PDFNet.PolyLineAnnot#getStartStyle
     * @example Return value enum:
     * <pre>
     * PDFNet.LineAnnot.EndingStyle = {
     * 	e_Square : 0
     * 	e_Circle : 1
     * 	e_Diamond : 2
     * 	e_OpenArrow : 3
     * 	e_ClosedArrow : 4
     * 	e_Butt : 5
     * 	e_ROpenArrow : 6
     * 	e_RClosedArrow : 7
     * 	e_Slash : 8
     * 	e_None : 9
     * 	e_Unknown : 10
     * }
     * </pre>
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     * <pre>
     * PDFNet.LineAnnot.EndingStyle = {
     * 	e_Square : 0
     * 	e_Circle : 1
     * 	e_Diamond : 2
     * 	e_OpenArrow : 3
     * 	e_ClosedArrow : 4
     * 	e_Butt : 5
     * 	e_ROpenArrow : 6
     * 	e_RClosedArrow : 7
     * 	e_Slash : 8
     * 	e_None : 9
     * 	e_Unknown : 10
     * }
     * </pre>
     */
    getStartStyle(): Promise<number>;
    /**
     *
     * @method PDFNet.PolyLineAnnot#setStartStyle
     * @param {number} style
     * <pre>
     * PDFNet.LineAnnot.EndingStyle = {
     * 	e_Square : 0
     * 	e_Circle : 1
     * 	e_Diamond : 2
     * 	e_OpenArrow : 3
     * 	e_ClosedArrow : 4
     * 	e_Butt : 5
     * 	e_ROpenArrow : 6
     * 	e_RClosedArrow : 7
     * 	e_Slash : 8
     * 	e_None : 9
     * 	e_Unknown : 10
     * }
     * </pre>
     */
    setStartStyle(style: number): void;
    /**
     * @method PDFNet.PolyLineAnnot#getEndStyle
     * @example Return value enum:
     * <pre>
     * PDFNet.LineAnnot.EndingStyle = {
     * 	e_Square : 0
     * 	e_Circle : 1
     * 	e_Diamond : 2
     * 	e_OpenArrow : 3
     * 	e_ClosedArrow : 4
     * 	e_Butt : 5
     * 	e_ROpenArrow : 6
     * 	e_RClosedArrow : 7
     * 	e_Slash : 8
     * 	e_None : 9
     * 	e_Unknown : 10
     * }
     * </pre>
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     * <pre>
     * PDFNet.LineAnnot.EndingStyle = {
     * 	e_Square : 0
     * 	e_Circle : 1
     * 	e_Diamond : 2
     * 	e_OpenArrow : 3
     * 	e_ClosedArrow : 4
     * 	e_Butt : 5
     * 	e_ROpenArrow : 6
     * 	e_RClosedArrow : 7
     * 	e_Slash : 8
     * 	e_None : 9
     * 	e_Unknown : 10
     * }
     * </pre>
     */
    getEndStyle(): Promise<number>;
    /**
     *
     * @method PDFNet.PolyLineAnnot#setEndStyle
     * @param {number} style
     * <pre>
     * PDFNet.LineAnnot.EndingStyle = {
     * 	e_Square : 0
     * 	e_Circle : 1
     * 	e_Diamond : 2
     * 	e_OpenArrow : 3
     * 	e_ClosedArrow : 4
     * 	e_Butt : 5
     * 	e_ROpenArrow : 6
     * 	e_RClosedArrow : 7
     * 	e_Slash : 8
     * 	e_None : 9
     * 	e_Unknown : 10
     * }
     * </pre>
     */
    setEndStyle(style: number): void;
    /**
     * Returns the intent name as a value of the "IntentName" enumeration type.
     *
     * @method PDFNet.PolyLineAnnot#getIntentName
     * @return {Promise<number>} A promise that resolves tos The intent type of the annotation.
     * @see IntentType
     * @example Return value enum:
     * <pre>
     * PDFNet.PolyLineAnnot.IntentType = {
     * 	e_PolygonCloud : 0
     * 	e_PolyLineDimension : 1
     * 	e_PolygonDimension : 2
     * 	e_Unknown : 3
     * }
     * </pre>
     */
    getIntentName(): Promise<number>;
    /**
     * Sets the Intent name as a value of the "IntentName" enumeration type.
     * (Optional; PDF 1.6 )
     *
     * @method PDFNet.PolyLineAnnot#setIntentName
     * @param {number} mode
     * <pre>
     * PDFNet.PolyLineAnnot.IntentType = {
     * 	e_PolygonCloud : 0
     * 	e_PolyLineDimension : 1
     * 	e_PolygonDimension : 2
     * 	e_Unknown : 3
     * }
     * </pre>
     * The intent name of the annotation.
     * @see IntentType
     */
    setIntentName(mode: number): void;
  }
  /**
   * A polygon annotation
   * @class
   * @name PolygonAnnot
   * @memberof PDFNet
   */
  class PolygonAnnot {
    /**
     * creates a Polygon annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.PolygonAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.PolygonAnnot>} A promise that resolves to an object of type: "PolygonAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.PolygonAnnot>;
    /**
     * creates a Polygon annotation and initializes it using given annotation object.
     * @method PDFNet.PolygonAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Polygon annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.PolygonAnnot>} A promise that resolves to an object of type: "PolygonAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.PolygonAnnot>;
    /**
     * Creates a new Polygon annotation in the specified document.
     *
     * @method PDFNet.PolygonAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the Polygon annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the Polygon annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.PolygonAnnot>} A promise that resolves to a newly created blank Polygon annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.PolygonAnnot>;
  }
  /**
   * A pop-up annotation (PDF 1.3) displays text in a pop-up window for entry and
   * editing. It shall not appear alone but is associated with a markup annotation,
   * its parent annotation, and shall be used for editing the parent's text.
   * It shall have no appearance stream or associated actions of its own and
   * shall be identified by the Popup entry in the parent's annotation dictionary.
   * @class
   * @name PopupAnnot
   * @memberof PDFNet
   */
  class PopupAnnot {
    /**
     * creates a Popup annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.PopupAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.PopupAnnot>} A promise that resolves to an object of type: "PopupAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.PopupAnnot>;
    /**
     * creates a Popup annotation and initializes it using given annotation object.
     * @method PDFNet.PopupAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Popup annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.PopupAnnot>} A promise that resolves to an object of type: "PopupAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.PopupAnnot>;
    /**
     * Creates a new Popup annotation in the specified document.
     *
     * @method PDFNet.PopupAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the Popup annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the Popup annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.PopupAnnot>} A promise that resolves to a newly created blank Popup annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.PopupAnnot>;
    /**
     * Returns the parent annotation of the Popup annotation.
     *
     * @method PDFNet.PopupAnnot#getParent
     * @return {Promise<PDFNet.Annot>} A promise that resolves to an annot object which is the parent annotation of the Popup annotation.
     * @note This annotation object represents the parent annotation with which this
     * pop-up annotation shall be associated.
     * @note If this entry is present, the parent annotation's Contents, M, C, and T entries
     * shall override those of the pop-up annotation itself.
     */
    getParent(): Promise<PDFNet.Annot>;
    /**
     * sets the Parent annotation of the Popup annotation.
     * (Optional)
     *
     * @method PDFNet.PopupAnnot#setParent
     * @param {PDFNet.Annot} parent An annot object which is the parent annotation of the Popup annotation.
     * @note This annotation object represents the parent annotation with which this
     * pop-up annotation shall be associated.
     * @note If this entry is present, the parent annotation's Contents, M, C, and T entries
     * shall override those of the pop-up annotation itself.
     */
    setParent(parent: PDFNet.Annot): void;
    /**
     * Returns the initial opening condition of Popup.
     *
     * @method PDFNet.PopupAnnot#isOpen
     * @return {Promise<boolean>} A promise that resolves to a bool indicating whether the Popup is initially open.
     * @note This is a flag specifying whether the pop-up
     * annotation's window shall initially be displayed.
     * Default value: false (closed).
     */
    isOpen(): Promise<boolean>;
    /**
     * sets the initial opening condition of Popup.
     * (Optional)
     *
     * @method PDFNet.PopupAnnot#setOpen
     * @param {boolean} isopen A bool indicating whether the Popup is initially open.
     * @note This is a flag specifying whether the pop-up
     * annotation's window shall initially be displayed.
     * Default value: false (closed).
     */
    setOpen(isopen: boolean): void;
  }
  /**
   * [Missing documentation]
   * @class
   * @name PrinterMode
   * @memberof PDFNet
   */
  class PrinterMode {}
  /**
   * [Not Yet Documented]
   * @class
   * @name ProgressMonitor
   * @memberof PDFNet
   */
  class ProgressMonitor {}
  /**
   * [Missing documentation]
   * @class
   * @name PushButtonWidget
   * @memberof PDFNet
   */
  class PushButtonWidget {
    /**
     * Constructor
     * @method PDFNet.PushButtonWidget.create
     * @param {PDFNet.PDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @param {string} [field_name]
     * @return {Promise<PDFNet.PushButtonWidget>} A promise that resolves to an object of type: "PushButtonWidget"
     */
    static create(doc: PDFNet.PDFDoc, pos: PDFNet.Rect, field_name?: string): Promise<PDFNet.PushButtonWidget>;
    /**
     *
     * @method PDFNet.PushButtonWidget.createWithField
     * @param {PDFNet.PDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @param {PDFNet.Field} field
     * @return {Promise<PDFNet.PushButtonWidget>} A promise that resolves to an object of type: "PushButtonWidget"
     */
    static createWithField(doc: PDFNet.PDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.PushButtonWidget>;
    /**
     *
     * @method PDFNet.PushButtonWidget.createFromObj
     * @param {PDFNet.Obj} [obj]
     * @return {Promise<PDFNet.PushButtonWidget>} A promise that resolves to an object of type: "PushButtonWidget"
     */
    static createFromObj(obj?: PDFNet.Obj): Promise<PDFNet.PushButtonWidget>;
    /**
     *
     * @method PDFNet.PushButtonWidget.createFromAnnot
     * @param {PDFNet.Annot} annot
     * @return {Promise<PDFNet.PushButtonWidget>} A promise that resolves to an object of type: "PushButtonWidget"
     */
    static createFromAnnot(annot: PDFNet.Annot): Promise<PDFNet.PushButtonWidget>;
  }
  /**
   * [Missing documentation]
   * @class
   * @name RadioButtonGroup
   * @memberof PDFNet
   */
  class RadioButtonGroup {}
  /**
   * [Missing documentation]
   * @class
   * @name RadioButtonWidget
   * @memberof PDFNet
   */
  class RadioButtonWidget {
    /**
     *
     * @method PDFNet.RadioButtonWidget.createFromObj
     * @param {PDFNet.Obj} [obj]
     * @return {Promise<PDFNet.RadioButtonWidget>} A promise that resolves to an object of type: "RadioButtonWidget"
     */
    static createFromObj(obj?: PDFNet.Obj): Promise<PDFNet.RadioButtonWidget>;
    /**
     *
     * @method PDFNet.RadioButtonWidget.createFromAnnot
     * @param {PDFNet.Annot} annot
     * @return {Promise<PDFNet.RadioButtonWidget>} A promise that resolves to an object of type: "RadioButtonWidget"
     */
    static createFromAnnot(annot: PDFNet.Annot): Promise<PDFNet.RadioButtonWidget>;
    /**
     *
     * @method PDFNet.RadioButtonWidget#isEnabled
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    isEnabled(): Promise<boolean>;
    /**
     *
     * @method PDFNet.RadioButtonWidget#enableButton
     */
    enableButton(): void;
    /**
     *
     * @method PDFNet.RadioButtonWidget#getGroup
     * @return {Promise<PDFNet.RadioButtonGroup>} A promise that resolves to an object of type: "RadioButtonGroup"
     */
    getGroup(): Promise<PDFNet.RadioButtonGroup>;
  }
  /**
   * Rect is a struct used to manipulate PDF rectangle objects
   *
   * @note - Rectangles are conventionally specified by their lower-left and
   * upper-right corners respectively.
   *
   * --------------------
   * Since Rect is a struct, it can be created by calling "new PDFNet.Rect(x1,y1,x2,y2)"
   * eg. var myfoo = new PDFNet.Rect(1,2,3,4);
   *
   * Default values for a rect are:
   * x1 = 0
   * y1 = 0
   * x2 = 0
   * y2 = 0
   * mp_rect = "0"
   * @class
   * @name Rect
   * @memberof PDFNet
   */
  class Rect {
    /**
     * Create a Rect and initialize it using specified parameters.
     * @method PDFNet.Rect.init
     * @param {number} x1 The left-most position of the rect.
     * @param {number} y1 The bottom-most position of the rect.
     * @param {number} x2 The right-most position of the rect.
     * @param {number} y2 The top-most position of the rect.
     * @return {Promise<PDFNet.Rect>} A promise that resolves to a Rect (rectangle) object
     * The rect is not attached to any Cos/SDF object.
     */
    static init(x1: number, y1: number, x2: number, y2: number): Promise<PDFNet.Rect>;
    /**
     * attach the Cos/SDF object to the Rect.
     *
     * @method PDFNet.Rect#attach
     * @param {PDFNet.Obj} obj underlying Cos/SDF object. Must be an SDF::Array with four
     *  SDF::Number elements.
     */
    attach(obj: PDFNet.Obj): void;
    /**
     * Saves changes made to the Rect object in the attached (or specified) SDF/Cos rectangle.
     *
     * @method PDFNet.Rect#update
     * @param {PDFNet.Obj} [obj] an optional parameter indicating a SDF array that should be
     *  updated and attached to this Rect. If parameter rect is NULL or is omitted, update
     *  is performed on previously attached Cos/SDF rectangle.
     *
     * @return {Promise<boolean>} A promise that resolves to true if the attached Cos/SDF rectangle array was successfully updated,
     * false otherwise.
     */
    update(obj?: PDFNet.Obj): Promise<boolean>;
    /**
     * Get the coordinates of the rectangle
     * @method PDFNet.Rect#get
     */
    get(): void;
    /**
     * Set the coordinates of the rectangle
     *
     * @method PDFNet.Rect#set
     * @param {number} x1 The left-most position of the rect.
     * @param {number} y1 The bottom-most position of the rect.
     * @param {number} x2 The right-most position of the rect.
     * @param {number} y2 The top-most position of the rect.
     * The rect is not attached to any Cos/SDF object.
     */
    set(x1: number, y1: number, x2: number, y2: number): void;
    /**
     * @method PDFNet.Rect#width
     * @return {Promise<number>} A promise that resolves to rectangle's width
     */
    width(): Promise<number>;
    /**
     * @method PDFNet.Rect#height
     * @return {Promise<number>} A promise that resolves to rectangle's height
     */
    height(): Promise<number>;
    /**
     * Determines if the specified point is contained within the rectangular region
     * defined by this Rectangle
     * @method PDFNet.Rect#contains
     * @param {number} x horizontal x value of the point to check
     * @param {number} y vertical y value of the point to check
     * @return {Promise<boolean>} A promise that resolves to true is the point is in the rectangle, false otherwise.
     */
    contains(x: number, y: number): Promise<boolean>;
    /**
     * Makes a Rect equal to the intersection of two existing rectangles.
     *
     * @method PDFNet.Rect#intersectRect
     * @param {PDFNet.Rect} rect1 A Rect object that contains a source rectangle.
     * @param {PDFNet.Rect} rect2 A Rect object that contains a source rectangle.
     *
     * @return {Promise<boolean>} A promise that resolves to true if the intersection is not empty; 0 if the intersection is empty.
     *
     * @note The intersection is the largest rectangle contained in both existing rectangles.
     */
    intersectRect(rect1: PDFNet.Rect, rect2: PDFNet.Rect): Promise<boolean>;
    /**
     * Arrange the points in the rectangle so that the first point is the lower-left
     * corner and the second point is the upper-right corner of the rectangle.
     *
     * @method PDFNet.Rect#normalize
     * @note Although rectangles are conventionally specified by their lower-left
     * and upper-right corners, it is acceptable to specify any two diagonally
     * opposite corners.
     */
    normalize(): void;
    /**
     * Expands the rectangle by the specified size, in all directions.
     *
     * @method PDFNet.Rect#inflate1
     * @param {number} amount Specifies the amount to increase the rectangle in all directions.
     */
    inflate1(amount: number): void;
    /**
     * Expands the rectangle by the specified size, in all directions.
     *
     * @method PDFNet.Rect#inflate2
     * @param {number} x Specifies the amount to increase the rectangle's Left (x1) and Right (x2) properties.
     * @param {number} y Specifies the amount to increase the rectangle's Top (y1) and Bottom (y2) properties.
     */
    inflate2(x: number, y: number): void;
  }
  /**
   * A redaction annotation (PDF 1.7) identifies content that is intended to
   * be removed from the document. The intent of redaction annotations is to
   * enable the following:
   * a)Content identification. A user applies redact annotations that specify
   * the pieces or regions of content that should be removed. Up until the
   * next step is performed, the user can see, move and redefine these
   * annotations.
   * b)Content removal. The user instructs the viewer application to apply
   * the redact annotations, after which the content in the area specified
   * by the redact annotations is removed. In the removed content's place,
   * some marking appears to indicate the area has been redacted. Also, the
   * redact annotations are removed from the PDF document.
   * Redaction annotations provide a mechanism for the first step in the
   * redaction process (content identification). This allows content to be
   * marked for redaction in a non-destructive way, thus enabling a review
   * process for evaluating potential redactions prior to removing the
   * specified content.
   * Redaction annotations shall provide enough information to be used
   * in the second phase of the redaction process (content removal).
   * This phase is application-specific and requires the conforming reader
   * to remove all content identified by the redaction annotation, as well
   * as the annotation itself.
   * Conforming readers that support redaction annotations shall provide
   * a mechanism for applying content removal, and they shall remove all
   * traces of the specified content. If a portion of an image is contained
   * in a redaction region, that portion of the image data shall be destroyed;
   * clipping or image masks shall not be used to hide that data.
   * Such conforming readers shall also be diligent in their consideration
   * of all content that can exist in a PDF document, including XML Forms
   * Architecture (XFA) content and Extensible Metadata Platform (XMP)
   * content.
   * @class
   * @name Redaction
   * @memberof PDFNet
   */
  class Redaction {}
  /**
   * A redaction annotation (PDF 1.7) identifies content that is intended to
   * be removed from the document. The intent of redaction annotations is to
   * enable the following:
   * a)Content identification. A user applies redact annotations that specify
   * the pieces or regions of content that should be removed. Up until the
   * next step is performed, the user can see, move and redefine these
   * annotations.
   * b)Content removal. The user instructs the viewer application to apply
   * the redact annotations, after which the content in the area specified
   * by the redact annotations is removed. In the removed content's place,
   * some marking appears to indicate the area has been redacted. Also, the
   * redact annotations are removed from the PDF document.
   * Redaction annotations provide a mechanism for the first step in the
   * redaction process (content identification). This allows content to be
   * marked for redaction in a non-destructive way, thus enabling a review
   * process for evaluating potential redactions prior to removing the
   * specified content.
   * Redaction annotations shall provide enough information to be used
   * in the second phase of the redaction process (content removal).
   * This phase is application-specific and requires the conforming reader
   * to remove all content identified by the redaction annotation, as well
   * as the annotation itself.
   * Conforming readers that support redaction annotations shall provide
   * a mechanism for applying content removal, and they shall remove all
   * traces of the specified content. If a portion of an image is contained
   * in a redaction region, that portion of the image data shall be destroyed;
   * clipping or image masks shall not be used to hide that data.
   * Such conforming readers shall also be diligent in their consideration
   * of all content that can exist in a PDF document, including XML Forms
   * Architecture (XFA) content and Extensible Metadata Platform (XMP)
   * content.
   * @class
   * @name RedactionAnnot
   * @memberof PDFNet
   */
  class RedactionAnnot {
    /**
     * creates a Redaction annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.RedactionAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.RedactionAnnot>} A promise that resolves to an object of type: "RedactionAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.RedactionAnnot>;
    /**
     * creates an Redaction annotation and initializes it using given annotation object.
     * @method PDFNet.RedactionAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Redaction annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.RedactionAnnot>} A promise that resolves to an object of type: "RedactionAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.RedactionAnnot>;
    /**
     * Creates a new Redaction annotation in the specified document.
     *
     * @method PDFNet.RedactionAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the annotation's bounds, in user space coordinates.
     *
     * @return {Promise<PDFNet.RedactionAnnot>} A promise that resolves to a newly created blank Circle annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.RedactionAnnot>;
    /**
     * Returns the number of QuadPoints in the QuadPoints array of the Redaction annotation.
     *
     * @method PDFNet.RedactionAnnot#getQuadPointCount
     * @return {Promise<number>} A promise that resolves to the number of QuadPoints.
     * @note An array of n QuadPoints that denote
     * the content region that is intended to be removed. If quad points are not present,
     * the Rect entry denotes the content region that is intended to be removed.
     */
    getQuadPointCount(): Promise<number>;
    /**
     * Returns the QuadPoint located at a certain index of the QuadPoint array of the Redaction
     * annotation.
     *
     * @method PDFNet.RedactionAnnot#getQuadPoint
     * @param {number} idx The index of the QuadPoint, starts at zero and must be less than return value of GetQuadPointCount().
     * @return {Promise<PDFNet.QuadPoint>} A promise that resolves to the QuadPoint located at a certain index of the QuadPoint array of the Redaction annotation.
     * @note An array of n QuadPoints that denote
     * the content region that is intended to be removed. If quad points are not present,
     * the Rect entry denotes the content region that is intended to be removed.
     */
    getQuadPoint(idx: number): Promise<PDFNet.QuadPoint>;
    /**
     * Set the QuadPoint to be located at a certain index of the QuadPoint array of the Redaction
     * annotation.
     * (Optional; PDF 1.6 )
     *
     * @method PDFNet.RedactionAnnot#setQuadPoint
     * @param {number} idx The index position where the QuadPoint of interest is to be inserted, starting at 0.
     * @param {PDFNet.QuadPoint} qp  The QuadPoint to be inserted at that position.
     * @note  For orientation purposes, the bottom of a quadrilateral is the line formed by p1 and p2 of the QuadPoint.
     * QuadPoints shall be ignored if any coordinate in the array lies outside the region specified by Rect.
     */
    setQuadPoint(idx: number, qp: PDFNet.QuadPoint): void;
    /**
     * sets Overlay appearance of the Redaction annotation.
     * (Optional)
     *
     * @method PDFNet.RedactionAnnot#setAppFormXO
     * @param {PDFNet.Obj} formxo An SDF object that represents the overlay appearance of the Redaction annotation.
     * @note This object is a form XObject specifying the overlay appearance for this
     * redaction annotation. After this redaction is applied and the affected content has been removed,
     * the overlay appearance should be drawn such that its origin lines up with the lower-left corner
     * of the annotation rectangle. This form XObject is not necessarily related to other annotation
     * appearances, and may or may not be present in the Appearance dictionary. This entry takes precedence over the Interior Color(IC),
     * OverlayText, OverlayTextAppearance(DA), and QuadPoint(Q) entries.
     */
    setAppFormXO(formxo: PDFNet.Obj): void;
    /**
     * Returns Overlay text of the Redaction annotation.
     *
     * @method PDFNet.RedactionAnnot#getOverlayText
     * @return {Promise<string>} A promise that resolves to a string containing the overlay text of the annotation.
     * @note The OverlayText string is a text string specifying the
     * overlay text that should be drawn over the redacted region
     * after the affected content has been removed.
     * This entry is ignored if the Overlay appearance(RO) entry is present.
     */
    getOverlayText(): Promise<string>;
    /**
     * sets Overlay text of the Redaction annotation.
     *
     * @method PDFNet.RedactionAnnot#setOverlayText
     * @param {string} title A string containing the overlay text of the annotation.
     * @note The OverlayText string is a text string specifying the
     * overlay text that should be drawn over the redacted region
     * after the affected content has been removed.
     * This entry is ignored if the Overlay appearance stream (RO) entry is present.
     */
    setOverlayText(title: string): void;
    /**
     * Returns the option of whether to use repeat for the Redaction annotation.
     *
     * @method PDFNet.RedactionAnnot#getUseRepeat
     * @return {Promise<boolean>} A promise that resolves to a bool indicating whether to repeat for the Redaction annotation.
     * @note If userepeat value is true, then the text specified by OverlayText
     * should be repeated to fill the redacted region after the affected content
     * has been removed. This entry is ignored if the Overlay appearance stream
     * (RO) entry is present.
     * Default value: false.
     */
    getUseRepeat(): Promise<boolean>;
    /**
     * sets the option of whether to use repeat for the Redaction annotation.
     *
     * @method PDFNet.RedactionAnnot#setUseRepeat
     * @param {boolean} [userepeat] A bool indicating whether to repeat for the Redaction annotation.
     * @note If userepeat value is true, then the text specified by OverlayText
     * should be repeated to fill the redacted region after the affected content
     * has been removed. This entry is ignored if the Overlay appearance stream
     * (RO) entry is present.
     * @default userepeat = false.
     */
    setUseRepeat(userepeat?: boolean): void;
    /**
     * Returns Overlay text appearance of the Redaction annotation.
     *
     * @method PDFNet.RedactionAnnot#getOverlayTextAppearance
     * @return {Promise<string>} A promise that resolves to a string containing the overlay text appearance of the annotation.
     * @note The overlay text appearance is the appearance string to be used
     * in formatting the overlay text when it is drawn after the affected content
     * has been removed. This entry is ignored if the Overlay appearance stream
     * (RO) entry is present.
     */
    getOverlayTextAppearance(): Promise<string>;
    /**
     * sets Overlay text appearance of the Redaction annotation.
     *
     * @method PDFNet.RedactionAnnot#setOverlayTextAppearance
     * @param {string} app A string containing the overlay text appearance of the annotation.
     * @note The overlay text appearance is the appearance string to be used
     * in formatting the overlay text when it is drawn after the affected content
     * has been removed. This entry is ignored if the Overlay appearance stream
     * (RO) entry is present.
     */
    setOverlayTextAppearance(app: string): void;
    /**
     * Returns Overlay text quadding(justification) format of the Redaction annotation.
     *
     * @method PDFNet.RedactionAnnot#getQuadForm
     * @return {Promise<number>} A promise that resolves to a value of the "QuadForm" enum type, indicating the
     * overlay text quadding(justification) format of the Redaction annotation's overlay text.
     * @example Return value enum:
     * <pre>
     * PDFNet.RedactionAnnot.QuadForm = {
     * 	e_LeftJustified : 0
     * 	e_Centered : 1
     * 	e_RightJustified : 2
     * 	e_None : 3
     * }
     * </pre>
     */
    getQuadForm(): Promise<number>;
    /**
     * sets Overlay text quadding (justification) format of the Redaction annotation.
     *
     * @method PDFNet.RedactionAnnot#setQuadForm
     * @param {number} [form]
     * <pre>
     * PDFNet.RedactionAnnot.QuadForm = {
     * 	e_LeftJustified : 0
     * 	e_Centered : 1
     * 	e_RightJustified : 2
     * 	e_None : 3
     * }
     * </pre>
     * A value of the "QuadForm" enum type, indicating the
     * overlay text quadding(justification) format of the Redaction annotation.
     * @note Quadding format specifies the form of justification to be
     * used in displaying the overlay text.
     * @default form=e_LeftJustified
     */
    setQuadForm(form?: number): void;
    /**
     * Returns Overlay appearance of the Redaction annotation.
     *
     * @method PDFNet.RedactionAnnot#getAppFormXO
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an SDF object that represents the overlay appearance of the Redaction annotation.
     * @note This object is a form XObject specifying the overlay appearance for this
     * redaction annotation. After this redaction is applied and the affected content has been removed,
     * the overlay appearance should be drawn such that its origin lines up with the lower-left corner
     * of the annotation rectangle. This form XObject is not necessarily related to other annotation
     * appearances, and may or may not be present in the Appearance dictionary. This entry takes precedence over the Interior Color(IC),
     * OverlayText, OverlayTextAppearance(DA), and QuadPoint(Q) entries.
     */
    getAppFormXO(): Promise<PDFNet.Obj>;
  }
  /**
   * [Not Yet Documented]
   * @class
   * @name RedactionAppearance
   * @memberof PDFNet
   */
  class RedactionAppearance {
    /**
     * Destructor
     * @method PDFNet.RedactionAppearance#destroy
     */
    destroy(): void;
  }
  /**
   * PDF Redactor is a separately licensable Add-on that offers options to remove
   * (not just covering or obscuring) content within a region of PDF.
   * With printed pages, redaction involves blacking-out or cutting-out areas of
   * the printed page. With electronic documents that use formats such as PDF,
   * redaction typically involves removing sensitive content within documents for
   * safe distribution to courts, patent and government institutions, the media,
   * customers, vendors or any other audience with restricted access to the content.
   *
   * The redaction process in PDFNet consists of two steps:
   *
   *  a) Content identification: A user applies redact annotations that specify the
   * pieces or regions of content that should be removed. The content for redaction
   * can be identified either interactively (e.g. using 'pdftron.PDF.PDFViewCtrl'
   * as shown in PDFView sample) or programmatically (e.g. using 'pdftron.PDF.TextSearch'
   * or 'pdftron.PDF.TextExtractor'). Up until the next step is performed, the user
   * can see, move and redefine these annotations.
   *  b) Content removal: Using 'pdftron.PDF.Redactor.Redact()' the user instructs
   * PDFNet to apply the redact regions, after which the content in the area specified
   * by the redact annotations is removed. The redaction function includes number of
   * options to control the style of the redaction overlay (including color, text,
   * font, border, transparency, etc.).
   *
   * PDFTron Redactor makes sure that if a portion of an image, text, or vector graphics
   * is contained in a redaction region, that portion of the image or path data is
   * destroyed and is not simply hidden with clipping or image masks. PDFNet API can also
   * be used to review and remove metadata and other content that can exist in a PDF
   * document, including XML Forms Architecture (XFA) content and Extensible Metadata
   * Platform (XMP) content.
   * @class
   * @name Redactor
   * @memberof PDFNet
   */
  class Redactor {
    /**
     * Constructor
     * @method PDFNet.Redactor.redactionCreate
     * @param {number} page_num
     * @param {PDFNet.Rect} bbox
     * @param {boolean} negative
     * @param {string} text
     * @return {Promise<PDFNet.Redaction>} A promise that resolves to an object of type: "Redaction"
     */
    static redactionCreate(
      page_num: number,
      bbox: PDFNet.Rect,
      negative: boolean,
      text: string,
    ): Promise<PDFNet.Redaction>;
    /**
     * Destructor
     * @method PDFNet.Redactor.redactionDestroy
     * @param {PDFNet.Redaction} redaction
     */
    static redactionDestroy(redaction: PDFNet.Redaction): void;
    /**
     * Copy Constructor
     * @method PDFNet.Redactor.redactionCopy
     * @param {PDFNet.Redaction} other
     * @return {Promise<PDFNet.Redaction>} A promise that resolves to an object of type: "Redaction"
     */
    static redactionCopy(other: PDFNet.Redaction): Promise<PDFNet.Redaction>;
    /**
     * Apply the redactions specified in the array red_arr to the PDFDoc doc.
     *
     * @method PDFNet.Redactor.redact
     * @param {PDFNet.PDFDoc} doc the document to redact
     * @param {PDFNet.Redactor[]} red_arr an array of redaction objects specifying the regions to redact.
     * @param {PDFNet.RedactionAppearance} [appearance] optional parameter used to customize the appearance of the redaction overlay.
     * To create an appearance object, create an empty javascript object {} and add entries
     * containing values to it. The following entries are handled by redact:
     *
     * <pre>
     * app.redaction_overlay = boolean
     * If redaction_overlay is set to true, redactor will draw an overlay
     * covering all redacted regions. The rest of properties in the
     * appearance object defines visual properties of the overlay.
     * If false the overlay region will not be drawn.
     * Defaults to true.
     *
     * app.positive_overlay_color = ColorPt object
     * positive_overlay_color defines the overlay background color in RGB color space for positive redactions.
     * Defaults to white (PDFNet.ColorPt(1, 1, 1, 0));
     *
     * app.negative_overlay_color = ColorPt object
     * negative_overlay_color defines the overlay background color in RGB color space for negative redactions.
     * Defaults to white (PDFNet.ColorPt(1, 1, 1, 0));
     *
     * app.border = boolean
     * border specifies if the overlay will be surrounded by a border.
     * Defaults to true.
     *
     * app.font = Font object
     * font specifies the font used to represent the text in the overlay.
     * Defaults to true.
     *
     * app.min_font_size = int
     * min_font_size specifies the minimum font size used to represent the text in the overlay
     * Defaults to 2.
     *
     * app.max_font_size = int
     * max_font_size specifies the maximum font size used to represent the text in the overlay
     * Defaults to 24.
     *
     * app.text_color = ColorPt object
     * text_color specifies the color used to paint the text in the overlay (in RGB).
     * Defaults to dark green (PDFNet.ColorPt(0, 0.5, 0, 0));
     *
     * app.horiz_text_alignment = int
     * horiz_text_alignment specifies the horizontal text alignment in the overlay:
     *	align<0	 -> text will be left aligned.
     *	align==0 -> text will be center aligned.
     *	align>0	 -> text will be right aligned.
     * Defaults to -1.
     *
     * app.vert_text_alignment = int
     * vert_text_alignment specifies the vertical text alignment in the overlay:
     *	align<0	 -> text will be top aligned.
     *	align==0 -> text will be center aligned.
     *	align>0	 -> text will be bottom aligned.
     * Defaults to 1.
     *
     * app.show_redacted_content_regions = boolean
     * show_redacted_content_regions specifies whether an overlay should be drawn in place of
     * the redacted content. This option can be used to indicate the areas where the content
     * was removed from without revealing the content itself. Defaults to false. Uses
     * RedactedContentColor as a fill color.
     * Defaults to false.
     *
     * app.redacted_content_color = ColorPt object
     * Specifies the color used to paint the regions where content was removed.
     * Only useful when ShowRedactedContentRegions == true.
     * Defaults to gray (PDFNet.ColorPt(0.3, 0.3, 0.3, 0)).
     * </pre>
     * @param {boolean} [ext_neg_mode=true] if true, negative redactions expand beyond the page to remove
     * content from other pages in the document. if false, the redaction will be localized
     * to the given page.
     * @param {boolean} [page_coord_sys=true] if true, redaction coordinates are relative to the lower-left corner of the page,
     * otherwise the redaction coordinates are defined in PDF user coordinate system (which may or may not coincide with
     * page coordinates).
     */
    static redact(
      doc: PDFNet.PDFDoc,
      red_arr: PDFNet.Redactor[],
      appearance?: PDFNet.RedactionAppearance,
      ext_neg_mode?: boolean,
      page_coord_sys?: boolean,
    ): void;
  }
  /**
   * The class ResultSnapshot.
   * Represents a transition between two document states.
   * @class
   * @name ResultSnapshot
   * @memberof PDFNet
   */
  class ResultSnapshot {
    /**
     * Retrieves the document state to which this transition has transitioned.
     *
     * @method PDFNet.ResultSnapshot#currentState
     * @return {Promise<PDFNet.DocSnapshot>} A promise that resolves to the current document state.
     */
    currentState(): Promise<PDFNet.DocSnapshot>;
    /**
     * Retrieves the document state from which this transition has transitioned.
     *
     * @method PDFNet.ResultSnapshot#previousState
     * @return {Promise<PDFNet.DocSnapshot>} A promise that resolves to the previous document state.
     */
    previousState(): Promise<PDFNet.DocSnapshot>;
    /**
     * Returns whether this transition is valid or a null transition.
     *
     * @method PDFNet.ResultSnapshot#isOk
     * @return {Promise<boolean>} A promise that resolves to whether this transition is valid or a null transition.
     */
    isOk(): Promise<boolean>;
    /**
     * Returns whether this transition is a null transition.
     *
     * @method PDFNet.ResultSnapshot#isNullTransition
     * @return {Promise<boolean>} A promise that resolves to whether this transition is a null transition.
     */
    isNullTransition(): Promise<boolean>;
    /**
     * Destructor
     * @method PDFNet.ResultSnapshot#destroy
     */
    destroy(): void;
  }
  /**
   * RoleMap is a dictionary that maps the names of structure types used in the
   * document to their approximate equivalents in the set of standard structure
   * types.
   * @class
   * @name RoleMap
   * @memberof PDFNet
   */
  class RoleMap {
    /**
     * Initialize a RoleMap using an existing low-level Cos/SDF role map dictionary.
     *
     * @method PDFNet.RoleMap.create
     * @param {PDFNet.Obj} dict a low-level (SDF/Cos) RoleMap dictionary.
     *
     * @note This constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.RoleMap>} A promise that resolves to an object of type: "RoleMap"
     */
    static create(dict: PDFNet.Obj): Promise<PDFNet.RoleMap>;
    /**
     * Copy Constructor
     * @method PDFNet.RoleMap#copy
     * @return {Promise<PDFNet.RoleMap>} A promise that resolves to an object of type: "RoleMap"
     */
    copy(): Promise<PDFNet.RoleMap>;
    /**
     * @method PDFNet.RoleMap#isValid
     * @return {Promise<boolean>} A promise that resolves to true if this is a valid (non-null) RoleMap, false otherwise.
     * If the function returns false the underlying SDF/Cos object is null or is
     * not valid and the RoleMap should be treated as NULL object.
     */
    isValid(): Promise<boolean>;
    /**
     * @method PDFNet.RoleMap#getDirectMap
     * @return {Promise<string>} A promise that resolves to the direct mapping of given StructElement type, or NULL
     * if such mapping is not defined.
     *
     * @param {string} type element type
     */
    getDirectMap(type: string): Promise<string>;
    /**
     * Returns the RoleMap dictionary.
     * @method PDFNet.RoleMap#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the object to the underlying SDF/Cos dictionary.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
  }
  /**
   * A RubberStamp annotation displays text or graphics intended
   * to look as if they were stamped on the page with a rubber stamp.
   * @class
   * @name RubberStampAnnot
   * @memberof PDFNet
   */
  class RubberStampAnnot {
    /**
     * creates a RubberStamp annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.RubberStampAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.RubberStampAnnot>} A promise that resolves to an object of type: "RubberStampAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.RubberStampAnnot>;
    /**
     * creates a RubberStamp annotation and initializes it using given annotation object.
     * @method PDFNet.RubberStampAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the RubberStamp annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.RubberStampAnnot>} A promise that resolves to an object of type: "RubberStampAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.RubberStampAnnot>;
    /**
     * Constructor
     * @method PDFNet.RubberStampAnnot.create
     * @param {PDFNet.SDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @return {Promise<PDFNet.RubberStampAnnot>} A promise that resolves to an object of type: "RubberStampAnnot"
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.RubberStampAnnot>;
    /**
     * Returns the type of the icon associated with the RubberStamp annotation.
     *
     * @method PDFNet.RubberStampAnnot#getIcon
     * @return {Promise<number>} A promise that resolves to a value of enum "Icon" that represents
     * the type of icon associated with the annotation.
     * Default value: e_Draft.
     * @example Return value enum:
     * <pre>
     * PDFNet.RubberStampAnnot.Icon = {
     * 	e_Approved : 0
     * 	e_Experimental : 1
     * 	e_NotApproved : 2
     * 	e_AsIs : 3
     * 	e_Expired : 4
     * 	e_NotForPublicRelease : 5
     * 	e_Confidential : 6
     * 	e_Final : 7
     * 	e_Sold : 8
     * 	e_Departmental : 9
     * 	e_ForComment : 10
     * 	e_TopSecret : 11
     * 	e_ForPublicRelease : 12
     * 	e_Draft : 13
     * 	e_Unknown : 14
     * }
     * </pre>
     */
    getIcon(): Promise<number>;
    /**
     * sets the type of the icon associated with the RubberStamp annotation.
     *
     * @method PDFNet.RubberStampAnnot#setIcon
     * @param {number} [type]
     * <pre>
     * PDFNet.RubberStampAnnot.Icon = {
     * 	e_Approved : 0
     * 	e_Experimental : 1
     * 	e_NotApproved : 2
     * 	e_AsIs : 3
     * 	e_Expired : 4
     * 	e_NotForPublicRelease : 5
     * 	e_Confidential : 6
     * 	e_Final : 7
     * 	e_Sold : 8
     * 	e_Departmental : 9
     * 	e_ForComment : 10
     * 	e_TopSecret : 11
     * 	e_ForPublicRelease : 12
     * 	e_Draft : 13
     * 	e_Unknown : 14
     * }
     * </pre>
     * A value of enum "Icon" type that represents
     * the type of icon associated with the annotation.
     * Default value: e_Draft.
     */
    setIcon(type?: number): void;
    /**
     *
     * @method PDFNet.RubberStampAnnot#setIconDefault
     */
    setIconDefault(): void;
    /**
     * Returns the name of the icon associated with the RubberStamp annotation.
     *
     * @method PDFNet.RubberStampAnnot#getIconName
     * @return {Promise<string>} A promise that resolves to a string that is the name of the icon associated with
     * the RubberStamp annotation.
     * @note The following icon names are equivalent
     * to predefined icon types from the enum "Icon":
     * "Approved" = e_Approved
     * "Experimental" = e_Experimental
     * "NotApproved" = e_NotApproved
     * "AsIs" = e_AsIs
     * "Expired" = e_Expired
     * "NotForPublicRelease" = e_NotForPublicRelease
     * "Confidential" = e_Confidential
     * "Final" = e_Final
     * "Sold" = e_Sold
     * "Departmental" = e_Departmental
     * "Format" = e_ForComment
     * "TopSecret" = e_TopSecret
     * "ForPublicRelease" = e_ForPublicRelease
     * "Draft" = e_Draft
     * "Unknown" = e_Unknown
     * Names other than mentioned above do not have predefined icon appearances.
     */
    getIconName(): Promise<string>;
    /**
     * sets the name of the icon associated with the RubberStamp annotation.
     *
     * @method PDFNet.RubberStampAnnot#setIconName
     * @param {string} iconstring the name of the icon associated with
     * the RubberStamp annotation.
     * @note The following icon names are equivalent
     * to predefined icon types from the enum "Icon":
     * "Approved" = e_Approved
     * "Experimental" = e_Experimental
     * "NotApproved" = e_NotApproved
     * "AsIs" = e_AsIs
     * "Expired" = e_Expired
     * "NotForPublicRelease" = e_NotForPublicRelease
     * "Confidential" = e_Confidential
     * "Final" = e_Final
     * "Sold" = e_Sold
     * "Departmental" = e_Departmental
     * "Format" = e_ForComment
     * "TopSecret" = e_TopSecret
     * "ForPublicRelease" = e_ForPublicRelease
     * "Draft" = e_Draft
     * "Unknown" = e_Unknown
     * Names other than mentioned above do not have predefined icon appearances.
     */
    setIconName(iconstring: string): void;
  }
  /**
   * SDFDoc is a low-level document representing a graph of SDF::Obj nodes that
   * can be used to build higher-level document models such as PDF (Portable Document
   * Format) or FDF (Forms Document Format).
   *
   * SDFDoc brings together document security, document utility methods, and all SDF
   * objects.
   *
   * A SDF document can be created from scratch using a default constructor:
   *
   * SDFDoc mydoc;
   * Obj trailer = mydoc.GetTrailer();
   *
   * SDF document can be also created from an existing file (e.g. an external PDF document):
   * <pre>
   * SDFDoc mydoc("in.pdf");
   * Obj trailer = mydoc.GetTrailer();
   * </pre>
   * or from a memory buffer or some other Filter/Stream such as a HTTP Filter connection:
   *
   * <pre>
   * MemoryFilter memory = ....
   * SDFDoc mydoc(memory);
   * Obj trailer = mydoc.GetTrailer();
   * </pre>
   *
   * Finally SDF document can be accessed from a high-level PDF document as follows:
   *
   * <pre>
   * PDFDoc doc("in.pdf");
   * SDFDoc& mydoc = doc.GetSDFDoc();
   * Obj trailer = mydoc.GetTrailer();
   * </pre>
   *
   * Note that the examples above used doc.GetTrailer() in order to access document
   * trailer, the starting SDF object (root node) in every document. Following the trailer
   * links, it is possible to visit all low-level objects in a document (e.g. all pages,
   * outlines, fonts, etc).
   *
   * SDFDoc also provides utility methods used to import objects and object collections
   * from one document to another. These methods can be useful for copy operations between
   * documents such as a high-level page merge and document assembly.
   * @class
   * @name SDFDoc
   * @memberof PDFNet
   */
  class SDFDoc {
    /**
     * Copy Constructor
     * @method PDFNet.SDFDoc#createShallowCopy
     * @return {Promise<PDFNet.SDFDoc>} A promise that resolves to an object of type: "SDFDoc"
     */
    createShallowCopy(): Promise<PDFNet.SDFDoc>;
    /**
     *
     * @method PDFNet.SDFDoc#releaseFileHandles
     */
    releaseFileHandles(): void;
    /**
     * @method PDFNet.SDFDoc#isEncrypted
     * @return {Promise<boolean>} A promise that resolves to true if the document is/was originally encrypted false otherwise.
     */
    isEncrypted(): Promise<boolean>;
    /**
     * Initializes document's SecurityHandler using the supplied
     * password. This version of InitSecurityHandler() assumes that
     * document uses Standard security and that a password is specified
     * directly.
     *
     * This function should be called immediately after an encrypted
     * document is opened. The function does not have any side effects on
     * documents that are not encrypted.
     *
     * If the security handler was successfully initialized, it can be later
     * obtained using GetSecurityHandler() method.
     *
     * @method PDFNet.SDFDoc#initStdSecurityHandler
     * @return {Promise<boolean>} A promise that resolves to true if the given password successfully unlocked the document,
     * false otherwise.
     *
     * @param {string} password Specifies the password used to open the document without
     * any user feedback. If you would like to dynamically obtain the password,
     * you need to derive a custom class from StdSecurityHandler() and use
     * InitSecurityHandler() without any parameters. See EncTest sample
     * for example code.
     *
     * @param {number} password_sz An optional parameter used to specify the size of
     * the password buffer, in bytes. If the 'password_sz' is 0, or if the parameter
     * is not specified, the function assumes that the string is null terminated.
     *
     * @remark Deprecated. Use versions that accepts UString or buffer instead.
     */
    initStdSecurityHandler(password: string, password_sz: number): Promise<boolean>;
    /**
     * Initializes document's SecurityHandler using the supplied
     * password. This version of InitSecurityHandler() assumes that
     * document uses Standard security and that a password is specified
     * directly.
     *
     * This function should be called immediately after an encrypted
     * document is opened. The function does not have any side effects on
     * documents that are not encrypted.
     *
     * If the security handler was successfully initialized, it can be later
     * obtained using GetSecurityHandler() method.
     *
     * @method PDFNet.SDFDoc#initStdSecurityHandlerUString
     * @param {string} password Specifies the password used to open the document without
     * any user feedback. If you would like to dynamically obtain the password,
     * you need to derive a custom class from StdSecurityHandler() and use
     * InitSecurityHandler() without any parameters. See EncTest sample
     * for example code.
     *
     * @return {Promise<boolean>} A promise that resolves to true if the given password successfully unlocked the document,
     * false otherwise.
     */
    initStdSecurityHandlerUString(password: string): Promise<boolean>;
    /**
     * @method PDFNet.SDFDoc#isModified
     * @return {Promise<boolean>} A promise that resolves to true if document was modified, false otherwise
     */
    isModified(): Promise<boolean>;
    /**
     * Checks whether or not the underlying file has an XRef table that had to be repaired
     * when the file was opened. If the document had an invalid XRef table when opened,
     * PDFNet will have repaired the XRef table for its working representation of the document.
     *
     * @method PDFNet.SDFDoc#hasRepairedXRef
     * @return {Promise<boolean>} A promise that resolves to true if document was found to be corrupted, and was repaired, during
     * opening and has not been saved since.
     *
     * @note If this function returns true, it is not possible to incrementally save the document
     * (see http://www.pdftron.com/kb_corrupt_xref)
     */
    hasRepairedXRef(): Promise<boolean>;
    /**
     * @method PDFNet.SDFDoc#isFullSaveRequired
     * @return {Promise<boolean>} A promise that resolves to true if the document requires full save.
     */
    isFullSaveRequired(): Promise<boolean>;
    /**
     * @method PDFNet.SDFDoc#getTrailer
     * @return {Promise<PDFNet.Obj>} A promise that resolves to A dictionary representing the root of the document (i.e.
     * a document trailer dictionary)
     */
    getTrailer(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.SDFDoc#getObj
     * @param {number} obj_num object number of the object to retrieve.
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the latest version of the object matching specified object number.
     */
    getObj(obj_num: number): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.SDFDoc#importObj
     * @param {PDFNet.Obj} obj an object to import.
     * @param {boolean} deep_copy a boolean indicating whether to perform a deep or shallow copy.
     * In case of shallow copy all indirect references will be set to null.
     *
     * If the object belongs to a document the function will perform deep or shallow
     * clone depending whether deep_copy flag was specified.
     *
     * If the object does not belong to any document ImportObj does not take the
     * object ownership. ImportObj copies the source object and it is users
     * responsibility to delete free objects.
     *
     * @return {Promise<PDFNet.Obj>} A promise that resolves to a pointer to the root indirect object in this document
     */
    importObj(obj: PDFNet.Obj, deep_copy: boolean): Promise<PDFNet.Obj>;
    /**
     *
     * @method PDFNet.SDFDoc#importObjsWithExcludeList
     * @param {PDFNet.Obj} obj_list
     * @param {number} length
     * @param {PDFNet.Obj} exclude_list
     * @param {number} exclude_length
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    importObjsWithExcludeList(
      obj_list: PDFNet.Obj,
      length: number,
      exclude_list: PDFNet.Obj,
      exclude_length: number,
    ): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.SDFDoc#xRefSize
     * @return {Promise<number>} A promise that resolves to The size of cross reference table
     */
    xRefSize(): Promise<number>;
    /**
     * Removes 'marked' flag from all objects in cross reference table.
     * @method PDFNet.SDFDoc#clearMarks
     */
    clearMarks(): void;
    /**
     * Saves the document to a stream.
     *
     * @method PDFNet.SDFDoc#saveStream
     * @param {PDFNet.Filter} stream The output stream where to write data.
     * @param {number} flags A bit field composed of an OR of the SDFDoc::SaveOptions values.
     * @param {string} header Fileheader header. A new file header is set only during full save. See also GetHeader()
     *
     * @note Save will modify the SDFDoc object's internal representation.  As such,
     *			  the user should acquire a write lock before calling save.
     */
    saveStream(stream: PDFNet.Filter, flags: number, header: string): void;
    /**
     * @method PDFNet.SDFDoc#getHeader
     * @return {Promise<string>} A promise that resolves to the header string identifying the document version to which the file conforms.
     * For a file conforming to PDF version 1.4, the header should be %PDF-1.4.
     * In general header strings have the following syntax: %AAA-N.n where AAA identifies
     * document specification (such as PDF, FDF, PJTF etc), N is the major version and
     * n is the minor version. The new header string can be set during a full save (see SDFDoc::Save()).
     * For a document that is not serialized the function returns an empty string.
     */
    getHeader(): Promise<string>;
    /**
     * @method PDFNet.SDFDoc#getSecurityHandler
     * @return {Promise<PDFNet.SecurityHandler>} A promise that resolves to currently selected SecurityHandler.
     *
     * @note InitSecurityHandler() should be called before GetSecurityHandler()
     * in order to initialize the handler.
     *
     * @note Returned security handler can be modified in order to change the
     * security settings of the existing document. Changes to the current handler
     * will not invalidate the access to the original file and will take effect
     * during document Save().
     *
     * @note If the security handler is modified, document will perform a full save
     * even if e_incremental was given as a flag in Save() method.
     */
    getSecurityHandler(): Promise<PDFNet.SecurityHandler>;
    /**
     *
     * @method PDFNet.SDFDoc#setSecurityHandler
     * @param {PDFNet.SecurityHandler} handler
     */
    setSecurityHandler(handler: PDFNet.SecurityHandler): void;
    /**
     * This function removes document security.
     * @method PDFNet.SDFDoc#removeSecurity
     */
    removeSecurity(): void;
    /**
     * Sometimes it is desirable to modify all indirect references to a given
     * indirect object. It would be inefficient to manually search for all
     * indirect references to a given indirect object.
     *
     * A more efficient and less error prone method is to replace the indirect
     * object in the cross reference table with a new object. This way the object
     * that is referred to is modified (or replaced) and indirect references do
     * not have to be changed.
     *
     * @method PDFNet.SDFDoc#swap
     * @param {number} obj_num1 object number of first object to be swapped.
     * @param {number} obj_num2 object number of second object to be swapped.
     */
    swap(obj_num1: number, obj_num2: number): void;
    /**
     * Call this function to determine whether the document is represented in
     * linearized (fast web view) format.
     *
     * @method PDFNet.SDFDoc#isLinearized
     * @return {Promise<boolean>} A promise that resolves to true if document is stored in fast web view format, false otherwise.
     *
     * @note any changes to the document can invalidate linearization. The function will
     * return 'true' only if the original document is linearized and if it is not
     * modified.
     *
     * In order to provide good performance over relatively slow communication links,
     * PDFNet can generate PDF documents with linearized objects and hint tables that
     * can allow a PDF viewer application to download and view one page of a PDF file
     * at a time, rather than requiring the entire file (including fonts and images) to
     * be downloaded before any of it can be viewed.
     *
     * To save a document in linearized (fast web view) format you only need to pass
     * 'SDFDoc.SaveOptions.e_linearized' flag in the Save method.
     */
    isLinearized(): Promise<boolean>;
    /**
     * Returns document's initial linearization dictionary if it is available.
     *
     * @method PDFNet.SDFDoc#getLinearizationDict
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the linearization dictionary of the original document or NULL
     * if the dictionary is not available.
     */
    getLinearizationDict(): Promise<PDFNet.Obj>;
    /**
     * Returns document's initial linearization hint stream if it is available.
     *
     * @method PDFNet.SDFDoc#getHintStream
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the linearization hint stream of the original document or NULL
     * if the hint stream is not available.
     */
    getHintStream(): Promise<PDFNet.Obj>;
    /**
     * A document uses a temporary file which is used to cache the contents
     * of any new stream object created in the document (that is the default behavior).
     * @method PDFNet.SDFDoc#enableDiskCaching
     * @param {boolean} use_cache_flag true to enable caching, false to disable caching.
     * Use this function to enable or disable this feature dynamically.
     */
    enableDiskCaching(use_cache_flag: boolean): void;
    /**
     * Locks the document to prevent competing threads from accessing the document
     * at the same time. Threads attempting to access the document will wait in
     * suspended state until the thread that owns the lock calls doc.Unlock().
     * @method PDFNet.SDFDoc#lock
     */
    lock(): void;
    /**
     * Removes the lock from the document.
     * @method PDFNet.SDFDoc#unlock
     */
    unlock(): void;
    /**
     * Locks the document to prevent competing write threads (using Lock()) from accessing the document
     * at the same time. Other reader threads however, will be allowed to access the document.
     * Threads attempting to obtain write access to the document will wait in
     * suspended state until the thread that owns the lock calls doc.UnlockRead().
     * Note: To avoid deadlocks obtaining a write lock while holding
     * a read lock is not permitted and will throw an exception. If this situation is encountered
     * please either unlock the read lock before the write lock is obtained
     * or acquire a write lock (rather than read lock) in the first place.
     * @method PDFNet.SDFDoc#lockRead
     */
    lockRead(): void;
    /**
     * Removes the lock from the document.
     * @method PDFNet.SDFDoc#unlockRead
     */
    unlockRead(): void;
    /**
     * Try locking the document.
     * @method PDFNet.SDFDoc#tryLock
     * @return {Promise<boolean>} A promise that resolves to true if the document is locked for multi-threaded access, false otherwise.
     */
    tryLock(): Promise<boolean>;
    /**
     * Tries to obtain a read lock the document and returns true if the lock was
     * successfully acquired
     * @method PDFNet.SDFDoc#tryLockRead
     * @return {Promise<boolean>} A promise that resolves to true if the document is locked for multi-threaded access, false otherwise.
     */
    tryLockRead(): Promise<boolean>;
    /**
     * @method PDFNet.SDFDoc#getFileName
     * @return {Promise<string>} A promise that resolves to the filename of the document if the document is loaded from disk,
     * or empty string if the document is not yet saved or is loaded from a memory
     * buffer.
     */
    getFileName(): Promise<string>;
    /**
     * Used to create SDF/Cos indirect object.
     *
     * Unlike direct objects, indirect objects can be referenced by more than one
     * object (i.e. indirect objects they can be shared).
     *
     * @method PDFNet.SDFDoc#createIndirectName
     * @param {string} name indirect const char* object to create.
     * @note In C++ doc.CreateIndirect???(...) is equivalent to ???::CreateIndirect(...).
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createIndirectName(name: string): Promise<PDFNet.Obj>;
    /**
     * Used to create SDF/Cos indirect object.
     *
     * Unlike direct objects, indirect objects can be referenced by more than one
     * object (i.e. indirect objects they can be shared).
     *
     * @method PDFNet.SDFDoc#createIndirectArray
     * @note In C++ doc.CreateIndirect???(...) is equivalent to ???::CreateIndirect(...).
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createIndirectArray(): Promise<PDFNet.Obj>;
    /**
     * Used to create SDF/Cos indirect object.
     *
     * Unlike direct objects, indirect objects can be referenced by more than one
     * object (i.e. indirect objects they can be shared).
     *
     * @method PDFNet.SDFDoc#createIndirectBool
     * @param {boolean} value indirect boolean to create.
     * @note In C++ doc.CreateIndirect???(...) is equivalent to ???::CreateIndirect(...).
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createIndirectBool(value: boolean): Promise<PDFNet.Obj>;
    /**
     *
     * @method PDFNet.SDFDoc#createIndirectDict
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createIndirectDict(): Promise<PDFNet.Obj>;
    /**
     *
     * @method PDFNet.SDFDoc#createIndirectNull
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createIndirectNull(): Promise<PDFNet.Obj>;
    /**
     * Used to create SDF/Cos indirect object.
     *
     * Unlike direct objects, indirect objects can be referenced by more than one
     * object (i.e. indirect objects they can be shared).
     *
     * @method PDFNet.SDFDoc#createIndirectNumber
     * @param {number} value indirect boolean to create.
     * @return {Promise<PDFNet.Obj>} {Obj} A promise that resolves to the created indirect object.
     */
    createIndirectNumber(value: number): Promise<PDFNet.Obj>;
    /**
     * Used to create SDF/Cos indirect object.
     *
     * Unlike direct objects, indirect objects can be referenced by more than one
     * object (i.e. indirect objects they can be shared).
     *
     * @method PDFNet.SDFDoc#createIndirectString
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} buf_value indirect boolean to create.
     * @return {Promise<PDFNet.Obj>} {Obj} A promise that resolves to the created indirect object.
     */
    createIndirectString(buf_value: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<PDFNet.Obj>;
    /**
     * Used to create SDF/Cos indirect object.
     *
     * Unlike direct objects, indirect objects can be referenced by more than one
     * object (i.e. indirect objects they can be shared).
     *
     * @method PDFNet.SDFDoc#createIndirectStringFromUString
     * @param {string} str indirect boolean to create.
     * @return {Promise<PDFNet.Obj>} {Obj} A promise that resolves to the created indirect object.
     */
    createIndirectStringFromUString(str: string): Promise<PDFNet.Obj>;
    /**
     *
     * @method PDFNet.SDFDoc#createIndirectStreamFromFilter
     * @param {PDFNet.FilterReader} data
     * @param {PDFNet.Filter} [filter_chain]
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createIndirectStreamFromFilter(data: PDFNet.FilterReader, filter_chain?: PDFNet.Filter): Promise<PDFNet.Obj>;
    /**
     *
     * @method PDFNet.SDFDoc#createIndirectStream
     * @param {string} data
     * @param {number} data_size
     * @param {PDFNet.Filter} [filter_chain]
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an object of type: "Obj"
     */
    createIndirectStream(data: string, data_size: number, filter_chain?: PDFNet.Filter): Promise<PDFNet.Obj>;
    /**
     * Initializes document's SecurityHandler. This version of InitSecurityHandler()
     * works with Standard and Custom PDF security and can be used in situations where
     * the password is obtained dynamically via user feedback. See EncTest sample for
     * example code.
     *
     * This function should be called immediately after an encrypted
     * document is opened. The function does not have any side effects on
     * documents that are not encrypted.
     *
     * If the security handler was successfully initialized it can be later obtained
     * using GetSecurityHandler() method.
     *
     * @method PDFNet.SDFDoc#initSecurityHandler
     * @return {Promise<boolean>} A promise that resolves to true if the SecurityHandler was successfully initialized (this
     * may include authentication data collection, verification etc.),
     * false otherwise.
     */
    initSecurityHandler(): Promise<boolean>;
    /**
     * [Documentation Not Yet Added]
     * @method PDFNet.SDFDoc#saveMemory
     * @param {string} flags (generated documentation)
     * @param {number} header (generated documentation)
     */
    saveMemory(flags: string, header: number): void;
  }
  /**
   * SElement represents PDF structural elements, which are nodes in a tree
   * structure, defining a PDF document's logical structure.
   *
   * Unlike the StructTree, SElement can have two different kinds
   * of children: another SElement or a ContentItem (which can be marked
   * content (MC), or a PDF object reference (OBJR)).
   * @class
   * @name SElement
   * @memberof PDFNet
   */
  class SElement {
    /**
     * Initialize a SElement using an existing low-level Cos/SDF object.
     *
     * @method PDFNet.SElement.create
     * @param {PDFNet.Obj} [dict] a low-level (SDF/Cos) dictionary representing the structural element.
     *
     * @note This constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.SElement>} A promise that resolves to an object of type: "SElement"
     */
    static create(dict?: PDFNet.Obj): Promise<PDFNet.SElement>;
    /**
     *
     * @method PDFNet.SElement.createFromPDFDoc
     * @param {PDFNet.PDFDoc} doc
     * @param {string} struct_type
     * @return {Promise<PDFNet.SElement>} A promise that resolves to an object of type: "SElement"
     */
    static createFromPDFDoc(doc: PDFNet.PDFDoc, struct_type: string): Promise<PDFNet.SElement>;
    /**
     *
     * @method PDFNet.SElement#insert
     * @param {PDFNet.SElement} kid
     * @param {number} insert_before
     */
    insert(kid: PDFNet.SElement, insert_before: number): void;
    /**
     * @method PDFNet.SElement#createContentItem
     * @param {PDFNet.PDFDoc} doc The document in which the new ContentItem will be created in.
     * @param {PDFNet.Page} page The page object to insert the ContentItem in.
     * @param {number} [insert_before] The position after which the kid is inserted. If
     * element currently has no kids, insert_before is ignored.
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     */
    createContentItem(doc: PDFNet.PDFDoc, page: PDFNet.Page, insert_before?: number): Promise<number>;
    /**
     * @method PDFNet.SElement#isValid
     * @return {Promise<boolean>} A promise that resolves to true if this is a valid structure element object, false otherwise.
     */
    isValid(): Promise<boolean>;
    /**
     * @method PDFNet.SElement#getType
     * @return {Promise<string>} A promise that resolves to the element's structural element type. The type corresponds to
     * the 'S' (i.e. subtype) key in the structure element dictionary.
     *
     * The type identifies the nature of the structure element and its role
     * within the document (such as a chapter, paragraph, or footnote).
     */
    getType(): Promise<string>;
    /**
     * @method PDFNet.SElement#getNumKids
     * @return {Promise<number>} A promise that resolves to the number of direct kids.
     */
    getNumKids(): Promise<number>;
    /**
     * @method PDFNet.SElement#isContentItem
     * @return {Promise<boolean>} A promise that resolves to true if the kid at a given array index is a content item,
     * false otherwise.
     * @param {number} index The index of the kid type to obtain.
     *
     * To retrieve a content item at a given array index use GetAsContentItem(index),
     * otherwise use GetAsStructElem(index)
     */
    isContentItem(index: number): Promise<boolean>;
    /**
     * @method PDFNet.SElement#getAsContentItem
     * @return {Promise<PDFNet.ContentItem>} A promise that resolves to the kid at a given array index assuming that the kid is a ContentItem.
     * @note use IsContentItem(index) prior to calling this method to make sure that
     * the kid is indeed a ContentItem.
     * @param {number} index The index of the kid to obtain.
     */
    getAsContentItem(index: number): Promise<PDFNet.ContentItem>;
    /**
     * @method PDFNet.SElement#getAsStructElem
     * @return {Promise<PDFNet.SElement>} A promise that resolves to the kid at a given array index assuming that the kid is a SElement.
     * @note use IsContentItem(index) prior to calling this method to make sure that
     * the kid is not a ContentItem and is another SElement.
     * @param {number} index The index of the kid to obtain.
     */
    getAsStructElem(index: number): Promise<PDFNet.SElement>;
    /**
     * @method PDFNet.SElement#getParent
     * @return {Promise<PDFNet.SElement>} A promise that resolves to the immediate ancestor element of the specified element in
     * the structure tree.
     *
     * @note If the element's parent is the structure tree root, the returned
     * SElement will be not valid (i.e. element.IsValid() -> false) and the
     * underlying SDF/Cos object will be NULL.
     */
    getParent(): Promise<PDFNet.SElement>;
    /**
     * @method PDFNet.SElement#getStructTreeRoot
     * @return {Promise<PDFNet.STree>} A promise that resolves to the structure tree root of the document that directly or
     * indirectly contains this element.
     */
    getStructTreeRoot(): Promise<PDFNet.STree>;
    /**
     * @method PDFNet.SElement#hasTitle
     * @return {Promise<boolean>} A promise that resolves to if this SElement has title.
     *
     * The title of the structure element, a text string representing it in
     * human-readable form.
     */
    hasTitle(): Promise<boolean>;
    /**
     * @method PDFNet.SElement#getTitle
     * @return {Promise<string>} A promise that resolves to the title of this structure element.
     */
    getTitle(): Promise<string>;
    /**
     * @method PDFNet.SElement#getID
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the ID of an element, or NULL if the ID is not defined.
     */
    getID(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.SElement#hasActualText
     * @return {Promise<boolean>} A promise that resolves to if this structure element defines ActualText.
     *
     * ActualText is an exact replacement for the structure element and its children.
     * This replacement text is useful when extracting the document's contents in
     * support of accessibility to users with disabilities or for other purposes.
     */
    hasActualText(): Promise<boolean>;
    /**
     * @method PDFNet.SElement#getActualText
     * @return {Promise<string>} A promise that resolves to the ActualText associated with this element.
     *
     * @note The ActualText can be defined as an empty string. To differentiate
     * between an ActualText string of zero length and no ActualText being defined,
     * use HasActualText().
     */
    getActualText(): Promise<string>;
    /**
     * @method PDFNet.SElement#hasAlt
     * @return {Promise<boolean>} A promise that resolves to if this structure element defines Alt text.
     *
     * Alt text is an alternate description of the structure element and
     * its children in human-readable form, which is useful when extracting
     * the document's contents in support of accessibility.
     */
    hasAlt(): Promise<boolean>;
    /**
     * @method PDFNet.SElement#getAlt
     * @return {Promise<string>} A promise that resolves to the alternate text associated with this element.
     *
     * @note The Alt text can be defined as an empty string. To differentiate
     * between an Alt text string of zero length and no Alt text being defined,
     * use HasAlt().
     */
    getAlt(): Promise<string>;
    /**
     * @method PDFNet.SElement#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to pointer to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
  }
  /**
   * STree is the root of the structure tree, which is a central repository
   * for information related to a PDF document's logical structure. There is at most
   * one structure tree in each document.
   * @class
   * @name STree
   * @memberof PDFNet
   */
  class STree {
    /**
     * Initialize a STree using an existing low-level Cos/SDF object.
     *
     * @method PDFNet.STree.create
     * @param {PDFNet.Obj} struct_dict a low-level (SDF/Cos) dictionary representing the .
     *
     * @note This constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.STree>} A promise that resolves to an object of type: "STree"
     */
    static create(struct_dict: PDFNet.Obj): Promise<PDFNet.STree>;
    /**
     * Create a structure tree if it is missing, else return the existing
     * structure tree
     * @method PDFNet.STree.createFromPDFDoc
     * @param {PDFNet.PDFDoc} doc the document in which to create or get the structure tree from
     *
     * @return {Promise<PDFNet.STree>} A promise that resolves to structure tree of the document
     */
    static createFromPDFDoc(doc: PDFNet.PDFDoc): Promise<PDFNet.STree>;
    /**
     * Inserts the specified kid element after the given position as a kid of
     * the specified structure tree root.
     *
     * @method PDFNet.STree#insert
     * @param {PDFNet.SElement} kid The kid element to insert.
     * @param {number} insert_before The position after which the kid is inserted. If
     * element currently has no kids, insert_before is ignored.
     */
    insert(kid: PDFNet.SElement, insert_before: number): void;
    /**
     * Copy Constructor
     * @method PDFNet.STree#copy
     * @return {Promise<PDFNet.STree>} A promise that resolves to an object of type: "STree"
     */
    copy(): Promise<PDFNet.STree>;
    /**
     * @method PDFNet.STree#isValid
     * @return {Promise<boolean>} A promise that resolves to true if this is a valid STree object, false otherwise.
     */
    isValid(): Promise<boolean>;
    /**
     * @method PDFNet.STree#getNumKids
     * @return {Promise<number>} A promise that resolves to the number of kids of the structure tree root.
     */
    getNumKids(): Promise<number>;
    /**
     * @method PDFNet.STree#getKid
     * @return {Promise<PDFNet.SElement>} A promise that resolves to the kid at an array index in the structure tree root.
     * @param {number} index The index of the kid to obtain.
     */
    getKid(index: number): Promise<PDFNet.SElement>;
    /**
     * @method PDFNet.STree#getRoleMap
     * @return {Promise<PDFNet.RoleMap>} A promise that resolves to the RoleMap object from the structure tree root.
     */
    getRoleMap(): Promise<PDFNet.RoleMap>;
    /**
     * @method PDFNet.STree#getClassMap
     * @return {Promise<PDFNet.ClassMap>} A promise that resolves to the ClassMap object from the structure tree root.
     */
    getClassMap(): Promise<PDFNet.ClassMap>;
    /**
     * @method PDFNet.STree#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to pointer to the underlying SDF/Cos object.
     */
    getSDFObj(): Promise<PDFNet.Obj>;
  }
  /**
   * A screen annotation (PDF 1.5) specifies a region of a page upon which
   * media clips may be played. It also serves as an object from which
   * actions can be triggered.
   * @class
   * @name ScreenAnnot
   * @memberof PDFNet
   */
  class ScreenAnnot {
    /**
     * creates a Screen annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.ScreenAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.ScreenAnnot>} A promise that resolves to an object of type: "ScreenAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.ScreenAnnot>;
    /**
     * creates a Screen annotation and initializes it using given annotation object.
     * @method PDFNet.ScreenAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Screen annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.ScreenAnnot>} A promise that resolves to an object of type: "ScreenAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.ScreenAnnot>;
    /**
     * Returns the title of the annotation.
     *
     * @method PDFNet.ScreenAnnot#getTitle
     * @return {Promise<string>} A promise that resolves to a string representing the title of the annotation.
     */
    getTitle(): Promise<string>;
    /**
     * sets the title of the Annotation.
     *(Optional)
     *
     * @method PDFNet.ScreenAnnot#setTitle
     * @param {string} title A string representing the title of the annotation.
     */
    setTitle(title: string): void;
    /**
     * Creates a new Screen annotation in the specified document.
     *
     * @method PDFNet.ScreenAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.ScreenAnnot>} A promise that resolves to a newly created blank Screen annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.ScreenAnnot>;
    /**
     * Returns the action of the Screen annotation
     *
     * @method PDFNet.ScreenAnnot#getAction
     * @return {Promise<PDFNet.Action>} A promise that resolves to an action object representing the action of the annotation.
     * @note The action is an action that shall be performed when the annotation is activated.
     */
    getAction(): Promise<PDFNet.Action>;
    /**
     * sets the action of the Screen annotation
     * (Optional; PDF 1.1 )
     *
     * @method PDFNet.ScreenAnnot#setAction
     * @param {PDFNet.Action} action An action object representing the action of the annotation.
     * @note The action is an action that shall be performed when the annotation is activated.
     */
    setAction(action: PDFNet.Action): void;
    /**
     * Returns the border color of the annotation.
     *
     * @method PDFNet.ScreenAnnot#getBorderColor
     * @return {Promise<PDFNet.ColorPt>} A promise that resolves to a color object that denotes the color of the Screen border.
     * @note The color can be in different color spaces: Gray, RGB, or CMYK.
     * Call "GetBorderColorCompNum" to access the color space information corresponding to the border color.
     */
    getBorderColor(): Promise<PDFNet.ColorPt>;
    /**
     * sets the border color of the annotation.
     * (Optional)
     *
     * @method PDFNet.ScreenAnnot#setBorderColor
     * @param {PDFNet.ColorPt} col A color object that denotes the color of the screen border.
     * @param {number} numcomp An integer which value indicates the color space used for the parameter c.
     */
    setBorderColor(col: PDFNet.ColorPt, numcomp: number): void;
    /**
     * Returns the number indicating border color space of the annotation.
     *
     * @method PDFNet.ScreenAnnot#getBorderColorCompNum
     * @return {Promise<number>} A promise that resolves to an integer indicating a color space value from the ColorSpace::Type enum.
     * That is, 1 corresponding to "e_device_gray",
     * 3 corresponding to "e_device_rgb", and 4 corresponding to "e_device_cmyk".
     * 0 means this annotation had no color assigned.
     */
    getBorderColorCompNum(): Promise<number>;
    /**
     * Returns the number indicating background color space of the annotation.
     *
     * @method PDFNet.ScreenAnnot#getBackgroundColorCompNum
     * @return {Promise<number>} A promise that resolves to an integer indicating a color space value from the ColorSpace::Type enum.
     * That is, 1 corresponding to "e_device_gray",
     * 3 corresponding to "e_device_rgb", and 4 corresponding to "e_device_cmyk" if color space is applicable,
     * 0 means no background color was assigned.
     */
    getBackgroundColorCompNum(): Promise<number>;
    /**
     * Returns the background color of the annotation.
     *
     * @method PDFNet.ScreenAnnot#getBackgroundColor
     * @return {Promise<PDFNet.ColorPt>} A promise that resolves to a color object that denotes the color of the Screen background.
     * @note The color can be in different color spaces: Gray, RGB, or CMYK.
     * Call "GetBackgroundColorCompNum" to access the color space information corresponding to the border color.
     */
    getBackgroundColor(): Promise<PDFNet.ColorPt>;
    /**
     * sets the background color of the annotation.
     *(Optional)
     *
     * @method PDFNet.ScreenAnnot#setBackgroundColor
     * @param {PDFNet.ColorPt} col A color point that denotes the color of the screen background.
     * @param {number} numcomp An integer which value indicates the color space used for the parameter c.
     */
    setBackgroundColor(col: PDFNet.ColorPt, numcomp: number): void;
    /**
     * Returns static caption text of the annotation.
     *
     * @method PDFNet.ScreenAnnot#getStaticCaptionText
     * @return {Promise<string>} A promise that resolves to a string containing the static caption text of the annotation.
     * @note The static caption is the annotation's normal caption, which
     * shall be displayed when it is not interacting with the user.
     */
    getStaticCaptionText(): Promise<string>;
    /**
     * sets static caption text of the annotation.
     * (Optional; button fields only)
     *
     * @method PDFNet.ScreenAnnot#setStaticCaptionText
     * @param {string} contents A string containing the static caption text of the annotation.
     * @note The static caption is the annotation's normal caption, which
     * shall be displayed when it is not interacting with the user.
     */
    setStaticCaptionText(contents: string): void;
    /**
     * Returns the rollover caption text of the annotation.
     *
     * @method PDFNet.ScreenAnnot#getRolloverCaptionText
     * @return {Promise<string>} A promise that resolves to a string containing the rollover caption text of the annotation.
     * @note The rollover caption shall be displayed when the user rolls the cursor
     * into its active area without pressing the mouse button.
     */
    getRolloverCaptionText(): Promise<string>;
    /**
     * sets the roll over caption text of the annotation.
     * (Optional; button fields only)
     *
     * @method PDFNet.ScreenAnnot#setRolloverCaptionText
     * @param {string} contents A string containing the roll over caption text of the annotation.
     * @note The rollover caption shall be displayed when the user rolls the cursor
     * into its active area without pressing the mouse button.
     */
    setRolloverCaptionText(contents: string): void;
    /**
     * Returns the button down caption text of the annotation.
     *
     * @method PDFNet.ScreenAnnot#getMouseDownCaptionText
     * @return {Promise<string>} A promise that resolves to a string containing the button down text of the annotation.
     * @note The button down caption shall be displayed when the mouse button is
     * pressed within its active area.
     */
    getMouseDownCaptionText(): Promise<string>;
    /**
     * sets the button down caption text of the annotation.
     * (Optional; button fields only)
     *
     * @method PDFNet.ScreenAnnot#setMouseDownCaptionText
     * @param {string} contents A string containing the button down text of the annotation.
     * @note The button down caption shall be displayed when the mouse button is
     * pressed within its active area.
     */
    setMouseDownCaptionText(contents: string): void;
    /**
     * Returns the static icon associated with the annotation.
     *
     * @method PDFNet.ScreenAnnot#getStaticIcon
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an SDF object that represents the static icon
     * associated with the annotation.
     * @note The static icon object is a form XObject defining the
     * annotation's normal icon, which shall be
     * displayed when it is not interacting with the user.
     */
    getStaticIcon(): Promise<PDFNet.Obj>;
    /**
     * sets the static icon associated with the annotation.
     * (Optional; button fields only)
     *
     * @method PDFNet.ScreenAnnot#setStaticIcon
     * @param {PDFNet.Obj} icon An SDF object that represents the static icon
     * associated with the annotation.
     * @note The static icon object is a form XObject defining the
     * annotation's normal icon, which shall be
     * displayed when it is not interacting with the user.
     */
    setStaticIcon(icon: PDFNet.Obj): void;
    /**
     * Returns the rollover icon associated with the annotation.
     *
     * @method PDFNet.ScreenAnnot#getRolloverIcon
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an SDF object that represents the rollover icon
     * associated with the annotation.
     * @note The rollover icon object is a form XObject defining the
     * annotation's rollover icon, which shall be displayed
     * when the user rolls the cursor into its active area without
     * pressing the mouse button.
     */
    getRolloverIcon(): Promise<PDFNet.Obj>;
    /**
     * sets the rollover icon associated with the annotation.
     * (Optional; button fields only)
     *
     * @method PDFNet.ScreenAnnot#setRolloverIcon
     * @param {PDFNet.Obj} icon An SDF object that represents the rollover icon
     * associated with the annotation.
     * @note The rollover icon object is a form XObject defining the
     * annotation's rollover icon, which shall be displayed
     * when the user rolls the cursor into its active area without
     * pressing the mouse button.
     */
    setRolloverIcon(icon: PDFNet.Obj): void;
    /**
     * Returns the Mouse Down icon associated with the annotation.
     *
     * @method PDFNet.ScreenAnnot#getMouseDownIcon
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an SDF object that represents the Mouse Down icon
     * associated with the annotation.
     * @note The Mouse Down icon object is a form XObject defining the
     * annotation's alternate (down) icon, which shall be displayed
     * when the mouse button is pressed within its active area.
     */
    getMouseDownIcon(): Promise<PDFNet.Obj>;
    /**
     * sets the Mouse Down icon associated with the annotation.
     * (Optional; button fields only)
     *
     * @method PDFNet.ScreenAnnot#setMouseDownIcon
     * @param {PDFNet.Obj} icon An SDF object that represents the Mouse Down icon
     * associated with the annotation.
     * @note The Mouse Down icon object is a form XObject defining the
     * annotation's alternate (down) icon, which shall be displayed
     * when the mouse button is pressed within its active area.
     */
    setMouseDownIcon(icon: PDFNet.Obj): void;
    /**
     * Returns the Scale Type of the annotation.
     *
     * @method PDFNet.ScreenAnnot#getScaleType
     * @return {Promise<number>} A promise that resolves to a value of the "ScaleType" enum which represents the Scale Type of the annotation.
     * Default value: P.
     * @see ScaleType
     * @example Return value enum:
     * <pre>
     * PDFNet.ScreenAnnot.ScaleType = {
     * 	e_Anamorphic : 0
     * 	e_Proportional : 1
     * }
     * </pre>
     */
    getScaleType(): Promise<number>;
    /**
     * sets the Scale Type of the annotation.
     * (Optional)
     *
     * @method PDFNet.ScreenAnnot#setScaleType
     * @param {number} st
     * <pre>
     * PDFNet.ScreenAnnot.ScaleType = {
     * 	e_Anamorphic : 0
     * 	e_Proportional : 1
     * }
     * </pre>
     * An entry of the "ScaleType" enum which represents the Scale Type of the annotation.
     * Default value: P.
     * @see ScaleType
     */
    setScaleType(st: number): void;
    /**
     * Returns the Icon and caption relationship of the  annotation.
     *
     * @method PDFNet.ScreenAnnot#getIconCaptionRelation
     * @return {Promise<number>} A promise that resolves to a value of the "IconCaptionRelation" enum type.
     * Default value: e_NoIcon.
     * @see IconCaptionRelation
     * @example Return value enum:
     * <pre>
     * PDFNet.ScreenAnnot.IconCaptionRelation = {
     * 	e_NoIcon : 0
     * 	e_NoCaption : 1
     * 	e_CBelowI : 2
     * 	e_CAboveI : 3
     * 	e_CRightILeft : 4
     * 	e_CLeftIRight : 5
     * 	e_COverlayI : 6
     * }
     * </pre>
     */
    getIconCaptionRelation(): Promise<number>;
    /**
     * sets the Icon and caption relationship of the  annotation.
     * (Optional; pushbutton fields only)
     *
     * @method PDFNet.ScreenAnnot#setIconCaptionRelation
     * @param {number} icr
     * <pre>
     * PDFNet.ScreenAnnot.IconCaptionRelation = {
     * 	e_NoIcon : 0
     * 	e_NoCaption : 1
     * 	e_CBelowI : 2
     * 	e_CAboveI : 3
     * 	e_CRightILeft : 4
     * 	e_CLeftIRight : 5
     * 	e_COverlayI : 6
     * }
     * </pre>
     * A value of the "IconCaptionRelation" enum type.
     * Default value: e_NoIcon.
     * @see IconCaptionRelation
     */
    setIconCaptionRelation(icr: number): void;
    /**
     * Returns the condition under which the icon should be scaled.
     *
     * @method PDFNet.ScreenAnnot#getScaleCondition
     * @return {Promise<number>} A promise that resolves to a value of the "ScaleCondition" enum type.
     * Default value: e_Always.
     * @see ScaleCondition
     * @example Return value enum:
     * <pre>
     * PDFNet.ScreenAnnot.ScaleCondition = {
     * 	e_Always : 0
     * 	e_WhenBigger : 1
     * 	e_WhenSmaller : 2
     * 	e_Never : 3
     * }
     * </pre>
     */
    getScaleCondition(): Promise<number>;
    /**
     * sets the condition under which the icon should be scaled.
     * (Optional)
     *
     * @method PDFNet.ScreenAnnot#setScaleCondition
     * @param {number} sc
     * <pre>
     * PDFNet.ScreenAnnot.ScaleCondition = {
     * 	e_Always : 0
     * 	e_WhenBigger : 1
     * 	e_WhenSmaller : 2
     * 	e_Never : 3
     * }
     * </pre>
     * A value of the "ScaleCondition" enum type.
     * Default value: e_Always.
     */
    setScaleCondition(sc: number): void;
    /**
     * Returns the "fit full" flag.
     *
     * @method PDFNet.ScreenAnnot#getFitFull
     * @return {Promise<boolean>} A promise that resolves to a boolean value indicating the "fit full" flag value.
     * @note the fit full flag, if true, indicates that the button
     * appearance shall be scaled to fit fully within the bounds of
     * the annotation without taking into consideration the line
     * width of the border.
     * Default value: false.
     */
    getFitFull(): Promise<boolean>;
    /**
     * sets the "fit full" flag.
     * (Optional)
     *
     * @method PDFNet.ScreenAnnot#setFitFull
     * @param {boolean} ff A boolean value indicating the "fit full" flag value.
     * @note the fit full flag, if true, indicates that the button
     * appearance shall be scaled to fit fully within the bounds of
     * the annotation without taking into consideration the line
     * width of the border. Default value: false.
     */
    setFitFull(ff: boolean): void;
    /**
     * Returns the horizontal leftover space of the icon within the annotation.
     *
     * @method PDFNet.ScreenAnnot#getHIconLeftOver
     * @return {Promise<number>} A promise that resolves to a number indicating the horizontal
     * leftover space of the icon within the annotation.
     * @note the horizontal leftover is a number that shall be between
     * 0.0 and 1.0 indicating the fraction of leftover space to allocate at the left.
     * A value of 0.0 shall position the icon at the left of the annotation rectangle.
     * A value of 0.5 shall center it in the horizontal direction within the rectangle.
     * This entry shall be used only if the icon is scaled proportionally.
     * Default value: 0.5.
     */
    getHIconLeftOver(): Promise<number>;
    /**
     * sets the horizontal leftover space of the icon within the annotation.
     * (Optional)
     *
     * @method PDFNet.ScreenAnnot#setHIconLeftOver
     * @param {number} hl A number indicating the horizontal
     * leftover space of the icon within the annotation.
     * @note the horizontal leftover space is a number that shall be between
     * 0.0 and 1.0 indicating the fraction of leftover space to allocate at the left.
     * A value of 0.0 shall position the icon at the left of the annotation rectangle.
     * A value of 0.5 shall center it in the horizontal direction within the rectangle.
     * This entry shall be used only if the icon is scaled proportionally.
     * Default value: 0.5.
     */
    setHIconLeftOver(hl: number): void;
    /**
     * Returns the vertical leftover space of the icon within the annotation.
     *
     * @method PDFNet.ScreenAnnot#getVIconLeftOver
     * @return {Promise<number>} A promise that resolves to a number indicating the vertical
     * leftover space of the icon within the annotation.
     * @note the vertical leftover space is a number that
     * shall be between 0.0 and 1.0 indicating the fraction of leftover
     * space to allocate at the bottom of the icon.
     * A value of 0.0 shall position the icon at the bottom
     * of the annotation rectangle.
     * A value of 0.5 shall center it in the vertical direction within
     * the rectangle.
     * This entry shall be used only if the icon is scaled proportionally.
     * Default value: 0.5.
     */
    getVIconLeftOver(): Promise<number>;
    /**
     * sets the vertical leftover space of the icon within the annotation.
     * (Optional)
     *
     * @method PDFNet.ScreenAnnot#setVIconLeftOver
     * @param {number} vl A number indicating the vertical
     * leftover space of the icon within the annotation.
     * @note the vertical leftover space is a number that
     * shall be between 0.0 and 1.0 indicating the fraction of leftover
     * space to allocate at the bottom of the icon.
     * A value of 0.0 shall position the icon at the bottom
     * of the annotation rectangle.
     * A value of 0.5 shall center it in the vertical direction within
     * the rectangle.
     * This entry shall be used only if the icon is scaled proportionally.
     * Default value: 0.5.
     */
    setVIconLeftOver(vl: number): void;
  }
  /**
   * Standard Security Handler is a standard password-based security handler.
   * @class
   * @name SecurityHandler
   * @memberof PDFNet
   */
  class SecurityHandler {
    /**
     * @method PDFNet.SecurityHandler#clone
     * @return {Promise<PDFNet.SecurityHandler>} A promise that resolves to a new, cloned instance of SecurityHandler.
     * @note this method must be implemented in any derived class from SecurityHandler.
     */
    clone(): Promise<PDFNet.SecurityHandler>;
    /**
     * Destructor
     * @method PDFNet.SecurityHandler#destroy
     */
    destroy(): void;
    /**
     * @method PDFNet.SecurityHandler#getPermission
     * @return {Promise<boolean>} A promise that resolves to true if the SecurityHandler permits the specified action (Permission p)
     * on the document, or false if the permission was not granted.
     *
     * @param {number} p
     * <pre>
     * PDFNet.SecurityHandler.Permission = {
     * 	e_owner : 1
     * 	e_doc_open : 2
     * 	e_doc_modify : 3
     * 	e_print : 4
     * 	e_print_high : 5
     * 	e_extract_content : 6
     * 	e_mod_annot : 7
     * 	e_fill_forms : 8
     * 	e_access_support : 9
     * 	e_assemble_doc : 10
     * }
     * </pre>
     * A Permission to be granted.
     *
     * @note in order to check for permission the method will repeatedly (up to three
     * times) attempt to GetAuthorizationData() and Authorize() permission. If the
     * permission is not granted AuthorizeFailed() callback will be called. This callback
     * method allows derived class to provide UI feedback for failed authorization.
     */
    getPermission(p: number): Promise<boolean>;
    /**
     * @method PDFNet.SecurityHandler#getKeyLength
     * @return {Promise<number>} A promise that resolves to the length of the encryption key in bytes.
     * @note The returned key length is given in bytes.
     */
    getKeyLength(): Promise<number>;
    /**
     * @method PDFNet.SecurityHandler#getEncryptionAlgorithmID
     * @return {Promise<number>} A promise that resolves to the encryption algorithm identifier. A code specifying the algorithm
     * to be used in encrypting and decrypting the document. Returned number corresponds
     * to V entry in encryption dictionary. Currently allowed values are from 0-4.
     * See PDF Reference Manual for more details.
     */
    getEncryptionAlgorithmID(): Promise<number>;
    /**
     * @method PDFNet.SecurityHandler#getHandlerDocName
     * @return {Promise<string>} A promise that resolves to the name of the security handler as it appears in the serialized file
     * as the value of /Filter key in /Encrypt dictionary.
     */
    getHandlerDocName(): Promise<string>;
    /**
     * @method PDFNet.SecurityHandler#isModified
     * @return {Promise<boolean>} A promise that resolves to true if the SecurityHandler was modified (by calling SetModified())
     * or false otherwise.
     *
     * If the user changes SecurityHandler's settings (e.g. by changing a password),
     * IsModified() should return true.
     */
    isModified(): Promise<boolean>;
    /**
     * The method allows derived classes to set SecurityHandler is modified flag.
     * This method should be called whenever there are changes (e.g. a password change)
     * to the SecurityHandler
     * @method PDFNet.SecurityHandler#setModified
     * @param {boolean} [is_modified] Value to set the SecurityHandler's is modified flag to
     */
    setModified(is_modified?: boolean): void;
    /**
     * create a Standard Security Handler.
     *
     * @method PDFNet.SecurityHandler.create
     * @param {number} crypt_type
     * <pre>
     * PDFNet.SecurityHandler.AlgorithmType = {
     * 	e_RC4_40 : 1
     * 	e_RC4_128 : 2
     * 	e_AES : 3
     * 	e_AES_256 : 4
     * }
     * </pre>
     * The encryption algorithm identifier.
     * @return {Promise<PDFNet.SecurityHandler>} A promise that resolves to an object of type: "SecurityHandler"
     */
    static create(crypt_type: number): Promise<PDFNet.SecurityHandler>;
    /**
     * create a Standard Security Handler.
     *
     * @method PDFNet.SecurityHandler.createFromEncCode
     * @param {string} name The name of the Standard Security Handler.
     * @param {number} key_len The bit length of the encryption key (40 or 128 bit).
     * @param {number} enc_code The encryption algorithm identifier. The number corresponds
     * to the V entry in encryption dictionary. Currently allowed values are (see
     * Table 3.18 in PDF Reference Manual v1.6 for more details):
     *   1 : Encryption using 40-bit RC4 algorithm.
     *   2 : Encryption using 128-bit RC4 algorithm. Available in PDF 1.4 and above.
     *   3 : This algorithm was deprecated by PDF standard and is not supported.
     *   4 : Encryption using Crypt filters and 128-bit AES (Advanced Encryption
     *         Standard) algorithm. Available in PDF 1.6 and above.
     *
     * @default values for key_len and enc_code are 128 and 2 respectively.
     * @return {Promise<PDFNet.SecurityHandler>} A promise that resolves to an object of type: "SecurityHandler"
     */
    static createFromEncCode(name: string, key_len: number, enc_code: number): Promise<PDFNet.SecurityHandler>;
    /**
     * Create a default Security Handler.
     * @method PDFNet.SecurityHandler.createDefault
     * @return {Promise<PDFNet.SecurityHandler>} {SecurityHandler} A promise that resolves to a SecurityHandler object.
     */
    static createDefault(): Promise<PDFNet.SecurityHandler>;
    /**
     * Set the permission setting of the StdSecurityHandler.
     * @method PDFNet.SecurityHandler#setPermission
     * @param {number} perm
     * <pre>
     * PDFNet.SecurityHandler.Permission = {
     * 	e_owner : 1
     * 	e_doc_open : 2
     * 	e_doc_modify : 3
     * 	e_print : 4
     * 	e_print_high : 5
     * 	e_extract_content : 6
     * 	e_mod_annot : 7
     * 	e_fill_forms : 8
     * 	e_access_support : 9
     * 	e_assemble_doc : 10
     * }
     * </pre>
     * indicates a permission to set or clear. It can be any of the
     * following values:
     *
     *	e_print				// print the document.
     *	e_doc_modify		// edit the document more than adding or modifying text notes.
     *	e_extract_content	// enable content extraction
     *	e_mod_annot			// allow modifications to annotations
     *	e_fill_forms		// allow changes to fill in forms
     *	e_access_support	// content access for the visually impaired.
     *	e_assemble_doc		// allow document assembly
     *	e_print_high		// high resolution print.
     *
     * @param {boolean} value true if the permission/s should be granted, false otherwise.
     */
    setPermission(perm: number, value: boolean): void;
    /**
     * Change the revision number and the encryption algorithm of the
     * standard security handler.
     *
     * @method PDFNet.SecurityHandler#changeRevisionNumber
     * @param {number} rev_num the new revision number of the standard security
     * algorithm. Currently allowed values for the revision number are
     * (see Table 3.18 in PDF Reference Manual v1.6 for more details):
     *   2 : Encryption using 40-bit RC4 algorithm.
     *   3 : Encryption using 128-bit RC4 algorithm. Available in PDF 1.4 and above.
     *   4 : Encryption using Crypt filters and 128-bit AES (Advanced Encryption
     *         Standard) algorithm. Available in PDF 1.6 and above.
     */
    changeRevisionNumber(rev_num: number): void;
    /**
     * Indicates whether the document-level metadata stream is to
     * be encrypted.
     *
     * @method PDFNet.SecurityHandler#setEncryptMetadata
     * @param {boolean} encrypt_metadata true if metadata stream should be
     * encrypted, false otherwise.
     *
     * @note EncryptMetadata flag affects only Crypt filters available
     * in PDF 1.5 (Acrobat 6) and later. By default, metadata stream
     * will be encrypted.
     */
    setEncryptMetadata(encrypt_metadata: boolean): void;
    /**
     * @method PDFNet.SecurityHandler#getRevisionNumber
     * @return {Promise<number>} A promise that resolves to the revision number of the standard security algorithm.
     */
    getRevisionNumber(): Promise<number>;
    /**
     * @method PDFNet.SecurityHandler#isUserPasswordRequired
     * @return {Promise<boolean>} A promise that resolves to true if the SecurityHandler requires a user password.
     */
    isUserPasswordRequired(): Promise<boolean>;
    /**
     * @method PDFNet.SecurityHandler#isMasterPasswordRequired
     * @return {Promise<boolean>} A promise that resolves to true if the SecurityHandler requires a master (owner) password.
     */
    isMasterPasswordRequired(): Promise<boolean>;
    /**
     * @method PDFNet.SecurityHandler#isAES
     * @return {Promise<boolean>} A promise that resolves to true is this security handler uses 128 bit AES (Advanced Encryption Standard)
     * algorithm to encrypt strings or streams.
     */
    isAES(): Promise<boolean>;
    /**
     * The following function can be used to verify whether a given stream is
     * encrypted using AES.
     *
     * @method PDFNet.SecurityHandler#isAESObj
     * @return {Promise<boolean>} A promise that resolves to true if the given stream is encrypted using AES encryption.
     * @param {PDFNet.Obj} stream A pointer to an SDF::Stream object
     */
    isAESObj(stream: PDFNet.Obj): Promise<boolean>;
    /**
     * @method PDFNet.SecurityHandler#isRC4
     * @return {Promise<boolean>} A promise that resolves to true is this security handler uses RC4 algorithm to encrypt strings or streams.
     */
    isRC4(): Promise<boolean>;
    /**
     * Sets the new user password.
     * @method PDFNet.SecurityHandler#changeUserPasswordUString
     * @param {string} password The new user password.
     */
    changeUserPasswordUString(password: string): void;
    /**
     *
     * @method PDFNet.SecurityHandler#changeUserPasswordBuffer
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} password_buf
     */
    changeUserPasswordBuffer(password_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): void;
    /**
     * Sets the new master/owner password.
     * @method PDFNet.SecurityHandler#changeMasterPasswordUString
     * @param {string} password The new master/owner password.
     */
    changeMasterPasswordUString(password: string): void;
    /**
     *
     * @method PDFNet.SecurityHandler#changeMasterPasswordBuffer
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} password_buf
     */
    changeMasterPasswordBuffer(password_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): void;
    /**
     *
     * @method PDFNet.SecurityHandler#initPasswordUString
     * @param {string} password
     */
    initPasswordUString(password: string): void;
    /**
     *
     * @method PDFNet.SecurityHandler#initPasswordBuffer
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} password_buf
     */
    initPasswordBuffer(password_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): void;
    /**
     * The method is called when a user tries to set security for an encrypted
     * document and when a user tries to open a file. It must decide, based on
     * the contents of the authorization data structure, whether or not the
     * user is permitted to open the file, and what permissions the user has
     * for this file.
     *
     * @method PDFNet.SecurityHandler#authorize
     * @note This callback must not obtain the authorization data (e.g. by
     * displaying a user interface into which a user can type a password).
     * This is handled by the security handler's GetAuthorizationData(), which
     * must be called before this callback. Instead, Authorize() should work
     * with authorization data it has access to.
     *
     * @param {number} p
     * <pre>
     * PDFNet.SecurityHandler.Permission = {
     * 	e_owner : 1
     * 	e_doc_open : 2
     * 	e_doc_modify : 3
     * 	e_print : 4
     * 	e_print_high : 5
     * 	e_extract_content : 6
     * 	e_mod_annot : 7
     * 	e_fill_forms : 8
     * 	e_access_support : 9
     * 	e_assemble_doc : 10
     * }
     * </pre>
     * permission to authorize
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    authorize(p: number): Promise<boolean>;
    /**
     * A callback method indicating repeated failed authorization.
     * Override this callback in order to provide a UI feedback for failed
     * authorization. Default implementation returns immediately.
     * @method PDFNet.SecurityHandler#authorizeFailed
     */
    authorizeFailed(): void;
    /**
     * This method is invoked in case Authorize() failed. The callback must
     * determine the user's authorization properties for the document by
     * obtaining authorization data (e.g. a password through a GUI dialog).
     *
     * The authorization data is subsequently used by the security handler's Authorize()
     * to determine whether or not the user is authorized to open the file.
     *
     * @method PDFNet.SecurityHandler#getAuthorizationData
     * @return {Promise<boolean>} A promise that resolves to false if the operation was canceled, true otherwise.
     * @param {number} req_opr
     * <pre>
     * PDFNet.SecurityHandler.Permission = {
     * 	e_owner : 1
     * 	e_doc_open : 2
     * 	e_doc_modify : 3
     * 	e_print : 4
     * 	e_print_high : 5
     * 	e_extract_content : 6
     * 	e_mod_annot : 7
     * 	e_fill_forms : 8
     * 	e_access_support : 9
     * 	e_assemble_doc : 10
     * }
     * </pre>
     * the permission for which authorization data is requested.
     */
    getAuthorizationData(req_opr: number): Promise<boolean>;
    /**
     *
     * @method PDFNet.SecurityHandler#editSecurityData
     * @param {PDFNet.SDFDoc} doc
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    editSecurityData(doc: PDFNet.SDFDoc): Promise<boolean>;
    /**
     * Called when an encrypted document is saved. Fills the document's Encryption
     * dictionary with whatever information the security handler wants to store in
     * the document.
     *
     * The sequence of events during creation of the encrypt_dict is as follows:
     *  encrypt_dict is created (if it does not exist)
     *  Filter attribute is added to the dictionary
     *  call this method to allow the security handler to add its own attributes
     *  call the GetCryptKey to get the algorithm version, key, and key length
     *  checks if the V attribute has been added to the dictionary and, if not,
     *    then sets V to the algorithm version
     *  set the Length attribute if V is 2 or greater
     *  add the encrypt_dict to the document
     *
     *	@method PDFNet.SecurityHandler#fillEncryptDict
     * @param {PDFNet.SDFDoc} doc The document to save.
     *  @return {Promise<PDFNet.Obj>} A promise that resolves to encrypt_dict
     *
     * @warning Unlike all other strings and streams, direct object elements of
     * the encrypt_dict are not encrypted automatically. If you want them encrypted,
     * you must encrypt them before inserting them into the dictionary.
     */
    fillEncryptDict(doc: PDFNet.SDFDoc): Promise<PDFNet.Obj>;
    /**
     * Set the new user password to a binary string
     * @method PDFNet.SecurityHandler#changeUserPasswordNonAscii
     * @param {string} password the new user password
     */
    changeUserPasswordNonAscii(password: string): void;
    /**
     * Set the new master password to a binary string
     * @method PDFNet.SecurityHandler#changeMasterPasswordNonAscii
     * @param {string} password the new user password
     */
    changeMasterPasswordNonAscii(password: string): void;
    /**
     * the method can be called in GetAuthorizationData() callback to
     * specify user supplied ASCII password.
     * @method PDFNet.SecurityHandler#initPassword
     * @param {string} password user supplied ASCII password
     */
    initPassword(password: string): void;
    /**
     * the method can be called in GetAuthorizationData() callback to
     * specify user supplied non-ASCII password.
     * @method PDFNet.SecurityHandler#initPasswordNonAscii
     * @param {string} password user supplied non-ASCII password
     */
    initPasswordNonAscii(password: string): void;
  }
  /**
   * Shading is a class that represents a flat interface around all PDF shading types:
   *
   *  - In Function-based (type 1) shadings, the color at every point in
   *    the domain is defined by a specified mathematical function. The function need
   *    not be smooth or continuous. This is the most general of the available shading
   *    types, and is useful for shadings that cannot be adequately described with any
   *    of the other types.
   *
   *  - Axial shadings (type 2) define a color blend along a line between two points,
   *    optionally extended beyond the boundary points by continuing the boundary
   *    colors.
   *
   *  - Radial shadings (type 3) define a color blend that varies between two circles.
   *    Shadings of this type are commonly used to depict three-dimensional spheres
   *    and cones.
   *
   *  - Free-form Gouraud-shaded triangle mesh shadings (type 4) and lattice Gouraud
   *    shadings (type 5) are commonly used to represent complex colored and shaded
   *    three-dimensional shapes. The area to be shaded is defined by a path composed entirely
   *    of triangles. The color at each vertex of the triangles is specified, and a technique
   *    known as Gouraud interpolation is used to color the interiors. The interpolation
   *    functions defining the shading may be linear or nonlinear.
   *
   *  - Coons patch mesh shadings (type 6) are constructed from one or more color
   *    patches, each bounded by four cubic Bezier curves.
   *
   *    A Coons patch generally has two independent aspects:
   *    - Colors are specified for each corner of the unit square, and bilinear
   *      interpolation is used to fill in colors over the entire unit square<BR>
   *    - Coordinates are mapped from the unit square into a four-sided patch whose
   *      sides are not necessarily linear. The mapping is continuous: the corners
   *      of the unit square map to corners of the patch and the sides of the unit
   *      square map to sides of the patch.
   *
   *  - Tensor-product patch mesh shadings (type 7) are identical to type 6
   *    (Coons mesh), except that they are based on a bicubic tensor-product
   *    patch defined by 16 control points, instead of the 12 control points
   *    that define a Coons patch. The shading Patterns dictionaries representing
   *    the two patch types differ only in the value of the Type entry and
   *    in the number of control points specified for each patch in the data stream.
   *    Although the Coons patch is more concise and easier to use, the tensor-
   *    product patch affords greater control over color mapping.
   * @class
   * @name Shading
   * @memberof PDFNet
   */
  class Shading {
    /**
     *
     * @method PDFNet.Shading.create
     * @param {PDFNet.Obj} [shading_dict]
     * @return {Promise<PDFNet.Shading>} A promise that resolves to an object of type: "Shading"
     */
    static create(shading_dict?: PDFNet.Obj): Promise<PDFNet.Shading>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.Shading#destroy
     */
    destroy(): void;
    /**
     * @method PDFNet.Shading.getTypeFromObj
     * @param {PDFNet.Obj} shading_dict SDF/Cos shading dictionary to get the Type from
     * @return {Promise<number>} A promise that resolves to the Type of a given SDF/Cos shading dictionary, or e_null for if
     * SDF object is not a valid shading object
     * @example Return value enum:
     * <pre>
     * PDFNet.Shading.Type = {
     * 	e_function_shading : 0
     * 	e_axial_shading : 1
     * 	e_radial_shading : 2
     * 	e_free_gouraud_shading : 3
     * 	e_lattice_gouraud_shading : 4
     * 	e_coons_shading : 5
     * 	e_tensor_shading : 6
     * 	e_null : 7
     * }
     * </pre>
     */
    static getTypeFromObj(shading_dict: PDFNet.Obj): Promise<number>;
    /**
     * @method PDFNet.Shading#getType
     * @return {Promise<number>} A promise that resolves to the shading type
     * @example Return value enum:
     * <pre>
     * PDFNet.Shading.Type = {
     * 	e_function_shading : 0
     * 	e_axial_shading : 1
     * 	e_radial_shading : 2
     * 	e_free_gouraud_shading : 3
     * 	e_lattice_gouraud_shading : 4
     * 	e_coons_shading : 5
     * 	e_tensor_shading : 6
     * 	e_null : 7
     * }
     * </pre>
     */
    getType(): Promise<number>;
    /**
     * @method PDFNet.Shading#getSDFObj
     * @return {Promise<PDFNet.Obj>} A promise that resolves to the underlying SDF/Cos object
     */
    getSDFObj(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.Shading#getBaseColorSpace
     * @return {Promise<PDFNet.ColorSpace>} A promise that resolves to the color space in which color values are expressed.
     * This may be any device, CIE-based, or special color space
     * except a Pattern space.
     */
    getBaseColorSpace(): Promise<PDFNet.ColorSpace>;
    /**
     * @method PDFNet.Shading#hasBBox
     * @return {Promise<boolean>} A promise that resolves to true if shading has a bounding box, false otherwise.
     */
    hasBBox(): Promise<boolean>;
    /**
     * @method PDFNet.Shading#getBBox
     * @return {Promise<PDFNet.Rect>} A promise that resolves to a rectangle giving the left, bottom, right, and top
     * coordinates, respectively, of the shading's bounding box. The coordinates
     * are interpreted in the shading's target coordinate space. If present, this
     * bounding box is applied as a temporary clipping boundary when the shading
     * is painted, in addition to the current clipping path and any other clipping
     * boundaries in effect at that time.
     *
     * @note Use HasBBox() method to determine whether the shading has a
     * background color.
     */
    getBBox(): Promise<PDFNet.Rect>;
    /**
     * @method PDFNet.Shading#hasBackground
     * @return {Promise<boolean>} A promise that resolves to true if the shading has a background color or false otherwise.
     */
    hasBackground(): Promise<boolean>;
    /**
     * An color point represented in base color space specifying a single
     * background color value. If present, this color is used before
     * any painting operation involving the shading, to fill those portions of the
     * area to be painted that lie outside the bounds of the shading object itself.
     * In the opaque imaging model, the effect is as if the painting operation were
     * performed twice: first with the background color and then again with the
     * shading.
     *
     * @method PDFNet.Shading#getBackground
     * @note The background color is applied only when the shading is used as part
     * of a shading pattern, not when it is painted directly with the sh operator.
     *
     * @note Use HasBackground() method to determine whether the shading has a
     * background color.
     * @return {Promise<PDFNet.ColorPt>} A promise that resolves to an object of type: "ColorPt"
     */
    getBackground(): Promise<PDFNet.ColorPt>;
    /**
     * @method PDFNet.Shading#getAntialias
     * @return {Promise<boolean>} A promise that resolves to a flag indicating whether to filter the shading function to prevent
     * aliasing artifacts. See Table 4.25
     */
    getAntialias(): Promise<boolean>;
    /**
     * @method PDFNet.Shading#getParamStart
     * @return {Promise<number>} A promise that resolves to a number specifying the limiting value of a parametric variable t.
     * The variable is considered to vary linearly between GetParamStart() and
     * GetParamEnd() as the color gradient varies between the starting and ending points
     * of the axis for Axial shading or circles for Radial shading.
     * The variable t becomes the input argument to the color function(s).
     * @note the returned value corresponds to the first value in Domain array.
     *
     * @note for shadings other than Axial or Radial this method throws an exception.
     */
    getParamStart(): Promise<number>;
    /**
     * @method PDFNet.Shading#getParamEnd
     * @return {Promise<number>} A promise that resolves to a number specifying the limiting value of a parametric variable t.
     * The variable is considered to vary linearly between GetParamStart() and
     * GetParamEnd() as the color gradient varies between the starting and ending points
     * of the axis for Axial shading or circles for Radial shading.
     * The variable t becomes the input argument to the color function(s).
     * @note the returned value corresponds to the second value in Domain array.
     *
     * @note for shadings other than Axial or Radial this method throws an exception.
     */
    getParamEnd(): Promise<number>;
    /**
     * @method PDFNet.Shading#isExtendStart
     * @return {Promise<boolean>} A promise that resolves to a flag specifying whether to extend the shading beyond the starting
     * point of the axis for Axial shading or starting circle for Radial shading.
     *
     * @note for shadings other than Axial or Radial this method throws an exception.
     */
    isExtendStart(): Promise<boolean>;
    /**
     * @method PDFNet.Shading#isExtendEnd
     * @return {Promise<boolean>} A promise that resolves to a flag specifying whether to extend the shading beyond the ending
     * point of the axis for Axial shading or ending circle for Radial shading.
     *
     * @note for shadings other than Axial or Radial this method throws an exception.
     */
    isExtendEnd(): Promise<boolean>;
    /**
     *
     * @method PDFNet.Shading#getColor
     * @param {number} t
     */
    getColor(t: number): void;
    /**
     *
     * @method PDFNet.Shading#getCoords
     */
    getCoords(): void;
    /**
     * @method PDFNet.Shading#getCoordsRadial
     * @return for Radial shading returns six numbers (x0 y0 r0 x1 y1 r1) specifying
     * the centers and radii of the starting and ending circles, expressed in the
     * shading's target coordinate space. The radii r0 and r1 must both be greater
     * than or equal to 0. If one radius is 0, the corresponding circle is treated
     * as a point; if both are 0, nothing is painted.
     *
     * @note for shadings other than Radial this method throws an exception.
     */
    getCoordsRadial(): any;
    /**
     * @method PDFNet.Shading#getDomain
     * @return an array of four numbers [xmin xmax ymin ymax] specifying the rectangular
     * domain of coordinates over which the color function(s) are defined.
     * If the function does not contain /Domain entry the function returns: [0 1 0 1].
     *
     * @note for shadings other than Function this method throws an exception.
     */
    getDomain(): any;
    /**
     * @method PDFNet.Shading#getMatrix
     * @return {Promise<PDFNet.Matrix2D>} A promise that resolves to a matrix specifying a mapping from the coordinate space specified
     * by the Domain entry into the shading's target coordinate space.
     *
     * @note for shadings other than Function this method throws an exception.
     */
    getMatrix(): Promise<PDFNet.Matrix2D>;
    /**
     *
     * @method PDFNet.Shading#getColorForFunction
     * @param {number} t1
     * @param {number} t2
     */
    getColorForFunction(t1: number, t2: number): void;
  }
  /**
   * SignatureHandler instances are responsible for defining the digest and cipher algorithms to create
   * and/or validate a signed PDF document. SignatureHandlers are added to PDFDoc instances by
   * calling the [PDFDoc].addSignatureHandler method.
   * @class
   * @name SignatureHandler
   * @memberof PDFNet
   */
  class SignatureHandler {
    /**
     * Gets the name of this SignatureHandler. The name of the SignatureHandler is what identifies this SignatureHandler
     * from all others. This name is also added to the PDF as the value of /Filter entry in the signature dictionary.
     * @method PDFNet.SignatureHandler#getName
     * @return {Promise<string>} A promise that resolves to the name of this SignatureHandler.
     */
    getName(): Promise<string>;
    /**
     * Resets any data appending and signature calculations done so far. This method should allow PDFNet to restart the
     * whole signature calculation process. It is important that when this method is invoked, any data processed with
     * the AppendData method should be discarded.
     * @method PDFNet.SignatureHandler#reset
     * @return {Promise<boolean>} A promise that resolves to true if there are no errors, otherwise false.
     */
    reset(): Promise<boolean>;
    /**
     * Destructor
     * @method PDFNet.SignatureHandler#destructor
     */
    destructor(): void;
  }
  /**
   * [Missing documentation]
   * @class
   * @name SignatureWidget
   * @memberof PDFNet
   */
  class SignatureWidget {
    /**
     * Constructor
     * @method PDFNet.SignatureWidget.create
     * @param {PDFNet.PDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @param {string} [field_name]
     * @return {Promise<PDFNet.SignatureWidget>} A promise that resolves to an object of type: "SignatureWidget"
     */
    static create(doc: PDFNet.PDFDoc, pos: PDFNet.Rect, field_name?: string): Promise<PDFNet.SignatureWidget>;
    /**
     *
     * @method PDFNet.SignatureWidget.createWithField
     * @param {PDFNet.PDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @param {PDFNet.Field} field
     * @return {Promise<PDFNet.SignatureWidget>} A promise that resolves to an object of type: "SignatureWidget"
     */
    static createWithField(doc: PDFNet.PDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.SignatureWidget>;
    /**
     *
     * @method PDFNet.SignatureWidget.createWithDigitalSignatureField
     * @param {PDFNet.PDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @param {PDFNet.DigitalSignatureField} field
     * @return {Promise<PDFNet.SignatureWidget>} A promise that resolves to an object of type: "SignatureWidget"
     */
    static createWithDigitalSignatureField(
      doc: PDFNet.PDFDoc,
      pos: PDFNet.Rect,
      field: PDFNet.DigitalSignatureField,
    ): Promise<PDFNet.SignatureWidget>;
    /**
     *
     * @method PDFNet.SignatureWidget.createFromObj
     * @param {PDFNet.Obj} [obj]
     * @return {Promise<PDFNet.SignatureWidget>} A promise that resolves to an object of type: "SignatureWidget"
     */
    static createFromObj(obj?: PDFNet.Obj): Promise<PDFNet.SignatureWidget>;
    /**
     *
     * @method PDFNet.SignatureWidget.createFromAnnot
     * @param {PDFNet.Annot} annot
     * @return {Promise<PDFNet.SignatureWidget>} A promise that resolves to an object of type: "SignatureWidget"
     */
    static createFromAnnot(annot: PDFNet.Annot): Promise<PDFNet.SignatureWidget>;
    /**
     *
     * @method PDFNet.SignatureWidget#createSignatureAppearance
     * @param {PDFNet.Image} img
     */
    createSignatureAppearance(img: PDFNet.Image): void;
    /**
     *
     * @method PDFNet.SignatureWidget#getDigitalSignatureField
     * @return {Promise<PDFNet.DigitalSignatureField>} A promise that resolves to an object of type: "DigitalSignatureField"
     */
    getDigitalSignatureField(): Promise<PDFNet.DigitalSignatureField>;
  }
  /**
   * A Sound annotation represents a sound recording attached to a point in
   * the PDF document. When closed, this annotation appear as an icon; when open
   * and activated, a sound record from the computer's microphone or imported from a file
   * associated with this annotation is played.The icon of this annotation by default
   * is a speaker.
   * @class
   * @name SoundAnnot
   * @memberof PDFNet
   */
  class SoundAnnot {
    /**
     * creates a Sound annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.SoundAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.SoundAnnot>} A promise that resolves to an object of type: "SoundAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.SoundAnnot>;
    /**
     * creates a Sound annotation and initializes it using given annotation object.
     * @method PDFNet.SoundAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Sound annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.SoundAnnot>} A promise that resolves to an object of type: "SoundAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.SoundAnnot>;
    /**
     * Constructor
     * @method PDFNet.SoundAnnot.create
     * @param {PDFNet.SDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @return {Promise<PDFNet.SoundAnnot>} A promise that resolves to an object of type: "SoundAnnot"
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.SoundAnnot>;
    /**
     *
     * @method PDFNet.SoundAnnot.createWithData
     * @param {PDFNet.SDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @param {PDFNet.Filter} stream
     * @param {number} sample_bits
     * @param {number} sample_freq
     * @param {number} num_channels
     * @return {Promise<PDFNet.SoundAnnot>} A promise that resolves to an object of type: "SoundAnnot"
     */
    static createWithData(
      doc: PDFNet.SDFDoc,
      pos: PDFNet.Rect,
      stream: PDFNet.Filter,
      sample_bits: number,
      sample_freq: number,
      num_channels: number,
    ): Promise<PDFNet.SoundAnnot>;
    /**
     *
     * @method PDFNet.SoundAnnot.createAtPoint
     * @param {PDFNet.SDFDoc} doc
     * @param {PDFNet.Point} pos
     * @return {Promise<PDFNet.SoundAnnot>} A promise that resolves to an object of type: "SoundAnnot"
     */
    static createAtPoint(doc: PDFNet.SDFDoc, pos: PDFNet.Point): Promise<PDFNet.SoundAnnot>;
    /**
     * Returns the sound object of the Sound annotation.
     *
     * @method PDFNet.SoundAnnot#getSoundStream
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an SDF object representing a sound stream.
     * @note The sound stream is to be played when the Sound
     * annotation is activated.
     */
    getSoundStream(): Promise<PDFNet.Obj>;
    /**
     * sets the sound object of the Sound annotation.
     *
     * @method PDFNet.SoundAnnot#setSoundStream
     * @param {PDFNet.Obj} icon An SDF object representing a sound stream.
     * @note The sound stream is to be played when the Sound
     * annotation is activated.
     */
    setSoundStream(icon: PDFNet.Obj): void;
    /**
     * Returns the Icon of the Sound annotation.
     *
     * @method PDFNet.SoundAnnot#getIcon
     * @return {Promise<number>} A promise that resolves to a value of the "Icon" enum.
     * Default value: e_Speaker.
     * @note The Icon defines the appearance associated with the Sound annotation.
     * The annotation's appearance stream, if present, will take
     * precedence over this entry.
     * @example Return value enum:
     * <pre>
     * PDFNet.SoundAnnot.Icon = {
     * 	e_Speaker : 0
     * 	e_Mic : 1
     * 	e_Unknown : 2
     * }
     * </pre>
     */
    getIcon(): Promise<number>;
    /**
     * sets the Icon of the Sound annotation.
     *(Optional)
     *
     * @method PDFNet.SoundAnnot#setIcon
     * @param {number} [type]
     * <pre>
     * PDFNet.SoundAnnot.Icon = {
     * 	e_Speaker : 0
     * 	e_Mic : 1
     * 	e_Unknown : 2
     * }
     * </pre>
     * A value of the "Icon" enumeration type specifying the icon to display.
     * Default value: e_Speaker.
     * @note The Icon defines the appearance associated with the Sound annotation.
     * The annotation's appearance stream, if present, will take
     * precedence over this entry.
     */
    setIcon(type?: number): void;
    /**
     * Returns the Icon name of the Sound annotation.
     *
     * @method PDFNet.SoundAnnot#getIconName
     * @return {Promise<string>} A promise that resolves to a string denoting the Icon name of the Sound annotation.
     * @note The following Icon names are equivalent
     * to predefined Icons from the enum "Icon":
     * "Speaker" = e_Speaker
     * "Mic" = e_Mic
     * "Unknown" = e_Unknown
     * The Icon defines the appearance associated with the Sound annotation.
     * Names other than mentioned above do not have predefined icon appearances.
     * The annotation's appearance stream, if present, will take
     * precedence over this entry.
     */
    getIconName(): Promise<string>;
    /**
     * sets the Icon name of the Sound annotation.
     *(Optional)
     *
     * @method PDFNet.SoundAnnot#setIconName
     * @param {string} type A string denoting the Icon name of the Sound annotation.
     * @note The following Icon names are equivalent
     * to predefined types from the enum "Icon":
     * "Speaker" = e_Speaker
     * "Mic" = e_Mic
     * "Unknown" = e_Unknown
     * The Icon defines the appearance associated with the Sound annotation.
     * Names other than mentioned above do not have predefined icon appearances.
     * The annotation's appearance stream, if present, will take
     * precedence over this entry.
     */
    setIconName(type: string): void;
  }
  /**
   * Square annotation is used to display a rectangle on the page. When opened,
   * a square annotation can display a pop-up window containing the text of the
   * associated note. The rectangle may be inscribed and possibly padded within the
   * annotation rectangle defined by the annotation dictionary's Rect entry.
   * @class
   * @name SquareAnnot
   * @memberof PDFNet
   */
  class SquareAnnot {
    /**
     * creates an Square annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.SquareAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.SquareAnnot>} A promise that resolves to an object of type: "SquareAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.SquareAnnot>;
    /**
     * creates a Square annotation and initializes it using given annotation object.
     * @method PDFNet.SquareAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Square annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.SquareAnnot>} A promise that resolves to an object of type: "SquareAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.SquareAnnot>;
    /**
     * Creates a new Square annotation in the specified document.
     *
     * @method PDFNet.SquareAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the annotation's bounds, in user space coordinates.
     *
     * @return {Promise<PDFNet.SquareAnnot>} A promise that resolves to a newly created blank Square annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.SquareAnnot>;
    /**
     *
     * @method PDFNet.SquareAnnot#getInteriorColor
     * @return {Promise<PDFNet.ColorPt>} A promise that resolves to an object of type: "ColorPt"
     */
    getInteriorColor(): Promise<PDFNet.ColorPt>;
    /**
     *
     * @method PDFNet.SquareAnnot#getInteriorColorCompNum
     * @return {Promise<number>} A promise that resolves to an object of type: "number"
     */
    getInteriorColorCompNum(): Promise<number>;
    /**
     *
     * @method PDFNet.SquareAnnot#setInteriorColorDefault
     * @param {PDFNet.ColorPt} col
     */
    setInteriorColorDefault(col: PDFNet.ColorPt): void;
    /**
     *
     * @method PDFNet.SquareAnnot#setInteriorColor
     * @param {PDFNet.ColorPt} col
     * @param {number} numcomp
     */
    setInteriorColor(col: PDFNet.ColorPt, numcomp: number): void;
    /**
     *
     * @method PDFNet.SquareAnnot#getContentRect
     * @return {Promise<PDFNet.Rect>} A promise that resolves to an object of type: "Rect"
     */
    getContentRect(): Promise<PDFNet.Rect>;
    /**
     *
     * @method PDFNet.SquareAnnot#setContentRect
     * @param {PDFNet.Rect} cr
     */
    setContentRect(cr: PDFNet.Rect): void;
    /**
     *
     * @method PDFNet.SquareAnnot#getPadding
     * @return {Promise<PDFNet.Rect>} A promise that resolves to an object of type: "Rect"
     */
    getPadding(): Promise<PDFNet.Rect>;
    /**
     *
     * @method PDFNet.SquareAnnot#setPadding
     * @param {PDFNet.Rect} cr
     */
    setPadding(cr: PDFNet.Rect): void;
  }
  /**
   * A Squiggly annotation shows as a wavy line segment across the bottom
   * of a word or a group of contiguous words.
   * @class
   * @name SquigglyAnnot
   * @memberof PDFNet
   */
  class SquigglyAnnot {
    /**
     * creates a Squiggly annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.SquigglyAnnot.createFromObj
     * @param {PDFNet.Obj} d The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.SquigglyAnnot>} A promise that resolves to an object of type: "SquigglyAnnot"
     */
    static createFromObj(d: PDFNet.Obj): Promise<PDFNet.SquigglyAnnot>;
    /**
     * creates a Squiggly annotation and initializes it using given annotation object.
     * @method PDFNet.SquigglyAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Squiggly annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.SquigglyAnnot>} A promise that resolves to an object of type: "SquigglyAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.SquigglyAnnot>;
    /**
     * Creates a new Squiggly annotation in the specified document.
     *
     * @method PDFNet.SquigglyAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the Popup annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the Popup annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.SquigglyAnnot>} A promise that resolves to a newly created blank Squiggly annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.SquigglyAnnot>;
  }
  /**
   * Stamper is a utility class that can be used to stamp PDF pages with text, images,
   * or vector art (including another PDF page) in only a few lines of code.
   *
   * Although Stamper is very simple to use compared to ElementBuilder/ElementWriter
   * it is not as powerful or flexible. In case you need full control over PDF creation
   * use ElementBuilder/ElementWriter to add new content to existing PDF pages as
   * shown in the ElementBuilder sample project.
   * @class
   * @name Stamper
   * @memberof PDFNet
   */
  class Stamper {
    /**
     * Stamper constructor
     *
     * @method PDFNet.Stamper.create
     * @param {number} size_type
     * <pre>
     * PDFNet.Stamper.SizeType = {
     * 	e_relative_scale : 1
     * 	e_absolute_size : 2
     * 	e_font_size : 3
     * }
     * </pre>
     * Specifies how the stamp will be sized
     *		-e_relative_scale: Stamp size is relative to the size of the crop box of
     *		the destination page. 'a' is a percentage of the width of the crop box
     *		(e.g.: 0.5 is 50% of the width of the crop box) 'b' is a percentage of the
     *		height of the crop box. If 'a' <= 0 then only b will be used. If 'b' <= 0
     *		then only 'a' will be used.
     *
     *		-e_absolute_scale: Stamp size is explicitly set. 'a' sets the width of
     *		of the stamp's bounding box. 'b' sets the height of the stamp's bounding
     *		box. The width and height are constant, regardless of the size of the
     *		destination page's bounding box.
     *
     *		-e_font_size: This type only applies to text stamps. 'a' sets the font
     *		size. 'b' is ignored.
     * @param {number} a @see size_type
     * @param {number} b @see size_type
     * @return {Promise<PDFNet.Stamper>} A promise that resolves to an object of type: "Stamper"
     */
    static create(size_type: number, a: number, b: number): Promise<PDFNet.Stamper>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.Stamper#destroy
     */
    destroy(): void;
    /**
     * Stamps an image to the given destination document at the set of page numbers
     *
     * @method PDFNet.Stamper#stampImage
     * @param {PDFNet.PDFDoc} dest_doc The document being stamped
     * @param {PDFNet.Image} img The image that is being stamped to the document
     * @param {PDFNet.PageSet} dest_pages The set of pages in the document being stamped
     */
    stampImage(dest_doc: PDFNet.PDFDoc, img: PDFNet.Image, dest_pages: PDFNet.PageSet): void;
    /**
     * Stamps a PDF page to the given destination document at the set of page numbers
     *
     * @method PDFNet.Stamper#stampPage
     * @param {PDFNet.PDFDoc} dest_doc The document being stamped
     * @param {PDFNet.Page} page The page that is being stamped to the document
     * @param {PDFNet.PageSet} dest_pages The set of pages in the document being stamped
     */
    stampPage(dest_doc: PDFNet.PDFDoc, page: PDFNet.Page, dest_pages: PDFNet.PageSet): void;
    /**
     * Stamps text to the given destination document at the set of page numbers
     *
     * @method PDFNet.Stamper#stampText
     * @param {PDFNet.PDFDoc} dest_doc The document being stamped
     * @param {string} txt The image that is being stamped to the document
     * @param {PDFNet.PageSet} dest_pages The set of pages in the document being stamped
     */
    stampText(dest_doc: PDFNet.PDFDoc, txt: string, dest_pages: PDFNet.PageSet): void;
    /**
     *
     * Defines the font of the stamp. (This only applies to text-based stamps)
     *
     * @method PDFNet.Stamper#setFont
     * @param {PDFNet.Font} font The font of the text stamp
     */
    setFont(font: PDFNet.Font): void;
    /**
     * Sets the font color (This only effects text-based stamps)
     *
     * @method PDFNet.Stamper#setFontColor
     * @param {PDFNet.ColorPt} font_color The color of the font
     */
    setFontColor(font_color: PDFNet.ColorPt): void;
    /**
     * Sets the text alignment (note: this only applies to text watermarks)
     *
     * @method PDFNet.Stamper#setTextAlignment
     * @param {number} text_alignment
     * <pre>
     * PDFNet.Stamper.TextAlignment = {
     * 	e_align_left : -1
     * 	e_align_center : 0
     * 	e_align_right : 1
     * }
     * </pre>
     * Enumerator for text alignment (e_left, e_center, e_right)
     */
    setTextAlignment(text_alignment: number): void;
    /**
     * Sets the opacity value for the stamp
     *
     * @method PDFNet.Stamper#setOpacity
     * @param {number} opacity The opacity value of the stamp
     */
    setOpacity(opacity: number): void;
    /**
     * Rotates the stamp by the given number of degrees
     *
     * @method PDFNet.Stamper#setRotation
     * @param {number} rotation Rotation in degrees
     */
    setRotation(rotation: number): void;
    /**
     * Specifies if the stamp is to be stamped in the background or the foreground.
     *
     * @method PDFNet.Stamper#setAsBackground
     * @param {boolean} background A flag specifying if the stamp should be added
     * as a background layer to the destination page
     */
    setAsBackground(background: boolean): void;
    /**
     * Specifies if the stamp is to be stamped as an annotation.
     *
     * @method PDFNet.Stamper#setAsAnnotation
     * @param {boolean} annotation A flag specifying if the stamp should be added
     * as an annotation or not
     *
     * @note Stamps created with this setting do not work with SetAsBackground,
     * HasStamps, and DeleteStamps, if annotation is true.
     */
    setAsAnnotation(annotation: boolean): void;
    /**
     * @method PDFNet.Stamper#showsOnScreen
     * @param {boolean} on_screen Specifies if the watermark will be displayed on screen
     */
    showsOnScreen(on_screen: boolean): void;
    /**
     * @method PDFNet.Stamper#showsOnPrint
     * @param {boolean} on_print Specifies if the watermark will be displayed when printed
     */
    showsOnPrint(on_print: boolean): void;
    /**
     * Sets the alignment for the x and y variables.
     *
     * @method PDFNet.Stamper#setAlignment
     * @see SetPosition
     *
     * @param {number} horizontal_alignment
     * <pre>
     * PDFNet.Stamper.HorizontalAlignment = {
     * 	e_horizontal_left : -1
     * 	e_horizontal_center : 0
     * 	e_horizontal_right : 1
     * }
     * </pre>
     * Can be set to e_left, e_center or e_right
     *		e_left:	horizontal_distance measures the distance between the left edge of the stamp's
     *			bounding box and the left edge of the crop box
     *		e_center: horizontal_distance measures the distance between the horizontal bisector of the
     *			stamp's bounding box and the horizontal bisector of the crop box
     *		e_right: horizontal_distance measures the distance between the right edge of the stamp's
     *			bounding box and the right edge of the crop box
     *
     * @param {number} vertical_alignment
     * <pre>
     * PDFNet.Stamper.VerticalAlignment = {
     * 	e_vertical_bottom : -1
     * 	e_vertical_center : 0
     * 	e_vertical_top : 1
     * }
     * </pre>
     * Can be set to e_top, e_center or e_bottom
     *		e_bottom: vertical_distance measures the distance between the bottom edge of the stamp's
     *			bounding box and the bottom edge of the crop box
     *		e_center: vertical_distance measures the distance between the vertical bisector of the
     *			stamp's bounding box and the vertical bisector of the crop box
     *		e_top: vertical_distance measures the distance between the top edge of the stamp's
     *			bounding box and the top edge of the crop box
     */
    setAlignment(horizontal_alignment: number, vertical_alignment: number): void;
    /**
     *
     * @method PDFNet.Stamper#setPosition
     * @param {number} x
     * @param {number} y
     * @param {boolean} [use_percentage]
     */
    setPosition(x: number, y: number, use_percentage?: boolean): void;
    /**
     *
     * @method PDFNet.Stamper#setSize
     * @param {number} size_type
     * <pre>
     * PDFNet.Stamper.SizeType = {
     * 	e_relative_scale : 1
     * 	e_absolute_size : 2
     * 	e_font_size : 3
     * }
     * </pre>
     * @param {number} a
     * @param {number} b
     */
    setSize(size_type: number, a: number, b: number): void;
    /**
     * Deletes PDFTron stamps from document at given page numbers
     *
     * @method PDFNet.Stamper.deleteStamps
     * @param {PDFNet.PDFDoc} doc The document to delete stamps from
     * @param {PDFNet.PageSet} page_set The set of pages to delete stamps from
     */
    static deleteStamps(doc: PDFNet.PDFDoc, page_set: PDFNet.PageSet): void;
    /**
     * Returns true if the given set of pages has at least one stamp
     *
     * @method PDFNet.Stamper.hasStamps
     * @param {PDFNet.PDFDoc} doc The document that's being checked
     * @param {PDFNet.PageSet} page_set The set of page that's being checked
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    static hasStamps(doc: PDFNet.PDFDoc, page_set: PDFNet.PageSet): Promise<boolean>;
  }
  /**
   * A StrikeOut annotation shows as a line segment crossing out
   * a word or a group of contiguous words.
   * @class
   * @name StrikeOutAnnot
   * @memberof PDFNet
   */
  class StrikeOutAnnot {
    /**
     * creates a StrikeOut annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.StrikeOutAnnot.createFromObj
     * @param {PDFNet.Obj} d The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.StrikeOutAnnot>} A promise that resolves to an object of type: "StrikeOutAnnot"
     */
    static createFromObj(d: PDFNet.Obj): Promise<PDFNet.StrikeOutAnnot>;
    /**
     * creates a StrikeOut annotation and initializes it using given annotation object.
     * @method PDFNet.StrikeOutAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the StrikeOut annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.StrikeOutAnnot>} A promise that resolves to an object of type: "StrikeOutAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.StrikeOutAnnot>;
    /**
     * Creates a new StrikeOut annotation in the specified document.
     *
     * @method PDFNet.StrikeOutAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the Popup annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the Popup annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.StrikeOutAnnot>} A promise that resolves to a newly created blank StrikeOut annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.StrikeOutAnnot>;
  }
  /**
   * A text annotation represents a "sticky note" attached to a point in
   * the PDF document. When closed, the annotation shall appear as an icon;
   * when open, it shall display a pop-up window containing the text of
   * the note in a font and size chosen by the conforming reader.
   * Text annotations do not scale and rotate with the page (i.e. they should
   * behave as if the NoZoom and NoRotate annotation flags).
   * @class
   * @name TextAnnot
   * @memberof PDFNet
   */
  class TextAnnot {
    /**
     * creates a Text annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.TextAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.TextAnnot>} A promise that resolves to an object of type: "TextAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.TextAnnot>;
    /**
     * creates a Text annotation and initializes it using given annotation object.
     * @method PDFNet.TextAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Text annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.TextAnnot>} A promise that resolves to an object of type: "TextAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.TextAnnot>;
    /**
     *
     * @method PDFNet.TextAnnot.createAtPoint
     * @param {PDFNet.SDFDoc} doc
     * @param {PDFNet.Point} pos
     * @return {Promise<PDFNet.TextAnnot>} A promise that resolves to an object of type: "TextAnnot"
     */
    static createAtPoint(doc: PDFNet.SDFDoc, pos: PDFNet.Point): Promise<PDFNet.TextAnnot>;
    /**
     * Constructor
     * @method PDFNet.TextAnnot.create
     * @param {PDFNet.SDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @return {Promise<PDFNet.TextAnnot>} A promise that resolves to an object of type: "TextAnnot"
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.TextAnnot>;
    /**
     * Returns the initial status of the Text annotation.
     *
     * @method PDFNet.TextAnnot#isOpen
     * @return {Promise<boolean>} A promise that resolves to a boolean value that specifies whether the annotation shall
     * initially be displayed as opened.
     * Default value: false.
     */
    isOpen(): Promise<boolean>;
    /**
     * sets the initial status of the Text annotation.
     * (Optional)
     *
     * @method PDFNet.TextAnnot#setOpen
     * @param {boolean} isopen A boolean value that specifies whether the annotation shall
     * initially be displayed as opened.
     * Default value: false.
     */
    setOpen(isopen: boolean): void;
    /**
     * Returns the type of the icon associated with the Text annotation.
     *
     * @method PDFNet.TextAnnot#getIcon
     * @return {Promise<number>} A promise that resolves to a value of the enumeration type "Icon".
     * Default value: e_Note.
     * @note The annotation's appearance stream,
     * if present, will take precedence over this entry.
     * @example Return value enum:
     * <pre>
     * PDFNet.TextAnnot.Icon = {
     * 	e_Comment : 0
     * 	e_Key : 1
     * 	e_Help : 2
     * 	e_NewParagraph : 3
     * 	e_Paragraph : 4
     * 	e_Insert : 5
     * 	e_Note : 6
     * 	e_Unknown : 7
     * }
     * </pre>
     */
    getIcon(): Promise<number>;
    /**
     * sets the type of the icon associated with the Text annotation.
     * (Optional)
     *
     * @method PDFNet.TextAnnot#setIcon
     * @param {number} [icon]
     * <pre>
     * PDFNet.TextAnnot.Icon = {
     * 	e_Comment : 0
     * 	e_Key : 1
     * 	e_Help : 2
     * 	e_NewParagraph : 3
     * 	e_Paragraph : 4
     * 	e_Insert : 5
     * 	e_Note : 6
     * 	e_Unknown : 7
     * }
     * </pre>
     * A value of the enum "Icon" type.
     * Default value: e_Note.
     * @note The annotation's appearance stream,
     * if present, will take precedence over this entry.
     */
    setIcon(icon?: number): void;
    /**
     *
     * @method PDFNet.TextAnnot#setIconDefault
     */
    setIconDefault(): void;
    /**
     * Returns the name of the icon associated with the Text annotation.
     *
     * @method PDFNet.TextAnnot#getIconName
     * @return {Promise<string>} A promise that resolves to a string denoting the name of the icon.
     * @note The following icon names are equivalent
     * to predefined icon types from the enum "Icon":
     * "Comment" = e_Comment
     * "Key" = e_Key
     * "Help" = e_Help
     * "NewParagraph" = e_NewParagraph
     * "Paragraph" = e_Paragraph
     * "Insert" = e_Insert
     * "Note" = e_Note
     * "Unknown" = e_Unknown
     * Names other than mentioned above do not have predefined icon appearances.
     * @note The annotation's appearance stream,
     * if present, will take precedence over this entry.
     */
    getIconName(): Promise<string>;
    /**
     * sets the name of the icon associated with the Text annotation.
     * (Optional)
     *
     * @method PDFNet.TextAnnot#setIconName
     * @param {string} icon A string denoting the name of the icon.
     * @note The following icon names are equivalent
     * to predefined icon types from the enum "Icon":
     * "Comment" = e_Comment
     * "Key" = e_Key
     * "Help" = e_Help
     * "NewParagraph" = e_NewParagraph
     * "Paragraph" = e_Paragraph
     * "Insert" = e_Insert
     * "Note" = e_Note
     * "Unknown" = e_Unknown
     * Names other than mentioned above do not have predefined icon appearances.
     * @note The annotation's appearance stream,
     * if present, will take precedence over this entry.
     */
    setIconName(icon: string): void;
    /**
     * Returns the string indicating the state of the Text annotation.
     * (PDF 1.5)
     *
     * @method PDFNet.TextAnnot#getState
     * @return {Promise<string>} A promise that resolves to a string that indicates the state of the Text annotation when first loaded.
     * Default: "Unmarked" if StateModel is "Marked"; "None" if StateModel is "Review".
     */
    getState(): Promise<string>;
    /**
     * Sets the string indicating the state of the Text annotation.
     * (Optional; PDF 1.5 )
     *
     * @method PDFNet.TextAnnot#setState
     * @param {string} [state] A string that indicates the state of the Text annotation when first loaded.
     * Default: "Unmarked" if StateModel is "Marked"; "None" if StateModel is "Review".
     */
    setState(state?: string): void;
    /**
     * Returns the string indicating the state model of the Text annotation.
     * (PDF 1.5)
     *
     * @method PDFNet.TextAnnot#getStateModel
     * @return {Promise<string>} A promise that resolves to a string containing the state model name either "Marked" or "Review".
     */
    getStateModel(): Promise<string>;
    /**
     * Sets the string indicating the state model of the Text annotation.
     * (Required if State is present, otherwise optional; PDF 1.5 )
     *
     * @method PDFNet.TextAnnot#setStateModel
     * @param {string} sm A string containing the state model name either "Marked" or "Review".
     */
    setStateModel(sm: string): void;
  }
  /**
   * TextExtractor is used to analyze a PDF page and extract words and logical
   * structure within a given region. The resulting list of lines and words can
   * be traversed element by element or accessed as a string buffer. The class
   * also includes utility methods to extract PDF text as HTML or XML.
   *
   * Possible use case scenarios for TextExtractor include:
   *  - Converting PDF pages to text or XML for content repurposing.
   *  - Searching PDF pages for specific words or keywords.
   *  - Indexing large PDF repositories for indexing or content
   *    retrieval purposes (i.e. implementing a PDF search engine).
   *  - Classifying or summarizing PDF documents based on their text content.
   *  - Finding specific words for content editing purposes (such as splitting pages
   *    based on keywords etc).
   *
   * The main task of TextExtractor is to interpret PDF pages and offer a
   * simple to use API to:
   *  - Normalize all text content to Unicode.
   *  - Extract inferred logical structure (word by word, line by line,
   *    or paragraph by paragraph).
   *  - Extract positioning information for every line, word, or a glyph.
   *  - Extract style information (such as information about the font, font size,
   *    font styles, etc) for every line, word, or a glyph.
   *  - Control the content analysis process. A number of options (such as
   *    removal of text obscured by images) is available to let the user
   *    direct the flow of content recognition algorithms that will meet their
   *    requirements.
   *  - Offer utility methods to convert PDF page content to text, XML, or HTML.
   *
   * Note: TextExtractor is analyzing only textual content of the page.
   * This means that the rasterized (e.g. in scanned pages) or vectorized
   * text (where glyphs are converted to path outlines) will not be recognized
   * as text. Please note that it is still possible to extract this content
   * using pdftron.PDF.ElementReader interface.
   *
   * In some cases TextExtractor may extract text that does not appear to
   * be on the visible page (e.g. when text is obscured by an image or a
   * rectangle). In these situations it is possible to use processing flags
   * such as 'e_remove_hidden_text' and 'e_no_invisible_text' to remove
   * hidden text.
   *
   * A sample use case (in C++):
   *
   * <pre>
   * ... Initialize PDFNet ...
   * PDFDoc doc(filein);
   * doc.InitSecurityHandler();
   * Page page = *doc.PageBegin();
   * TextExtractor txt;
   * txt.Begin(page, 0, TextExtractor::e_remove_hidden_text);
   * UString text;
   * txt.GetAsText(text);
   * // or traverse words one by one...
   * TextExtractor::Line line = txt.GetFirstLine(), lend;
   * TextExtractor::Word word, wend;
   * for (; line!=lend; line=line.GetNextLine()) {
   *  for (word=line.GetFirstWord(); word!=wend; word=word.GetNextWord()) {
   *    text.Assign(word.GetString(), word.GetStringLen());
   *    cout << text << '\n';
   *  }
   * }
   * </pre>
   *
   * A sample use case (in C#):
   *
   * <pre>
   * ... Initialize PDFNet ...
   * PDFDoc doc = new PDFDoc(filein);
   * doc.InitSecurityHandler();
   * Page page = doc.PageBegin().Current();
   * TextExtractor txt = new TextExtractor();
   * txt.Begin(page, 0, TextExtractor.ProcessingFlags.e_remove_hidden_text);
   * string text = txt.GetAsText();
   * // or traverse words one by one...
   * TextExtractor.Word word;
   * for (TextExtractor.Line line = txt.GetFirstLine(); line.IsValid(); line=line.GetNextLine()) {
   *   for (word=line.GetFirstWord(); word.IsValid(); word=word.GetNextWord()) {
   *     Console.WriteLine(word.GetString());
   *   }
   * }
   * </pre>
   *
   * For full sample code, please take a look at TextExtract sample project.
   * @class
   * @name TextExtractor
   * @memberof PDFNet
   */
  class TextExtractor {
    /**
     * Constructor and destructor
     * @method PDFNet.TextExtractor.create
     * @return {Promise<PDFNet.TextExtractor>} A promise that resolves to an object of type: "TextExtractor"
     */
    static create(): Promise<PDFNet.TextExtractor>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.TextExtractor#destroy
     */
    destroy(): void;
    /**
     * Start reading the page.
     *
     * @method PDFNet.TextExtractor#begin
     * @param {PDFNet.Page} page Page to read.
     * @param {PDFNet.Rect} [clip_ptr] A pointer to the optional clipping rectangle. This
     * parameter can be used to selectively read text from a given rectangle.
     * @param {number} [flags] A list of ProcessingFlags used to control text extraction
     * algorithm.
     */
    begin(page: PDFNet.Page, clip_ptr?: PDFNet.Rect, flags?: number): void;
    /**
     * @method PDFNet.TextExtractor#getWordCount
     * @return {Promise<number>} A promise that resolves to the number of words on the page.
     */
    getWordCount(): Promise<number>;
    /**
     * Sets the directionality of text extractor.
     * Must be called before the processing of a page started.
     * @method PDFNet.TextExtractor#setRightToLeftLanguage
     * @param {boolean} rtl mode reverses the directionality of TextExtractor algorithm.
     */
    setRightToLeftLanguage(rtl: boolean): void;
    /**
     * @method PDFNet.TextExtractor#getRightToLeftLanguage
     * @return {Promise<boolean>} A promise that resolves to the directionality of text extractor.
     */
    getRightToLeftLanguage(): Promise<boolean>;
    /**
     * get all words in the current selection as a single string.
     *
     * @method PDFNet.TextExtractor#getAsText
     * @param {boolean} [dehyphen] If true, finds and removes hyphens that split words
     * across two lines. Hyphens are often used a the end of lines as an
     * indicator that a word spans two lines. Hyphen detection enables removal
     * of hyphen character and merging of text runs to form a single word.
     * This option has no effect on Tagged PDF files.
     * @return {Promise<string>} A promise that resolves to an object of type: "string"
     */
    getAsText(dehyphen?: boolean): Promise<string>;
    /**
     * Get all the characters that intersect an annotation.
     *
     * @method PDFNet.TextExtractor#getTextUnderAnnot
     * @param {PDFNet.Annot} annot The annotation to intersect with.
     * @return {Promise<string>} A promise that resolves to an object of type: "string"
     */
    getTextUnderAnnot(annot: PDFNet.Annot): Promise<string>;
    /**
     * get text content in a form of an XML string.
     *
     * @method PDFNet.TextExtractor#getAsXML
     * @param {number} [xml_output_flags] flags controlling XML output. For more
     * information, please see TextExtract::XMLOutputFlags.
     *
     * XML output will be encoded in UTF-8 and will have the following
     * structure:
     * <pre>
     * <Page num="1 crop_box="0, 0, 612, 792" media_box="0, 0, 612, 792" rotate="0">
     *  <Flow id="1">
     *   <Para id="1">
     *    <Line box="72, 708.075, 467.895, 10.02" style="font-family:Calibri; font-size:10.02; color: #000000;">
     *      <Word box="72, 708.075, 30.7614, 10.02">PDFNet</Word>
     *      <Word box="106.188, 708.075, 15.9318, 10.02">SDK</Word>
     *      <Word box="125.617, 708.075, 6.22242, 10.02">is</Word>
     *      ...
     *    </Line>
     *   </Para>
     *  </Flow>
     * </Page>
     * </pre>
     *
     * The above XML output was generated by passing the following union of
     * flags in the call to GetAsXML():
     *   (TextExtractor::e_words_as_elements | TextExtractor::e_output_bbox | TextExtractor::e_output_style_info)
     *
     * In case 'xml_output_flags' was not specified, the default XML output
     * would look as follows:
     *
     * <Page num="1 crop_box="0, 0, 612, 792" media_box="0, 0, 612, 792" rotate="0">
     * <Flow id="1">
     * <Para id="1">
     *     <Line>PDFNet SDK is an amazingly comprehensive, high-quality PDF developer toolkit...</Line>
     *     <Line>levels. Using the PDFNet PDF library, ...</Line>
     *     ...
     *   </Para>
     *  </Flow>
     * </Page>
     * </pre>
     * @return {Promise<string>} A promise that resolves to an object of type: "string"
     */
    getAsXML(xml_output_flags?: number): Promise<string>;
    /**
     * @method PDFNet.TextExtractor#getNumLines
     * @return {Promise<number>} A promise that resolves to the number of lines of text on the selected page.
     */
    getNumLines(): Promise<number>;
    /**
     * @method PDFNet.TextExtractor#getFirstLine
     * @return {Promise<PDFNet.TextExtractorLine>} A promise that resolves to the first line of text on the selected page.
     *
     * @note To traverse the list of all text lines on the page use line.GetNextLine().
     * @note To traverse the list of all word on a given line use line.GetFirstWord().
     */
    getFirstLine(): Promise<PDFNet.TextExtractorLine>;
    /**
     * [CURRENTLY BUGGED]
     * @method PDFNet.TextExtractor#getQuads
     * @param {PDFNet.Matrix2D} mtx The quadrilateral representing a tight bounding box
     * @param {number} quads n
     * @param {number} quads_size n
     * for this word (in unrotated page coordinates).
     */
    getQuads(mtx: PDFNet.Matrix2D, quads: number, quads_size: number): void;
  }
  /**
   * TextExtractor::Line object represents a line of text on a PDF page.
   * Each line consists of a sequence of words, and each words in one or
   * more styles.
   * @class
   * @name TextExtractorLine
   * @memberof PDFNet
   */
  class TextExtractorLine {
    /**
     * @method PDFNet.TextExtractorLine#getNumWords
     * @return {Promise<number>} A promise that resolves to the number of words in this line.
     */
    getNumWords(): Promise<number>;
    /**
     * @method PDFNet.TextExtractorLine#isSimpleLine
     * @return {Promise<boolean>} A promise that resolves to true is this line is not rotated (i.e. if the
     * quadrilaterals returned by GetBBox() and GetQuad() coincide).
     */
    isSimpleLine(): Promise<boolean>;
    /**
     * @method PDFNet.TextExtractorLine#getFirstWord
     * @return {Promise<PDFNet.TextExtractorWord>} A promise that resolves to the first word in the line.
     * @note To traverse the list of all words on this line use word.GetNextWord().
     */
    getFirstWord(): Promise<PDFNet.TextExtractorWord>;
    /**
     * @method PDFNet.TextExtractorLine#getWord
     * @return {Promise<PDFNet.TextExtractorWord>} A promise that resolves to the i-th word in this line.
     * @param {number} word_idx A integer representing the index of the word to get.
     */
    getWord(word_idx: number): Promise<PDFNet.TextExtractorWord>;
    /**
     * @method PDFNet.TextExtractorLine#getNextLine
     * @return {Promise<PDFNet.TextExtractorLine>} A promise that resolves to the next line on the page.
     */
    getNextLine(): Promise<PDFNet.TextExtractorLine>;
    /**
     * @method PDFNet.TextExtractorLine#getCurrentNum
     * @return {Promise<number>} A promise that resolves to the index of this line of the current page.
     */
    getCurrentNum(): Promise<number>;
    /**
     * @method PDFNet.TextExtractorLine#getStyle
     * @return {Promise<PDFNet.TextExtractorStyle>} A promise that resolves to predominant style for this line.
     */
    getStyle(): Promise<PDFNet.TextExtractorStyle>;
    /**
     * @method PDFNet.TextExtractorLine#getParagraphID
     * @return {Promise<number>} A promise that resolves to the unique identifier for a paragraph or column
     * that this line belongs to. This information can be used to
     * identify which lines belong to which paragraphs.
     */
    getParagraphID(): Promise<number>;
    /**
     * @method PDFNet.TextExtractorLine#getFlowID
     * @return {Promise<number>} A promise that resolves to the unique identifier for a paragraph or column
     * that this line belongs to. This information can be used to
     * identify which lines/paragraphs belong to which flows.
     */
    getFlowID(): Promise<number>;
    /**
     * @method PDFNet.TextExtractorLine#endsWithHyphen
     * @return {Promise<boolean>} A promise that resolves to true is this line of text ends with a hyphen (i.e. '-'),
     * false otherwise.
     */
    endsWithHyphen(): Promise<boolean>;
    /**
     * Constructor
     * @method PDFNet.TextExtractorLine.create
     * @return {Promise<PDFNet.TextExtractorLine>} A promise that resolves to an object of type: "TextExtractorLine"
     */
    static create(): Promise<PDFNet.TextExtractorLine>;
    /**
     * @method PDFNet.TextExtractorLine#isValid
     * @return {Promise<boolean>} A promise that resolves to true if this is a valid line, false otherwise.
     */
    isValid(): Promise<boolean>;
    /**
     * @method PDFNet.TextExtractorLine#getBBox
     * @return {Promise<PDFNet.Rect>} A promise that resolves to the bounding box for this line (in unrotated page
     * coordinates).
     */
    getBBox(): Promise<PDFNet.Rect>;
    /**
     * Gets the quadrilateral bounding box for the line (in unrotated page coordinates)
     * @method PDFNet.TextExtractorLine#getQuad
     */
    getQuad(): void;
  }
  /**
   * A class representing predominant text style associated with a
   * given Line, a Word, or a Glyph. The class includes information about
   * the font, font size, font styles, text color, etc.
   * @class
   * @name TextExtractorStyle
   * @memberof PDFNet
   */
  class TextExtractorStyle {
    /**
     * @method PDFNet.TextExtractorStyle#getFont
     * @return {Promise<PDFNet.Obj>} A promise that resolves to low-level PDF font object. A high level font object can
     * be instantiated as follows:
     * In C++: pdftron.PDF.Font f(style.GetFont())
     * In C#: pdftron.PDF.Font f = new pdftron.PDF.Font(style.GetFont());
     */
    getFont(): Promise<PDFNet.Obj>;
    /**
     * @method PDFNet.TextExtractorStyle#getFontName
     * @return {Promise<string>} A promise that resolves to the font name used to draw the selected text.
     */
    getFontName(): Promise<string>;
    /**
     * @method PDFNet.TextExtractorStyle#getFontSize
     * @return {Promise<number>} A promise that resolves to the font size used to draw the selected text as it
     * appears on the output page.
     * @note Unlike the 'font size' in the graphics state (pdftron.PDF.GState)
     * the returned font size accounts for the effects CTM, text matrix,
     * and other graphics state attributes that can affect the appearance of
     * text.
     */
    getFontSize(): Promise<number>;
    /**
     * @method PDFNet.TextExtractorStyle#getWeight
     * @return {Promise<number>} A promise that resolves to the weight (thickness) component of the fully-qualified font name
     * or font specifier. The possible values are 100, 200, 300, 400, 500, 600, 700,
     * 800, or 900, where each number indicates a weight that is at least as dark as
     * its predecessor. A value of 400 indicates a normal weight; 700 indicates bold.
     * Note: The specific interpretation of these values varies from font to font.
     * For example, 300 in one font may appear most similar to 500 in another.
     */
    getWeight(): Promise<number>;
    /**
     * @method PDFNet.TextExtractorStyle#isItalic
     * @return {Promise<boolean>} A promise that resolves to true if glyphs have dominant vertical strokes that are slanted.
     * @note the return value corresponds to the state of 'italic' flag in the 'Font Descriptor'.
     */
    isItalic(): Promise<boolean>;
    /**
     * @method PDFNet.TextExtractorStyle#isSerif
     * @return {Promise<boolean>} A promise that resolves to true if glyphs have serifs, which are short strokes drawn at an angle on the top
     * and bottom of glyph stems.
     * @note the return value corresponds to the state of 'serif' flag in the 'Font Descriptor'.
     */
    isSerif(): Promise<boolean>;
    /**
     * Constructor
     * @method PDFNet.TextExtractorStyle.create
     * @return {Promise<PDFNet.TextExtractorStyle>} A promise that resolves to an object of type: "TextExtractorStyle"
     */
    static create(): Promise<PDFNet.TextExtractorStyle>;
    /**
     * Copy Constructor
     * @method PDFNet.TextExtractorStyle#copy
     * @return {Promise<PDFNet.TextExtractorStyle>} A promise that resolves to an object of type: "TextExtractorStyle"
     */
    copy(): Promise<PDFNet.TextExtractorStyle>;
    /**
     * @method PDFNet.TextExtractorStyle#getColor
     * @return {Promise<ColorPt>} A promise that resolves to text color in RGB color space.
     */
    getColor(): Promise<ColorPt>;
  }
  /**
   * TextExtractor::Word object represents a word on a PDF page.
   * Each word contains a sequence of characters in one or more styles
   * (see TextExtractor::Style).
   * @class
   * @name TextExtractorWord
   * @memberof PDFNet
   */
  class TextExtractorWord {
    /**
     * @method PDFNet.TextExtractorWord#getNumGlyphs
     * @return {Promise<number>} A promise that resolves to the number of glyphs in this word.
     */
    getNumGlyphs(): Promise<number>;
    /**
     * @method PDFNet.TextExtractorWord#getCharStyle
     * @param {number} char_idx The index of a character in this word.
     * @return {Promise<PDFNet.TextExtractorStyle>} A promise that resolves to the style associated with a given character.
     */
    getCharStyle(char_idx: number): Promise<PDFNet.TextExtractorStyle>;
    /**
     * @method PDFNet.TextExtractorWord#getStyle
     * @return {Promise<PDFNet.TextExtractorStyle>} A promise that resolves to predominant style for this word.
     */
    getStyle(): Promise<PDFNet.TextExtractorStyle>;
    /**
     * @method PDFNet.TextExtractorWord#getStringLen
     * @return {Promise<number>} A promise that resolves to the number of characters in this word.
     */
    getStringLen(): Promise<number>;
    /**
     * @method PDFNet.TextExtractorWord#getNextWord
     * @return {Promise<PDFNet.TextExtractorWord>} A promise that resolves to the next word on the current line.
     */
    getNextWord(): Promise<PDFNet.TextExtractorWord>;
    /**
     * @method PDFNet.TextExtractorWord#getCurrentNum
     * @return {Promise<number>} A promise that resolves to the index of this word of the current line. A word that
     * starts the line will return 0, whereas the last word in the line
     * will return (line.GetNumWords()-1).
     */
    getCurrentNum(): Promise<number>;
    /**
     * Constructor
     * @method PDFNet.TextExtractorWord.create
     * @return {Promise<PDFNet.TextExtractorWord>} A promise that resolves to an object of type: "TextExtractorWord"
     */
    static create(): Promise<PDFNet.TextExtractorWord>;
    /**
     * @method PDFNet.TextExtractorWord#isValid
     * @return {Promise<boolean>} A promise that resolves to true if this is a valid word, false otherwise.
     */
    isValid(): Promise<boolean>;
    /**
     * @method PDFNet.TextExtractorWord#getBBox
     * @return {Promise<PDFNet.Rect>} A promise that resolves to the bounding box for this word (in unrotated page
     * coordinates).
     */
    getBBox(): Promise<PDFNet.Rect>;
    /**
     * @method PDFNet.TextExtractorWord#getQuad
     * @return {Promise<PDFNet.QuadPoint>} A promise that resolves to the quadrilateral representing a tight
     * bounding box for this word (in unrotated page coordinates).
     */
    getQuad(): Promise<PDFNet.QuadPoint>;
    /**
     * @method PDFNet.TextExtractorWord#getString
     * @return {Promise<string>} A promise that resolves to the content of this word represented as a string.
     * coordinates).
     */
    getString(): Promise<string>;
  }
  /**
   * A TextMarkup is a base class for highlight, underline,
   * strikeout, and squiggly annotations.
   * @class
   * @name TextMarkupAnnot
   * @memberof PDFNet
   */
  class TextMarkupAnnot {
    /**
     * creates a TextMarkup annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.TextMarkupAnnot.createFromObj
     * @param {PDFNet.Obj} d The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.TextMarkupAnnot>} A promise that resolves to an object of type: "TextMarkupAnnot"
     */
    static createFromObj(d: PDFNet.Obj): Promise<PDFNet.TextMarkupAnnot>;
    /**
     * creates a TextMarkup annotation and initializes it using given annotation object.
     * @method PDFNet.TextMarkupAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the TextMarkup annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.TextMarkupAnnot>} A promise that resolves to an object of type: "TextMarkupAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.TextMarkupAnnot>;
    /**
     * Returns the number of QuadPoints in the QuadPoints array of the TextMarkup annotation
     * (PDF 1.6)
     *
     * @method PDFNet.TextMarkupAnnot#getQuadPointCount
     * @return {Promise<number>} A promise that resolves to the number of QuadPoints.
     * @note QuadPoints specify the coordinates of quadrilaterals in default user space. Each quadrilateral
     * encompasses a word or group of contiguous words in the text underlying the annotation.
     * The four points(p1, p2, p3, p4) of a QuadPoint specify the quadrilateral's four vertices
     * in counterclockwise order.
     * The text needs to be oriented with respect to the edge connecting points (p1) and (p2).
     * The annotation dictionary's Appearance entry, if present, takes precedence over QuadPoints.
     */
    getQuadPointCount(): Promise<number>;
    /**
     * Returns the QuadPoint located at a certain index of the QuadPoint array.
     * (PDF 1.6)
     *
     * @method PDFNet.TextMarkupAnnot#getQuadPoint
     * @param {number} idx The index where the QuadPoint is located. The index starts at zero and must be less than return value of GetQuadPointCount().
     * @return {Promise<PDFNet.QuadPoint>} A promise that resolves to the QuadPoint located at a certain index of the QuadPoint array of the TextMarkup annotation.
     * @note QuadPoints specify the coordinates of quadrilaterals in default user space. Each quadrilateral
     * encompasses a word or group of contiguous words in the text underlying the annotation.
     * The four points(p1, p2, p3, p4) of a QuadPoint specify the quadrilateral's four vertices
     * in counterclockwise order.
     * The text needs to be oriented with respect to the edge connecting points (p1) and (p2).
     * The annotation dictionary's Appearance entry, if present, takes precedence over QuadPoints.
     */
    getQuadPoint(idx: number): Promise<PDFNet.QuadPoint>;
    /**
     * sets the QuadPoint to be located at a certain index of the QuadPoint array.
     * (Optional; PDF 1.6 )
     *
     * @method PDFNet.TextMarkupAnnot#setQuadPoint
     * @param {number} idx The index where the QuadPoint is to be located (the index is counted from 0).
     * @param {PDFNet.QuadPoint} qp The QuadPoint to be located at a certain index of the QuadPoint array of the TextMarkup annotation.
     * @attention To make this QuadPoint compatible with Adobe Acrobat|Reader, you can use either clockwise or counterclockwise order,
     * but the points p3 and p4 must be swapped. This is because those readers do not follow the PDF specification for TextMarkup QuadPoints.
     * @note An array of n QuadPoints specifying the coordinates of n quadrilaterals in default user space. Each quadrilateral shall
     * encompasses a word or group of contiguous words in the text underlying the annotation. The coordinates for each quadrilateral
     * shall be given in the order p1, p2, p3, p4 specifying the quadrilateral's four vertices in counterclockwise order.
     * The text shall be oriented with respect to the edge connecting points (p1) and (p2).
     * The annotation dictionary's Appearance(AP) entry, if present, shall take precedence over QuadPoints.
     */
    setQuadPoint(idx: number, qp: PDFNet.QuadPoint): void;
  }
  /**
   * TextSearch searches through a PDF document for a user-given search pattern.
   * The current implementation supports both verbatim search and the search
   * using regular expressions, whose detailed syntax can be found at:
   *
   * http://www.boost.org/doc/libs/release/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html
   *
   * TextSearch also provides users with several useful search modes and extra
   * information besides the found string that matches the pattern. TextSearch
   * can either keep running until a matched string is found or be set to return
   * periodically in order for the caller to perform any necessary updates
   * (e.g., UI updates). It is also worth mentioning that the search modes can be
   * changed on the fly while searching through a document.
   *
   * Possible use case scenarios for TextSearch include:
   *  - Guide users of a PDF viewer (e.g. implemented by PDFViewCtrl) to places
   *    where they are intersted in;
   *  - Find interested PDF documents which contain certain patterns;
   *  - Extract interested information (e.g., credit card numbers) from a set of files;
   *  - Extract Highlight information (refer to the Highlights class for details) from
   *    files for external use.
   *
   * Note:
   *  - Since hyphens ('-') are frequently used in PDF documents to concatenate the two
   *    broken pieces of a word at the end of a line, for example
   *
   *	  "TextSearch is powerful for finding patterns in PDF files; yes, it is really pow-
   *     erful."
   *
   *    a search for "powerful" should return both instances. However, not all end-of-line
   *    hyphens are hyphens added to connect a broken word; some of them could be "real"
   *    hyphens. In addition, an input search pattern may also contain hyphens that complicate
   *    the situation. To tackle this problem, the following conventions are adopted:
   *
   *    a)When in the verbatim search mode and the pattern contains no hyphen, a matching
   *      string is returned if it is exactly the same or it contains end-of-line
   *      or start-of-line hyphens. For example, as mentioned above, a search for "powerful"
   *      would return both instances.
   *    b)When in verbatim search mode and the pattern contains one or multiple hyphens, a
   *      matching string is returned only if the string matches the pattern exactly. For
   *      example, a search for "pow-erful" will only return the second instance, and a search
   *      for "power-ful" will return nothing.
   *    c)When searching using regular expressions, hyphens are not taken care implicitly.
   *      Users should take care of it themselves. For example, in order to find both the
   *      "powerful" instances, the input pattern can be "pow-{0,1}erful".
   *
   * A sample use case (in C++):
   *
   * <pre>
   * //... Initialize PDFNet ...
   * PDFDoc doc(filein);
   * doc.InitSecurityHandler();
   * int page_num;
   * char buf[32];
   * UString result_str, ambient_string;
   * Highlights hlts;
   * TextSearch txt_search;
   * TextSearch::Mode mode = TextSearch::e_whole_word | TextSearch::e_page_stop;
   * UString pattern( "joHn sMiTh" );
   *
   * //PDFDoc doesn't allow simultaneous access from different threads. If this
   * //document could be used from other threads (e.g., the rendering thread inside
   * //PDFView/PDFViewCtrl, if used), it is good practice to lock it.
   * //Notice: don't forget to call doc.Unlock() to avoid deadlock.
   * doc.Lock();
   *
   * txt_search.Begin( doc, pattern, mode );
   * while ( true )
   * {
   *	   SearchResult result = code = txt_search.Run(page_num, result_str, ambient_string, hlts );
   *	   if ( code == TextSearch::e_found )
   *	   {
   *		   result_str.ConvertToAscii(buf, 32, true);
   *		   cout << "found one instance: " << char_buf << endl;
   *	   }
   *	   else
   *	   {
   *		   break;
   *	   }
   * }
   *
   * //unlock the document to avoid deadlock.
   * doc.UnLock();
   * </pre>
   *
   *
   * For a full sample, please take a look at the TextSearch sample project.
   * @class
   * @name TextSearch
   * @memberof PDFNet
   */
  class TextSearch {
    /**
     * Constructor and destructor.
     * @method PDFNet.TextSearch.create
     * @return {Promise<PDFNet.TextSearch>} A promise that resolves to an object of type: "TextSearch"
     */
    static create(): Promise<PDFNet.TextSearch>;
    /**
     * Frees the native memory of the object.
     * @method PDFNet.TextSearch#destroy
     */
    destroy(): void;
    /**
     *
     * @method PDFNet.TextSearch#begin
     * @param {PDFNet.PDFDoc} doc
     * @param {string} pattern
     * @param {number} mode
     * @param {number} [start_page]
     * @param {number} [end_page]
     * @return {Promise<boolean>} A promise that resolves to an object of type: "boolean"
     */
    begin(doc: PDFNet.PDFDoc, pattern: string, mode: number, start_page?: number, end_page?: number): Promise<boolean>;
    /**
     * Set the current search pattern. Note that it is not necessary to call this method since
     * the search pattern is already set when calling the Begin() method. This method is provided
     * for users to change the search pattern while searching through a document.
     *
     * @method PDFNet.TextSearch#setPattern
     * @param {string} pattern the search pattern to set.
     * @return {Promise<boolean>} A promise that resolves to true if the setting has succeeded.
     */
    setPattern(pattern: string): Promise<boolean>;
    /**
     * Retrieve the current search mode.
     * @method PDFNet.TextSearch#getMode
     * @return {Promise<number>} A promise that resolves to the current search mode.
     */
    getMode(): Promise<number>;
    /**
     * set the current search mode. For example, the following code turns on the regular
     * expressions:
     *
     *	TextSearch ts;
     *   ...
     *   TextSearch::Mode mode = ts.GetMode();
     *   mode |= TextSearch::e_reg_expression;
     *   ts.SetMode(mode);
     *   ...
     *
     * @method PDFNet.TextSearch#setMode
     * @param {number} mode the search mode to set.
     */
    setMode(mode: number): void;
    /**
     * Tells TextSearch that language is from right to left.
     * @method PDFNet.TextSearch#setRightToLeftLanguage
     * @param {boolean} flag Set to true if the language is right to left.
     */
    setRightToLeftLanguage(flag: boolean): void;
    /**
     * Retrieve the number of the current page that is searched in.
     * If the returned value is -1, it indicates the search process has not been initialized
     * (e.g., Begin() is not called yet); if the returned value is 0, it indicates the search
     * process has finished, and if the returned value is positive, it is a valid page number.
     * @method PDFNet.TextSearch#getCurrentPage
     * @return {Promise<number>} A promise that resolves to the current page number.
     */
    getCurrentPage(): Promise<number>;
    /**
     * Runs a search on the document for a certain string. Make sure to call
     * TextSearch.begin(doc, pattern, mode) with the proper parameters
     * before calling TextSearch.run()
     *
     * The resolved object that TextSearch.run() returns contains the following objects:
     * page_num - The number of the page with the match
     * out_str - The string that matches the search parameter
     * ambient_str - The ambient string of the found string (computed only if e_ambient_string is set)
     * highlights - The Highlights info associated with the match (computed only if 'e_highlight' is set)
     * code - Number representing the status of the search.
     *	- 0 - e_done, reached end of document.
     *	- 1 - e_page, reached end of page. (if set to return by specifying mode 'e_page_stop')
     *	- 2 - e_found, found an instance matching the search pattern
     * @method PDFNet.TextSearch#run
     * @return {Promise<Object>} A promise that resolves to an object containing the page_num, out_str
     * ambient_str, highlights, and result code.
     */
    run(): Promise<object>;
  }
  /**
   * [Missing documentation]
   * @class
   * @name TextWidget
   * @memberof PDFNet
   */
  class TextWidget {
    /**
     * Constructor
     * @method PDFNet.TextWidget.create
     * @param {PDFNet.PDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @param {string} [field_name]
     * @return {Promise<PDFNet.TextWidget>} A promise that resolves to an object of type: "TextWidget"
     */
    static create(doc: PDFNet.PDFDoc, pos: PDFNet.Rect, field_name?: string): Promise<PDFNet.TextWidget>;
    /**
     *
     * @method PDFNet.TextWidget.createWithField
     * @param {PDFNet.PDFDoc} doc
     * @param {PDFNet.Rect} pos
     * @param {PDFNet.Field} field
     * @return {Promise<PDFNet.TextWidget>} A promise that resolves to an object of type: "TextWidget"
     */
    static createWithField(doc: PDFNet.PDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.TextWidget>;
    /**
     *
     * @method PDFNet.TextWidget.createFromObj
     * @param {PDFNet.Obj} [obj]
     * @return {Promise<PDFNet.TextWidget>} A promise that resolves to an object of type: "TextWidget"
     */
    static createFromObj(obj?: PDFNet.Obj): Promise<PDFNet.TextWidget>;
    /**
     *
     * @method PDFNet.TextWidget.createFromAnnot
     * @param {PDFNet.Annot} annot
     * @return {Promise<PDFNet.TextWidget>} A promise that resolves to an object of type: "TextWidget"
     */
    static createFromAnnot(annot: PDFNet.Annot): Promise<PDFNet.TextWidget>;
    /**
     *
     * @method PDFNet.TextWidget#setText
     * @param {string} text
     */
    setText(text: string): void;
    /**
     *
     * @method PDFNet.TextWidget#getText
     * @return {Promise<string>} A promise that resolves to an object of type: "string"
     */
    getText(): Promise<string>;
  }
  /**
   * The class TrustVerificationResult.
   * The detailed result of a trust verification step of a verification
   * operation performed on a digital signature.
   * @class
   * @name TrustVerificationResult
   * @memberof PDFNet
   */
  class TrustVerificationResult {
    /**
     * Retrieves the trust verification status.
     *
     * @method PDFNet.TrustVerificationResult#wasSuccessful
     * @return {Promise<boolean>} A promise that resolves to a boolean representing whether or not the trust verification operation was successful. Whether trust-related warnings are treated as errors or not depend on the VerificationOptions used for the verification operation.
     */
    wasSuccessful(): Promise<boolean>;
    /**
     * Retrieves a string representation of the details of the trust verification status.
     *
     * @method PDFNet.TrustVerificationResult#getResultString
     * @return {Promise<string>} A promise that resolves to a string.
     */
    getResultString(): Promise<string>;
    /**
     * Retrieves the reference-time used for trust verification as an epoch time.
     *
     * @method PDFNet.TrustVerificationResult#getTimeOfTrustVerification
     * @return {Promise<number>} A promise that resolves to an integral value representing an epoch time.
     */
    getTimeOfTrustVerification(): Promise<number>;
    /**
     * Retrieves the type of reference-time used for trust verification.
     *
     * @method PDFNet.TrustVerificationResult#getTimeOfTrustVerificationEnum
     * @return {Promise<number>} A promise that resolves to an enumerated value representing the type of reference-time used for trust verification.
     * @example Return value enum:
     * <pre>
     * PDFNet.VerificationOptions.TimeMode = {
     * 	e_signing : 0
     * 	e_timestamp : 1
     * 	e_current : 2
     * }
     * </pre>
     */
    getTimeOfTrustVerificationEnum(): Promise<number>;
    /**
     * Destructor
     * @method PDFNet.TrustVerificationResult#destroy
     */
    destroy(): void;
  }
  /**
   * An Underline annotation shows as a line segment across the bottom
   * of a word or a group of contiguous words.
   * @class
   * @name UnderlineAnnot
   * @memberof PDFNet
   */
  class UnderlineAnnot {
    /**
     * creates an Underline annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.UnderlineAnnot.createFromObj
     * @param {PDFNet.Obj} d The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.UnderlineAnnot>} A promise that resolves to an object of type: "UnderlineAnnot"
     */
    static createFromObj(d: PDFNet.Obj): Promise<PDFNet.UnderlineAnnot>;
    /**
     * creates an Underline annotation and initializes it using given annotation object.
     * @method PDFNet.UnderlineAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Underline annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.UnderlineAnnot>} A promise that resolves to an object of type: "UnderlineAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.UnderlineAnnot>;
    /**
     * Creates a new Underline annotation in the specified document.
     *
     * @method PDFNet.UnderlineAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the Underline annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the Underline annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.UnderlineAnnot>} A promise that resolves to a newly created blank Underline annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.UnderlineAnnot>;
  }
  /**
   * The class UndoManager.
   * Undo-redo interface; one-to-one mapped to document
   * @class
   * @name UndoManager
   * @memberof PDFNet
   */
  class UndoManager {
    /**
     * Forget all changes in this manager (without changing the document).
     *
     * @method PDFNet.UndoManager#discardAllSnapshots
     * @return {Promise<PDFNet.DocSnapshot>} A promise that resolves to an invalid DocSnapshot.
     */
    discardAllSnapshots(): Promise<PDFNet.DocSnapshot>;
    /**
     * Restores to the previous snapshot point, if there is one.
     *
     * @method PDFNet.UndoManager#undo
     * @return {Promise<PDFNet.ResultSnapshot>} A promise that resolves to the resulting snapshot id.
     */
    undo(): Promise<PDFNet.ResultSnapshot>;
    /**
     * Returns whether it is possible to undo from the current snapshot.
     *
     * @method PDFNet.UndoManager#canUndo
     * @return {Promise<boolean>} A promise that resolves to whether it is possible to undo from the current snapshot.
     */
    canUndo(): Promise<boolean>;
    /**
     * Gets the previous state of the document. This state may be invalid if it is impossible to undo.
     *
     * @method PDFNet.UndoManager#getNextUndoSnapshot
     * @return {Promise<PDFNet.DocSnapshot>} A promise that resolves to the previous state of the document. This state may be invalid if it is impossible to undo.
     */
    getNextUndoSnapshot(): Promise<PDFNet.DocSnapshot>;
    /**
     * Restores to the next snapshot, if there is one.
     *
     * @method PDFNet.UndoManager#redo
     * @return {Promise<PDFNet.ResultSnapshot>} A promise that resolves to a representation of the transition to the next snapshot, if there is one.
     */
    redo(): Promise<PDFNet.ResultSnapshot>;
    /**
     * Returns a boolean indicating whether it is possible to redo from the current snapshot.
     *
     * @method PDFNet.UndoManager#canRedo
     * @return {Promise<boolean>} A promise that resolves to a boolean indicating whether it is possible to redo from the current snapshot.
     */
    canRedo(): Promise<boolean>;
    /**
     * Gets the next state of the document. This state may be invalid if it is impossible to redo.
     *
     * @method PDFNet.UndoManager#getNextRedoSnapshot
     * @return {Promise<PDFNet.DocSnapshot>} A promise that resolves to the next state of the document. This state may be invalid if it is impossible to redo.
     */
    getNextRedoSnapshot(): Promise<PDFNet.DocSnapshot>;
    /**
     * Creates a snapshot of document state, transitions to the new snapshot.
     *
     * @method PDFNet.UndoManager#takeSnapshot
     * @return {Promise<PDFNet.ResultSnapshot>} A promise that resolves to a representation of the transition.
     */
    takeSnapshot(): Promise<PDFNet.ResultSnapshot>;
    /**
     * Destructor
     * @method PDFNet.UndoManager#destroy
     */
    destroy(): void;
  }
  /**
   * The class VerificationOptions.
   * Options pertaining to digital signature verification.
   * @class
   * @name VerificationOptions
   * @memberof PDFNet
   */
  class VerificationOptions {
    /**
     * Constructs a set of options for digital signature verification.
     *
     * @method PDFNet.VerificationOptions.create
     * @param {number} in_level
     * <pre>
     * PDFNet.VerificationOptions.SecurityLevel = {
     * 	e_compatibility_and_archiving : 0
     * 	e_maximum : 1
     * }
     * </pre>
     * -- the general security level to use. Sets other security settings internally.
     * @return {Promise<PDFNet.VerificationOptions>} A promise that resolves to an object of type: "VerificationOptions"
     */
    static create(in_level: number): Promise<PDFNet.VerificationOptions>;
    /**
     *
     * @method PDFNet.VerificationOptions#addTrustedCertificate
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} in_binary_DER_certificate_buf
     */
    addTrustedCertificate(
      in_binary_DER_certificate_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray,
    ): void;
    /**
     *
     * @method PDFNet.VerificationOptions#removeTrustedCertificate
     * @param {ArrayBuffer|Int8Array|Uint8Array|Uint8ClampedArray} in_binary_DER_certificate_buf
     */
    removeTrustedCertificate(
      in_binary_DER_certificate_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray,
    ): void;
    /**
     * Sets a flag that can turn on or off the verification of the permissibility of any modifications made to the document after the signing of the digital signature being verified, in terms of the document and field permissions specified by the digital signature being verified.
     *
     * @method PDFNet.VerificationOptions#enableModificationVerification
     * @param {boolean} in_on_or_off -- A boolean.
     */
    enableModificationVerification(in_on_or_off: boolean): void;
    /**
     * Sets a flag that can turn on or off the verification of the digest (cryptographic hash) component of a digital signature.
     *
     * @method PDFNet.VerificationOptions#enableDigestVerification
     * @param {boolean} in_on_or_off -- A boolean.
     */
    enableDigestVerification(in_on_or_off: boolean): void;
    /**
     * Sets a flag that can turn on or off the verification of the trust status of a digital signature.
     *
     * @method PDFNet.VerificationOptions#enableTrustVerification
     * @param {boolean} in_on_or_off -- A boolean.
     */
    enableTrustVerification(in_on_or_off: boolean): void;
    /**
     * Destructor
     * @method PDFNet.VerificationOptions#destroy
     */
    destroy(): void;
    /**
     * Adds a certificate from a url to the store of trusted certificates inside this options object.
     * @method PDFNet.VerificationOptions.addTrustedCertificateFromURL
     * @param {string} url The url from which to download the file
     * @param {Object} [options] Additional options
     * @param {boolean} options.withCredentials Whether to set the withCredentials property on the XMLHttpRequest
     */
    static addTrustedCertificateFromURL(
      url: string,
      options?: {
        withCredentials: boolean;
      },
    ): void;
  }
  /**
   * The class VerificationResult.
   * The result of a verification operation performed on a digital signature.
   * @class
   * @name VerificationResult
   * @memberof PDFNet
   */
  class VerificationResult {
    /**
     *
     * @method PDFNet.VerificationResult#getDigitalSignatureField
     * @return {Promise<PDFNet.DigitalSignatureField>} A promise that resolves to an object of type: "DigitalSignatureField"
     */
    getDigitalSignatureField(): Promise<PDFNet.DigitalSignatureField>;
    /**
     * Retrieves the main verification status. The main status is determined based on the other statuses.
     *
     * @method PDFNet.VerificationResult#getVerificationStatus
     * @return {Promise<boolean>} A promise that resolves to a boolean representing whether or not the verification operation was completely successful.
     */
    getVerificationStatus(): Promise<boolean>;
    /**
     * Retrieves the document-related result condition associated with a digital signature verification operation.
     *
     * @method PDFNet.VerificationResult#getDocumentStatus
     * @return {Promise<number>} A promise that resolves to a DocumentStatus-type enumeration value.
     * @example Return value enum:
     * <pre>
     * PDFNet.VerificationResult.DocumentStatus = {
     * 	e_no_error : 0
     * 	e_corrupt_file : 1
     * 	e_unsigned : 2
     * 	e_bad_byteranges : 3
     * 	e_corrupt_cryptographic_contents : 4
     * }
     * </pre>
     */
    getDocumentStatus(): Promise<number>;
    /**
     * Retrieves the digest-related result condition associated with a digital signature verification operation.
     *
     * @method PDFNet.VerificationResult#getDigestStatus
     * @return {Promise<number>} A promise that resolves to a DigestStatus-type enumeration value.
     * @example Return value enum:
     * <pre>
     * PDFNet.VerificationResult.DigestStatus = {
     * 	e_digest_invalid : 0
     * 	e_digest_verified : 1
     * 	e_digest_verification_disabled : 2
     * 	e_weak_digest_algorithm_but_digest_verifiable : 3
     * 	e_no_digest_status : 4
     * 	e_unsupported_encoding : 5
     * }
     * </pre>
     */
    getDigestStatus(): Promise<number>;
    /**
     * Retrieves the trust-related result condition associated with a digital signature verification operation.
     *
     * @method PDFNet.VerificationResult#getTrustStatus
     * @return {Promise<number>} A promise that resolves to a TrustStatus-type enumeration value.
     * @example Return value enum:
     * <pre>
     * PDFNet.VerificationResult.TrustStatus = {
     * 	e_trust_verified : 0
     * 	e_untrusted : 1
     * 	e_trust_verification_disabled : 2
     * 	e_no_trust_status : 3
     * }
     * </pre>
     */
    getTrustStatus(): Promise<number>;
    /**
     * Retrieves the result condition about permissions checks performed on any unsigned modifications associated with a digital signature verification operation.
     *
     * @method PDFNet.VerificationResult#getPermissionsStatus
     * @return {Promise<number>} A promise that resolves to a ModificationPermissionsStatus-type enumeration value.
     * @example Return value enum:
     * <pre>
     * PDFNet.VerificationResult.ModificationPermissionsStatus = {
     * 	e_invalidated_by_disallowed_changes : 0
     * 	e_has_allowed_changes : 1
     * 	e_unmodified : 2
     * 	e_permissions_verification_disabled : 3
     * 	e_no_permissions_status : 4
     * }
     * </pre>
     */
    getPermissionsStatus(): Promise<number>;
    /**
     * Retrieves the detailed result associated with the trust step of the verification operation that returned this VerificationResult, if such a detailed trust result is available. Must call HasTrustVerificationResult first and check for a true result.
     *
     * @method PDFNet.VerificationResult#getTrustVerificationResult
     * @return {Promise<PDFNet.TrustVerificationResult>} A promise that resolves to an optional TrustVerificationResult.
     */
    getTrustVerificationResult(): Promise<PDFNet.TrustVerificationResult>;
    /**
     * Returns whether there is a detailed TrustVerificationResult in this VerificationResult or not.
     *
     * @method PDFNet.VerificationResult#hasTrustVerificationResult
     * @return {Promise<boolean>} A promise that resolves to a boolean.
     */
    hasTrustVerificationResult(): Promise<boolean>;
    /**
     * Retrieves a list of informational structures regarding any disallowed changes that have been made to the document since the signature associated with this verification result was signed.
     *
     * @method PDFNet.VerificationResult#getDisallowedChanges
     * @return {Promise<Array<PDFNet.DisallowedChange>>} A promise that resolves to a collection of DisallowedChange objects.
     */
    getDisallowedChanges(): Promise<PDFNet.DisallowedChange[]>;
    /**
     * Retrieves an enumeration value representing the digest algorithm used to sign the signature that is associated with this verification result.
     *
     * @method PDFNet.VerificationResult#getSignersDigestAlgorithm
     * @return {Promise<number>} A promise that resolves to a DigestAlgorithm enumeration value.
     * @example Return value enum:
     * <pre>
     * PDFNet.DigestAlgorithm.Type = {
     * 	e_SHA1 : 0
     * 	e_SHA256 : 1
     * 	e_SHA384 : 2
     * 	e_SHA512 : 3
     * 	e_RIPEMD160 : 4
     * 	e_unknown_digest_algorithm : 5
     * }
     * </pre>
     */
    getSignersDigestAlgorithm(): Promise<number>;
    /**
     * Destructor
     * @method PDFNet.VerificationResult#destroy
     */
    destroy(): void;
  }
  /**
   * [Missing documentation]
   * @class
   * @name ViewChangeCollection
   * @memberof PDFNet
   */
  class ViewChangeCollection {}
  /**
   * A Watermark annotation is an annotation that is printed at a fixed
   * size and position on a page, regardless of the dimensions of the printed page.
   * @class
   * @name WatermarkAnnot
   * @memberof PDFNet
   */
  class WatermarkAnnot {
    /**
     * creates a Watermark annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.WatermarkAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.WatermarkAnnot>} A promise that resolves to an object of type: "WatermarkAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.WatermarkAnnot>;
    /**
     * creates a Watermark annotation and initializes it using given annotation object.
     * @method PDFNet.WatermarkAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Watermark annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.WatermarkAnnot>} A promise that resolves to an object of type: "WatermarkAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.WatermarkAnnot>;
    /**
     * Creates a new Watermark annotation in the specified document.
     *
     * @method PDFNet.WatermarkAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the annotation's bounds in default user space units.
     *
     * @return {Promise<PDFNet.WatermarkAnnot>} A promise that resolves to a newly created blank Watermark annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect): Promise<PDFNet.WatermarkAnnot>;
  }
  /**
   * Interactive forms use widget annotations (PDF 1.2) to represent the appearance
   * of fields and to manage user interactions. As a convenience, when a field has
   * only a single associated widget annotation, the contents of the field dictionary
   * and the annotation dictionary may be merged into a single dictionary containing
   * entries that pertain to both a field and an annotation.
   * NOTE This presents no ambiguity, since the contents of the two kinds of
   * dictionaries do not conflict.
   * @class
   * @name WidgetAnnot
   * @memberof PDFNet
   */
  class WidgetAnnot {
    /**
     * Creates a new widget annotation in the specified document.
     *
     * @method PDFNet.WidgetAnnot.create
     * @param {PDFNet.SDFDoc} doc A document to which the annotation is added.
     * @param {PDFNet.Rect} pos A rectangle specifying the annotation's bounds in default user space units.
     * @param {PDFNet.Field} field A form field associated with this widget.
     *
     * @return {Promise<PDFNet.WidgetAnnot>} A promise that resolves to a newly created blank widget annotation.
     */
    static create(doc: PDFNet.SDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.WidgetAnnot>;
    /**
     * creates a widget annotation and initializes it using given Cos/SDF object.
     * @method PDFNet.WidgetAnnot.createFromObj
     * @param {PDFNet.Obj} [d] The Cos/SDF object to initialze the annotation with.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.WidgetAnnot>} A promise that resolves to an object of type: "WidgetAnnot"
     */
    static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.WidgetAnnot>;
    /**
     * creates a widget annotation and initializes it using given annotation object.
     * @method PDFNet.WidgetAnnot.createFromAnnot
     * @param {PDFNet.Annot} ann Annot object used to initialize the Widget annotation.
     * @note The constructor does not copy any data, but is instead the logical
     * equivalent of a type cast.
     * @return {Promise<PDFNet.WidgetAnnot>} A promise that resolves to an object of type: "WidgetAnnot"
     */
    static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.WidgetAnnot>;
    /**
     * Returns the field associated with the Widget.
     * @method PDFNet.WidgetAnnot#getField
     * @return {Promise<PDFNet.Field>} A promise that resolves to a Field object.
     */
    getField(): Promise<PDFNet.Field>;
    /**
     * @method PDFNet.WidgetAnnot#getHighlightingMode
     * @return {Promise<number>} A promise that resolves to the HighlightingMode of the widget annotation.
     * @note The annotation's highlighting mode is the visual effect that shall be used
     * when the mouse button is pressed or held down inside its active area
     * @note A highlighting mode other than e_push will override any down appearance
     * defined for the annotation.
     * @default e_invert.
     * @example Return value enum:
     * <pre>
     * PDFNet.WidgetAnnot.HighlightingMode = {
     * 	e_none : 0
     * 	e_invert : 1
     * 	e_outline : 2
     * 	e_push : 3
     * 	e_toggle : 4
     * }
     * </pre>
     */
    getHighlightingMode(): Promise<number>;
    /**
     * sets the HighlightingMode for the widget annotation.
     * @method PDFNet.WidgetAnnot#setHighlightingMode
     * @note The annotation's highlighting mode is the visual effect that shall be used
     * when the mouse button is pressed or held down inside its active area
     * @param {number} [value]
     * <pre>
     * PDFNet.WidgetAnnot.HighlightingMode = {
     * 	e_none : 0
     * 	e_invert : 1
     * 	e_outline : 2
     * 	e_push : 3
     * 	e_toggle : 4
     * }
     * </pre>
     * New highlighting mode for the widget.
     * @note A highlighting mode other than e_push shall override any down appearance defined
     * for the annotation.
     * Default value: e_invert.
     */
    setHighlightingMode(value?: number): void;
    /**
     * Returns the action of the widget annotation
     *
     * @method PDFNet.WidgetAnnot#getAction
     * @return {Promise<PDFNet.Action>} A promise that resolves to an action object representing the action of the widget annotation
     * that should be performed when the annotation is activated.
     */
    getAction(): Promise<PDFNet.Action>;
    /**
     * Sets the action of the widget annotation
     * (Optional; PDF 1.2 )
     *
     * @method PDFNet.WidgetAnnot#setAction
     * @param {PDFNet.Action} action An action object representing the action of the widget annotation
     * that should be performed when the annotation is activated.
     */
    setAction(action: PDFNet.Action): void;
    /**
     * Returns the border color of the annotation.
     *
     * @method PDFNet.WidgetAnnot#getBorderColor
     * @return {Promise<PDFNet.ColorPt>} A promise that resolves to a color object that denotes the color of the Screen border.
     * @note The color can be in different color spaces: Gray, RGB, or CMYK.
     * Call "GetBorderColorCompNum" to access the color space information corresponding to the border color.
     */
    getBorderColor(): Promise<PDFNet.ColorPt>;
    /**
     * sets the border color of the annotation.
     * (Optional)
     *
     * @method PDFNet.WidgetAnnot#setBorderColor
     * @param {PDFNet.ColorPt} col A color object that denotes the color of the screen border.
     * @param {number} compnum An integer which value indicates the color space used for the parameter c.
     */
    setBorderColor(col: PDFNet.ColorPt, compnum: number): void;
    /**
     * Returns the number indicating border color space of the annotation.
     *
     * @method PDFNet.WidgetAnnot#getBorderColorCompNum
     * @return {Promise<number>} A promise that resolves to an integer indicating a color space value from the ColorSpace::Type enum.
     * That is, 1 corresponding to "e_device_gray",
     * 3 corresponding to "e_device_rgb", and 4 corresponding to "e_device_cmyk".
     * 0 means this annotation had no color assigned.
     */
    getBorderColorCompNum(): Promise<number>;
    /**
     * Returns the number indicating background color space of the annotation.
     *
     * @method PDFNet.WidgetAnnot#getBackgroundColorCompNum
     * @return {Promise<number>} A promise that resolves to an integer indicating a color space value from the ColorSpace::Type enum.
     * That is, 1 corresponding to "e_device_gray",
     * 3 corresponding to "e_device_rgb", and 4 corresponding to "e_device_cmyk" if color space is applicable,
     * 0 means no background color was assigned.
     */
    getBackgroundColorCompNum(): Promise<number>;
    /**
     * Returns the background color of the annotation.
     *
     * @method PDFNet.WidgetAnnot#getBackgroundColor
     * @return {Promise<PDFNet.ColorPt>} A promise that resolves to a color object that denotes the color of the Screen background.
     * @note The color can be in different color spaces: Gray, RGB, or CMYK.
     * Call "GetBackgroundColorCompNum" to access the color space information corresponding to the border color.
     */
    getBackgroundColor(): Promise<PDFNet.ColorPt>;
    /**
     * sets the background color of the annotation.
     * (Optional)
     *
     * @method PDFNet.WidgetAnnot#setBackgroundColor
     * @param {PDFNet.ColorPt} col A color point that denotes the color of the screen background.
     * @param {number} compnum An integer which value indicates the color space used for the parameter c.
     */
    setBackgroundColor(col: PDFNet.ColorPt, compnum: number): void;
    /**
     * Returns static caption text of the annotation.
     *
     * @method PDFNet.WidgetAnnot#getStaticCaptionText
     * @return {Promise<string>} A promise that resolves to a string containing the static caption text of the annotation.
     * @note The static caption is the annotation's normal caption, which
     * shall be displayed when it is not interacting with the user.
     * Unlike the remaining entries with the captions, which apply only to widget
     * annotations associated with pushbutton fields, the Static Caption(CA) entry may be used
     * with any type of button field, including check boxes.
     * @note This property is part of the Widget appearance characteristics dictionary, this dictionary
     * that shall be used in constructing a dynamic appearance stream specifying the annotation's visual
     * presentation on the page.
     */
    getStaticCaptionText(): Promise<string>;
    /**
     * sets static caption text of the annotation.
     * (Optional; button fields only)
     *
     * @method PDFNet.WidgetAnnot#setStaticCaptionText
     * @param {string} contents A string containing the static caption text of the annotation.
     * @note The static caption is the annotation's normal caption, which
     * shall be displayed when it is not interacting with the user.
     * Unlike the remaining entries with the captions, which apply only to widget
     * annotations associated with pushbutton fields, the Static Caption(CA) entry may be used
     * with any type of button field, including check boxes.
     * @note This property is part of the Widget appearance characteristics dictionary, this dictionary
     * that shall be used in constructing a dynamic appearance stream specifying the annotation's visual
     * presentation on the page.
     */
    setStaticCaptionText(contents: string): void;
    /**
     * Returns the rollover caption text of the annotation.
     *
     * @method PDFNet.WidgetAnnot#getRolloverCaptionText
     * @return {Promise<string>} A promise that resolves to a string containing the rollover caption text of the annotation.
     * @note The rollover caption shall be displayed when the user rolls the cursor
     * into its active area without pressing the mouse button.
     */
    getRolloverCaptionText(): Promise<string>;
    /**
     * sets the roll over caption text of the annotation.
     * (Optional; button fields only)
     *
     * @method PDFNet.WidgetAnnot#setRolloverCaptionText
     * @param {string} contents A string containing the roll over caption text of the annotation.
     * @note The rollover caption shall be displayed when the user rolls the cursor
     * into its active area without pressing the mouse button.
     */
    setRolloverCaptionText(contents: string): void;
    /**
     * Returns the button down caption text of the annotation.
     *
     * @method PDFNet.WidgetAnnot#getMouseDownCaptionText
     * @return {Promise<string>} A promise that resolves to a string containing the button down text of the annotation.
     * @note The button down caption shall be displayed when the mouse button is
     * pressed within its active area.
     */
    getMouseDownCaptionText(): Promise<string>;
    /**
     * sets the button down caption text of the annotation.
     * (Optional; button fields only)
     *
     * @method PDFNet.WidgetAnnot#setMouseDownCaptionText
     * @param {string} contents A string containing the button down text of the annotation.
     * @note The button down caption shall be displayed when the mouse button is
     * pressed within its active area.
     */
    setMouseDownCaptionText(contents: string): void;
    /**
     * Returns the static icon associated with the annotation.
     *
     * @method PDFNet.WidgetAnnot#getStaticIcon
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an SDF object that represents the static icon
     * associated with the annotation.
     * @note The static icon object is a form XObject defining the
     * annotation's normal icon, which shall be
     * displayed when it is not interacting with the user.
     */
    getStaticIcon(): Promise<PDFNet.Obj>;
    /**
     * sets the static icon associated with the annotation.
     * (Optional; button fields only)
     *
     * @method PDFNet.WidgetAnnot#setStaticIcon
     * @param {PDFNet.Obj} icon An SDF object that represents the static icon
     * associated with the annotation.
     * @note The static icon object is a form XObject defining the
     * annotation's normal icon, which shall be
     * displayed when it is not interacting with the user.
     */
    setStaticIcon(icon: PDFNet.Obj): void;
    /**
     * Returns the rollover icon associated with the annotation.
     *
     * @method PDFNet.WidgetAnnot#getRolloverIcon
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an SDF object that represents the rollover icon
     * associated with the annotation.
     * @note The rollover icon object is a form XObject defining the
     * annotation's rollover icon, which shall be displayed
     * when the user rolls the cursor into its active area without
     * pressing the mouse button.
     */
    getRolloverIcon(): Promise<PDFNet.Obj>;
    /**
     * sets the rollover icon associated with the annotation.
     * (Optional; button fields only)
     *
     * @method PDFNet.WidgetAnnot#setRolloverIcon
     * @param {PDFNet.Obj} icon An SDF object that represents the rollover icon
     * associated with the annotation.
     * @note The rollover icon object is a form XObject defining the
     * annotation's rollover icon, which shall be displayed
     * when the user rolls the cursor into its active area without
     * pressing the mouse button.
     */
    setRolloverIcon(icon: PDFNet.Obj): void;
    /**
     * Returns the Mouse Down icon associated with the annotation.
     *
     * @method PDFNet.WidgetAnnot#getMouseDownIcon
     * @return {Promise<PDFNet.Obj>} A promise that resolves to an SDF object that represents the Mouse Down icon
     * associated with the annotation.
     * @note The Mouse Down icon object is a form XObject defining the
     * annotation's alternate (down) icon, which shall be displayed
     * when the mouse button is pressed within its active area.
     */
    getMouseDownIcon(): Promise<PDFNet.Obj>;
    /**
     * sets the Mouse Down icon associated with the annotation.
     * (Optional; button fields only)
     *
     * @method PDFNet.WidgetAnnot#setMouseDownIcon
     * @param {PDFNet.Obj} icon An SDF object that represents the Mouse Down icon
     * associated with the annotation.
     * @note The Mouse Down icon object is a form XObject defining the
     * annotation's alternate (down) icon, which shall be displayed
     * when the mouse button is pressed within its active area.
     */
    setMouseDownIcon(icon: PDFNet.Obj): void;
    /**
     * Returns the Scale Type of the annotation.
     *
     * @method PDFNet.WidgetAnnot#getScaleType
     * @return {Promise<number>} A promise that resolves to a value of the "ScaleType" enum which represents the Scale Type of the annotation.
     * Default value: P.
     * @see ScaleType
     * @example Return value enum:
     * <pre>
     * PDFNet.WidgetAnnot.ScaleType = {
     * 	e_Anamorphic : 0
     * 	e_Proportional : 1
     * }
     * </pre>
     */
    getScaleType(): Promise<number>;
    /**
     * sets the Scale Type of the annotation.
     * (Optional)
     *
     * @method PDFNet.WidgetAnnot#setScaleType
     * @param {number} st
     * <pre>
     * PDFNet.WidgetAnnot.ScaleType = {
     * 	e_Anamorphic : 0
     * 	e_Proportional : 1
     * }
     * </pre>
     * An entry of the "ScaleType" enum which represents the Scale Type of the annotation.
     * Default value: P.
     * @see ScaleType
     */
    setScaleType(st: number): void;
    /**
     * Returns the Icon and caption relationship of the  annotation.
     *
     * @method PDFNet.WidgetAnnot#getIconCaptionRelation
     * @return {Promise<number>} A promise that resolves to a value of the "IconCaptionRelation" enum type.
     * Default value: e_NoIcon.
     * @see IconCaptionRelation
     * @example Return value enum:
     * <pre>
     * PDFNet.WidgetAnnot.IconCaptionRelation = {
     * 	e_NoIcon : 0
     * 	e_NoCaption : 1
     * 	e_CBelowI : 2
     * 	e_CAboveI : 3
     * 	e_CRightILeft : 4
     * 	e_CLeftIRight : 5
     * 	e_COverlayI : 6
     * }
     * </pre>
     */
    getIconCaptionRelation(): Promise<number>;
    /**
     * sets the Icon and caption relationship of the  annotation.
     * (Optional; pushbutton fields only)
     *
     * @method PDFNet.WidgetAnnot#setIconCaptionRelation
     * @param {number} icr
     * <pre>
     * PDFNet.WidgetAnnot.IconCaptionRelation = {
     * 	e_NoIcon : 0
     * 	e_NoCaption : 1
     * 	e_CBelowI : 2
     * 	e_CAboveI : 3
     * 	e_CRightILeft : 4
     * 	e_CLeftIRight : 5
     * 	e_COverlayI : 6
     * }
     * </pre>
     * A value of the "IconCaptionRelation" enum type.
     * Default value: e_NoIcon.
     * @see IconCaptionRelation
     */
    setIconCaptionRelation(icr: number): void;
    /**
     * Returns the condition under which the icon should be scaled.
     *
     * @method PDFNet.WidgetAnnot#getScaleCondition
     * @return {Promise<number>} A promise that resolves to a value of the "ScaleCondition" enum type.
     * Default value: e_Always.
     * @see ScaleCondition
     * @example Return value enum:
     * <pre>
     * PDFNet.WidgetAnnot.ScaleCondition = {
     * 	e_Always : 0
     * 	e_WhenBigger : 1
     * 	e_WhenSmaller : 2
     * 	e_Never : 3
     * }
     * </pre>
     */
    getScaleCondition(): Promise<number>;
    /**
     * sets the condition under which the icon should be scaled.
     * (Optional)
     *
     * @method PDFNet.WidgetAnnot#setScaleCondition
     * @param {number} sd
     * <pre>
     * PDFNet.WidgetAnnot.ScaleCondition = {
     * 	e_Always : 0
     * 	e_WhenBigger : 1
     * 	e_WhenSmaller : 2
     * 	e_Never : 3
     * }
     * </pre>
     * A value of the "ScaleCondition" enum type.
     * Default value: e_Always.
     */
    setScaleCondition(sd: number): void;
    /**
     * Returns the "fit full" flag.
     *
     * @method PDFNet.WidgetAnnot#getFitFull
     * @return {Promise<boolean>} A promise that resolves to a boolean value indicating the "fit full" flag value.
     * @note the fit full flag, if true, indicates that the button
     * appearance shall be scaled to fit fully within the bounds of
     * the annotation without taking into consideration the line
     * width of the border.
     * Default value: false.
     */
    getFitFull(): Promise<boolean>;
    /**
     * sets the "fit full" flag.
     * (Optional)
     *
     * @method PDFNet.WidgetAnnot#setFitFull
     * @param {boolean} ff A boolean value indicating the "fit full" flag value.
     * @note the fit full flag, if true, indicates that the button
     * appearance shall be scaled to fit fully within the bounds of
     * the annotation without taking into consideration the line
     * width of the border. Default value: false.
     */
    setFitFull(ff: boolean): void;
    /**
     * Returns the horizontal leftover space of the icon within the annotation.
     *
     * @method PDFNet.WidgetAnnot#getHIconLeftOver
     * @return {Promise<number>} A promise that resolves to a number indicating the horizontal
     * leftover space of the icon within the annotation.
     * @note the horizontal leftover is a number that shall be between
     * 0.0 and 1.0 indicating the fraction of leftover space to allocate at the left.
     * A value of 0.0 shall position the icon at the left of the annotation rectangle.
     * A value of 0.5 shall center it in the horizontal direction within the rectangle.
     * This entry shall be used only if the icon is scaled proportionally.
     * Default value: 0.5.
     */
    getHIconLeftOver(): Promise<number>;
    /**
     * sets the horizontal leftover space of the icon within the annotation.
     * (Optional)
     *
     * @method PDFNet.WidgetAnnot#setHIconLeftOver
     * @param {number} hl A number indicating the horizontal
     * leftover space of the icon within the annotation.
     * @note the horizontal leftover space is a number that shall be between
     * 0.0 and 1.0 indicating the fraction of leftover space to allocate at the left.
     * A value of 0.0 shall position the icon at the left of the annotation rectangle.
     * A value of 0.5 shall center it in the horizontal direction within the rectangle.
     * This entry shall be used only if the icon is scaled proportionally.
     * Default value: 0.5.
     */
    setHIconLeftOver(hl: number): void;
    /**
     * Returns the vertical leftover space of the icon within the annotation.
     *
     * @method PDFNet.WidgetAnnot#getVIconLeftOver
     * @return {Promise<number>} A promise that resolves to a number indicating the vertical
     * leftover space of the icon within the annotation.
     * @note the vertical leftover space is a number that
     * shall be between 0.0 and 1.0 indicating the fraction of leftover
     * space to allocate at the bottom of the icon.
     * A value of 0.0 shall position the icon at the bottom
     * of the annotation rectangle.
     * A value of 0.5 shall center it in the vertical direction within
     * the rectangle.
     * This entry shall be used only if the icon is scaled proportionally.
     * Default value: 0.5.
     */
    getVIconLeftOver(): Promise<number>;
    /**
     * sets the vertical leftover space of the icon within the annotation.
     * (Optional)
     *
     * @method PDFNet.WidgetAnnot#setVIconLeftOver
     * @param {number} vl A number indicating the vertical
     * leftover space of the icon within the annotation.
     * @note the vertical leftover space is a number that
     * shall be between 0.0 and 1.0 indicating the fraction of leftover
     * space to allocate at the bottom of the icon.
     * A value of 0.0 shall position the icon at the bottom
     * of the annotation rectangle.
     * A value of 0.5 shall center it in the vertical direction within
     * the rectangle.
     * This entry shall be used only if the icon is scaled proportionally.
     * Default value: 0.5.
     */
    setVIconLeftOver(vl: number): void;
    /**
     * Sets the font size of the Widget Annotation.
     *
     * @method PDFNet.WidgetAnnot#setFontSize
     * @param {number} font_size the new font size
     * @note A font size of 0 specifies that the text should be autosized to fit in the Widget.
     */
    setFontSize(font_size: number): void;
    /**
     *
     * @method PDFNet.WidgetAnnot#setTextColor
     * @param {PDFNet.ColorPt} col
     * @param {number} col_comp
     */
    setTextColor(col: PDFNet.ColorPt, col_comp: number): void;
    /**
     * Specifies a font to be used for text in this Widget.
     *
     * @method PDFNet.WidgetAnnot#setFont
     * @param {PDFNet.Font} font the font to use.
     */
    setFont(font: PDFNet.Font): void;
    /**
     * Returns the font size used in this Widget Annotation.
     *
     * @method PDFNet.WidgetAnnot#getFontSize
     * @return {Promise<number>} A promise that resolves tos the font size
     * @note A font size of 0 specifies that the text should be autosized to fit in the Widget.
     */
    getFontSize(): Promise<number>;
    /**
     *
     * @method PDFNet.WidgetAnnot#getTextColor
     * @param {PDFNet.ColorPt} col
     * @param {number} col_comp
     */
    getTextColor(col: PDFNet.ColorPt, col_comp: number): void;
    /**
     * Retrieves the font used for displaying text in this Widget.
     *
     * @method PDFNet.WidgetAnnot#getFont
     * @return {Promise<PDFNet.Font>} A promise that resolves tos the font used by this Widget.
     */
    getFont(): Promise<PDFNet.Font>;
  }
  /**
   * QuadPoint
   *
   * A QuadpPoint struct contains 8 values representing the (x,y) coordinates of four points in a rectangle..
   *
   * --------------------
   * Since QuadPoint is a struct, it can be created manually by calling "new PDFNet.QuadPoint(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y)"
   * eg. var myfoo = new PDFNet.QuadPoint(1, 2, 3, 4, 5, 6, 7, 8)
   *
   * Default values for a Point struct are:
   * p1x = 0
   * p1y = 0
   * p2x = 0
   * p2y = 0
   * p3x = 0
   * p3y = 0
   * p4x = 0
   * p4y = 0
   * @class
   * @name QuadPoint
   * @memberof PDFNet
   */
  class QuadPoint {}
  /**
   * 2D Point
   *
   * A Point represents an (x,y) coordinate point.
   *
   * --------------------
   * Since Point is a struct, it can be created manually by calling "new PDFNet.Point(x, y)"
   * eg. var myfoo = new PDFNet.Point(1,2);
   *
   * Default values for a Point struct are:
   * x = 0
   * y = 0
   * @class
   * @name Point
   * @memberof PDFNet
   */
  class Point {}
  namespace Optimizer {
    /**
     * An object that stores downsampling/recompression settings for color and grayscale images.
     * @class
     * @name ImageSettings
     * @memberof PDFNet.Optimizer
     */
    class ImageSettings {
      /**
       * Sets the maximum and resampling dpi for images.
       * By default these are set to 225 and 150 respectively.
       * @method PDFNet.Optimizer.ImageSettings#setImageDPI
       * @param {number} maximum the highest dpi of an image before it will be resampled
       * @param {number} resampling the image dpi to resample to if an image is encountered over the maximum dpi
       * @return {PDFNet.Optimizer.ImageSettings} this object, for call chaining
       */
      setImageDPI(maximum: number, resampling: number): PDFNet.Optimizer.ImageSettings;
      /**
       * Sets the output compression mode for this type of image
       * The default value is e_retain
       * @method PDFNet.Optimizer.ImageSettings#setCompressionMode
       * @param {number} mode the compression mode to set
       * <pre>
       * PDFNet.Optimizer.ImageSettings.CompressionMode = {
       *  e_retain : 0,
       *  e_flate : 1,
       *  e_jpeg : 2,
       *  e_jpeg2000 : 3,
       *  e_none : 4
       * }
       * </pre>
       * @return {PDFNet.Optimizer.ImageSettings} this object, for call chaining
       */
      setCompressionMode(mode: number): PDFNet.Optimizer.ImageSettings;
      /**
       * Sets the downsample mode for this type of image
       * The default value is e_default which will allow downsampling of images
       * @method PDFNet.Optimizer.ImageSettings#setDownsampleMode
       * @param {number} mode the compression mode to set
       * <pre>
       * PDFNet.Optimizer.ImageSettings.DownsampleMode = {
       *  e_off : 0,
       *	e_default : 1
       * }
       * </pre>
       * @return {PDFNet.Optimizer.ImageSettings} this object, for call chaining
       */
      setDownsampleMode(mode: number): PDFNet.Optimizer.ImageSettings;
      /**
       * Sets the quality for lossy compression modes.
       * from 1 to 10 where 10 is lossless (if possible)
       * the default value is 5
       * @method PDFNet.Optimizer.ImageSettings#setQuality
       * @param {number} quality the quality for lossy compression modes.
       * @return {PDFNet.Optimizer.ImageSettings} this object, for call chaining
       */
      setQuality(quality: number): PDFNet.Optimizer.ImageSettings;
      /**
       * Sets whether recompression to the specified compression method, should be forced when the image is not downsampled.
       * By default the compression method for these images will not be changed.
       * @method PDFNet.Optimizer.ImageSettings#forceRecompression
       * @param {boolean} force if true the compression method for all
       * @return {PDFNet.Optimizer.ImageSettings} this object, for call chaining
       */
      forceRecompression(force: boolean): PDFNet.Optimizer.ImageSettings;
      /**
       * Sets whether image changes that grow the PDF file should be kept.
       * This is off by default.
       * @method PDFNet.Optimizer.ImageSettings#forceChanges
       * @param {boolean} force if true all image changes will be kept.
       * @return {PDFNet.Optimizer.ImageSettings} this object, for call chaining
       */
      forceChanges(force: boolean): PDFNet.Optimizer.ImageSettings;
    }
    /**
     * An object that stores downsampling/recompression settings for monochrome images.
     * @class
     * @name MonoImageSettings
     * @memberof PDFNet.Optimizer
     */
    class MonoImageSettings {
      /**
       * Sets the maximum and resampling dpi for monochrome images.
       * By default these are set to 450 and 300 respectively.
       * @method PDFNet.Optimizer.MonoImageSettings#setImageDPI
       * @param {number} maximum the highest dpi of an image before it will be resampled
       * @param {number} resampling the image dpi to resample to if an image is encountered over the maximum dpi
       * @return {PDFNet.Optimizer.MonoImageSettings} this object, for call chaining
       */
      setImageDPI(maximum: number, resampling: number): PDFNet.Optimizer.MonoImageSettings;
      /**
       * Sets the output compression mode for monochrome images
       * The default value is e_jbig2
       * @method PDFNet.Optimizer.MonoImageSettings#setCompressionMode
       * @param {number} mode the compression mode to set
       * <pre>
       * PDFNet.Optimizer.MonoImageSettings.CompressionMode = {
       *	e_jbig2 : 0,
       *	e_flate : 1,
       *	e_none : 2
       * }
       * </pre>
       * @return {PDFNet.Optimizer.MonoImageSettings} this object, for call chaining
       */
      setCompressionMode(mode: number): PDFNet.Optimizer.MonoImageSettings;
      /**
       * Sets the downsample mode for monochrome images
       * The default value is e_default
       * @method PDFNet.Optimizer.MonoImageSettings#setDownsampleMode
       * @param {number} mode the compression mode to set
       * <pre>
       * PDFNet.Optimizer.MonoImageSettings.DownsampleMode = {
       *  e_off : 0,
       *	e_default : 1
       * }
       * </pre>
       * @return {PDFNet.Optimizer.MonoImageSettings} this object, for call chaining
       */
      setDownsampleMode(mode: number): PDFNet.Optimizer.MonoImageSettings;
      /**
       * Sets the quality for lossy JBIG2Decode compression mode.
       * The threshold is a floating point number in the range from 4 to 9
       * The default value for JBIG2 is 8.5.  The setting is ignored for FLATE.
       * @method PDFNet.Optimizer.MonoImageSettings#setJBIG2Threshold
       * @param {number} jbig2_threshold the quality for lossy compression modes.
       * @return {PDFNet.Optimizer.MonoImageSettings} this object, for call chaining
       */
      setJBIG2Threshold(jbig2_threshold: number): PDFNet.Optimizer.MonoImageSettings;
      /**
       * Sets whether recompression to the specified compression method, should be forced when the image is not downsampled.
       * By default the compression method for these images will not be changed.
       * @method PDFNet.Optimizer.MonoImageSettings#forceRecompression
       * @param {boolean} force if true the compression method for all
       * @return {PDFNet.Optimizer.MonoImageSettings} this object, for call chaining
       */
      forceRecompression(force: boolean): PDFNet.Optimizer.MonoImageSettings;
      /**
       * Sets whether image changes that grow the PDF file should be kept.
       * This is off by default.
       * @method PDFNet.Optimizer.MonoImageSettings#forceChanges
       * @param {boolean} force if true all image changes will be kept.
       * @return {PDFNet.Optimizer.MonoImageSettings} this object, for call chaining
       */
      forceChanges(force: boolean): PDFNet.Optimizer.MonoImageSettings;
    }
    /**
     * An object that stores image text optimization settings.
     * @class
     * @name TextSettings
     * @memberof PDFNet.Optimizer
     */
    class TextSettings {
      /**
       * Sets whether embedded fonts will be subset. This will generally reduce the size of fonts,
       * but will strip font hinting.
       * Subsetting is off by default.
       * @method PDFNet.Optimizer.TextSettings#subsetFonts
       * @param {boolean} subset if true all embedded fonts will be subsetted.
       * @return {PDFNet.Optimizer.TextSettings} this object, for call chaining
       */
      subsetFonts(subset: boolean): PDFNet.Optimizer.TextSettings;
      /**
       * Sets whether fonts should be embedded. This will generally increase the size of the file,
       * but will make the file appear the same on different machines.
       * Font embedding is off by default.
       * @method PDFNet.Optimizer.TextSettings#embedFonts
       * @param {boolean} embed if true all fonts will be embedded.
       * @return {PDFNet.Optimizer.TextSettings} this object, for call chaining
       */
      embedFonts(embed: boolean): PDFNet.Optimizer.TextSettings;
    }
    /**
     * An object that stores settings for the optimizer
     * @class
     * @name OptimizerSettings
     * @memberof PDFNet.Optimizer
     */
    class OptimizerSettings {
      /**
       * updates the settings for color image processing
       * @method PDFNet.Optimizer.OptimizerSettings#setColorImageSettings
       * @param {PDFNet.Optimizer.ImageSettings} settings settings for color image processing
       * @return {PDFNet.Optimizer.OptimizerSettings} this object, for call chaining
       */
      setColorImageSettings(settings: PDFNet.Optimizer.ImageSettings): PDFNet.Optimizer.OptimizerSettings;
      /**
       * updates the settings for grayscale image processing
       * @method PDFNet.Optimizer.OptimizerSettings#setGrayscaleImageSettings
       * @param {PDFNet.Optimizer.ImageSettings} settings settings for grayscale image processing
       * @return {PDFNet.Optimizer.OptimizerSettings} this object, for call chaining
       */
      setGrayscaleImageSettings(settings: PDFNet.Optimizer.ImageSettings): PDFNet.Optimizer.OptimizerSettings;
      /**
       * updates the settings for monochrome image processing
       * @method PDFNet.Optimizer.OptimizerSettings#setMonoImageSettings
       * @param {PDFNet.Optimizer.MonoImageSettings} settings settings for monochrome image processing
       * @return {PDFNet.Optimizer.OptimizerSettings} this object, for call chaining
       */
      setMonoImageSettings(settings: PDFNet.Optimizer.MonoImageSettings): PDFNet.Optimizer.OptimizerSettings;
      /**
       * updates the settings for text processing
       * @method PDFNet.Optimizer.OptimizerSettings#setTextSettings
       * @param {PDFNet.Optimizer.TextSettings} settings settings for text processing
       * @return {PDFNet.Optimizer.OptimizerSettings} this object, for call chaining
       */
      setTextSettings(settings: PDFNet.Optimizer.TextSettings): PDFNet.Optimizer.OptimizerSettings;
      /**
       * Enable or disable removal of custom entries in the PDF.
       * By default custom entries are removed.
       * @method PDFNet.Optimizer.OptimizerSettings#removeCustomEntries
       * @param {boolean} should_remove if true custom entries will be removed.
       * @return {PDFNet.Optimizer.OptimizerSettings} this object, for call chaining
       */
      removeCustomEntries(should_remove: boolean): PDFNet.Optimizer.OptimizerSettings;
    }
    namespace ImageSettings {
      /**
       * @enum {number}
       * @name CompressionMode
       * @memberof PDFNet.Optimizer.ImageSettings
       * @property {number} e_retain
       * @property {number} e_flate
       * @property {number} e_jpeg
       * @property {number} e_jpeg2000
       * @property {number} e_none
       */
      enum CompressionMode {
        e_retain,
        e_flate,
        e_jpeg,
        e_jpeg2000,
        e_none,
      }
      /**
       * @enum {number}
       * @name DownsampleMode
       * @memberof PDFNet.Optimizer.ImageSettings
       * @property {number} e_off
       * @property {number} e_default
       */
      enum DownsampleMode {
        e_off,
        e_default,
      }
    }
    namespace MonoImageSettings {
      /**
       * @enum {number}
       * @name CompressionMode
       * @memberof PDFNet.Optimizer.MonoImageSettings
       * @property {number} e_jbig2
       * @property {number} e_flate
       * @property {number} e_none
       */
      enum CompressionMode {
        e_jbig2,
        e_flate,
        e_none,
      }
      /**
       * @enum {number}
       * @name DownsampleMode
       * @memberof PDFNet.Optimizer.MonoImageSettings
       * @property {number} e_off
       * @property {number} e_default
       */
      enum DownsampleMode {
        e_off,
        e_default,
      }
    }
  }
  namespace Convert {
    /**
     * An object containing options for wordToPdf functions
     * @class
     * @name OfficeToPDFOptions
     * @memberof PDFNet.Convert
     */
    class OfficeToPDFOptions {
      /**
       * Sets the value for LayoutResourcesPluginPath in the options object
       * The path at which the pdftron-provided font resource plugin resides
       * @method PDFNet.Convert.OfficeToPDFOptions#setLayoutResourcesPluginPath
       * @param {string} value The path at which the pdftron-provided font resource plugin resides
       * @return {PDFNet.Convert.OfficeToPDFOptions} this object, for call chaining
       */
      setLayoutResourcesPluginPath(value: string): PDFNet.Convert.OfficeToPDFOptions;
      /**
       * Sets the value for ResourceDocPath in the options object
       * The path at which the a .docx resource document resides
       * @method PDFNet.Convert.OfficeToPDFOptions#setResourceDocPath
       * @param {string} value The path at which the a .docx resource document resides
       * @return {PDFNet.Convert.OfficeToPDFOptions} this object, for call chaining
       */
      setResourceDocPath(value: string): PDFNet.Convert.OfficeToPDFOptions;
      /**
       * Sets the value for SmartSubstitutionPluginPath in the options object
       * The path at which the pdftron-provided font resource plugin resides
       * @method PDFNet.Convert.OfficeToPDFOptions#setSmartSubstitutionPluginPath
       * @param {string} value The path at which the pdftron-provided font resource plugin resides
       * @return {PDFNet.Convert.OfficeToPDFOptions} this object, for call chaining
       */
      setSmartSubstitutionPluginPath(value: string): PDFNet.Convert.OfficeToPDFOptions;
      /**
       * @method PDFNet.Convert.OfficeToPDFOptions#setExcelDefaultCellBorderWidth
       * @param {number} width
       * @return {PDFNet.Convert.OfficeToPDFOptions} this object, for call chaining
       */
      setExcelDefaultCellBorderWidth(width: number): PDFNet.Convert.OfficeToPDFOptions;
    }
    /**
     * @enum {number}
     * @name PrinterMode
     * @memberof PDFNet.Convert
     * @property {number} e_auto
     * @property {number} e_interop_only
     * @property {number} e_printer_only
     * @property {number} e_prefer_builtin_converter
     */
    enum PrinterMode {
      e_auto,
      e_interop_only,
      e_printer_only,
      e_prefer_builtin_converter,
    }
  }
  namespace PrinterMode {
    /**
     * @enum {number}
     * @name PaperSize
     * @memberof PDFNet.PrinterMode
     * @property {number} e_custom
     * @property {number} e_letter
     * @property {number} e_letter_small
     * @property {number} e_tabloid
     * @property {number} e_ledger
     * @property {number} e_legal
     * @property {number} e_statement
     * @property {number} e_executive
     * @property {number} e_a3
     * @property {number} e_a4
     * @property {number} e_a4_mall
     * @property {number} e_a5
     * @property {number} e_b4_jis
     * @property {number} e_b5_jis
     * @property {number} e_folio
     * @property {number} e_quarto
     * @property {number} e_10x14
     * @property {number} e_11x17
     * @property {number} e_note
     * @property {number} e_envelope_9
     * @property {number} e_envelope_10
     * @property {number} e_envelope_11
     * @property {number} e_envelope_12
     * @property {number} e_envelope_14
     * @property {number} e_c_size_sheet
     * @property {number} e_d_size_sheet
     * @property {number} e_e_size_sheet
     * @property {number} e_envelope_dl
     * @property {number} e_envelope_c5
     * @property {number} e_envelope_c3
     * @property {number} e_envelope_c4
     * @property {number} e_envelope_c6
     * @property {number} e_envelope_c65
     * @property {number} e_envelope_b4
     * @property {number} e_envelope_b5
     * @property {number} e_envelope_b6
     * @property {number} e_envelope_italy
     * @property {number} e_envelope_monarch
     * @property {number} e_6_3_quarters_envelope
     * @property {number} e_us_std_fanfold
     * @property {number} e_german_std_fanfold
     * @property {number} e_german_legal_fanfold
     * @property {number} e_b4_iso
     * @property {number} e_japanese_postcard
     * @property {number} e_9x11
     * @property {number} e_10x11
     * @property {number} e_15x11
     * @property {number} e_envelope_invite
     * @property {number} e_reserved_48
     * @property {number} e_reserved_49
     * @property {number} e_letter_extra
     * @property {number} e_legal_extra
     * @property {number} e_tabloid_extra
     * @property {number} e_a4_extra
     * @property {number} e_letter_transverse
     * @property {number} e_a4_transverse
     * @property {number} e_letter_extra_transverse
     * @property {number} e_supera_supera_a4
     * @property {number} e_Superb_Superb_a3
     * @property {number} e_letter_plus
     * @property {number} e_a4_plus
     * @property {number} e_a5_transverse
     * @property {number} e_b5_jis_transverse
     * @property {number} e_a3_extra
     * @property {number} e_a5_extra
     * @property {number} e_b5_iso_extra
     * @property {number} e_a2
     * @property {number} e_a3_transverse
     * @property {number} e_a3_extra_transverse
     * @property {number} e_japanese_double_postcard
     * @property {number} e_a6
     * @property {number} e_japanese_envelope_kaku_2
     * @property {number} e_japanese_envelope_kaku_3
     * @property {number} e_japanese_envelope_chou_3
     * @property {number} e_japanese_envelope_chou_4
     * @property {number} e_letter_rotated
     * @property {number} e_a3_rotated
     * @property {number} e_a4_rotated
     * @property {number} e_a5_rotated
     * @property {number} e_b4_jis_rotated
     * @property {number} e_b5_jis_rotated
     * @property {number} e_japanese_postcard_rotated
     * @property {number} e_double_japanese_postcard_rotated
     * @property {number} e_a6_rotated
     * @property {number} e_japanese_envelope_kaku_2_rotated
     * @property {number} e_japanese_envelope_kaku_3_rotated
     * @property {number} e_japanese_envelope_chou_3_rotated
     * @property {number} e_japanese_envelope_chou_4_rotated
     * @property {number} e_b6_jis
     * @property {number} e_b6_jis_rotated
     * @property {number} e_12x11
     * @property {number} e_japanese_envelope_you_4
     * @property {number} e_japanese_envelope_you_4_rotated
     * @property {number} e_PrinterMode_prc_16k
     * @property {number} e_prc_32k
     * @property {number} e_prc_32k_big
     * @property {number} e_prc_envelop_1
     * @property {number} e_prc_envelop_2
     * @property {number} e_prc_envelop_3
     * @property {number} e_prc_envelop_4
     * @property {number} e_prc_envelop_5
     * @property {number} e_prc_envelop_6
     * @property {number} e_prc_envelop_7
     * @property {number} e_prc_envelop_8
     * @property {number} e_prc_envelop_9
     * @property {number} e_prc_envelop_10
     * @property {number} e_prc_16k_rotated
     * @property {number} e_prc_32k_rotated
     * @property {number} e_prc_32k_big__rotated
     * @property {number} e_prc_envelop_1_rotated
     * @property {number} e_prc_envelop_2_rotated
     * @property {number} e_prc_envelop_3_rotated
     * @property {number} e_prc_envelop_4_rotated
     * @property {number} e_prc_envelop_5_rotated
     * @property {number} e_prc_envelop_6_rotated
     * @property {number} e_prc_envelop_7_rotated
     * @property {number} e_prc_envelop_8_rotated
     * @property {number} e_prc_envelop_9_rotated
     * @property {number} e_prc_envelop_10_rotated
     */
    enum PaperSize {
      e_custom,
      e_letter,
      e_letter_small,
      e_tabloid,
      e_ledger,
      e_legal,
      e_statement,
      e_executive,
      e_a3,
      e_a4,
      e_a4_mall,
      e_a5,
      e_b4_jis,
      e_b5_jis,
      e_folio,
      e_quarto,
      e_10x14,
      e_11x17,
      e_note,
      e_envelope_9,
      e_envelope_10,
      e_envelope_11,
      e_envelope_12,
      e_envelope_14,
      e_c_size_sheet,
      e_d_size_sheet,
      e_e_size_sheet,
      e_envelope_dl,
      e_envelope_c5,
      e_envelope_c3,
      e_envelope_c4,
      e_envelope_c6,
      e_envelope_c65,
      e_envelope_b4,
      e_envelope_b5,
      e_envelope_b6,
      e_envelope_italy,
      e_envelope_monarch,
      e_6_3_quarters_envelope,
      e_us_std_fanfold,
      e_german_std_fanfold,
      e_german_legal_fanfold,
      e_b4_iso,
      e_japanese_postcard,
      e_9x11,
      e_10x11,
      e_15x11,
      e_envelope_invite,
      e_reserved_48,
      e_reserved_49,
      e_letter_extra,
      e_legal_extra,
      e_tabloid_extra,
      e_a4_extra,
      e_letter_transverse,
      e_a4_transverse,
      e_letter_extra_transverse,
      e_supera_supera_a4,
      e_Superb_Superb_a3,
      e_letter_plus,
      e_a4_plus,
      e_a5_transverse,
      e_b5_jis_transverse,
      e_a3_extra,
      e_a5_extra,
      e_b5_iso_extra,
      e_a2,
      e_a3_transverse,
      e_a3_extra_transverse,
      e_japanese_double_postcard,
      e_a6,
      e_japanese_envelope_kaku_2,
      e_japanese_envelope_kaku_3,
      e_japanese_envelope_chou_3,
      e_japanese_envelope_chou_4,
      e_letter_rotated,
      e_a3_rotated,
      e_a4_rotated,
      e_a5_rotated,
      e_b4_jis_rotated,
      e_b5_jis_rotated,
      e_japanese_postcard_rotated,
      e_double_japanese_postcard_rotated,
      e_a6_rotated,
      e_japanese_envelope_kaku_2_rotated,
      e_japanese_envelope_kaku_3_rotated,
      e_japanese_envelope_chou_3_rotated,
      e_japanese_envelope_chou_4_rotated,
      e_b6_jis,
      e_b6_jis_rotated,
      e_12x11,
      e_japanese_envelope_you_4,
      e_japanese_envelope_you_4_rotated,
      e_PrinterMode_prc_16k,
      e_prc_32k,
      e_prc_32k_big,
      e_prc_envelop_1,
      e_prc_envelop_2,
      e_prc_envelop_3,
      e_prc_envelop_4,
      e_prc_envelop_5,
      e_prc_envelop_6,
      e_prc_envelop_7,
      e_prc_envelop_8,
      e_prc_envelop_9,
      e_prc_envelop_10,
      e_prc_16k_rotated,
      e_prc_32k_rotated,
      e_prc_32k_big__rotated,
      e_prc_envelop_1_rotated,
      e_prc_envelop_2_rotated,
      e_prc_envelop_3_rotated,
      e_prc_envelop_4_rotated,
      e_prc_envelop_5_rotated,
      e_prc_envelop_6_rotated,
      e_prc_envelop_7_rotated,
      e_prc_envelop_8_rotated,
      e_prc_envelop_9_rotated,
      e_prc_envelop_10_rotated,
    }
  }
  namespace Field {
    /**
     * @enum {number}
     * @name EventType
     * @memberof PDFNet.Field
     * @property {number} e_action_trigger_keystroke
     * @property {number} e_action_trigger_format
     * @property {number} e_action_trigger_validate
     * @property {number} e_action_trigger_calculate
     */
    enum EventType {
      e_action_trigger_keystroke,
      e_action_trigger_format,
      e_action_trigger_validate,
      e_action_trigger_calculate,
    }
    /**
     * @enum {number}
     * @name Type
     * @memberof PDFNet.Field
     * @property {number} e_button
     * @property {number} e_check
     * @property {number} e_radio
     * @property {number} e_text
     * @property {number} e_choice
     * @property {number} e_signature
     * @property {number} e_null
     */
    enum Type {
      e_button,
      e_check,
      e_radio,
      e_text,
      e_choice,
      e_signature,
      e_null,
    }
    /**
     * @enum {number}
     * @name Flag
     * @memberof PDFNet.Field
     * @property {number} e_read_only
     * @property {number} e_required
     * @property {number} e_no_export
     * @property {number} e_pushbutton_flag
     * @property {number} e_radio_flag
     * @property {number} e_toggle_to_off
     * @property {number} e_radios_in_unison
     * @property {number} e_multiline
     * @property {number} e_password
     * @property {number} e_file_select
     * @property {number} e_no_spellcheck
     * @property {number} e_no_scroll
     * @property {number} e_comb
     * @property {number} e_rich_text
     * @property {number} e_combo
     * @property {number} e_edit
     * @property {number} e_sort
     * @property {number} e_multiselect
     * @property {number} e_commit_on_sel_change
     */
    enum Flag {
      e_read_only,
      e_required,
      e_no_export,
      e_pushbutton_flag,
      e_radio_flag,
      e_toggle_to_off,
      e_radios_in_unison,
      e_multiline,
      e_password,
      e_file_select,
      e_no_spellcheck,
      e_no_scroll,
      e_comb,
      e_rich_text,
      e_combo,
      e_edit,
      e_sort,
      e_multiselect,
      e_commit_on_sel_change,
    }
    /**
     * @enum {number}
     * @name TextJustification
     * @memberof PDFNet.Field
     * @property {number} e_left_justified
     * @property {number} e_centered
     * @property {number} e_right_justified
     */
    enum TextJustification {
      e_left_justified,
      e_centered,
      e_right_justified,
    }
  }
  namespace Filter {
    /**
     * @enum {number}
     * @name StdFileOpenMode
     * @memberof PDFNet.Filter
     * @property {number} e_read_mode
     * @property {number} e_write_mode
     * @property {number} e_append_mode
     */
    enum StdFileOpenMode {
      e_read_mode,
      e_write_mode,
      e_append_mode,
    }
    /**
     * @enum {number}
     * @name ReferencePos
     * @memberof PDFNet.Filter
     * @property {number} e_begin
     * @property {number} e_end
     * @property {number} e_cur
     */
    enum ReferencePos {
      e_begin,
      e_end,
      e_cur,
    }
  }
  namespace OCGContext {
    /**
     * @enum {number}
     * @name OCDrawMode
     * @memberof PDFNet.OCGContext
     * @property {number} e_VisibleOC
     * @property {number} e_AllOC
     * @property {number} e_NoOC
     */
    enum OCDrawMode {
      e_VisibleOC,
      e_AllOC,
      e_NoOC,
    }
  }
  namespace OCMD {
    /**
     * @enum {number}
     * @name VisibilityPolicyType
     * @memberof PDFNet.OCMD
     * @property {number} e_AllOn
     * @property {number} e_AnyOn
     * @property {number} e_AnyOff
     * @property {number} e_AllOff
     */
    enum VisibilityPolicyType {
      e_AllOn,
      e_AnyOn,
      e_AnyOff,
      e_AllOff,
    }
  }
  namespace PDFACompliance {
    /**
     * @enum {number}
     * @name Conformance
     * @memberof PDFNet.PDFACompliance
     * @property {number} e_Level1A
     * @property {number} e_Level1B
     * @property {number} e_Level2A
     * @property {number} e_Level2B
     * @property {number} e_Level2U
     * @property {number} e_Level3A
     * @property {number} e_Level3B
     * @property {number} e_Level3U
     */
    enum Conformance {
      e_Level1A,
      e_Level1B,
      e_Level2A,
      e_Level2B,
      e_Level2U,
      e_Level3A,
      e_Level3B,
      e_Level3U,
    }
    /**
     * @enum {number}
     * @name ErrorCode
     * @memberof PDFNet.PDFACompliance
     * @property {number} e_PDFA0_1_0
     * @property {number} e_PDFA0_1_1
     * @property {number} e_PDFA0_1_2
     * @property {number} e_PDFA0_1_3
     * @property {number} e_PDFA0_1_4
     * @property {number} e_PDFA0_1_5
     * @property {number} e_PDFA1_2_1
     * @property {number} e_PDFA1_2_2
     * @property {number} e_PDFA1_3_1
     * @property {number} e_PDFA1_3_2
     * @property {number} e_PDFA1_3_3
     * @property {number} e_PDFA1_3_4
     * @property {number} e_PDFA1_4_1
     * @property {number} e_PDFA1_4_2
     * @property {number} e_PDFA1_6_1
     * @property {number} e_PDFA1_7_1
     * @property {number} e_PDFA1_7_2
     * @property {number} e_PDFA1_7_3
     * @property {number} e_PDFA1_7_4
     * @property {number} e_PDFA1_8_1
     * @property {number} e_PDFA1_8_2
     * @property {number} e_PDFA1_8_3
     * @property {number} e_PDFA1_8_4
     * @property {number} e_PDFA1_8_5
     * @property {number} e_PDFA1_8_6
     * @property {number} e_PDFA1_10_1
     * @property {number} e_PDFA1_11_1
     * @property {number} e_PDFA1_11_2
     * @property {number} e_PDFA1_12_1
     * @property {number} e_PDFA1_12_2
     * @property {number} e_PDFA1_12_3
     * @property {number} e_PDFA1_12_4
     * @property {number} e_PDFA1_12_5
     * @property {number} e_PDFA1_12_6
     * @property {number} e_PDFA1_13_1
     * @property {number} e_PDFA2_2_1
     * @property {number} e_PDFA2_3_2
     * @property {number} e_PDFA2_3_3
     * @property {number} e_PDFA2_3_3_1
     * @property {number} e_PDFA2_3_3_2
     * @property {number} e_PDFA2_3_4_1
     * @property {number} e_PDFA2_4_1
     * @property {number} e_PDFA2_4_2
     * @property {number} e_PDFA2_4_3
     * @property {number} e_PDFA2_4_4
     * @property {number} e_PDFA2_5_1
     * @property {number} e_PDFA2_5_2
     * @property {number} e_PDFA2_6_1
     * @property {number} e_PDFA2_7_1
     * @property {number} e_PDFA2_8_1
     * @property {number} e_PDFA2_9_1
     * @property {number} e_PDFA2_10_1
     * @property {number} e_PDFA3_2_1
     * @property {number} e_PDFA3_3_1
     * @property {number} e_PDFA3_3_2
     * @property {number} e_PDFA3_3_3_1
     * @property {number} e_PDFA3_3_3_2
     * @property {number} e_PDFA3_4_1
     * @property {number} e_PDFA3_5_1
     * @property {number} e_PDFA3_5_2
     * @property {number} e_PDFA3_5_3
     * @property {number} e_PDFA3_5_4
     * @property {number} e_PDFA3_5_5
     * @property {number} e_PDFA3_5_6
     * @property {number} e_PDFA3_6_1
     * @property {number} e_PDFA3_7_1
     * @property {number} e_PDFA3_7_2
     * @property {number} e_PDFA3_7_3
     * @property {number} e_PDFA4_1
     * @property {number} e_PDFA4_2
     * @property {number} e_PDFA4_3
     * @property {number} e_PDFA4_4
     * @property {number} e_PDFA4_5
     * @property {number} e_PDFA4_6
     * @property {number} e_PDFA5_2_1
     * @property {number} e_PDFA5_2_2
     * @property {number} e_PDFA5_2_3
     * @property {number} e_PDFA5_2_4
     * @property {number} e_PDFA5_2_5
     * @property {number} e_PDFA5_2_6
     * @property {number} e_PDFA5_2_7
     * @property {number} e_PDFA5_2_8
     * @property {number} e_PDFA5_2_9
     * @property {number} e_PDFA5_2_10
     * @property {number} e_PDFA5_2_11
     * @property {number} e_PDFA5_3_1
     * @property {number} e_PDFA5_3_2_1
     * @property {number} e_PDFA5_3_2_2
     * @property {number} e_PDFA5_3_2_3
     * @property {number} e_PDFA5_3_2_4
     * @property {number} e_PDFA5_3_2_5
     * @property {number} e_PDFA5_3_3_1
     * @property {number} e_PDFA5_3_3_2
     * @property {number} e_PDFA5_3_3_3
     * @property {number} e_PDFA5_3_3_4
     * @property {number} e_PDFA5_3_4_0
     * @property {number} e_PDFA5_3_4_1
     * @property {number} e_PDFA5_3_4_2
     * @property {number} e_PDFA5_3_4_3
     * @property {number} e_PDFA6_1_1
     * @property {number} e_PDFA6_1_2
     * @property {number} e_PDFA6_2_1
     * @property {number} e_PDFA6_2_2
     * @property {number} e_PDFA6_2_3
     * @property {number} e_PDFA7_2_1
     * @property {number} e_PDFA7_2_2
     * @property {number} e_PDFA7_2_3
     * @property {number} e_PDFA7_2_4
     * @property {number} e_PDFA7_2_5
     * @property {number} e_PDFA7_3_1
     * @property {number} e_PDFA7_3_2
     * @property {number} e_PDFA7_3_3
     * @property {number} e_PDFA7_3_4
     * @property {number} e_PDFA7_3_5
     * @property {number} e_PDFA7_3_6
     * @property {number} e_PDFA7_3_7
     * @property {number} e_PDFA7_3_8
     * @property {number} e_PDFA7_3_9
     * @property {number} e_PDFA7_5_1
     * @property {number} e_PDFA7_8_1
     * @property {number} e_PDFA7_8_2
     * @property {number} e_PDFA7_8_3
     * @property {number} e_PDFA7_8_4
     * @property {number} e_PDFA7_8_5
     * @property {number} e_PDFA7_8_6
     * @property {number} e_PDFA7_8_7
     * @property {number} e_PDFA7_8_8
     * @property {number} e_PDFA7_8_9
     * @property {number} e_PDFA7_8_10
     * @property {number} e_PDFA7_8_11
     * @property {number} e_PDFA7_8_12
     * @property {number} e_PDFA7_8_13
     * @property {number} e_PDFA7_8_14
     * @property {number} e_PDFA7_8_15
     * @property {number} e_PDFA7_8_16
     * @property {number} e_PDFA7_8_17
     * @property {number} e_PDFA7_8_18
     * @property {number} e_PDFA7_8_19
     * @property {number} e_PDFA7_8_20
     * @property {number} e_PDFA7_8_21
     * @property {number} e_PDFA7_8_22
     * @property {number} e_PDFA7_8_23
     * @property {number} e_PDFA7_8_24
     * @property {number} e_PDFA7_8_25
     * @property {number} e_PDFA7_8_26
     * @property {number} e_PDFA7_8_27
     * @property {number} e_PDFA7_8_28
     * @property {number} e_PDFA7_8_29
     * @property {number} e_PDFA7_8_30
     * @property {number} e_PDFA7_8_31
     * @property {number} e_PDFA7_11_1
     * @property {number} e_PDFA7_11_2
     * @property {number} e_PDFA7_11_3
     * @property {number} e_PDFA7_11_4
     * @property {number} e_PDFA7_11_5
     * @property {number} e_PDFA9_1
     * @property {number} e_PDFA9_2
     * @property {number} e_PDFA9_3
     * @property {number} e_PDFA9_4
     * @property {number} e_PDFA3_8_1
     * @property {number} e_PDFA8_2_2
     * @property {number} e_PDFA8_3_3_1
     * @property {number} e_PDFA8_3_3_2
     * @property {number} e_PDFA8_3_4_1
     * @property {number} e_PDFA1_2_3
     * @property {number} e_PDFA1_10_2
     * @property {number} e_PDFA1_10_3
     * @property {number} e_PDFA1_12_10
     * @property {number} e_PDFA1_13_5
     * @property {number} e_PDFA2_3_10
     * @property {number} e_PDFA2_4_2_10
     * @property {number} e_PDFA2_4_2_11
     * @property {number} e_PDFA2_4_2_12
     * @property {number} e_PDFA2_4_2_13
     * @property {number} e_PDFA2_5_10
     * @property {number} e_PDFA2_5_11
     * @property {number} e_PDFA2_5_12
     * @property {number} e_PDFA2_8_3_1
     * @property {number} e_PDFA2_8_3_2
     * @property {number} e_PDFA2_8_3_3
     * @property {number} e_PDFA2_8_3_4
     * @property {number} e_PDFA2_8_3_5
     * @property {number} e_PDFA2_10_20
     * @property {number} e_PDFA2_10_21
     * @property {number} e_PDFA11_0_0
     * @property {number} e_PDFA6_2_11_8
     * @property {number} e_PDFA8_1
     * @property {number} e_PDFA_3E1
     * @property {number} e_PDFA_3E2
     * @property {number} e_PDFA_3E3
     * @property {number} e_PDFA_LAST
     */
    enum ErrorCode {
      e_PDFA0_1_0,
      e_PDFA0_1_1,
      e_PDFA0_1_2,
      e_PDFA0_1_3,
      e_PDFA0_1_4,
      e_PDFA0_1_5,
      e_PDFA1_2_1,
      e_PDFA1_2_2,
      e_PDFA1_3_1,
      e_PDFA1_3_2,
      e_PDFA1_3_3,
      e_PDFA1_3_4,
      e_PDFA1_4_1,
      e_PDFA1_4_2,
      e_PDFA1_6_1,
      e_PDFA1_7_1,
      e_PDFA1_7_2,
      e_PDFA1_7_3,
      e_PDFA1_7_4,
      e_PDFA1_8_1,
      e_PDFA1_8_2,
      e_PDFA1_8_3,
      e_PDFA1_8_4,
      e_PDFA1_8_5,
      e_PDFA1_8_6,
      e_PDFA1_10_1,
      e_PDFA1_11_1,
      e_PDFA1_11_2,
      e_PDFA1_12_1,
      e_PDFA1_12_2,
      e_PDFA1_12_3,
      e_PDFA1_12_4,
      e_PDFA1_12_5,
      e_PDFA1_12_6,
      e_PDFA1_13_1,
      e_PDFA2_2_1,
      e_PDFA2_3_2,
      e_PDFA2_3_3,
      e_PDFA2_3_3_1,
      e_PDFA2_3_3_2,
      e_PDFA2_3_4_1,
      e_PDFA2_4_1,
      e_PDFA2_4_2,
      e_PDFA2_4_3,
      e_PDFA2_4_4,
      e_PDFA2_5_1,
      e_PDFA2_5_2,
      e_PDFA2_6_1,
      e_PDFA2_7_1,
      e_PDFA2_8_1,
      e_PDFA2_9_1,
      e_PDFA2_10_1,
      e_PDFA3_2_1,
      e_PDFA3_3_1,
      e_PDFA3_3_2,
      e_PDFA3_3_3_1,
      e_PDFA3_3_3_2,
      e_PDFA3_4_1,
      e_PDFA3_5_1,
      e_PDFA3_5_2,
      e_PDFA3_5_3,
      e_PDFA3_5_4,
      e_PDFA3_5_5,
      e_PDFA3_5_6,
      e_PDFA3_6_1,
      e_PDFA3_7_1,
      e_PDFA3_7_2,
      e_PDFA3_7_3,
      e_PDFA4_1,
      e_PDFA4_2,
      e_PDFA4_3,
      e_PDFA4_4,
      e_PDFA4_5,
      e_PDFA4_6,
      e_PDFA5_2_1,
      e_PDFA5_2_2,
      e_PDFA5_2_3,
      e_PDFA5_2_4,
      e_PDFA5_2_5,
      e_PDFA5_2_6,
      e_PDFA5_2_7,
      e_PDFA5_2_8,
      e_PDFA5_2_9,
      e_PDFA5_2_10,
      e_PDFA5_2_11,
      e_PDFA5_3_1,
      e_PDFA5_3_2_1,
      e_PDFA5_3_2_2,
      e_PDFA5_3_2_3,
      e_PDFA5_3_2_4,
      e_PDFA5_3_2_5,
      e_PDFA5_3_3_1,
      e_PDFA5_3_3_2,
      e_PDFA5_3_3_3,
      e_PDFA5_3_3_4,
      e_PDFA5_3_4_0,
      e_PDFA5_3_4_1,
      e_PDFA5_3_4_2,
      e_PDFA5_3_4_3,
      e_PDFA6_1_1,
      e_PDFA6_1_2,
      e_PDFA6_2_1,
      e_PDFA6_2_2,
      e_PDFA6_2_3,
      e_PDFA7_2_1,
      e_PDFA7_2_2,
      e_PDFA7_2_3,
      e_PDFA7_2_4,
      e_PDFA7_2_5,
      e_PDFA7_3_1,
      e_PDFA7_3_2,
      e_PDFA7_3_3,
      e_PDFA7_3_4,
      e_PDFA7_3_5,
      e_PDFA7_3_6,
      e_PDFA7_3_7,
      e_PDFA7_3_8,
      e_PDFA7_3_9,
      e_PDFA7_5_1,
      e_PDFA7_8_1,
      e_PDFA7_8_2,
      e_PDFA7_8_3,
      e_PDFA7_8_4,
      e_PDFA7_8_5,
      e_PDFA7_8_6,
      e_PDFA7_8_7,
      e_PDFA7_8_8,
      e_PDFA7_8_9,
      e_PDFA7_8_10,
      e_PDFA7_8_11,
      e_PDFA7_8_12,
      e_PDFA7_8_13,
      e_PDFA7_8_14,
      e_PDFA7_8_15,
      e_PDFA7_8_16,
      e_PDFA7_8_17,
      e_PDFA7_8_18,
      e_PDFA7_8_19,
      e_PDFA7_8_20,
      e_PDFA7_8_21,
      e_PDFA7_8_22,
      e_PDFA7_8_23,
      e_PDFA7_8_24,
      e_PDFA7_8_25,
      e_PDFA7_8_26,
      e_PDFA7_8_27,
      e_PDFA7_8_28,
      e_PDFA7_8_29,
      e_PDFA7_8_30,
      e_PDFA7_8_31,
      e_PDFA7_11_1,
      e_PDFA7_11_2,
      e_PDFA7_11_3,
      e_PDFA7_11_4,
      e_PDFA7_11_5,
      e_PDFA9_1,
      e_PDFA9_2,
      e_PDFA9_3,
      e_PDFA9_4,
      e_PDFA3_8_1,
      e_PDFA8_2_2,
      e_PDFA8_3_3_1,
      e_PDFA8_3_3_2,
      e_PDFA8_3_4_1,
      e_PDFA1_2_3,
      e_PDFA1_10_2,
      e_PDFA1_10_3,
      e_PDFA1_12_10,
      e_PDFA1_13_5,
      e_PDFA2_3_10,
      e_PDFA2_4_2_10,
      e_PDFA2_4_2_11,
      e_PDFA2_4_2_12,
      e_PDFA2_4_2_13,
      e_PDFA2_5_10,
      e_PDFA2_5_11,
      e_PDFA2_5_12,
      e_PDFA2_8_3_1,
      e_PDFA2_8_3_2,
      e_PDFA2_8_3_3,
      e_PDFA2_8_3_4,
      e_PDFA2_8_3_5,
      e_PDFA2_10_20,
      e_PDFA2_10_21,
      e_PDFA11_0_0,
      e_PDFA6_2_11_8,
      e_PDFA8_1,
      e_PDFA_3E1,
      e_PDFA_3E2,
      e_PDFA_3E3,
      e_PDFA_LAST,
    }
  }
  namespace ContentItem {
    /**
     * @enum {number}
     * @name Type
     * @memberof PDFNet.ContentItem
     * @property {number} e_MCR
     * @property {number} e_MCID
     * @property {number} e_OBJR
     * @property {number} e_Unknown
     */
    enum Type {
      e_MCR,
      e_MCID,
      e_OBJR,
      e_Unknown,
    }
  }
  namespace Action {
    /**
     * @enum {number}
     * @name Type
     * @memberof PDFNet.Action
     * @property {number} e_GoTo
     * @property {number} e_GoToR
     * @property {number} e_GoToE
     * @property {number} e_Launch
     * @property {number} e_Thread
     * @property {number} e_URI
     * @property {number} e_Sound
     * @property {number} e_Movie
     * @property {number} e_Hide
     * @property {number} e_Named
     * @property {number} e_SubmitForm
     * @property {number} e_ResetForm
     * @property {number} e_ImportData
     * @property {number} e_JavaScript
     * @property {number} e_SetOCGState
     * @property {number} e_Rendition
     * @property {number} e_Trans
     * @property {number} e_GoTo3DView
     * @property {number} e_RichMediaExecute
     * @property {number} e_Unknown
     */
    enum Type {
      e_GoTo,
      e_GoToR,
      e_GoToE,
      e_Launch,
      e_Thread,
      e_URI,
      e_Sound,
      e_Movie,
      e_Hide,
      e_Named,
      e_SubmitForm,
      e_ResetForm,
      e_ImportData,
      e_JavaScript,
      e_SetOCGState,
      e_Rendition,
      e_Trans,
      e_GoTo3DView,
      e_RichMediaExecute,
      e_Unknown,
    }
    /**
     * @enum {number}
     * @name FormActionFlag
     * @memberof PDFNet.Action
     * @property {number} e_exclude
     * @property {number} e_include_no_value_fields
     * @property {number} e_export_format
     * @property {number} e_get_method
     * @property {number} e_submit_coordinates
     * @property {number} e_xfdf
     * @property {number} e_include_append_saves
     * @property {number} e_include_annotations
     * @property {number} e_submit_pdf
     * @property {number} e_canonical_format
     * @property {number} e_excl_non_user_annots
     * @property {number} e_excl_F_key
     * @property {number} e_embed_form
     */
    enum FormActionFlag {
      e_exclude,
      e_include_no_value_fields,
      e_export_format,
      e_get_method,
      e_submit_coordinates,
      e_xfdf,
      e_include_append_saves,
      e_include_annotations,
      e_submit_pdf,
      e_canonical_format,
      e_excl_non_user_annots,
      e_excl_F_key,
      e_embed_form,
    }
  }
  namespace Page {
    /**
     * @enum {number}
     * @name EventType
     * @memberof PDFNet.Page
     * @property {number} e_action_trigger_page_open
     * @property {number} e_action_trigger_page_close
     */
    enum EventType {
      e_action_trigger_page_open,
      e_action_trigger_page_close,
    }
    /**
     * @enum {number}
     * @name Box
     * @memberof PDFNet.Page
     * @property {number} e_media
     * @property {number} e_crop
     * @property {number} e_bleed
     * @property {number} e_trim
     * @property {number} e_art
     */
    enum Box {
      e_media,
      e_crop,
      e_bleed,
      e_trim,
      e_art,
    }
    /**
     * @enum {number}
     * @name Rotate
     * @memberof PDFNet.Page
     * @property {number} e_0
     * @property {number} e_90
     * @property {number} e_180
     * @property {number} e_270
     */
    enum Rotate {
      e_0,
      e_90,
      e_180,
      e_270,
    }
  }
  namespace Annot {
    /**
     * @enum {number}
     * @name EventType
     * @memberof PDFNet.Annot
     * @property {number} e_action_trigger_activate
     * @property {number} e_action_trigger_annot_enter
     * @property {number} e_action_trigger_annot_exit
     * @property {number} e_action_trigger_annot_down
     * @property {number} e_action_trigger_annot_up
     * @property {number} e_action_trigger_annot_focus
     * @property {number} e_action_trigger_annot_blur
     * @property {number} e_action_trigger_annot_page_open
     * @property {number} e_action_trigger_annot_page_close
     * @property {number} e_action_trigger_annot_page_visible
     * @property {number} e_action_trigger_annot_page_invisible
     */
    enum EventType {
      e_action_trigger_activate,
      e_action_trigger_annot_enter,
      e_action_trigger_annot_exit,
      e_action_trigger_annot_down,
      e_action_trigger_annot_up,
      e_action_trigger_annot_focus,
      e_action_trigger_annot_blur,
      e_action_trigger_annot_page_open,
      e_action_trigger_annot_page_close,
      e_action_trigger_annot_page_visible,
      e_action_trigger_annot_page_invisible,
    }
    /**
     * @enum {number}
     * @name Type
     * @memberof PDFNet.Annot
     * @property {number} e_Text
     * @property {number} e_Link
     * @property {number} e_FreeText
     * @property {number} e_Line
     * @property {number} e_Square
     * @property {number} e_Circle
     * @property {number} e_Polygon
     * @property {number} e_Polyline
     * @property {number} e_Highlight
     * @property {number} e_Underline
     * @property {number} e_Squiggly
     * @property {number} e_StrikeOut
     * @property {number} e_Stamp
     * @property {number} e_Caret
     * @property {number} e_Ink
     * @property {number} e_Popup
     * @property {number} e_FileAttachment
     * @property {number} e_Sound
     * @property {number} e_Movie
     * @property {number} e_Widget
     * @property {number} e_Screen
     * @property {number} e_PrinterMark
     * @property {number} e_TrapNet
     * @property {number} e_Watermark
     * @property {number} e_3D
     * @property {number} e_Redact
     * @property {number} e_Projection
     * @property {number} e_RichMedia
     * @property {number} e_Unknown
     */
    enum Type {
      e_Text,
      e_Link,
      e_FreeText,
      e_Line,
      e_Square,
      e_Circle,
      e_Polygon,
      e_Polyline,
      e_Highlight,
      e_Underline,
      e_Squiggly,
      e_StrikeOut,
      e_Stamp,
      e_Caret,
      e_Ink,
      e_Popup,
      e_FileAttachment,
      e_Sound,
      e_Movie,
      e_Widget,
      e_Screen,
      e_PrinterMark,
      e_TrapNet,
      e_Watermark,
      e_3D,
      e_Redact,
      e_Projection,
      e_RichMedia,
      e_Unknown,
    }
    /**
     * @enum {number}
     * @name Flag
     * @memberof PDFNet.Annot
     * @property {number} e_invisible
     * @property {number} e_hidden
     * @property {number} e_print
     * @property {number} e_no_zoom
     * @property {number} e_no_rotate
     * @property {number} e_no_view
     * @property {number} e_annot_read_only
     * @property {number} e_locked
     * @property {number} e_toggle_no_view
     * @property {number} e_locked_contents
     */
    enum Flag {
      e_invisible,
      e_hidden,
      e_print,
      e_no_zoom,
      e_no_rotate,
      e_no_view,
      e_annot_read_only,
      e_locked,
      e_toggle_no_view,
      e_locked_contents,
    }
    /**
     * @enum {number}
     * @name State
     * @memberof PDFNet.Annot
     * @property {number} e_normal
     * @property {number} e_rollover
     * @property {number} e_down
     */
    enum State {
      e_normal,
      e_rollover,
      e_down,
    }
  }
  namespace AnnotBorderStyle {
    /**
     * @enum {number}
     * @name Style
     * @memberof PDFNet.AnnotBorderStyle
     * @property {number} e_solid
     * @property {number} e_dashed
     * @property {number} e_beveled
     * @property {number} e_inset
     * @property {number} e_underline
     */
    enum Style {
      e_solid,
      e_dashed,
      e_beveled,
      e_inset,
      e_underline,
    }
  }
  namespace LineAnnot {
    /**
     * @enum {number}
     * @name EndingStyle
     * @memberof PDFNet.LineAnnot
     * @property {number} e_Square
     * @property {number} e_Circle
     * @property {number} e_Diamond
     * @property {number} e_OpenArrow
     * @property {number} e_ClosedArrow
     * @property {number} e_Butt
     * @property {number} e_ROpenArrow
     * @property {number} e_RClosedArrow
     * @property {number} e_Slash
     * @property {number} e_None
     * @property {number} e_Unknown
     */
    enum EndingStyle {
      e_Square,
      e_Circle,
      e_Diamond,
      e_OpenArrow,
      e_ClosedArrow,
      e_Butt,
      e_ROpenArrow,
      e_RClosedArrow,
      e_Slash,
      e_None,
      e_Unknown,
    }
    /**
     * @enum {number}
     * @name IntentType
     * @memberof PDFNet.LineAnnot
     * @property {number} e_LineArrow
     * @property {number} e_LineDimension
     * @property {number} e_null
     */
    enum IntentType {
      e_LineArrow,
      e_LineDimension,
      e_null,
    }
    /**
     * @enum {number}
     * @name CapPos
     * @memberof PDFNet.LineAnnot
     * @property {number} e_Inline
     * @property {number} e_Top
     */
    enum CapPos {
      e_Inline,
      e_Top,
    }
  }
  namespace FileAttachmentAnnot {
    /**
     * @enum {number}
     * @name Icon
     * @memberof PDFNet.FileAttachmentAnnot
     * @property {number} e_Graph
     * @property {number} e_PushPin
     * @property {number} e_Paperclip
     * @property {number} e_Tag
     * @property {number} e_Unknown
     */
    enum Icon {
      e_Graph,
      e_PushPin,
      e_Paperclip,
      e_Tag,
      e_Unknown,
    }
  }
  namespace FreeTextAnnot {
    /**
     * @enum {number}
     * @name IntentName
     * @memberof PDFNet.FreeTextAnnot
     * @property {number} e_FreeText
     * @property {number} e_FreeTextCallout
     * @property {number} e_FreeTextTypeWriter
     * @property {number} e_Unknown
     */
    enum IntentName {
      e_FreeText,
      e_FreeTextCallout,
      e_FreeTextTypeWriter,
      e_Unknown,
    }
  }
  namespace LinkAnnot {
    /**
     * @enum {number}
     * @name HighlightingMode
     * @memberof PDFNet.LinkAnnot
     * @property {number} e_none
     * @property {number} e_invert
     * @property {number} e_outline
     * @property {number} e_push
     */
    enum HighlightingMode {
      e_none,
      e_invert,
      e_outline,
      e_push,
    }
  }
  namespace MarkupAnnot {
    /**
     * @enum {number}
     * @name BorderEffect
     * @memberof PDFNet.MarkupAnnot
     * @property {number} e_None
     * @property {number} e_Cloudy
     */
    enum BorderEffect {
      e_None,
      e_Cloudy,
    }
  }
  namespace PolyLineAnnot {
    /**
     * @enum {number}
     * @name IntentType
     * @memberof PDFNet.PolyLineAnnot
     * @property {number} e_PolygonCloud
     * @property {number} e_PolyLineDimension
     * @property {number} e_PolygonDimension
     * @property {number} e_Unknown
     */
    enum IntentType {
      e_PolygonCloud,
      e_PolyLineDimension,
      e_PolygonDimension,
      e_Unknown,
    }
  }
  namespace RedactionAnnot {
    /**
     * @enum {number}
     * @name QuadForm
     * @memberof PDFNet.RedactionAnnot
     * @property {number} e_LeftJustified
     * @property {number} e_Centered
     * @property {number} e_RightJustified
     * @property {number} e_None
     */
    enum QuadForm {
      e_LeftJustified,
      e_Centered,
      e_RightJustified,
      e_None,
    }
  }
  namespace RubberStampAnnot {
    /**
     * @enum {number}
     * @name Icon
     * @memberof PDFNet.RubberStampAnnot
     * @property {number} e_Approved
     * @property {number} e_Experimental
     * @property {number} e_NotApproved
     * @property {number} e_AsIs
     * @property {number} e_Expired
     * @property {number} e_NotForPublicRelease
     * @property {number} e_Confidential
     * @property {number} e_Final
     * @property {number} e_Sold
     * @property {number} e_Departmental
     * @property {number} e_ForComment
     * @property {number} e_TopSecret
     * @property {number} e_ForPublicRelease
     * @property {number} e_Draft
     * @property {number} e_Unknown
     */
    enum Icon {
      e_Approved,
      e_Experimental,
      e_NotApproved,
      e_AsIs,
      e_Expired,
      e_NotForPublicRelease,
      e_Confidential,
      e_Final,
      e_Sold,
      e_Departmental,
      e_ForComment,
      e_TopSecret,
      e_ForPublicRelease,
      e_Draft,
      e_Unknown,
    }
  }
  namespace ScreenAnnot {
    /**
     * @enum {number}
     * @name ScaleType
     * @memberof PDFNet.ScreenAnnot
     * @property {number} e_Anamorphic
     * @property {number} e_Proportional
     */
    enum ScaleType {
      e_Anamorphic,
      e_Proportional,
    }
    /**
     * @enum {number}
     * @name ScaleCondition
     * @memberof PDFNet.ScreenAnnot
     * @property {number} e_Always
     * @property {number} e_WhenBigger
     * @property {number} e_WhenSmaller
     * @property {number} e_Never
     */
    enum ScaleCondition {
      e_Always,
      e_WhenBigger,
      e_WhenSmaller,
      e_Never,
    }
    /**
     * @enum {number}
     * @name IconCaptionRelation
     * @memberof PDFNet.ScreenAnnot
     * @property {number} e_NoIcon
     * @property {number} e_NoCaption
     * @property {number} e_CBelowI
     * @property {number} e_CAboveI
     * @property {number} e_CRightILeft
     * @property {number} e_CLeftIRight
     * @property {number} e_COverlayI
     */
    enum IconCaptionRelation {
      e_NoIcon,
      e_NoCaption,
      e_CBelowI,
      e_CAboveI,
      e_CRightILeft,
      e_CLeftIRight,
      e_COverlayI,
    }
  }
  namespace SoundAnnot {
    /**
     * @enum {number}
     * @name Icon
     * @memberof PDFNet.SoundAnnot
     * @property {number} e_Speaker
     * @property {number} e_Mic
     * @property {number} e_Unknown
     */
    enum Icon {
      e_Speaker,
      e_Mic,
      e_Unknown,
    }
  }
  namespace TextAnnot {
    /**
     * @enum {number}
     * @name Icon
     * @memberof PDFNet.TextAnnot
     * @property {number} e_Comment
     * @property {number} e_Key
     * @property {number} e_Help
     * @property {number} e_NewParagraph
     * @property {number} e_Paragraph
     * @property {number} e_Insert
     * @property {number} e_Note
     * @property {number} e_Unknown
     */
    enum Icon {
      e_Comment,
      e_Key,
      e_Help,
      e_NewParagraph,
      e_Paragraph,
      e_Insert,
      e_Note,
      e_Unknown,
    }
  }
  namespace WidgetAnnot {
    /**
     * @enum {number}
     * @name HighlightingMode
     * @memberof PDFNet.WidgetAnnot
     * @property {number} e_none
     * @property {number} e_invert
     * @property {number} e_outline
     * @property {number} e_push
     * @property {number} e_toggle
     */
    enum HighlightingMode {
      e_none,
      e_invert,
      e_outline,
      e_push,
      e_toggle,
    }
    /**
     * @enum {number}
     * @name ScaleType
     * @memberof PDFNet.WidgetAnnot
     * @property {number} e_Anamorphic
     * @property {number} e_Proportional
     */
    enum ScaleType {
      e_Anamorphic,
      e_Proportional,
    }
    /**
     * @enum {number}
     * @name IconCaptionRelation
     * @memberof PDFNet.WidgetAnnot
     * @property {number} e_NoIcon
     * @property {number} e_NoCaption
     * @property {number} e_CBelowI
     * @property {number} e_CAboveI
     * @property {number} e_CRightILeft
     * @property {number} e_CLeftIRight
     * @property {number} e_COverlayI
     */
    enum IconCaptionRelation {
      e_NoIcon,
      e_NoCaption,
      e_CBelowI,
      e_CAboveI,
      e_CRightILeft,
      e_CLeftIRight,
      e_COverlayI,
    }
    /**
     * @enum {number}
     * @name ScaleCondition
     * @memberof PDFNet.WidgetAnnot
     * @property {number} e_Always
     * @property {number} e_WhenBigger
     * @property {number} e_WhenSmaller
     * @property {number} e_Never
     */
    enum ScaleCondition {
      e_Always,
      e_WhenBigger,
      e_WhenSmaller,
      e_Never,
    }
  }
  namespace ColorSpace {
    /**
     * @enum {number}
     * @name Type
     * @memberof PDFNet.ColorSpace
     * @property {number} e_device_gray
     * @property {number} e_device_rgb
     * @property {number} e_device_cmyk
     * @property {number} e_cal_gray
     * @property {number} e_cal_rgb
     * @property {number} e_lab
     * @property {number} e_icc
     * @property {number} e_indexed
     * @property {number} e_pattern
     * @property {number} e_separation
     * @property {number} e_device_n
     * @property {number} e_null
     */
    enum Type {
      e_device_gray,
      e_device_rgb,
      e_device_cmyk,
      e_cal_gray,
      e_cal_rgb,
      e_lab,
      e_icc,
      e_indexed,
      e_pattern,
      e_separation,
      e_device_n,
      e_null,
    }
  }
  namespace DocumentConversion {
    /**
     * @enum {number}
     * @name Result
     * @memberof PDFNet.DocumentConversion
     * @property {number} e_Success
     * @property {number} e_Incomplete
     * @property {number} e_Failure
     */
    enum Result {
      e_Success,
      e_Incomplete,
      e_Failure,
    }
  }
  namespace Destination {
    /**
     * @enum {number}
     * @name FitType
     * @memberof PDFNet.Destination
     * @property {number} e_XYZ
     * @property {number} e_Fit
     * @property {number} e_FitH
     * @property {number} e_FitV
     * @property {number} e_FitR
     * @property {number} e_FitB
     * @property {number} e_FitBH
     * @property {number} e_FitBV
     */
    enum FitType {
      e_XYZ,
      e_Fit,
      e_FitH,
      e_FitV,
      e_FitR,
      e_FitB,
      e_FitBH,
      e_FitBV,
    }
  }
  namespace GState {
    /**
     * @enum {number}
     * @name Attribute
     * @memberof PDFNet.GState
     * @property {number} e_transform
     * @property {number} e_rendering_intent
     * @property {number} e_stroke_cs
     * @property {number} e_stroke_color
     * @property {number} e_fill_cs
     * @property {number} e_fill_color
     * @property {number} e_line_width
     * @property {number} e_line_cap
     * @property {number} e_line_join
     * @property {number} e_flatness
     * @property {number} e_miter_limit
     * @property {number} e_dash_pattern
     * @property {number} e_char_spacing
     * @property {number} e_word_spacing
     * @property {number} e_horizontal_scale
     * @property {number} e_leading
     * @property {number} e_font
     * @property {number} e_font_size
     * @property {number} e_text_render_mode
     * @property {number} e_text_rise
     * @property {number} e_text_knockout
     * @property {number} e_text_pos_offset
     * @property {number} e_blend_mode
     * @property {number} e_opacity_fill
     * @property {number} e_opacity_stroke
     * @property {number} e_alpha_is_shape
     * @property {number} e_soft_mask
     * @property {number} e_smoothnes
     * @property {number} e_auto_stoke_adjust
     * @property {number} e_stroke_overprint
     * @property {number} e_fill_overprint
     * @property {number} e_overprint_mode
     * @property {number} e_transfer_funct
     * @property {number} e_BG_funct
     * @property {number} e_UCR_funct
     * @property {number} e_halftone
     * @property {number} e_null
     */
    enum Attribute {
      e_transform,
      e_rendering_intent,
      e_stroke_cs,
      e_stroke_color,
      e_fill_cs,
      e_fill_color,
      e_line_width,
      e_line_cap,
      e_line_join,
      e_flatness,
      e_miter_limit,
      e_dash_pattern,
      e_char_spacing,
      e_word_spacing,
      e_horizontal_scale,
      e_leading,
      e_font,
      e_font_size,
      e_text_render_mode,
      e_text_rise,
      e_text_knockout,
      e_text_pos_offset,
      e_blend_mode,
      e_opacity_fill,
      e_opacity_stroke,
      e_alpha_is_shape,
      e_soft_mask,
      e_smoothnes,
      e_auto_stoke_adjust,
      e_stroke_overprint,
      e_fill_overprint,
      e_overprint_mode,
      e_transfer_funct,
      e_BG_funct,
      e_UCR_funct,
      e_halftone,
      e_null,
    }
    /**
     * @enum {number}
     * @name LineCap
     * @memberof PDFNet.GState
     * @property {number} e_butt_cap
     * @property {number} e_round_cap
     * @property {number} e_square_cap
     */
    enum LineCap {
      e_butt_cap,
      e_round_cap,
      e_square_cap,
    }
    /**
     * @enum {number}
     * @name LineJoin
     * @memberof PDFNet.GState
     * @property {number} e_miter_join
     * @property {number} e_round_join
     * @property {number} e_bevel_join
     */
    enum LineJoin {
      e_miter_join,
      e_round_join,
      e_bevel_join,
    }
    /**
     * @enum {number}
     * @name TextRenderingMode
     * @memberof PDFNet.GState
     * @property {number} e_fill_text
     * @property {number} e_stroke_text
     * @property {number} e_fill_stroke_text
     * @property {number} e_invisible_text
     * @property {number} e_fill_clip_text
     * @property {number} e_stroke_clip_text
     * @property {number} e_fill_stroke_clip_text
     * @property {number} e_clip_text
     */
    enum TextRenderingMode {
      e_fill_text,
      e_stroke_text,
      e_fill_stroke_text,
      e_invisible_text,
      e_fill_clip_text,
      e_stroke_clip_text,
      e_fill_stroke_clip_text,
      e_clip_text,
    }
    /**
     * @enum {number}
     * @name RenderingIntent
     * @memberof PDFNet.GState
     * @property {number} e_absolute_colorimetric
     * @property {number} e_relative_colorimetric
     * @property {number} e_saturation
     * @property {number} e_perceptual
     */
    enum RenderingIntent {
      e_absolute_colorimetric,
      e_relative_colorimetric,
      e_saturation,
      e_perceptual,
    }
    /**
     * @enum {number}
     * @name BlendMode
     * @memberof PDFNet.GState
     * @property {number} e_bl_compatible
     * @property {number} e_bl_normal
     * @property {number} e_bl_multiply
     * @property {number} e_bl_screen
     * @property {number} e_bl_difference
     * @property {number} e_bl_darken
     * @property {number} e_bl_lighten
     * @property {number} e_bl_color_dodge
     * @property {number} e_bl_color_burn
     * @property {number} e_bl_exclusion
     * @property {number} e_bl_hard_light
     * @property {number} e_bl_overlay
     * @property {number} e_bl_soft_light
     * @property {number} e_bl_luminosity
     * @property {number} e_bl_hue
     * @property {number} e_bl_saturation
     * @property {number} e_bl_color
     */
    enum BlendMode {
      e_bl_compatible,
      e_bl_normal,
      e_bl_multiply,
      e_bl_screen,
      e_bl_difference,
      e_bl_darken,
      e_bl_lighten,
      e_bl_color_dodge,
      e_bl_color_burn,
      e_bl_exclusion,
      e_bl_hard_light,
      e_bl_overlay,
      e_bl_soft_light,
      e_bl_luminosity,
      e_bl_hue,
      e_bl_saturation,
      e_bl_color,
    }
  }
  namespace Element {
    /**
     * @enum {number}
     * @name Type
     * @memberof PDFNet.Element
     * @property {number} e_null
     * @property {number} e_path
     * @property {number} e_text_begin
     * @property {number} e_text
     * @property {number} e_text_new_line
     * @property {number} e_text_end
     * @property {number} e_image
     * @property {number} e_inline_image
     * @property {number} e_shading
     * @property {number} e_form
     * @property {number} e_group_begin
     * @property {number} e_group_end
     * @property {number} e_marked_content_begin
     * @property {number} e_marked_content_end
     * @property {number} e_marked_content_point
     */
    enum Type {
      e_null,
      e_path,
      e_text_begin,
      e_text,
      e_text_new_line,
      e_text_end,
      e_image,
      e_inline_image,
      e_shading,
      e_form,
      e_group_begin,
      e_group_end,
      e_marked_content_begin,
      e_marked_content_end,
      e_marked_content_point,
    }
    /**
     * @enum {number}
     * @name PathSegmentType
     * @memberof PDFNet.Element
     * @property {number} e_moveto
     * @property {number} e_lineto
     * @property {number} e_cubicto
     * @property {number} e_conicto
     * @property {number} e_rect
     * @property {number} e_closepath
     */
    enum PathSegmentType {
      e_moveto,
      e_lineto,
      e_cubicto,
      e_conicto,
      e_rect,
      e_closepath,
    }
  }
  namespace ElementWriter {
    /**
     * @enum {number}
     * @name WriteMode
     * @memberof PDFNet.ElementWriter
     * @property {number} e_underlay
     * @property {number} e_overlay
     * @property {number} e_replacement
     */
    enum WriteMode {
      e_underlay,
      e_overlay,
      e_replacement,
    }
  }
  namespace Flattener {
    /**
     * @enum {number}
     * @name Threshold
     * @memberof PDFNet.Flattener
     * @property {number} e_very_strict
     * @property {number} e_strict
     * @property {number} e_default
     * @property {number} e_keep_most
     * @property {number} e_keep_all
     */
    enum Threshold {
      e_very_strict,
      e_strict,
      e_default,
      e_keep_most,
      e_keep_all,
    }
    /**
     * @enum {number}
     * @name Mode
     * @memberof PDFNet.Flattener
     * @property {number} e_simple
     * @property {number} e_fast
     */
    enum Mode {
      e_simple,
      e_fast,
    }
  }
  namespace Font {
    /**
     * @enum {number}
     * @name StandardType1Font
     * @memberof PDFNet.Font
     * @property {number} e_times_roman
     * @property {number} e_times_bold
     * @property {number} e_times_italic
     * @property {number} e_times_bold_italic
     * @property {number} e_helvetica
     * @property {number} e_helvetica_bold
     * @property {number} e_helvetica_oblique
     * @property {number} e_helvetica_bold_oblique
     * @property {number} e_courier
     * @property {number} e_courier_bold
     * @property {number} e_courier_oblique
     * @property {number} e_courier_bold_oblique
     * @property {number} e_symbol
     * @property {number} e_zapf_dingbats
     * @property {number} e_null
     */
    enum StandardType1Font {
      e_times_roman,
      e_times_bold,
      e_times_italic,
      e_times_bold_italic,
      e_helvetica,
      e_helvetica_bold,
      e_helvetica_oblique,
      e_helvetica_bold_oblique,
      e_courier,
      e_courier_bold,
      e_courier_oblique,
      e_courier_bold_oblique,
      e_symbol,
      e_zapf_dingbats,
      e_null,
    }
    /**
     * @enum {number}
     * @name Encoding
     * @memberof PDFNet.Font
     * @property {number} e_IdentityH
     * @property {number} e_Indices
     */
    enum Encoding {
      e_IdentityH,
      e_Indices,
    }
    /**
     * @enum {number}
     * @name Type
     * @memberof PDFNet.Font
     * @property {number} e_Type1
     * @property {number} e_TrueType
     * @property {number} e_MMType1
     * @property {number} e_Type3
     * @property {number} e_Type0
     * @property {number} e_CIDType0
     * @property {number} e_CIDType2
     */
    enum Type {
      e_Type1,
      e_TrueType,
      e_MMType1,
      e_Type3,
      e_Type0,
      e_CIDType0,
      e_CIDType2,
    }
  }
  namespace Function {
    /**
     * @enum {number}
     * @name Type
     * @memberof PDFNet.Function
     * @property {number} e_sampled
     * @property {number} e_exponential
     * @property {number} e_stitching
     * @property {number} e_postscript
     */
    enum Type {
      e_sampled,
      e_exponential,
      e_stitching,
      e_postscript,
    }
  }
  namespace Image {
    /**
     * @enum {number}
     * @name InputFilter
     * @memberof PDFNet.Image
     * @property {number} e_none
     * @property {number} e_jpeg
     * @property {number} e_jp2
     * @property {number} e_flate
     * @property {number} e_g3
     * @property {number} e_g4
     * @property {number} e_ascii_hex
     */
    enum InputFilter {
      e_none,
      e_jpeg,
      e_jp2,
      e_flate,
      e_g3,
      e_g4,
      e_ascii_hex,
    }
  }
  namespace PageLabel {
    /**
     * @enum {number}
     * @name Style
     * @memberof PDFNet.PageLabel
     * @property {number} e_decimal
     * @property {number} e_roman_uppercase
     * @property {number} e_roman_lowercase
     * @property {number} e_alphabetic_uppercase
     * @property {number} e_alphabetic_lowercase
     * @property {number} e_none
     */
    enum Style {
      e_decimal,
      e_roman_uppercase,
      e_roman_lowercase,
      e_alphabetic_uppercase,
      e_alphabetic_lowercase,
      e_none,
    }
  }
  namespace PageSet {
    /**
     * @enum {number}
     * @name Filter
     * @memberof PDFNet.PageSet
     * @property {number} e_all
     * @property {number} e_even
     * @property {number} e_odd
     */
    enum Filter {
      e_all,
      e_even,
      e_odd,
    }
  }
  namespace PatternColor {
    /**
     * @enum {number}
     * @name Type
     * @memberof PDFNet.PatternColor
     * @property {number} e_uncolored_tiling_pattern
     * @property {number} e_colored_tiling_pattern
     * @property {number} e_shading
     * @property {number} e_null
     */
    enum Type {
      e_uncolored_tiling_pattern,
      e_colored_tiling_pattern,
      e_shading,
      e_null,
    }
    /**
     * @enum {number}
     * @name TilingType
     * @memberof PDFNet.PatternColor
     * @property {number} e_constant_spacing
     * @property {number} e_no_distortion
     * @property {number} e_constant_spacing_fast_fill
     */
    enum TilingType {
      e_constant_spacing,
      e_no_distortion,
      e_constant_spacing_fast_fill,
    }
  }
  namespace GeometryCollection {
    /**
     * @enum {number}
     * @name SnappingMode
     * @memberof PDFNet.GeometryCollection
     * @property {number} e_DefaultSnapMode
     * @property {number} e_PointOnLine
     * @property {number} e_LineMidpoint
     * @property {number} e_LineIntersection
     * @property {number} e_PathEndpoint
     */
    enum SnappingMode {
      e_DefaultSnapMode,
      e_PointOnLine,
      e_LineMidpoint,
      e_LineIntersection,
      e_PathEndpoint,
    }
  }
  namespace DigitalSignatureField {
    /**
     * @enum {number}
     * @name SubFilterType
     * @memberof PDFNet.DigitalSignatureField
     * @property {number} e_adbe_x509_rsa_sha1
     * @property {number} e_adbe_pkcs7_detached
     * @property {number} e_adbe_pkcs7_sha1
     * @property {number} e_ETSI_CAdES_detached
     * @property {number} e_ETSI_RFC3161
     * @property {number} e_unknown
     * @property {number} e_absent
     */
    enum SubFilterType {
      e_adbe_x509_rsa_sha1,
      e_adbe_pkcs7_detached,
      e_adbe_pkcs7_sha1,
      e_ETSI_CAdES_detached,
      e_ETSI_RFC3161,
      e_unknown,
      e_absent,
    }
    /**
     * @enum {number}
     * @name DocumentPermissions
     * @memberof PDFNet.DigitalSignatureField
     * @property {number} e_no_changes_allowed
     * @property {number} e_formfilling_signing_allowed
     * @property {number} e_annotating_formfilling_signing_allowed
     * @property {number} e_unrestricted
     */
    enum DocumentPermissions {
      e_no_changes_allowed,
      e_formfilling_signing_allowed,
      e_annotating_formfilling_signing_allowed,
      e_unrestricted,
    }
    /**
     * @enum {number}
     * @name FieldPermissions
     * @memberof PDFNet.DigitalSignatureField
     * @property {number} e_lock_all
     * @property {number} e_include
     * @property {number} e_exclude
     */
    enum FieldPermissions {
      e_lock_all,
      e_include,
      e_exclude,
    }
  }
  namespace PDFDoc {
    /**
     * @enum {number}
     * @name EventType
     * @memberof PDFNet.PDFDoc
     * @property {number} e_action_trigger_doc_will_close
     * @property {number} e_action_trigger_doc_will_save
     * @property {number} e_action_trigger_doc_did_save
     * @property {number} e_action_trigger_doc_will_print
     * @property {number} e_action_trigger_doc_did_print
     */
    enum EventType {
      e_action_trigger_doc_will_close,
      e_action_trigger_doc_will_save,
      e_action_trigger_doc_did_save,
      e_action_trigger_doc_will_print,
      e_action_trigger_doc_did_print,
    }
    /**
     * @enum {number}
     * @name InsertFlag
     * @memberof PDFNet.PDFDoc
     * @property {number} e_none
     * @property {number} e_insert_bookmark
     */
    enum InsertFlag {
      e_none,
      e_insert_bookmark,
    }
    /**
     * @enum {number}
     * @name ExtractFlag
     * @memberof PDFNet.PDFDoc
     * @property {number} e_forms_only
     * @property {number} e_annots_only
     * @property {number} e_both
     */
    enum ExtractFlag {
      e_forms_only,
      e_annots_only,
      e_both,
    }
  }
  namespace PDFDocViewPrefs {
    /**
     * @enum {number}
     * @name PageMode
     * @memberof PDFNet.PDFDocViewPrefs
     * @property {number} e_UseNone
     * @property {number} e_UseThumbs
     * @property {number} e_UseBookmarks
     * @property {number} e_FullScreen
     * @property {number} e_UseOC
     * @property {number} e_UseAttachments
     */
    enum PageMode {
      e_UseNone,
      e_UseThumbs,
      e_UseBookmarks,
      e_FullScreen,
      e_UseOC,
      e_UseAttachments,
    }
    /**
     * @enum {number}
     * @name PageLayout
     * @memberof PDFNet.PDFDocViewPrefs
     * @property {number} e_Default
     * @property {number} e_SinglePage
     * @property {number} e_OneColumn
     * @property {number} e_TwoColumnLeft
     * @property {number} e_TwoColumnRight
     * @property {number} e_TwoPageLeft
     * @property {number} e_TwoPageRight
     */
    enum PageLayout {
      e_Default,
      e_SinglePage,
      e_OneColumn,
      e_TwoColumnLeft,
      e_TwoColumnRight,
      e_TwoPageLeft,
      e_TwoPageRight,
    }
    /**
     * @enum {number}
     * @name ViewerPref
     * @memberof PDFNet.PDFDocViewPrefs
     * @property {number} e_HideToolbar
     * @property {number} e_HideMenubar
     * @property {number} e_HideWindowUI
     * @property {number} e_FitWindow
     * @property {number} e_CenterWindow
     * @property {number} e_DisplayDocTitle
     */
    enum ViewerPref {
      e_HideToolbar,
      e_HideMenubar,
      e_HideWindowUI,
      e_FitWindow,
      e_CenterWindow,
      e_DisplayDocTitle,
    }
  }
  namespace PDFRasterizer {
    /**
     * @enum {number}
     * @name Type
     * @memberof PDFNet.PDFRasterizer
     * @property {number} e_BuiltIn
     * @property {number} e_GDIPlus
     */
    enum Type {
      e_BuiltIn,
      e_GDIPlus,
    }
    /**
     * @enum {number}
     * @name OverprintPreviewMode
     * @memberof PDFNet.PDFRasterizer
     * @property {number} e_op_off
     * @property {number} e_op_on
     * @property {number} e_op_pdfx_on
     */
    enum OverprintPreviewMode {
      e_op_off,
      e_op_on,
      e_op_pdfx_on,
    }
    /**
     * @enum {number}
     * @name ColorPostProcessMode
     * @memberof PDFNet.PDFRasterizer
     * @property {number} e_postprocess_none
     * @property {number} e_postprocess_invert
     */
    enum ColorPostProcessMode {
      e_postprocess_none,
      e_postprocess_invert,
    }
  }
  namespace PDFDraw {
    /**
     * @enum {number}
     * @name PixelFormat
     * @memberof PDFNet.PDFDraw
     * @property {number} e_rgba
     * @property {number} e_bgra
     * @property {number} e_rgb
     * @property {number} e_bgr
     * @property {number} e_gray
     * @property {number} e_gray_alpha
     * @property {number} e_cmyk
     */
    enum PixelFormat {
      e_rgba,
      e_bgra,
      e_rgb,
      e_bgr,
      e_gray,
      e_gray_alpha,
      e_cmyk,
    }
  }
  /**
   * @enum {number}
   * @name CMSType
   * @memberof PDFNet
   * @property {number} e_lcms
   * @property {number} e_icm
   * @property {number} e_no_cms
   */
  enum CMSType {
    e_lcms,
    e_icm,
    e_no_cms,
  }
  /**
   * @enum {number}
   * @name CharacterOrdering
   * @memberof PDFNet
   * @property {number} e_Identity
   * @property {number} e_Japan1
   * @property {number} e_Japan2
   * @property {number} e_GB1
   * @property {number} e_CNS1
   * @property {number} e_Korea1
   */
  enum CharacterOrdering {
    e_Identity,
    e_Japan1,
    e_Japan2,
    e_GB1,
    e_CNS1,
    e_Korea1,
  }
  /**
   * @enum {number}
   * @name LogLevel
   * @memberof PDFNet
   * @property {number} e_LogLevel_Off
   * @property {number} e_LogLevel_Fatal
   * @property {number} e_LogLevel_Error
   * @property {number} e_LogLevel_Warning
   * @property {number} e_LogLevel_Info
   * @property {number} e_LogLevel_Trace
   * @property {number} e_LogLevel_Debug
   */
  enum LogLevel {
    e_LogLevel_Off,
    e_LogLevel_Fatal,
    e_LogLevel_Error,
    e_LogLevel_Warning,
    e_LogLevel_Info,
    e_LogLevel_Trace,
    e_LogLevel_Debug,
  }
  namespace Shading {
    /**
     * @enum {number}
     * @name Type
     * @memberof PDFNet.Shading
     * @property {number} e_function_shading
     * @property {number} e_axial_shading
     * @property {number} e_radial_shading
     * @property {number} e_free_gouraud_shading
     * @property {number} e_lattice_gouraud_shading
     * @property {number} e_coons_shading
     * @property {number} e_tensor_shading
     * @property {number} e_null
     */
    enum Type {
      e_function_shading,
      e_axial_shading,
      e_radial_shading,
      e_free_gouraud_shading,
      e_lattice_gouraud_shading,
      e_coons_shading,
      e_tensor_shading,
      e_null,
    }
  }
  namespace Stamper {
    /**
     * @enum {number}
     * @name SizeType
     * @memberof PDFNet.Stamper
     * @property {number} e_relative_scale
     * @property {number} e_absolute_size
     * @property {number} e_font_size
     */
    enum SizeType {
      e_relative_scale,
      e_absolute_size,
      e_font_size,
    }
    /**
     * @enum {number}
     * @name TextAlignment
     * @memberof PDFNet.Stamper
     * @property {number} e_align_left
     * @property {number} e_align_center
     * @property {number} e_align_right
     */
    enum TextAlignment {
      e_align_left,
      e_align_center,
      e_align_right,
    }
    /**
     * @enum {number}
     * @name HorizontalAlignment
     * @memberof PDFNet.Stamper
     * @property {number} e_horizontal_left
     * @property {number} e_horizontal_center
     * @property {number} e_horizontal_right
     */
    enum HorizontalAlignment {
      e_horizontal_left,
      e_horizontal_center,
      e_horizontal_right,
    }
    /**
     * @enum {number}
     * @name VerticalAlignment
     * @memberof PDFNet.Stamper
     * @property {number} e_vertical_bottom
     * @property {number} e_vertical_center
     * @property {number} e_vertical_top
     */
    enum VerticalAlignment {
      e_vertical_bottom,
      e_vertical_center,
      e_vertical_top,
    }
  }
  namespace TextExtractor {
    /**
     * @enum {number}
     * @name ProcessingFlags
     * @memberof PDFNet.TextExtractor
     * @property {number} e_no_ligature_exp
     * @property {number} e_no_dup_remove
     * @property {number} e_punct_break
     * @property {number} e_remove_hidden_text
     * @property {number} e_no_invisible_text
     */
    enum ProcessingFlags {
      e_no_ligature_exp,
      e_no_dup_remove,
      e_punct_break,
      e_remove_hidden_text,
      e_no_invisible_text,
    }
    /**
     * @enum {number}
     * @name XMLOutputFlags
     * @memberof PDFNet.TextExtractor
     * @property {number} e_words_as_elements
     * @property {number} e_output_bbox
     * @property {number} e_output_style_info
     */
    enum XMLOutputFlags {
      e_words_as_elements,
      e_output_bbox,
      e_output_style_info,
    }
  }
  namespace TextSearch {
    /**
     * @enum {number}
     * @name ResultCode
     * @memberof PDFNet.TextSearch
     * @property {number} e_done
     * @property {number} e_page
     * @property {number} e_found
     */
    enum ResultCode {
      e_done,
      e_page,
      e_found,
    }
    /**
     * @enum {number}
     * @name Mode
     * @memberof PDFNet.TextSearch
     * @property {number} e_reg_expression
     * @property {number} e_case_sensitive
     * @property {number} e_whole_word
     * @property {number} e_search_up
     * @property {number} e_page_stop
     * @property {number} e_highlight
     * @property {number} e_ambient_string
     */
    enum Mode {
      e_reg_expression,
      e_case_sensitive,
      e_whole_word,
      e_search_up,
      e_page_stop,
      e_highlight,
      e_ambient_string,
    }
  }
  namespace Obj {
    /**
     * @enum {number}
     * @name Type
     * @memberof PDFNet.Obj
     * @property {number} e_null
     * @property {number} e_bool
     * @property {number} e_number
     * @property {number} e_name
     * @property {number} e_string
     * @property {number} e_dict
     * @property {number} e_array
     * @property {number} e_stream
     */
    enum Type {
      e_null,
      e_bool,
      e_number,
      e_name,
      e_string,
      e_dict,
      e_array,
      e_stream,
    }
  }
  namespace SDFDoc {
    /**
     * @enum {number}
     * @name SaveOptions
     * @memberof PDFNet.SDFDoc
     * @property {number} e_incremental
     * @property {number} e_remove_unused
     * @property {number} e_hex_strings
     * @property {number} e_omit_xref
     * @property {number} e_linearized
     * @property {number} e_compatibility
     */
    enum SaveOptions {
      e_incremental,
      e_remove_unused,
      e_hex_strings,
      e_omit_xref,
      e_linearized,
      e_compatibility,
    }
  }
  namespace SecurityHandler {
    /**
     * @enum {number}
     * @name Permission
     * @memberof PDFNet.SecurityHandler
     * @property {number} e_owner
     * @property {number} e_doc_open
     * @property {number} e_doc_modify
     * @property {number} e_print
     * @property {number} e_print_high
     * @property {number} e_extract_content
     * @property {number} e_mod_annot
     * @property {number} e_fill_forms
     * @property {number} e_access_support
     * @property {number} e_assemble_doc
     */
    enum Permission {
      e_owner,
      e_doc_open,
      e_doc_modify,
      e_print,
      e_print_high,
      e_extract_content,
      e_mod_annot,
      e_fill_forms,
      e_access_support,
      e_assemble_doc,
    }
    /**
     * @enum {number}
     * @name AlgorithmType
     * @memberof PDFNet.SecurityHandler
     * @property {number} e_RC4_40
     * @property {number} e_RC4_128
     * @property {number} e_AES
     * @property {number} e_AES_256
     */
    enum AlgorithmType {
      e_RC4_40,
      e_RC4_128,
      e_AES,
      e_AES_256,
    }
  }
  namespace VerificationOptions {
    /**
     * @enum {number}
     * @name SecurityLevel
     * @memberof PDFNet.VerificationOptions
     * @property {number} e_compatibility_and_archiving
     * @property {number} e_maximum
     */
    enum SecurityLevel {
      e_compatibility_and_archiving,
      e_maximum,
    }
    /**
     * @enum {number}
     * @name TimeMode
     * @memberof PDFNet.VerificationOptions
     * @property {number} e_signing
     * @property {number} e_timestamp
     * @property {number} e_current
     */
    enum TimeMode {
      e_signing,
      e_timestamp,
      e_current,
    }
  }
  namespace DigestAlgorithm {
    /**
     * @enum {number}
     * @name Type
     * @memberof PDFNet.DigestAlgorithm
     * @property {number} e_SHA1
     * @property {number} e_SHA256
     * @property {number} e_SHA384
     * @property {number} e_SHA512
     * @property {number} e_RIPEMD160
     * @property {number} e_unknown_digest_algorithm
     */
    enum Type {
      e_SHA1,
      e_SHA256,
      e_SHA384,
      e_SHA512,
      e_RIPEMD160,
      e_unknown_digest_algorithm,
    }
  }
  namespace VerificationResult {
    /**
     * @enum {number}
     * @name DocumentStatus
     * @memberof PDFNet.VerificationResult
     * @property {number} e_no_error
     * @property {number} e_corrupt_file
     * @property {number} e_unsigned
     * @property {number} e_bad_byteranges
     * @property {number} e_corrupt_cryptographic_contents
     */
    enum DocumentStatus {
      e_no_error,
      e_corrupt_file,
      e_unsigned,
      e_bad_byteranges,
      e_corrupt_cryptographic_contents,
    }
    /**
     * @enum {number}
     * @name DigestStatus
     * @memberof PDFNet.VerificationResult
     * @property {number} e_digest_invalid
     * @property {number} e_digest_verified
     * @property {number} e_digest_verification_disabled
     * @property {number} e_weak_digest_algorithm_but_digest_verifiable
     * @property {number} e_no_digest_status
     * @property {number} e_unsupported_encoding
     */
    enum DigestStatus {
      e_digest_invalid,
      e_digest_verified,
      e_digest_verification_disabled,
      e_weak_digest_algorithm_but_digest_verifiable,
      e_no_digest_status,
      e_unsupported_encoding,
    }
    /**
     * @enum {number}
     * @name TrustStatus
     * @memberof PDFNet.VerificationResult
     * @property {number} e_trust_verified
     * @property {number} e_untrusted
     * @property {number} e_trust_verification_disabled
     * @property {number} e_no_trust_status
     */
    enum TrustStatus {
      e_trust_verified,
      e_untrusted,
      e_trust_verification_disabled,
      e_no_trust_status,
    }
    /**
     * @enum {number}
     * @name ModificationPermissionsStatus
     * @memberof PDFNet.VerificationResult
     * @property {number} e_invalidated_by_disallowed_changes
     * @property {number} e_has_allowed_changes
     * @property {number} e_unmodified
     * @property {number} e_permissions_verification_disabled
     * @property {number} e_no_permissions_status
     */
    enum ModificationPermissionsStatus {
      e_invalidated_by_disallowed_changes,
      e_has_allowed_changes,
      e_unmodified,
      e_permissions_verification_disabled,
      e_no_permissions_status,
    }
  }
  namespace DisallowedChange {
    /**
     * @enum {number}
     * @name Type
     * @memberof PDFNet.DisallowedChange
     * @property {number} e_form_filled
     * @property {number} e_digital_signature_signed
     * @property {number} e_page_template_instantiated
     * @property {number} e_annotation_created_or_updated_or_deleted
     * @property {number} e_other
     * @property {number} e_unknown
     */
    enum Type {
      e_form_filled,
      e_digital_signature_signed,
      e_page_template_instantiated,
      e_annotation_created_or_updated_or_deleted,
      e_other,
      e_unknown,
    }
  }
  /**
   *
   * @method PDFNet..getNormalizedUrl
   * @param {string} url
   * @return {Promise<string>} A promise that resolves to an object of type: "string"
   */
  function getNormalizedUrl(url: string): Promise<string>;
  /**
   *
   * @method PDFNet..pdfGetDownloadedByteCount
   * @param {PDFNet.PDFDoc} doc
   * @return {Promise<number>} A promise that resolves to an object of type: "number"
   */
  function pdfGetDownloadedByteCount(doc: PDFNet.PDFDoc): Promise<number>;
  /**
   *
   * @method PDFNet..pdfGetTotalRemoteByteCount
   * @param {PDFNet.PDFDoc} doc
   * @return {Promise<number>} A promise that resolves to an object of type: "number"
   */
  function pdfGetTotalRemoteByteCount(doc: PDFNet.PDFDoc): Promise<number>;
  /**
   * A switch that can be used to turn on/off JavaScript engine
   *
   * @method PDFNet.enableJavaScript
   * @param {boolean} enable true to enable JavaScript engine, false to disable.
   */
  function enableJavaScript(enable: boolean): void;
  /**
   * Test whether JavaScript is enabled
   *
   * @method PDFNet.isJavaScriptEnabled
   * @return {Promise<boolean>} A promise that resolves to true if it is enabled, false otherwise
   */
  function isJavaScriptEnabled(): Promise<boolean>;
  /**
   * Sets the location of PDFNet resource file.
   *
   * @method PDFNet.addResourceSearchPath
   * @note Starting with v.4.5 PDFNet no longer requires a seperate resource file,
   * and so this function is not required for proper PDFNet initialization.
   * The function can be used on all platforms to specify search paths for
   * ICC profiles, fonts, and other user defined resources.
   *
   * @param {string} path The resource directory path to add to the search list.
   */
  function addResourceSearchPath(path: string): void;
  /**
   * used to set a specific Color Management System (CMS) for
   * use during color conversion operators, image rendering, etc.
   *
   * @method PDFNet.setColorManagement
   * @param {number} [t]
   * <pre>
   * PDFNet.CMSType = {
   * 	e_lcms : 0
   * 	e_icm : 1
   * 	e_no_cms : 2
   * }
   * </pre>
   * identifies the type of color management to use.
   */
  function setColorManagement(t?: number): void;
  /**
   *  sets the default compression level for Flate (ZLib).
   *
   *	@method PDFNet.setDefaultFlateCompressionLevel
   * @param {number} level An integer in range 0-9 representing the compression value to use as
   *  a default for any Flate streams (e.g used to compress content streams, PNG images, etc).
   *  The library normally uses the default compression level (Z_DEFAULT_COMPRESSION).
   *  For most images, compression values in the range 3-6 compress nearly as well as higher
   *  levels, and do so much faster. For on-line applications it may be desirable to have
   *  maximum speed Z_BEST_SPEED = 1). You can also specify no compression (Z_NO_COMPRESSION = 0).
   *
   *	@default Z_DEFAULT_COMPRESSION (-1).
   */
  function setDefaultFlateCompressionLevel(level: number): void;
  /**
   * @method PDFNet.getVersion
   * @return {Promise<number>} A promise that resolves to pDFNet version number.
   */
  function getVersion(): Promise<number>;
  /**
   *
   * @method PDFNet.setLogLevel
   * @param {number} [level]
   * <pre>
   * PDFNet.LogLevel = {
   * 	e_LogLevel_Off : -1
   * 	e_LogLevel_Fatal : 5
   * 	e_LogLevel_Error : 4
   * 	e_LogLevel_Warning : 3
   * 	e_LogLevel_Info : 2
   * 	e_LogLevel_Trace : 1
   * 	e_LogLevel_Debug : 0
   * }
   * </pre>
   */
  function setLogLevel(level?: number): void;
  /**
   * Get available fonts on the system.
   *
   * @method PDFNet.getSystemFontList
   * @return {Promise<string>} A promise that resolves to a JSON list of fonts accessible to PDFNet
   */
  function getSystemFontList(): Promise<string>;
  /**
   * This function is a utility method which will initialize PDFNet and
   * execute an action defined by the first parameter generator. Unlike
   * runGeneratorWithCleanup this method will not clean up PDFNet resources
   * which can be useful when the user wishes to keep some of the objects alive.
   * @method PDFNet.runGeneratorWithoutCleanup
   * @param {object} generator The generator object function to execute.
   * @param {string} [license_key] the license key used to initialize PDFNet.
   * @return a promise that resolves to the return value of the generator.
   */
  function runGeneratorWithoutCleanup(generator: any, license_key?: string): any;
  /**
   * This function is a utility method which will initialize PDFNet, begin a PDFNet operation
   * execute an action defined by the first parameter generator and then finish this operation.
   * This method will also clean up all PDFNet resources that are allocated
   * within the generator which can greatly simplify user code. In some cases the user
   * may wish to keep PDFNet objects alive out of the scope of this generator
   * function in which case runGeneratorWithoutCleanup should be used instead.
   * @method PDFNet.runGeneratorWithCleanup
   * @param {object} generator The generator object function to execute.
   * @param {string} [license_key] the license key used to initialize PDFNet.
   * @return a promise that resolves to the return value of the generator.
   */
  function runGeneratorWithCleanup(generator: any, license_key?: string): any;
  /**
   * Displays in the console a list of objects still in memory in the form of their type and ID.
   * @method PDFNet.displayAllocatedObjects
   */
  function displayAllocatedObjects(): void;
  /**
   * startDeallocateStack initializes a deallocation point. All functions which create objects that take up
   * memory after the most recent startDeallocateStack call will be deallocated upon calling
   * PDFNet.endDeallocateStack().
   * @method PDFNet.startDeallocateStack
   */
  function startDeallocateStack(): void;
  /**
   * Deallocates all objects in memory that were created after the most recent startDeallocateStack call.
   * @method PDFNet.endDeallocateStack
   *
   */
  function endDeallocateStack(): void;
  /**
   * Gets the number of PDFNet.startDeallocateStack() calls made that have not yet been ended.
   * @method PDFNet.getStackCount
   * @return {Promise<number>} A promise that resolves to the number of PDFNet.startDeallocateStack() calls
   * not yet ended.
   *
   */
  function getStackCount(): Promise<number>;
  /**
   * Removes all PDFNetJS objects from memory.
   * @method PDFNet.deallocateAllObjects
   */
  function deallocateAllObjects(): void;
  /**
   * beginOperation locks all Emscripten worker operations on PDFNet so as to avoid
   * potential editing conflicts. Calling beginOperation a second time before
   * finishOperation is called will result in an exception being thrown. This can be
   * disabled allowing multiple beginOperations to be called by passing in an options
   * object (a default javascript object {}) with its parameter "allowMultipleInstances"
   * set to "true".
   * @method PDFNet.beginOperation
   * @param {Object} [optionsObj={}]
   * @param {boolean} [optionsObj.allowMultipleInstances=false] If allowMultipleInstances
   * set to true, multiple instances of beginOperation will be allowed.
   */
  function beginOperation(optionsObj?: { allowMultipleInstances?: boolean }): void;
  /**
   * finishOperation releases the lock on all Emscripten worker operations on PDFNet.
   * Will do nothing if PDFNet.beginOperation has not been called earlier.
   * @method PDFNet.finishOperation
   */
  function finishOperation(): void;
  /**
   * This function is a utility method which will initialize PDFNet, begin a PDFNet operation
   * and run a callback function passed in. This method will also clean up all PDFNet resources that are allocated
   * within the function which can greatly simplify user code. In some cases the user
   * may wish to keep PDFNet objects alive out of the scope of this
   * function in which case runWithoutCleanup should be used instead.
   * @method PDFNet.runWithCleanup
   * @param {function} callback A callback function to execute
   * @param {string} license_key the license key used to initialize PDFNet.
   * @return a promise that resolves to the return value (if there is one) of the input function
   */
  function runWithCleanup(callback: (...params: any[]) => any, license_key: string): any;
  /**
   * This function is a utility method which will initialize PDFNet and
   * execute an input. Unlike runWithCleanup this method will not clean up PDFNet resources
   * which can be useful if the user wishes to keep some of the objects alive.
   * @method PDFNet.runWithoutCleanup
   * @param {function} callback A callback function to execute
   * @param {string} license_key the license key used to initialize PDFNet.
   * @return a promise that resolves to the return value (if there is one) of the input function
   */
  function runWithoutCleanup(callback: (...params: any[]) => any, license_key: string): any;
}

/**
 * The namespace for anything to do with Part Retrievers
 * @namespace PartRetrievers
 */
declare namespace PartRetrievers {
  /**
   * Constructs a new BlackBoxPartRetriever.
   * BlackBoxPartRetriever streams a .xod file hosted on a web server and display pages as they are available.
   * <br/><br/>
   * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link PartRetrievers#getPartRetriever} function instead.
   * @class Represents a streaming part retriever.
   * @name BlackBoxPartRetriever
   * @memberof PartRetrievers
   * @param {string} url The URL of the file to load. May be relative to the current page.
   */
  class BlackBoxPartRetriever {
    constructor(url: string);
  }
  /**
   * Constructs a new AndroidContentPartRetriever.
   * AndroidContentPartRetriever retrieves Document parts asynchronously from a .xod file that exists locally in an Android app.
   * <br/><br/>
   * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link PartRetrievers#getPartRetriever} function instead.
   *
   * @class Represents a http part retriever.
   * @name AndroidContentPartRetriever
   * @extends PartRetrievers.HttpPartRetriever
   * @memberof PartRetrievers
   * @param {string} url The URL of the file to load. May be relative to the current page.
   * @param {PartRetrievers.CacheHinting} cacheHint The type of cache hinting to use
   * @param {function} decrypt Function to be called to decrypt a part of the file
   * @param {Object} decryptOptions An object with options for the decryption e.g. {p: "pass", type: "aes"} where is p is the password
   */
  class AndroidContentPartRetriever extends PartRetrievers.HttpPartRetriever {
    constructor(
      url: string,
      cacheHint: PartRetrievers.CacheHinting,
      decrypt: (...params: any[]) => any,
      decryptOptions: any,
    );
    /**
     * Sets a function to be called if there is an error loading the document or retrieving a part.
     * @method PartRetriever#setErrorCallback
     * @param {function} callback The callback to handle the error
     */
    setErrorCallback(callback: (...params: any[]) => any): void;
    /**
     * Sets custom HTTP headers that will be sent with XOD part requests.
     * @method PartRetriever#setCustomHeaders
     * @param {object} headers An object with the properties and values being the header names and values that will be set.
     * e.g. { 'MyCustomHeader': 'MyCustomValue'}
     */
    setCustomHeaders(headers: any): void;
    /**
     * Sets withCredentials on xhr requests for the document.
     * @method PartRetriever#setWithCredentials
     * @param {boolean} withCredentials
     */
    setWithCredentials(withCredentials: boolean): void;
  }
  /**
   * ArrayBufferPdfPartRetriever retrieves Document data from an ArrayBuffer
   * <br/><br/>
   * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link PartRetrievers#getPartRetriever} function instead.
   * @class Represents a pdf document retriever.
   * @name ArrayBufferPdfPartRetriever
   * @memberof PartRetrievers
   * @param {Object} arrayBuffer An ArrayBuffer containing the data to load.
   */
  class ArrayBufferPdfPartRetriever {
    constructor(arrayBuffer: any);
  }
  /**
   * Constructs a new AzurePartRetriever.
   * AzurePartRetriever retrieves Document parts asynchronously from a .xod file that exists on a Microsoft Azure server (though it works for other servers as well)
   * <br/><br/>
   * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link PartRetrievers#getPartRetriever} function instead.
   *
   * @class Represents a http part retriever.
   * @name AzurePartRetriever
   * @extends PartRetrievers.HttpPartRetriever
   * @memberof PartRetrievers
   * @param {string} url The URL of the file to load. May be relative to the current page.
   * @param {PartRetrievers.CacheHinting} cacheHint The type of cache hinting to use
   * @param {function} decrypt Function to be called to decrypt a part of the file
   * @param {Object} decryptOptions An object with options for the decryption e.g. {p: "pass", type: "aes"} where is p is the password
   */
  class AzurePartRetriever extends PartRetrievers.HttpPartRetriever {
    constructor(
      url: string,
      cacheHint: PartRetrievers.CacheHinting,
      decrypt: (...params: any[]) => any,
      decryptOptions: any,
    );
    /**
     * Sets a function to be called if there is an error loading the document or retrieving a part.
     * @method PartRetriever#setErrorCallback
     * @param {function} callback The callback to handle the error
     */
    setErrorCallback(callback: (...params: any[]) => any): void;
    /**
     * Sets custom HTTP headers that will be sent with XOD part requests.
     * @method PartRetriever#setCustomHeaders
     * @param {object} headers An object with the properties and values being the header names and values that will be set.
     * e.g. { 'MyCustomHeader': 'MyCustomValue'}
     */
    setCustomHeaders(headers: any): void;
    /**
     * Sets withCredentials on xhr requests for the document.
     * @method PartRetriever#setWithCredentials
     * @param {boolean} withCredentials
     */
    setWithCredentials(withCredentials: boolean): void;
  }
  /**
   * ExternalPdfPartRetriever retrieves Document data from a url.
   * <br/><br/>
   * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link PartRetrievers#getPartRetriever} function instead.
   *
   * @class Represents a pdf document retriever.
   * @name ExternalPdfPartRetriever
   * @memberof PartRetrievers
   * @param {string} url The URL of the file to load. May be relative to the current page.
   * @param {object} options Additional options
   * @param {boolean} options.useDownloader Whether to use Downloader, defaults to false.
   * @param {boolean} options.withCredentials Whether to set the withCredentials property on the XMLHttpRequest
   * @param {object} [options.customHeaders] Custom headers to send with the XMLHttpRequests
   */
  class ExternalPdfPartRetriever {
    constructor(
      url: string,
      options: {
        useDownloader: boolean;
        withCredentials: boolean;
        customHeaders?: any;
      },
    );
  }
  /**
   * Constructs a new HttpPartRetriever.
   * HttpPartRetriever retrieves Document parts asynchronously from a .xod file hosted on a web server. The server is required to support the HTTP/1.1 protocol.
   * <br/><br/>
   * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link PartRetrievers#getPartRetriever} function instead.
   * @class
   * @name HttpPartRetriever
   * @extends PartRetriever
   * @memberof PartRetrievers
   * @param {string} url The URL of the file to load. May be relative to the current page.
   * @param {PartRetrievers.CacheHinting} cacheHint The type of cache hinting to use
   * @param {function} decrypt Function to be called to decrypt a part of the file
   * @param {Object} decryptOptions An object with options for the decryption e.g. {p: "pass", type: "aes"} where is p is the password
   * @param {Object} [customHeaders] Custom headers to send with the XMLHttpRequests
   * @property {boolean} DISABLE_RANGE_HEADER Whether to disable the range header. This should only be used if your server will look at the range query parameters and return the correct bytes.
   */
  class HttpPartRetriever extends PartRetriever {
    constructor(
      url: string,
      cacheHint: PartRetrievers.CacheHinting,
      decrypt: (...params: any[]) => any,
      decryptOptions: any,
      customHeaders?: any,
    );
    /**
     * Sets a function to be called if there is an error loading the document or retrieving a part.
     * @method PartRetriever#setErrorCallback
     * @param {function} callback The callback to handle the error
     */
    setErrorCallback(callback: (...params: any[]) => any): void;
    /**
     * Sets custom HTTP headers that will be sent with XOD part requests.
     * @method PartRetriever#setCustomHeaders
     * @param {object} headers An object with the properties and values being the header names and values that will be set.
     * e.g. { 'MyCustomHeader': 'MyCustomValue'}
     */
    setCustomHeaders(headers: any): void;
    /**
     * Sets withCredentials on xhr requests for the document.
     * @method PartRetriever#setWithCredentials
     * @param {boolean} withCredentials
     */
    setWithCredentials(withCredentials: boolean): void;
    /**
     * Whether to disable the range header. This should only be used if your server will look at the range query parameters and return the correct bytes.
     */
    DISABLE_RANGE_HEADER: boolean;
  }
  /**
   * Constructs a new IOSPartRetriever.
   * IOSPartRetriever retrieves Document parts asynchronously from a .xod that exists locally in an iOS app.
   * <br/><br/>
   * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link PartRetrievers#getPartRetriever} function instead.
   * @class Represents a http part retriever.
   * @name IOSPartRetriever
   * @extends PartRetrievers.HttpPartRetriever
   * @memberof PartRetrievers
   * @param {string} url The URL of the file to load. May be relative to the current page.
   * @param {PartRetrievers.CacheHinting} cacheHint The type of cache hinting to use
   * @param {function} decrypt Function to be called to decrypt a part of the file
   * @param {Object} decryptOptions An object with options for the decryption e.g. {p: "pass", type: "aes"} where is p is the password
   */
  class IOSPartRetriever extends PartRetrievers.HttpPartRetriever {
    constructor(
      url: string,
      cacheHint: PartRetrievers.CacheHinting,
      decrypt: (...params: any[]) => any,
      decryptOptions: any,
    );
    /**
     * Sets a function to be called if there is an error loading the document or retrieving a part.
     * @method PartRetriever#setErrorCallback
     * @param {function} callback The callback to handle the error
     */
    setErrorCallback(callback: (...params: any[]) => any): void;
    /**
     * Sets custom HTTP headers that will be sent with XOD part requests.
     * @method PartRetriever#setCustomHeaders
     * @param {object} headers An object with the properties and values being the header names and values that will be set.
     * e.g. { 'MyCustomHeader': 'MyCustomValue'}
     */
    setCustomHeaders(headers: any): void;
    /**
     * Sets withCredentials on xhr requests for the document.
     * @method PartRetriever#setWithCredentials
     * @param {boolean} withCredentials
     */
    setWithCredentials(withCredentials: boolean): void;
  }
  /**
   * Constructs a new LocalPartRetriever.
   * LocalPartRetriever retrieves {@link Document} parts asynchronously from locally hosted .xod file. Requires a fully-functional file API.
   * <br/><br/>
   * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link PartRetrievers#getPartRetriever} function instead.
   * @class Represents a local part retriever.
   * @name LocalPartRetriever
   * @memberof PartRetrievers
   * @param {File} file The local file reference to read data from.
   * @param {function} decrypt Function to be called to decrypt a part of the file
   * @param {Object} decryptOptions An object with options for the decryption e.g. {password: "pass", type: "aes"}
   */
  class LocalPartRetriever {
    constructor(file: File, decrypt: (...params: any[]) => any, decryptOptions: any);
  }
  /**
   * LocalPdfPartRetriever retrieves Document data from a local file.
   * <br/><br/>
   * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link PartRetrievers#getPartRetriever} function instead.
   * @class Represents a local pdf document retriever.
   * @name LocalPdfPartRetriever
   * @memberof PartRetrievers
   * @param {Object} file The file to load.
   */
  class LocalPdfPartRetriever {
    constructor(file: any);
  }
  /**
   * The base class for PartRetrievers
   * @class
   * @name PartRetriever
   * @memberof PartRetrievers
   */
  class PartRetriever {}
  /**
   * Constructs a new StreamingPartRetriever.
   * StreamingPartRetriever streams a .xod file hosted on a web server and display pages as they are available.
   * <br/><br/>
   * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link PartRetrievers#getPartRetriever} function instead.
   * @class Represents a streaming part retriever.
   * @name StreamingPartRetriever
   * @extends PartRetrievers.PartRetriever
   * @memberof PartRetrievers
   * @param {string} url The URL of the file to load. May be relative to the current page.
   * @param {PartRetrievers.CacheHinting} cacheHint The type of cache hinting to use
   * @param {function} decrypt Function to be called to decrypt a part of the file
   * @param {Object} decryptOptions An object with options for the decryption e.g. {password: "pass", type: "aes"}
   * @param {Object} [customHeaders] Custom headers to send with the XMLHttpRequests
   */
  class StreamingPartRetriever extends PartRetrievers.PartRetriever {
    constructor(
      url: string,
      cacheHint: PartRetrievers.CacheHinting,
      decrypt: (...params: any[]) => any,
      decryptOptions: any,
      customHeaders?: any,
    );
  }
  /**
   * Constructs a new WinRTPartRetriever.
   * WinRTPartRetriever retrieves Document parts asynchronously from a .xod that exists locally in a WinRT app.
   * <br/><br/>
   * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link PartRetrievers#getPartRetriever} function instead.
   * @class Represents a http part retriever.
   * @name WinRTPartRetriever
   * @extends PartRetrievers.HttpPartRetriever
   * @memberof PartRetrievers
   * @param {string} url The URL of the file to load. May be relative to the current page.
   * @param {PartRetrievers.CacheHinting} cacheHint The type of cache hinting to use
   * @param {function} decrypt Function to be called to decrypt a part of the file
   * @param {Object} decryptOptions An object with options for the decryption e.g. {p: "pass", type: "aes"} where is p is the password
   */
  class WinRTPartRetriever extends PartRetrievers.HttpPartRetriever {
    constructor(
      url: string,
      cacheHint: PartRetrievers.CacheHinting,
      decrypt: (...params: any[]) => any,
      decryptOptions: any,
    );
    /**
     * Sets a function to be called if there is an error loading the document or retrieving a part.
     * @method PartRetriever#setErrorCallback
     * @param {function} callback The callback to handle the error
     */
    setErrorCallback(callback: (...params: any[]) => any): void;
    /**
     * Sets custom HTTP headers that will be sent with XOD part requests.
     * @method PartRetriever#setCustomHeaders
     * @param {object} headers An object with the properties and values being the header names and values that will be set.
     * e.g. { 'MyCustomHeader': 'MyCustomValue'}
     */
    setCustomHeaders(headers: any): void;
    /**
     * Sets withCredentials on xhr requests for the document.
     * @method PartRetriever#setWithCredentials
     * @param {boolean} withCredentials
     */
    setWithCredentials(withCredentials: boolean): void;
  }
  /**
   * An object containing all the possible types of part retrievers. Use in conjunction with getPartRetriever
   * @enum {string}
   * @name TYPES
   * @memberof PartRetrievers
   * @property {string} AndroidContentPartRetriever
   * @property {string} ArrayBufferPdfPartRetriever
   * @property {string} AzurePartRetriever
   * @property {string} ExternalPdfPartRetriever
   * @property {string} HttpPartRetriever
   * @property {string} IOSPartRetriever
   * @property {string} LocalPartRetriever
   * @property {string} LocalPdfPartRetriever
   * @property {string} StreamingPartRetriever
   * @property {string} WinRTPartRetriever
   * @property {string} BlackBoxPartRetriever
   * @property {string} WebDBPartRetriever
   * @example
   * const partRetriever = await getPartRetriever(PartRetrievers.TYPES.LocalPdfPartRetriever, file, options);
   */
  enum TYPES {
    AndroidContentPartRetriever,
    ArrayBufferPdfPartRetriever,
    AzurePartRetriever,
    ExternalPdfPartRetriever,
    HttpPartRetriever,
    IOSPartRetriever,
    LocalPartRetriever,
    LocalPdfPartRetriever,
    StreamingPartRetriever,
    WinRTPartRetriever,
    BlackBoxPartRetriever,
    WebDBPartRetriever,
  }
  /**
   * The type of hint to provide to browsers for caching the document. The part retriever may use query parameters
   * to influence browser caching behavior.
   * @enum {string}
   * @name CacheHinting
   * @memberof PartRetrievers
   * @example
   * NEVER_CACHE: A unique ID is appended to the document URL.
   * CACHE: The range of bytes requested is appended to the document URL.
   * This should be used in most cases.
   * NO_HINT: Nothing is appended to the document URL.
   * Useful if you require that the document URL never changes.
   */
  enum CacheHinting {}
  /**
   * @method PartRetrievers#getPartRetriever
   * @memberof PartRetrievers
   * @param {PartRetrievers.TYPES} type The type of retriever you want to use.
   * @param {(File|Blob|string|ArrayBuffer)} file The file to open with the part retriever
   * @param {Object} [options] Options to pass to the selected part retriever
   * @param {Function} [options.decrypt] Function to be called to decrypt a part of the file
   * @param {Function} [options.decryptOptions] An object with options for the decryption e.g. {p: "pass", type: "aes"} where is p is the password
   * @param {PartRetrievers.CacheHinting} [options.cacheHint] The type of cache hinting to use
   * @param {boolean} [options.useDownloader] Whether to use Downloader, defaults to false.
   * @param {string} [options.filename] A filename that is only useful when the type is ExternalPdfPartRetriever. Use this option when the filename can't be determined from file(the second argument).
   * @param {boolean} [options.withCredentials] Whether to set the withCredentials property on the XMLHttpRequest
   * @param {Object} [options.serverOptions] Options to pass to the server. e.g {serverRoot: "http://your-server-domain.com"}
   * @returns {Promise<PartRetrievers.PartRetriever>}
   */
  function getPartRetriever(
    type: PartRetrievers.TYPES,
    file: File | Blob | string | ArrayBuffer,
    options?: {
      decrypt?: (...params: any[]) => any;
      decryptOptions?: (...params: any[]) => any;
      cacheHint?: PartRetrievers.CacheHinting;
      useDownloader?: boolean;
      filename?: string;
      withCredentials?: boolean;
      serverOptions?: any;
    },
  ): Promise<PartRetrievers.PartRetriever>;
}

/**
 * Collection of utility functions
 * @namespace utils
 */
declare namespace utils {
  /**
   * Check if a composite operation is supported
   * @method utils#isBlendModeSupported
   * @param {string} type Composite operation to check
   * @return {boolean} True if if the input composite operation is supported, false otherwise
   */
  function isBlendModeSupported(type: string): boolean;
}

/**
 * @class
 * @name EventHandler
 */
declare class EventHandler {
  /**
   * Add a handler to the given event name
   * @method EventHandler#on
   * @param {string|number} type The name of the event to listen to
   * @param {function} fn The handler to be called when the event is triggered
   * @returns {object} Returns the object that 'on' is being called on
   * @example
   * annotManager.on('annotationChanged', (annotations, action) => {
   *   ...
   * });
   */
  on(type: string | number, fn: (...params: any[]) => any): any;
  /**
   * Remove a handler of the given event name
   * @method EventHandler#off
   * @param {(string|number)} [type] The name of the event to remove the handler of.
   * If type is undefined, all the handlers of the object will be removed
   * @param {function} [fn] The handler associated with this event to be removed.
   * If fn is undefined, all the handlers of the given event name will be removed
   * @returns {object} Returns the object that 'off' is being called on
   * @example
   * annotManager.off();
   * annotManager.off('annotationChanged');
   * annotManager.off('annotationChanged', fn);
   */
  off(type?: string | number, fn?: (...params: any[]) => any): any;
  /**
   * Calls the handlers of the event name with given data
   * @method EventHandler#trigger
   * @param {(string|number)} type event name of which the handlers will be called.
   * @param {*} [data] data that will be passed to the handlers.
   * If data is an array, it will be spread and then passed to the handlers
   * @return {object} Returns the object that 'trigger' is being called on
   * @example
   * annotManager.trigger('annotationChanged');
   * annotManager.trigger('annotationChanged', [[annotation], 'add', {}]);
   */
  trigger(type: string | number, data?: any): any;
  /**
   * Same as 'on' except the handler will be called only once
   * @param {string|number} type The name of the event to listen to
   * @param {function} fn The handler to be called when the event is triggered
   * @returns {object} Returns the object that 'one' is being called on
   * @example
   * annotManager.one('annotationChanged', (annotations, action) => {
   *  ...
   * });
   * @method EventHandler#one
   */
  one(type: string | number, fn: (...params: any[]) => any): any;
}

declare namespace WebViewerInstance {
  /**
   * Callback that gets passed to {@link CoreControls.ReaderControl#addSearchListener addSearchListener}.
   * @callback WebViewerInstance.searchListener
   * @param {string} searchValue Search value
   * @param {object} options Search options object, which includes 'caseSensitive', 'wholeWord', 'wildcard' and 'regex'
   * @param {Array.<object>} results Search results
   */
  type searchListener = (searchValue: string, options: any, results: object[]) => void;
  /**
   * Callback that gets passed to `sortStrategy.getSortedNotes` in {@link CoreControls.ReaderControl#addSortStrategy addSortStrategy}.
   * @callback WebViewerInstance.getSortedNotes
   * @param {Array<Annotations.Annotation>} notes List of unsorted notes (annotations)
   * @return {Array<Annotations.Annotation>} Sorted notes (annotations)
   */
  type getSortedNotes = (notes: Annotations.Annotation[]) => Annotations.Annotation[];
  /**
   * Callback that gets passed to `sortStrategy.shouldRenderSeparator` in {@link CoreControls.ReaderControl#addSortStrategy addSortStrategy}.
   * @callback WebViewerInstance.shouldRenderSeparator
   * @param {Annotations.Annotation} prevNote Previous note (annotation)
   * @param {Annotations.Annotation} currNote Current note (annotation)
   * @return {boolean} Whether a separator should be rendered or not
   */
  type shouldRenderSeparator = (prevNote: Annotations.Annotation, currNote: Annotations.Annotation) => boolean;
  /**
   * Callback that gets passed to `sortStrategy.getSeparatorContent` in {@link CoreControls.ReaderControl#addSortStrategy addSortStrategy}.
   * @callback WebViewerInstance.getSeparatorContent
   * @param {Annotations.Annotation} prevNote Previous note (annotation)
   * @param {Annotations.Annotation} currNote Current note (annotation)
   * @param {object} options Optional values
   * @param {Array.<string>} options.pageLabels List of page label
   * @return {(string|number)} Content to be rendered in a separator
   */
  type getSeparatorContent = (
    prevNote: Annotations.Annotation,
    currNote: Annotations.Annotation,
    options: {
      pageLabels: string[];
    },
  ) => string | number;
  /**
   * Callback that gets passed to {@link WebViewerInstance#disableReplyForAnnotations disableReplyForAnnotations}
   * @callback WebViewerInstance.storeisReplyDisabled
   * @param {Annotations.Annotation} annotation Annotation object
   * @returns {boolean} Whether the reply of the annotation should be disabled.
   */
  type storeisReplyDisabled = (annotation: Annotations.Annotation) => boolean;
  /**
   * Callback that gets passed to {@link CoreControls.ReaderControl#setCustomNoteFilter setCustomNoteFilter}.
   * @callback WebViewerInstance.filterAnnotation
   * @param {Annotations.Annotation} annotation Annotation object
   * @returns {boolean} Whether the annotation should be kept.
   */
  type filterAnnotation = (annotation: Annotations.Annotation) => boolean;
  /**
   * Callback that gets passed to `options.panel.render` in {@link CoreControls.ReaderControl#setCustomPanel setCustomPanel}.
   * @callback WebViewerInstance.renderCustomPanel
   * @returns {HTMLElement} Panel element.
   */
  type renderCustomPanel = () => HTMLElement;
  /**
   * Callback that gets passed to {@link CoreControls.ReaderControl#setHeaderItems setHeaderItems}.
   * @callback WebViewerInstance.headerCallback
   * @param {Header} header Header instance with helper functions
   */
  type headerCallback = (header: Header) => void;
  /**
   * @callback NoteTransformFunction
   * @memberof WebViewerInstance
   * @param {HTMLElement} wrapperElement  A reference to the DOM node that wraps the note. You can use this to query select child elements to mutate (see the examples below)
   * @param {object} state The state of the note. Contains two properties, 'annotation' and 'isSelected'
   * @param {Annotations.Annotation} state.annotation A reference to the annotation object associated with the note
   * @param {boolean} state.isSelected whether or not the note is currently expanded
   * @param {function} createElement A utility function that should be used when creating DOM nodes. This is a replacement for `document.createElement`.
   * Accepts the same parameters as `document.createElement`. Using document.createElement instead of this function will cause your DOM nodes to not be cleaned up on subsequent renders.
   */
  type NoteTransformFunction = (
    wrapperElement: HTMLElement,
    state: {
      annotation: Annotations.Annotation;
      isSelected: boolean;
    },
    createElement: (...params: any[]) => any,
  ) => void;
  /**
   * @callback WebViewerInstance.setSignatureFontsCallback
   * @param {Array.<string>} fonts current font families
   * @returns {Array.<string>} fonts to set.
   */
  type setSignatureFontsCallback = (fonts: string[]) => string[];
  /**
   * A class which contains popup APIs.<br/><br/>
   * <span style="color: red; font-size: 1.2em; font-weight: bold">⚠</span> If you want to remove an item in a popup, use {@link WebViewerInstance#disableElements disableElements}.
   * @interface WebViewerInstance.Popup
   */
  interface Popup {
    /**
         * Add an array of items after the item that has the given data element.
         * @method WebViewerInstance.Popup#add
         * @param {Array.<object>} items Same as <a href='https://www.pdftron.com/documentation/web/guides/customizing-header#header-items' target='_blank'>header items</a>
         * @param {string} [dataElement] An optional string. If not given, items will be added in the beginning
         * @returns {this} The instance itself
         * @example
          WebViewer(...)
          .then(function(instance) {
            instance.contextMenuPopup.add({
              type: 'actionButton',
              img: 'path/to/image',
              onClick: instance.downloadPdf,
            });
          });
         */
    add(items: object[], dataElement?: string): this;
    /**
         * Update all the items in the popup.
         * To update an individual item, use {@link WebViewerInstance#updateElement updateElement}
         * @method WebViewerInstance.Popup#update
         * @param {Array.<object>} [items] the items that will be rendered in the popup
         * @returns {this} The instance itself
         * @example
          WebViewer(...)
          .then(function(instance) {
            // replace existing items with a new array of items
            instance.contextMenuPopup.update([
              {
                type: 'actionButton',
                img: 'path/to/image',
                onClick: instance.downloadPdf,
              },
              {
                type: 'actionButton',
                img: 'path/to/image',
                onClick: instance.print,
              },
            ]);
          });
         */
    update(items?: object[]): this;
    /**
         * Return the array of items in the popup.
         * @method WebViewerInstance.Popup#getItems
         * @returns {Array.<object>} Current items in the popup.
         * @example
          WebViewer(...)
          .then(function(instance) {
            instance.annotationPopup.getItems();
          });
         */
    getItems(): object[];
  }
  /**
   * A class which contains hotkeys APIs.<br/><br/>
   * <span style="color: red; font-size: 1.2em; font-weight: bold">⚠</span> You must NOT instantiate this yourself. Access instances of this class using {@link WebViewerInstance#hotkeys instance.hotkeys}
   * @namespace Hotkeys
   * @memberof WebViewerInstance
   */
  namespace Hotkeys {
    /**
     * Available hotkeys that can be passed to {@link WebViewerInstance.Hotkeys#on instance.hotkeys.on} or {@link WebViewerInstance.Hotkeys#off instance.hotkeys.off} as lowercase. Hotkeys that use the Ctrl key can also be activated by pressing the Command key. <br/><br/>
     * <span style="color: red; font-size: 1.2em; font-weight: bold">⚠</span> These strings are not static properties of this class. They are listed here only for the documentation purpose.
     * @name WebViewerInstance.Hotkeys.AvailableHotkeys
     * @enum {string}
     * @property {string} Ctrl_Shift_Equals Rotate the document clockwise (Ctrl+Shift+=).
     * @property {string} Ctrl_Shift_Minus Rotate the document counterclockwise (Ctrl+Shift+-)
     * @property {string} Ctrl_C Copy selected text or annotations
     * @property {string} Ctrl_V Paste text or annotations
     * @property {string} Ctrl_Z Undo an annotation change
     * @property {string} Ctrl_Y Redo an annotation change
     * @property {string} Ctrl_O Open the file picker
     * @property {string} Ctrl_F Open the search overlay
     * @property {string} Ctrl_Equals Zoom in (Ctrl+=)
     * @property {string} Ctrl_Minus Zoom out (Ctrl+-)
     * @property {string} Ctrl_0 Fit the document to the screen width in a small screen(< 640px), otherwise fit it to its original size
     * @property {string} Ctrl_P Print
     * @property {string} PageUp Go to the previous page
     * @property {string} PageDown Go to the next page
     * @property {string} Up Go to the previous page in single layout mode (ArrowUp)
     * @property {string} Down Go to the next page in single layout mode (ArrowDown)
     * @property {string} Space Hold to switch to Pan mode and release to return to previous tool
     * @property {string} Escape Select the AnnotationEdit tool
     * @property {string} P Select the Pan tool
     * @property {string} A Select the AnnotationCreateArrow tool
     * @property {string} C Select the AnnotationCreateCallout tool
     * @property {string} E Select the AnnotationEraserTool tool
     * @property {string} F Select the AnnotationCreateFreeHand tool
     * @property {string} I Select the AnnotationCreateStamp tool
     * @property {string} L Select the AnnotationCreateLine tool
     * @property {string} N Select the AnnotationCreateSticky tool
     * @property {string} O Select the AnnotationCreateEllipse tool
     * @property {string} R Select the AnnotationCreateRectangle tool
     * @property {string} T Select the AnnotationCreateFreeText tool
     * @property {string} S Open the signature modal or the overlay
     * @property {string} G Select the AnnotationCreateTextSquiggly tool
     * @property {string} H Select the AnnotationCreateTextHighlight tool
     * @property {string} K Select the AnnotationCreateTextStrikeout tool
     * @property {string} U Select the AnnotationCreateTextUnderline tool
     */
    enum AvailableHotkeys {
      Ctrl_Shift_Equals,
      Ctrl_Shift_Minus,
      Ctrl_C,
      Ctrl_V,
      Ctrl_Z,
      Ctrl_Y,
      Ctrl_O,
      Ctrl_F,
      Ctrl_Equals,
      Ctrl_Minus,
      Ctrl_0,
      Ctrl_P,
      PageUp,
      PageDown,
      Up,
      Down,
      Space,
      Escape,
      P,
      A,
      C,
      E,
      F,
      I,
      L,
      N,
      O,
      R,
      T,
      S,
      G,
      H,
      K,
      U,
    }
    /**
         * Add an event handler for the given hotkey
         * @method WebViewerInstance.Hotkeys#on
         * @param {string} key A keyboard key or a tool name. <br/>
         * If a hotkey is consisted of more than one key. Those keys should be connected using '+'.
         * @param {function|object} [handler] An optional argument <br/>
         * If it is undefined, the default handler of the given key will be registered <br/>
         * If it is an function, it will be called on key down <br/>
         * If it is an object, it should have the shape of { keydown: func1, keyup: func2 }. Func1 will be called on keydown while func2 will be called on keyup
         * @example
          WebViewer(...)
          .then(function(instance) {
              // this will be called on keydown
              instance.hotkeys.on('ctrl+d, command+d', e => {
                e.preventDefault();
                instance.closeDocument();
              });
                instance.hotkeys.on('ctrl+g', {
                keydown: e => {
                  console.log('ctrl+g is pressed!');
                },
                keyup: e => {
                  console.log('ctrl+g is released!')
                },
              });
                // this will register the default zoom in handler
              instance.hotkeys.on('ctrl+=, command+=');
                // this is equivalent to instance.hotkeys.on('escape');
              instance.hotkeys.on('AnnotationEdit');
          });
         */
    function on(key: string, handler?: ((...params: any[]) => any) | any): void;
    /**
         * Remove an event handler for the given hotkey
         * @method WebViewerInstance.Hotkeys#off
         * @param {string} [key] An optional keyboard key or a tool name. If not passed, all handlers will be removed
         * @param {function} [handler] An optional function. If not passed, all handlers of the given key will be removed
         * @example
          WebViewer(...)
          .then(function(instance) {
              // this will remove all handlers for ctrl = and command =
              instance.hotkeys.off('ctrl+=, command+=');
                // this is equivalent to instance.hotkeys.off('escape');
              instance.hotkeys.off('AnnotationEdit');
          });
         */
    function off(key?: string, handler?: (...params: any[]) => any): void;
  }
  /**
   * A class which contains popup APIs.<br/><br/>
   * <span style="color: red; font-size: 1.2em; font-weight: bold">⚠</span> If you want to remove an item in a popup, use {@link WebViewerInstance#disableElements disableElements}.
   * @interface WebViewerInstance.Popup
   */
  interface Popup {
    /**
         * Add an array of items after the item that has the given data element.
         * @method WebViewerInstance.Popup#add
         * @param {Array.<object>} items Same as <a href='https://www.pdftron.com/documentation/web/guides/customizing-header#header-items' target='_blank'>header items</a>
         * @param {string} [dataElement] An optional string. If not given, items will be added in the beginning
         * @returns {this} The instance itself
         * @example
          WebViewer(...)
          .then(function(instance) {
            instance.contextMenuPopup.add({
              type: 'actionButton',
              img: 'path/to/image',
              onClick: instance.downloadPdf,
            });
          });
         */
    add(items: object[], dataElement?: string): this;
    /**
         * Update all the items in the popup.
         * To update an individual item, use {@link WebViewerInstance#updateElement updateElement}
         * @method WebViewerInstance.Popup#update
         * @param {Array.<object>} [items] the items that will be rendered in the popup
         * @returns {this} The instance itself
         * @example
          WebViewer(...)
          .then(function(instance) {
            // replace existing items with a new array of items
            instance.contextMenuPopup.update([
              {
                type: 'actionButton',
                img: 'path/to/image',
                onClick: instance.downloadPdf,
              },
              {
                type: 'actionButton',
                img: 'path/to/image',
                onClick: instance.print,
              },
            ]);
          });
         */
    update(items?: object[]): this;
    /**
         * Return the array of items in the popup.
         * @method WebViewerInstance.Popup#getItems
         * @returns {Array.<object>} Current items in the popup.
         * @example
          WebViewer(...)
          .then(function(instance) {
            instance.annotationPopup.getItems();
          });
         */
    getItems(): object[];
  }
}

/**
 * A class which contains header APIs.<br/><br/>
 * <span style="color: red; font-size: 1.2em; font-weight: bold">⚠</span> You must NOT instantiate this yourself. Access the header instance in {@link WebViewerInstance#setHeaderItems setHeaderItems} as follows:
 * @name Header
 * @class
 * @example
WebViewer(...)
  .then(function(instance) {
    instance.setHeaderItems(function(header) {
      // instance of Header is passed to the callback
    });
  });
 */
declare class Header {
  /**
   * Select a button from header to edit.
   * @method Header#get
   * @param {string} dataElement data-element of the button.
   * @returns {Header} Header object for chaining. You can call {@link Header#insertBefore insertBefore}, {@link Header#insertAfter insertAfter} and {@link Header#delete delete} to perform an operation on the button.
   */
  get(dataElement: string): Header;
  /**
   * Get all list of header items from a group selected from {@link Header#getHeader getHeader}. By default, it returns the items from 'default' group.
   * @method Header#getItems
   * @returns {Array.<object>} List of header item objects. You can edit it using normal array operations and update the whole header by passing it to {@link Header#update update}.
   */
  getItems(): object[];
  /**
   * Select a header group to edit.
   * @method Header#getHeader
   * @param {string} headerGroup Name of the header group. By default, 'default' and 'tools' are accepted.
   * @returns {Header} Header object for chaining. You can call {@link Header#get get}, {@link Header#getItems getItems}, {@link Header#shift shift}, {@link Header#unshift unshift}, {@link Header#push push}, {@link Header#pop pop} and {@link Header#update update}.
   */
  getHeader(headerGroup: string): Header;
  /**
   * Insert a button before the selected button from {@link Header#get get}.
   * @method Header#insertBefore
   * @param {object} obj A header object. See <a href='https://www.pdftron.com/documentation/web/guides/customizing-header#header-items' target='_blank'>Header items</a> for details.
   * @returns {Header} Header object for chaining. You can call {@link Header#get get}, {@link Header#getItems getItems}, {@link Header#shift shift}, {@link Header#unshift unshift}, {@link Header#push push}, {@link Header#pop pop} and {@link Header#update update}.
   */
  insertBefore(obj: any): Header;
  /**
   * Insert a button after the selected button from {@link Header#get get}.
   * @method Header#insertAfter
   * @param {object} obj A header object. See <a href='https://www.pdftron.com/documentation/web/guides/customizing-header#header-items' target='_blank'>Header items</a> for details.
   * @returns {Header} Header object for chaining. You can call {@link Header#get get}, {@link Header#getItems getItems}, {@link Header#shift shift}, {@link Header#unshift unshift}, {@link Header#push push}, {@link Header#pop pop} and {@link Header#update update}.
   */
  insertAfter(obj: any): Header;
  /**
   * Delete a button.
   * @method Header#delete
   * @param {(number|string)} [id] You can either pass an index or `data-element` of the button to delete. If you already selected a button from {@link Header#get get}, passing null would delete the selected button.
   * @returns {Header} Header object for chaining. You can call {@link Header#get get}, {@link Header#getItems getItems}, {@link Header#shift shift}, {@link Header#unshift unshift}, {@link Header#push push}, {@link Header#pop pop} and {@link Header#update update}.
   */
  delete(id?: number | string): Header;
  /**
   * Removes the first button in the header.
   * @method Header#shift
   * @returns {Header} Header object for chaining. You can call {@link Header#get get}, {@link Header#getItems getItems}, {@link Header#shift shift}, {@link Header#unshift unshift}, {@link Header#push push}, {@link Header#pop pop} and {@link Header#update update}.
   */
  shift(): Header;
  /**
   * Adds a button (or buttons) to the beginning of the header.
   * @method Header#unshift
   * @param {object|Array.<object>} obj Either one or array of header objects. See <a href='https://www.pdftron.com/documentation/web/guides/customizing-header#header-items' target='_blank'>Header items</a> for details.
   * @returns {Header} Header object for chaining. You can call {@link Header#get get}, {@link Header#getItems getItems}, {@link Header#shift shift}, {@link Header#unshift unshift}, {@link Header#push push}, {@link Header#pop pop} and {@link Header#update update}.
   */
  unshift(obj: any | object[]): Header;
  /**
   * Adds a button (or buttons) to the end of the header.
   * @method Header#push
   * @param {object|Array.<object>} obj Either one or array of header objects. See <a href='https://www.pdftron.com/documentation/web/guides/customizing-header#header-items' target='_blank'>Header items</a> for details.
   * @returns {Header} Header object for chaining. You can call {@link Header#get get}, {@link Header#getItems getItems}, {@link Header#shift shift}, {@link Header#unshift unshift}, {@link Header#push push}, {@link Header#pop pop} and {@link Header#update update}.
   */
  push(obj: any | object[]): Header;
  /**
   * Removes the last button in the header.
   * @method Header#pop
   * @returns {Header} Header object for chaining. You can call {@link Header#get get}, {@link Header#getItems getItems}, {@link Header#shift shift}, {@link Header#unshift unshift}, {@link Header#push push}, {@link Header#pop pop} and {@link Header#update update}.
   */
  pop(): Header;
  /**
   * Updates the header with new list of header items.
   * @method Header#update
   * @param {Array.<object>} headerObjects List of header objects to replace the exising header. You can use {@link Header#getItems getItems} to refer to existing header objects.
   * @returns {Header} Header object for chaining. You can call {@link Header#get get}, {@link Header#getItems getItems}, {@link Header#shift shift}, {@link Header#unshift unshift}, {@link Header#push push}, {@link Header#pop pop} and {@link Header#update update}.
   */
  update(headerObjects: object[]): Header;
}

/**
 * A single instance of webviewer. Can be retrieved from the
 * global WebViewer function.
 *
 * This class is not instantiable.
 * @class
 * @name WebViewerInstance
 * @example
 * WebViewer({...options}, document.getElementById('viewer'))
 *  .then(webviewerInstance => {
 *    // Call APIs on webviewerInstance here
 *  })
 */
declare class WebViewerInstance {
  /**
     * Adds a listener function to be called when search is completed.
     * @method WebViewerInstance#addSearchListener
     * @param {WebViewerInstance.searchListener} searchListener Callback function that will be triggered when search completed
     * @example
    WebViewer(...)
      .then(function(instance) {
        function searchListener(searchValue, options, results) {
          console.log(searchValue, options, results);
        };
    
        instance.addSearchListener(searchListener);
      });
     */
  addSearchListener(searchListener: WebViewerInstance.searchListener): void;
  /**
     * Adds a sorting strategy in notes panel.
     * @method WebViewerInstance#addSortStrategy
     * @param {object} sortStrategy Sorting strategy that will be used to sort notes
     * @param {string} sortStrategy.name Name of the strategy, which will be shown in notes panel's dropdown
     * @param {WebViewerInstance.getSortedNotes} sortStrategy.getSortedNotes Function that takes unsorted notes (annotations) and returns them sorted
     * @param {WebViewerInstance.shouldRenderSeparator} sortStrategy.shouldRenderSeparator Function that returns when a separator should be rendered
     * @param {WebViewerInstance.getSeparatorContent} sortStrategy.getSeparatorContent Function that returns the content of a separator
     * @example
    WebViewer(...)
      .then(function(instance) {
        var mySortStrategy = {
          name: 'annotationType',
          getSortedNotes: function(notes) {
            return notes.sort(function(a ,b) {
              if (a.Subject < b.Subject) return -1;
              if (a.Subject > b.Subject) return 1;
              if (a.Subject === b.Subject) return 0;
            });
          },
          shouldRenderSeparator: function(prevNote, currNote) {
            return prevNote.Subject !== currNote.Subject;
          },
          getSeparatorContent: function(prevNote, currNote) {
            return currNote.Subject;
          }
        };
    
        instance.addSortStrategy(mySortStrategy);
      });
     */
  addSortStrategy(sortStrategy: {
    name: string;
    getSortedNotes: WebViewerInstance.getSortedNotes;
    shouldRenderSeparator: WebViewerInstance.shouldRenderSeparator;
    getSeparatorContent: WebViewerInstance.getSeparatorContent;
  }): void;
  /**
     * An instance of Popup that can be used to edit items in the annotation popup component
     * @name WebViewerInstance#annotationPopup
     * @implements {WebViewerInstance.Popup}
     * @type {WebViewerInstance.Popup}
     * @example
    WebViewer(...)
      .then(function (instance) {
        instance.annotationPopup.someAPI();
      });
     */
  annotationPopup: WebViewerInstance.Popup;
  /**
     * Closes the document that's currently opened.
     * @method WebViewerInstance#closeDocument
     * @return {Promise<void>} A promise resolved after document is closed.
     * @example
    WebViewer(...)
      .then(function(instance) {
        var docViewer = instance.docViewer;
    
        // you must have a document loaded when calling this api
        docViewer.on('documentLoaded', function() {
          setTimeout(function() {
            instance.closeDocument().then(function() {
              console.log('Document is closed');
            });
          }, 3000);
        });
      });
     */
  closeDocument(): Promise<void>;
  /**
     * Sets visibility states of the elements to be hidden. Note that closeElements works only for panel/overlay/popup/modal elements.
     * @method WebViewerInstance#closeElements
     * @param {Array.<string>} dataElements Array of data-element attribute values for DOM elements. To find data-element of a DOM element, refer to <a href='https://www.pdftron.com/documentation/web/guides/hiding-elements/#finding-dataelement-attribute-values' target='_blank'>Finding data-element attribute values</a>.
     * @example
    WebViewer(...)
      .then(function(instance) {
        // closes (hides) text popup and left panel in the UI
        instance.closeElements([ 'menuOverlay', 'leftPanel' ]);
      });
     */
  closeElements(dataElements: string[]): void;
  /**
     * An instance of Popup that can be used to edit items in the context menu popup component
     * @name WebViewerInstance#contextMenuPopup
     * @implements {WebViewerInstance.Popup}
     * @type {WebViewerInstance.Popup}
     * @example
    WebViewer(...)
      .then(function (instance) {
        instance.contextMenuPopup.someAPI();
      });
     */
  contextMenuPopup: WebViewerInstance.Popup;
  /**
     * Unmount multiple elements in the DOM. Note that this ONLY removes the DOM elements without disabling related features.
     * @method WebViewerInstance#disableElements
     * @param {string[]} dataElements Array of data-element attribute values for DOM elements. To find data-element of a DOM element, refer to <a href='https://www.pdftron.com/documentation/web/guides/hiding-elements/#finding-dataelement-attribute-values' target='_blank'>Finding data-element attribute values</a>.
     * @example
    WebViewer(...)
      .then(function(instance) {
        // remove left panel and left panel button from the DOM
        instance.disableElements([ 'leftPanel', 'leftPanelButton' ]);
      });
     */
  disableElements(dataElements: string[]): void;
  /**
     * Disable certain features in the WebViewer UI.
     * @method WebViewerInstance#disableFeatures
     * @param {Array.<string>} features Array of features to disable.
     * @see WebViewerInstance#Feature
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.disableFeatures(instance.Feature.Measurement);
      });
     */
  disableFeatures(features: string[]): void;
  /**
     * Disable reply for annotations determined by the function passed in as parameter
     * @method WebViewerInstance#disableReplyForAnnotations
     * @param {WebViewerInstance.storeisReplyDisabled} isReplyDisabled Function that takes an annotation and returns if the reply of the annotation should be disabled.
     * @example
     WebViewer(...)
      .then(function(instance) {
        // disable reply for all Freehand annotations
        instance.disableReplyForAnnotations(function(annotation) {
          return annotation instanceof instance.Annotations.FreeHandAnnotation;
        });
      });
     */
  disableReplyForAnnotations(isReplyDisabled: WebViewerInstance.storeisReplyDisabled): void;
  /**
     * Disable multiple tools.
     * @method WebViewerInstance#disableTools
     * @param {Array.<string>} [toolNames=all tools] Array of name of the tools, either from tool names list or the name you registered your custom tool with. If nothing is passed, all tools will be disabled.
     * @example
    WebViewer(...)
      .then(function(instance) {
        // disable sticky annotation tool and free text tool
        instance.disableTools([ 'AnnotationCreateSticky', 'AnnotationCreateFreeText' ]);
      });
     */
  disableTools(toolNames?: string[]): void;
  /**
     * Downloads the pdf document with or without annotations added by WebViewer UI.
     * @method WebViewerInstance#downloadPdf
     * @param {object} [options] An object that contains the following download options.
     * @param {string} [options.filename] The filename of the downloaded document.
     * @param {string} [options.downloadType='pdf'] The type to download the file as, by default this is "pdf". PDF and image files can only be downloaded as PDFs, but office files can be downloaded as "pdf" or as "office" if you want to get the original file without annotations.
     * @param {string} [options.xfdfString] An xfdf string containing annotation data to be used when downloading. Use this option instead of `includeAnnotations` if not all annotations need to be contained in the downloaded file.
     * @param {boolean} [options.includeAnnotations=true] Whether or not to include annotations added by WebViewer UI.
     * @param {boolean} [options.flatten] Whether or not to flatten all the annotations in the downloaded document. Only useful fullAPI is enabled and either `xfdfString` or `includeAnnotations` is used.
     * @param {number} [options.flags=CoreControls.SaveOptions.REMOVE_UNUSED] The flags with which to save the document. Possible values include `CoreControls.SaveOptions.REMOVE_UNUSED` (remove unused objects during save) and `CoreControls.SaveOptions.LINEARIZED` (optimize the document for fast web view and remove unused objects).
     * @example
    WebViewer(...)
      .then(function(instance) {
        var docViewer = instance.docViewer;
        var annotManager = instance.annotManager;
    
        // you must have a document loaded when calling this api
        docViewer.on('documentLoaded', async function() {
          // download pdf without annotations added by WebViewer UI
          instance.downloadPdf({
            includeAnnotations: false,
          });
    
          // download pdf with all annotations flattened
          instance.downloadPdf({
            includeAnnotations: true,
            flatten: true,
          });
    
          // download pdf without links
          const xfdfString = await annotManager.exportAnnotations({ links: false });
          instance.downloadPdf({
            xfdfString: xfdfString,
          });
        });
      });
     */
  downloadPdf(options?: {
    filename?: string;
    downloadType?: string;
    xfdfString?: string;
    includeAnnotations?: boolean;
    flatten?: boolean;
    flags?: number;
  }): void;
  /**
     * Remount the hidden elements in the DOM.
     * @method WebViewerInstance#enableElements
     * @param {string[]} dataElements Array of data-element attribute values for DOM elements. To find data-element of a DOM element, refer to <a href='https://www.pdftron.com/documentation/web/guides/hiding-elements/#finding-dataelement-attribute-values' target='_blank'>Finding data-element attribute values</a>.
     * @example
    WebViewer(...)
      .then(function(instance) {
        // remove left panel and left panel button from the DOM
        instance.enableElements([ 'leftPanel', 'leftPanelButton' ]);
      });
     */
  enableElements(dataElements: string[]): void;
  /**
     * Enable certain features in the WebViewer UI.
     * @method WebViewerInstance#enableFeatures
     * @param {Array.<string>} features Array of features to enable.
     * @see WebViewerInstance#Feature
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.enableFeatures(instance.Feature.Measurement);
      });
     */
  enableFeatures(features: string[]): void;
  /**
     * Enable multiple tools.
     * @method WebViewerInstance#enableTools
     * @param {Array.<string>} [toolNames=all tools] Array of name of the tools, either from tool names list or the name you registered your custom tool with. If nothing is passed, all tools will be enabled.
     * @example
    WebViewer(...)
      .then(function(instance) {
        // enable sticky annotation tool and free text tool
        instance.enableTools([ 'AnnotationCreateSticky', 'AnnotationCreateFreeText' ]);
      });
     */
  enableTools(toolNames?: string[]): void;
  /**
     * Returns a dictionary with page indices as keys and the bookmark text as the values
     * @method WebViewerInstance#exportBookmarks
     * @return {Object} A dictionary with page indices as keys and the bookmark text as the values. ex: {"0":"Bookmark 1","2":"Bookmark 2"}
     * @example
    WebViewer(...)
      .then(function(instance) {
        // Save the annotation data for doc123
        const bookmarks = instance.exportBookmarks();
        const bookmarksString = JSON.stringify(bookmarks);
        fetch('/server/bookmarksHandler.js?documentId=doc123', {
          method: 'POST',
          body: bookmarksString // written into a json file on server
        });
      });
     */
  exportBookmarks(): any;
  /**
     * Extract pages from the current document
     * @method WebViewerInstance#extractPagesWithAnnotations
     * @param {Array<number>} pageIndexToExtract An array of pages to extract from the document. Annotations on the pages are included
     * @return {Promise<File>} A promise that resolve to a <a href='https://developer.mozilla.org/en-US/docs/Web/API/File' target='_blank'>File object</a>
     * @example // 6.0 and after
    WebViewer(...)
      .then(function(instance) {
        instance.extractPagesWithAnnotations ([1,2,3]).then(function(fileData){
        });
      });
     */
  extractPagesWithAnnotations(pageIndexToExtract: number[]): Promise<File>;
  /**
     * Focuses a note input field for the annotation. If the notes panel is closed, it is automatically opened before focusing.
     * @method WebViewerInstance#focusNote
     * @param {string} annotationId Id of an annotation.
     * @example
    WebViewer(...)
      .then(function(instance) {
        var annotManager = instance.annotManager;
    
        annotManager.on('annotationChanged', function(e, annotations, action) {
          annotations.forEach(function(annotation) {
            // Focus the note when annotation is created
            if (action === 'add' && annotation.Listable) {
              instance.focusNote(annotation.Id); // note it is a capital i
            }
          });
        });
      });
     */
  focusNote(annotationId: string): void;
  /**
   * A getter that returns a stringified version of the 'custom' property that is passed to the WebViewer constructor
   * <a href='https://www.pdftron.com/documentation/web/guides/config-files/#passing-custom-data' target='_blank'>Refer to the passing custom data section</a>.
   * @method WebViewerInstance#getCustomData
   * @returns {string} returns a stringified version of the 'custom' property that is passed to the WebViewer constructor
   */
  getCustomData(): string;
  /**
     * Return the current fit mode of the WebViewerInstance.
     * @method WebViewerInstance#getFitMode
     * @return {string} Current fit mode
     * @example
    WebViewer(...)
      .then(function(instance) {
        var docViewer = instance.docViewer;
    
        // you must have a document loaded when calling this api
        docViewer.on('documentLoaded', function() {
          console.log(instance.getFitMode());
        });
      });
     */
  getFitMode(): string;
  /**
     * Return the current layout mode of the WebViewerInstance.
     * @method WebViewerInstance#getLayoutMode
     * @return {string} Current layout mode
     * @example
    WebViewer(...)
      .then(function(instance) {
        var docViewer = instance.docViewer;
    
        // you must have a document loaded when calling this api
        docViewer.on('documentLoaded', function() {
          console.log(instance.getLayoutMode());
        });
      });
     */
  getLayoutMode(): string;
  /**
     * Get the currently selected pages
     * @method WebViewerInstance#getSelectedThumbnailPageNumbers
     * @return {Array<number>} an arry of select page numbers
     * @example // 6.0 and after
    WebViewer(...)
      .then(function(instance) {
        instance.getSelectedThumbnailPageNumbers();
      });
     */
  getSelectedThumbnailPageNumbers(): number[];
  /**
     * Return the current tool object.
     * @method WebViewerInstance#getToolMode
     * @return {Tools.Tool} Instance of the current tool
     * @example
    WebViewer(...)
      .then(function(instance) {
        console.log(instance.getToolMode().name, instance.getToolMode());
      });
     */
  getToolMode(): Tools.Tool;
  /**
     * Return the current zoom level
     * @method WebViewerInstance#getZoomLevel
     * @return {number} Zoom level (0 ~ 1)
     * @example
    WebViewer(...)
      .then(function(instance) {
        var docViewer = instance.docViewer;
    
        // you must have a document loaded when calling this api
        docViewer.on('documentLoaded', function() {
          console.log(instance.getZoomLevel());
        });
      });
     */
  getZoomLevel(): number;
  /**
   * An instance of Hotkeys that can be used to enable, disable or register custom hotkeys in the viewer
   * @name WebViewerInstance#hotkeys
   * @see WebViewerInstance.Hotkeys
   * @type {Class<WebViewerInstance.Hotkeys>}
   */
  hotkeys: typeof WebViewerInstance.Hotkeys;
  /**
     * Imports user bookmarks
     * @method WebViewerInstance#importBookmarks
     * @param {object} bookmarks A dictionary with page indices as keys and the bookmark text as the values. ex: {"0":"Bookmark 1","2":"Bookmark 2"}. Behaviour is undefined otherwise.
     * @example
    WebViewer(...)
      .then(function(instance) {
        // load the user bookmarks data for id 'doc123'
        fetch('/server/bookmarksHandler.js?documentId=doc123', {
          method: 'GET'
        }).then(function(response) {
          if (response.status === 200) {
            response.text().then(function(bookmarksString) {
              // {"0":"Bookmark 1","2":"Bookmark 2"}
              const bookmarks = JSON.parse(bookmarksString);
              instance.importBookmarks(bookmarks);
            });
          }
        });
      });
     */
  importBookmarks(bookmarks: any): void;
  /**
     * Returns whether the element is disabled.
     * @method WebViewerInstance#isElementDisabled
     * @param {string} dataElement data-element attribute value for a DOM element. To find data-element of a DOM element, refer to <a href='https://www.pdftron.com/documentation/web/guides/hiding-elements/#finding-dataelement-attribute-values' target='_blank'>Finding data-element attribute values</a>.
     * @returns {boolean} Whether the element is disabled.
     * @example
    WebViewer(...)
      .then(function(instance) {
        console.log(instance.isElementDisabled('leftPanel'));
      });
     */
  isElementDisabled(dataElement: string): boolean;
  /**
     * Returns whether the element is open.
     * @method WebViewerInstance#isElementOpen
     * @param {string} dataElement data-element attribute value for a DOM element. To find data-element of a DOM element, refer to <a href='https://www.pdftron.com/documentation/web/guides/hiding-elements/#finding-dataelement-attribute-values' target='_blank'>Finding data-element attribute values</a>.
     * @returns {boolean} Whether the element is open.
     * @example
    WebViewer(...)
      .then(function(instance) {
        console.log(instance.isElementOpen('leftPanel'));
      });
     */
  isElementOpen(dataElement: string): boolean;
  /**
     * Returns whether the tool is disabled.
     * @method WebViewerInstance#isToolDisabled
     * @param {string} toolName Name of the tool, either from <a href='https://www.pdftron.com/documentation/web/guides/annotations-and-tools/#list-of-tool-names' target='_blank'>tool names list</a> or the name you registered your custom tool with.
     * @returns {boolean} Whether the tool is disabled.
     * @example
    WebViewer(...)
      .then(function(instance) {
        console.log(instance.isToolDisabled());
      });
     */
  isToolDisabled(toolName: string): boolean;
  /**
     * Load a document inside WebViewer UI.
     * @method WebViewerInstance#loadDocument
     * @param {(string|File|Blob)} documentPath Path to the document OR <a href='https://developer.mozilla.org/en-US/docs/Web/API/File' target='_blank'>File object</a> if opening local file.
     * @param {object} [options] Additional options
     * @param {string} [options.extension] The extension of the file. If file is a blob/file object or a URL without an extension then this is necessary so that WebViewer knows what type of file to load.
     * @param {string} [options.filename] Filename of the document, which is used when downloading the PDF.
     * @param {object} [options.customHeaders] An object of custom HTTP headers to use when retrieving the document from the specified url.
     * @param {string} [options.documentId] Unique id of the document.
     * @param {boolean} [options.withCredentials] Whether or not cross-site requests should be made using credentials.
     * @param {string} [options.cacheKey] A key that will be used for caching the document on WebViewer Server.
     * @param {string} [options.password] A string that will be used to as the password to load a password protected document.
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.loadDocument('https://www.pdftron.com/downloads/pl/test.pdf', {
          documentId: '1',
          filename: 'sample-1.pdf'
        });
      });
     */
  loadDocument(
    documentPath: string | File | Blob,
    options?: {
      extension?: string;
      filename?: string;
      customHeaders?: any;
      documentId?: string;
      withCredentials?: boolean;
      cacheKey?: string;
      password?: string;
    },
  ): void;
  /**
     * Sets visibility states of the elements to be visible. Note that openElements works only for panel/overlay/popup/modal elements.
     * @method WebViewerInstance#openElements
     * @param {Array.<string>} dataElements Array of data-element attribute values for DOM elements. To find data-element of a DOM element, refer to <a href='https://www.pdftron.com/documentation/web/guides/hiding-elements/#finding-dataelement-attribute-values' target='_blank'>Finding data-element attribute values</a>.
     * @example
    WebViewer(...)
      .then(function(instance) {
        // opens (shows) text popup and annotation popup in the UI
        instance.openElements([ 'menuOverlay', 'leftPanel' ]);
      });
     */
  openElements(dataElements: string[]): void;
  /**
     * Print the current document.
     * @method WebViewerInstance#print
     * @example
    WebViewer(...)
      .then(function(instance) {
        var docViewer = instance.docViewer;
    
        // you must have a document loaded when calling this api
        docViewer.on('documentLoaded', function() {
          instance.print();
        });
      });
     */
  print(): void;
  /**
     * Registers tool in the document viewer tool mode map, and adds a button object to be used in the header. See <a href='https://www.pdftron.com/documentation/web/guides/customizing-tools' target='_blank'>Customizing tools</a> to learn how to make a tool.
     * @method WebViewerInstance#registerTool
     * @param {object} properties Tool properties.
     * @param {string} properties.toolName Name of the tool.
     * @param {Tools.Tool} properties.toolObject Instance of the tool.
     * @param {string} properties.buttonImage Path to an image or base64 data for the tool button.
     * @param {string} [properties.buttonName] Name of the tool button that will be used in data-element.
     * @param {string} [properties.buttonGroup] Group of the tool button belongs to.
     * @param {string} [properties.tooltip] Tooltip of the tool button.
     * @param {function} [annotationConstructor] The constructor function for the annotation that will be created by the registered tool.
     * @example
    WebViewer(...)
      .then(function(instance) {
        // assume myCustomTool and myCustomAnnotation are already defined
        var myTool = {
          toolName: 'MyTool',
          toolObject: myCustomTool,
          buttonImage: 'path/to/image',
          buttonName: 'myToolButton',
          buttonGroup: 'miscTools',
          tooltip: 'MyTooltip'
        };
    
        instance.registerTool(myTool, myCustomAnnotation);
      });
     */
  registerTool(
    properties: {
      toolName: string;
      toolObject: Tools.Tool;
      buttonImage: string;
      buttonName?: string;
      buttonGroup?: string;
      tooltip?: string;
    },
    annotationConstructor?: (...params: any[]) => any,
  ): void;
  /**
     * Removes the search listener function.
     * @method WebViewerInstance#removeSearchListener
     * @param {WebViewerInstance.searchListener} listener Search listener function that was added.
     * @example
    WebViewer(...)
      .then(function(instance) {
        function searchListener(searchValue, options, results) {
          console.log(searchValue, options, results);
        };
    
        instance.addSearchListener(searchListener);
        instance.removeSearchListener(searchListener);
      });
     */
  removeSearchListener(listener: WebViewerInstance.searchListener): void;
  /**
     * Searches the current page for the texts matching searchValue.
     * @method WebViewerInstance#searchText
     * @param {string} searchValue The text value to look for.
     * @param {object} [options] Search options.
     * @param {boolean} [options.caseSensitive=false] Search with matching cases.
     * @param {boolean} [options.wholeWord=false] Search whole words only.
     * @param {boolean} [options.wildcard=false] Search a string with a wildcard *. For example, *viewer.
     * @param {boolean} [options.regex=false] Search for a regex string. For example, www(.*)com.
     * @param {boolean} [options.searchUp=false] Search up the document (backwards).
     * @param {boolean} [options.ambientString=false] Get the ambient string in the result.
     * @example
    WebViewer(...)
      .then(function(instance) {
        var docViewer = instance.docViewer;
    
        // you must have a document loaded when calling this api
        docViewer.on('documentLoaded', function() {
          instance.searchText('test', {
            caseSensitive: true,
            wholeWord: true
          });
        });
      });
     */
  searchText(
    searchValue: string,
    options?: {
      caseSensitive?: boolean;
      wholeWord?: boolean;
      wildcard?: boolean;
      regex?: boolean;
      searchUp?: boolean;
      ambientString?: boolean;
    },
  ): void;
  /**
     * Searches the full document for the texts matching searchValue.
     * @method WebViewerInstance#searchTextFull
     * @param {string} searchValue The text value to look for.
     * @param {object} [options] Search options.
     * @param {boolean} [options.caseSensitive=false] Search with matching cases.
     * @param {boolean} [options.wholeWord=false] Search whole words only.
     * @param {boolean} [options.wildcard=false] Search a string with a wildcard *. For example, *viewer.
     * @param {boolean} [options.regex=false] Search for a regex string. For example, www(.*)com.
     * @example
    WebViewer(...)
      .then(function(instance) {
        var docViewer = instance.docViewer;
    
        // you must have a document loaded when calling this api
        docViewer.on('documentLoaded', function() {
          instance.searchTextFull('test', {
            wholeWord: true
          });
        });
      });
     */
  searchTextFull(
    searchValue: string,
    options?: {
      caseSensitive?: boolean;
      wholeWord?: boolean;
      wildcard?: boolean;
      regex?: boolean;
    },
  ): void;
  /**
     * Select thumbnails in the thumbnail panel. This requires the "ThumbnailMultiselect" feature to be enabled
     * @method WebViewerInstance#selectThumbnailPages
     * @param {Array<number>} pageNumbers array of page numbers to select
     * @example // 6.1 and after
    WebViewer(...)
      .then(function(instance) {
        instance.enableFeatures(['ThumbnailMultiselect']);
    
        const pageNumbersToSelect = [1, 2, 3];
        instance.selectThumbnailPages(pageNumbersToSelect);
      });
     */
  selectThumbnailPages(pageNumbers: number[]): void;
  /**
     * Sets a header group to be rendered in the Header element. This API comes useful when replacing the entire header items in small screens.
     * @method WebViewerInstance#setActiveHeaderGroup
     * @param {string} headerGroup Name of the header group to be rendered. Default WebViewer UI has two header groups: default and tools.
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.setActiveHeaderGroup('tools'); // switch to tools header
      });
     */
  setActiveHeaderGroup(headerGroup: string): void;
  /**
     * Sets a panel to be active in the leftPanel element. Note that this API does not include opening the leftPanel.
     * @method WebViewerInstance#setActiveLeftPanel
     * @param {string} dataElement Name of the panel to be active in leftPanel. Default WebViewer UI has three panel options: thumbnailsPanel, outlinesPanel and notesPanel.
     * @example
    WebViewer(...)
      .then(function(instance) {
        // open left panel
        instance.openElements([ 'leftPanel' ]);
        // view outlines panel
        instance.setActiveLeftPanel('outlinesPanel');
     */
  setActiveLeftPanel(dataElement: string): void;
  /**
     * Adds a custom overlay to annotations if that annotation currently support it. Currently only the Ellipsis annotation supports it.
     * @method WebViewerInstance#setCustomMeasurementOverlay
     * @param {array} customOverlayInfo an array of customOverlay configurations. The configuration object has five properties: title, label, validate, value, and onChange
     * @example
    WebViewer(...)
      .then(function(instance) {
          instance.setCustomMeasurementOverlayInfo([
          {
            title: "Radius Measurement", //Title for overlay
            label: "Radius", // Label to be shown for the value
            // Validate is a function to validate the annotation is valid for the current custom overlay
            validate: annotation => annotation instanceof instance.Annotations.EllipseAnnotation,
            // The value to be shown in the custom overlay
            value: annotation => annotation.Width / 2,
            // onChange will be called whenever the value in the overlay changes from user input
            onChange: (e, annotation) => {
              // Do something with the annot like resize/redraw
              instance.annotManager.redrawAnnotation(annotation);
            }
          }
        ])
      });
     */
  setCustomMeasurementOverlay(customOverlayInfo: any[]): void;
  /**
     * Filter the annotations shown in the notes panel
     * @method WebViewerInstance#setCustomNoteFilter
     * @param {WebViewerInstance.filterAnnotation} filterAnnotation Function that takes an annotation and returns if the annotation(note) should be shown in the notes panel.
     * @example
    WebViewer(...)
      .then(function(instance) {
        // only show annotations that are created by John
        instance.setCustomNoteFilter(function(annotation) {
          return annotation.Author === 'John';
        });
      });
     */
  setCustomNoteFilter(filterAnnotation: WebViewerInstance.filterAnnotation): void;
  /**
     * Adds a custom panel in left panel
     * @method WebViewerInstance#setCustomPanel
     * @param {object} options
     * @param {object} options.tab Tab options.
     * @param {string} options.tab.dataElement data-element for tab.
     * @param {string} options.tab.title Tooltip for tab.
     * @param {string} options.tab.img Url for an image.
     * @param {object} options.panel Panel options.
     * @param {string} options.panel.dataElement data-element for panel.
     * @param {WebViewerInstance.renderCustomPanel} options.panel.render Function that returns panel element.
     * @example
    WebViewer(...)
      .then(function(instance) {
        var myCustomPanel = {
          tab:{
            dataElement: 'customPanelTab',
            title: 'customPanelTab',
            img: 'https://www.pdftron.com/favicon-32x32.png',
          },
          panel: {
            dataElement: 'customPanel',
            render: function() {
              var div = document.createElement('div');
              div.innerHTML = 'Hello World';
              return div;
            }
          }
        };
    
        instance.setCustomPanel(myCustomPanel);
      });
     */
  setCustomPanel(options: {
    tab: {
      dataElement: string;
      title: string;
      img: string;
    };
    panel: {
      dataElement: string;
      render: WebViewerInstance.renderCustomPanel;
    };
  }): void;
  /**
     * Sets the fit mode of the viewer.
     * @method WebViewerInstance#setFitMode
     * @param {string} fitMode Fit mode of WebViewer.
     * @see WebViewerInstance#FitMode
     * @example
    WebViewer(...)
      .then(function(instance) {
        var docViewer = instance.docViewer;
        var FitMode = instance.FitMode;
    
        // you must have a document loaded when calling this api
        docViewer.on('documentLoaded', function() {
          instance.setFitMode(FitMode.FitWidth);
        });
      });
     */
  setFitMode(fitMode: string): void;
  /**
     * Customize header. Refer to <a href='https://www.pdftron.com/documentation/web/guides/customizing-header' target='_blank'>Customizing header</a> for details.
     * @method WebViewerInstance#setHeaderItems
     * @param {WebViewerInstance.headerCallback} headerCallback Callback function to perform different operations on the header.
     * @example
    // Adding save annotations button
    WebViewer(...)
      .then(function(instance) {
        instance.setHeaderItems(function(header) {
          var myCustomButton = {
            type: 'actionButton',
            img: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>',
            onClick: function() {
              instance.saveAnnotations();
            }
          }
    
          header.push(myCustomButton);
        });
      });
     * @example
    // Removing existing buttons
    WebViewer(...)
      .then(function(instance) {
        instance.setHeaderItems(function(header) {
          var items = header.getItems().slice(9, -3);
          header.update(items);
        });
      });
     * @example
    // Appending logo and shifting existing buttons to the right
    WebViewer(...)
      .then(function(instance) {
        instance.setHeaderItems(function(header) {
          header.delete(9);
          header.unshift({
            type: 'customElement',
            render: function() {
              var logo = document.createElement('img');
              logo.src = 'https://www.pdftron.com/downloads/logo.svg';
              logo.style.width = '200px';
              logo.style.marginLeft = '10px';
              logo.style.cursor = 'pointer';
              logo.onclick = function() {
                window.open('https://www.pdftron.com', '_blank');
              }
              return logo;
            }
          }, {
            type: 'spacer'
          });
        });
      });
     */
  setHeaderItems(headerCallback: WebViewerInstance.headerCallback): void;
  /**
     * Sets the color palette that will be used as a tool button's icon color.
     * @method WebViewerInstance#setIconColor
     * @param {string} toolName Name of the tool, either from <a href='https://www.pdftron.com/documentation/web/guides/annotations-and-tools/#list-of-tool-names' target='_blank'>tool names list</a> or the name you registered your custom tool with.
     * @param {string} colorPalette The palette which will be used as a tool button's icon color. One of 'text', 'border' and 'fill'.
     * @example
    WebViewer(...)
      .then(function(instance) {
        // sets the color in fill palette to be used as freetext tool button's icon color
        // by default freetext tool button will use the color in text palette as its icon color
        instance.setIconColor('AnnotationCreateFreeText', 'fill')
      });
     */
  setIconColor(toolName: string, colorPalette: string): void;
  /**
     * Set the language of WebViewer UI.
     * @method WebViewerInstance#setLanguage
     * @param {string} language The language WebViewer UI will use. By default, following languages are supported: en, zh_cn, fr.
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.setLanguage('fr'); // set the language to French
      });
     */
  setLanguage(language: string): void;
  /**
     * Sets the layout mode of the viewer.
     * @method WebViewerInstance#setLayoutMode
     * @param {string} layoutMode Layout mode of WebViewerInstance.
     * @see WebViewerInstance#LayoutMode
     * @example
    WebViewer(...)
      .then(function(instance) {
        var docViewer = instance.docViewer;
        var LayoutMode = instance.LayoutMode;
    
        // you must have a document loaded when calling this api
        docViewer.on('documentLoaded', function() {
          instance.setLayoutMode(LayoutMode.FacingContinuous);
        });
      });
     */
  setLayoutMode(layoutMode: string): void;
  /**
     * Set the number of signatures that can be stored in the WebViewer (default is 2)
     * @method WebViewerInstance#setMaxSignaturesCount
     * @param {number} [maxSignaturesCount=2] Number of signature webViewer can store
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.setMaxSignaturesCount(5); // allow up to 5 stored signatures
      });
     */
  setMaxSignaturesCount(maxSignaturesCount?: number): void;
  /**
     * Sets the maximum zoom level allowed by the UI. Default is 9999%.
     * @method WebViewerInstance#setMaxZoomLevel
     * @param {(string|number)} zoomLevel Zoom level in either number or percentage.
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.setMaxZoomLevel('150%'); // or setMaxZoomLevel(1.5)
      });
     */
  setMaxZoomLevel(zoomLevel: string | number): void;
  /**
     * Sets the units that will be displayed in the measurement tools' styles popup
     * Valid units are: 'mm', 'cm', 'm', 'km', 'mi', 'yd', 'ft', 'in', 'pt'
     * @method WebViewerInstance#setMeasurementUnits
     * @param {Object} units an object which contains the from units and to units
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.setMeasurementUnits({
          from: ['in', 'cm', 'm'],
          to: ['cm', 'm', 'km']
        });
      });
     */
  setMeasurementUnits(units: any): void;
  /**
     * Sets the minimum zoom level allowed by the UI. Default is 5%.
     * @method WebViewerInstance#setMinZoomLevel
     * @param {(string|number)} zoomLevel Zoom level in either number or percentage.
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.setMinZoomLevel('10%'); // or setMinZoomLevel(0.1)
      });
     */
  setMinZoomLevel(zoomLevel: string | number): void;
  /**
     * Sets the format for displaying the date when a note is create/modified. A list of formats can be found {@link https://github.com/iamkun/dayjs/blob/master/docs/en/API-reference.md#format-formatstringwithtokens-string dayjs API}.
     * @method WebViewerInstance#setNoteDateFormat
     * @param {string} format The format of date to display
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.setNoteDataFormat('DD.MM.YYYY HH:MM');
      });
     */
  setNoteDateFormat(format: string): void;
  /**
     * Accepts a function that will be called every time a note in the left panel is rendered.
     * This function can be used to add, edit or hide the contents of the note.
     * <br><br>
     * <span style='font-size: 18px'><b>Please carefully read the documentation and the notes below before using this API</b></span><br><br>
     *
     * <b>This API is experimental and should be used sparingly.</b> If you find you are heavily relying on this function,
     *  it is recommended that you <a href='https://www.pdftron.com/documentation/web/guides/advanced-customization/'>fork the UI repo</a> and make the changes directly in the source code (Note.js).
     * <br><br>
     *
     *
     * The structure of the HTML that is passed into this function may change may change without notice in any release. <b>Please make sure
     * to test this function thoroughly when upgrading WebViewer versions.</b>
     * <br><br>
     *
     *
     *  There may be unexpected behaviour when using this API. The HTML that is provided is controlled by React, and sometimes React will override any changes you make.
     *  If you find any unexpected behaviour when using this API, then this API probably won't work for your use case and you will have to make the changes directly in the source code.
     * <br><br>
     *
     *  <b>Do not use document.createElement to create DOM elements</b>. Instead, use the provided `createElement` utility function provided as the third parameter.
     *
     *  <b>Do not use HTMLElement.removeChild or any other APIs that remove elements from the DOM.</b> Doing so will cause React to lose reference to this node, and will crash.
     *  If you need to hide an HTML element, set the style to `display: none` instead.
     * <br><br>
     * @method WebViewerInstance#dangerouslySetNoteTransformFunction
     * @param {WebViewerInstance.NoteTransformFunction} noteTransformFunction The function that will be used to transform notes in the left panel
     * @example
    Webviewer(...)
      .then(instance => {
        instance.dangerouslySetNoteTransformFunction((wrapper, state, createElement) => {
          // Change the title of every note
          wrapper.querySelector('.title>span').innerHTML = 'My custom note title';
    
          // Add a button that alerts the user when clicked
          const button = createElement('button');
          button.onmousedown = (e) => {
            if(state.isSelected) {
              alert('Hello world!');
            } else {
              alert('Goodbye world!');
            }
          };
          button.innerHTML = 'Alert me'
          wrapper.appendChild(button);
    
          // Add a button that makes the annotation blue
          const button = createElement('button');
          button.onmousedown = (e) => {
            state.annotation.StrokeColor = new instance.Annotations.Color(0, 0, 255);
            instance.annotManager.redrawAnnotation(state.annotation)
          };
          button.innerHTML = 'Make me blue'
          wrapper.appendChild(button);
        })
      });
     */
  dangerouslySetNoteTransformFunction(noteTransformFunction: WebViewerInstance.NoteTransformFunction): void;
  /**
     * Sets page labels that will be displayed in UI. You may want to use this API if the document's page labels start with characters/numbers other than 1.
     * @method WebViewerInstance#setPageLabels
     * @param {Array.<string>} pageLabels Page labels that will be displayed in UI.
     * @example
    WebViewer(...)
      .then(function(instance) {
        var docViewer = instance.docViewer;
    
        // you must have a document loaded when calling this api
        docViewer.on('documentLoaded', function() {
          instance.setPageLabels(['i', 'ii', 'iii', '4', '5']); // assume a document has 5 pages
        });
      });
     */
  setPageLabels(pageLabels: string[]): void;
  /**
     * Sets the print quality. Higher values are higher quality but takes longer to complete and use more memory. The viewer's default quality is 1.
     * @method WebViewerInstance#setPrintQuality
     * @param {number} quality The quality of the document to print. Must be a positive number.
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.setPrintQuality(2);
      });
     */
  setPrintQuality(quality: number): void;
  /**
     * Set the fonts that are used when typing a signature in the signature dialog.
     * @method WebViewerInstance#setSignatureFonts
     * @param {Array.<string>|WebViewerInstance.setSignatureFontsCallback} fonts An array of font families.
     * @example // 6.1
    WebViewer(...)
      .then(function(instance) {
        instance.setSignatureFonts(['GreatVibes-Regular']);
        instance.setSignatureFonts(currentFonts => [
          ...currentFonts,
          'sans-serif',
        ]);
      });
     */
  setSignatureFonts(fonts: string[] | WebViewerInstance.setSignatureFontsCallback): void;
  /**
     * Sets a sorting algorithm in NotesPanel.
     * @method WebViewerInstance#setSortStrategy
     * @param {string} sortStrategy Name of the algorithm. By default, there are two algorithm options: position and time.
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.setSortStrategy('time'); // sort notes by time
      });
     */
  setSortStrategy(sortStrategy: string): void;
  /**
     * Sets the swipe orientation between pages of WebViewer UI on mobile devices. Default is horizontal.
     * @method WebViewerInstance#setSwipeOrientation
     * @param {string} swipeOrientation The swipe orientation to navigate between pages. Available orientations are: horizontal, vertical and both.
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.setSwipeOrientation('vertical'); // set the swipe orientation to vertical.
      });
     */
  setSwipeOrientation(swipeOrientation: string): void;
  /**
     * Sets the theme of Webviewer UI. Please note that this does not work in IE11.
     * @method WebViewerInstance#setTheme
     * @param {(string|object)} theme Either theme object or predefined string. Predefined strings are 'default' and 'dark'.
     * @param {string} [theme.primary=#FFFFFF] Background color for the header, modals, overlays, etc.
     * @param {string} [theme.secondary=#F5F5F5] ackground color for panels and the document container.
     * @param {string} [theme.border=#CDCDCD] Border color for different components.
     * @param {string} [theme.buttonHover=#F6F6F6] Background color for hovering on a button.
     * @param {string} [theme.buttonActive=#F0F0F0] Background color for an active button.
     * @param {string} [theme.text=#333333] Text color.
     * @param {string} [theme.icon=#757575] Icon color.
     * @param {string} [theme.iconActive=#757575] Icon color when button is active.
     * @example
    // Using an object
    WebViewer(...)
      .then(function(instance) {
        instance.setTheme({
          primary: '#2C2B3A',
          secondary: '#4D4C5F',
          border: '#555555',
          buttonHover: '#686880',
          buttonActive: '#686880',
          text: '#FFFFFF',
          icon: '#FFFFFF',
          iconActive: '#FFFFFF'
        });
      });
     * @example
    // Using predefined string
    WebViewer(...)
      .then(function(instance) {
        instance.setTheme('dark');
      });
     */
  setTheme(theme: {
    primary?: string;
    secondary?: string;
    border?: string;
    buttonHover?: string;
    buttonActive?: string;
    text?: string;
    icon?: string;
    iconActive?: string;
  }): void;
  /**
     * Sets tool mode.
     * @method WebViewerInstance#setToolMode
     * @param {string|Tools.ToolNames} toolName Name of the tool, either from <a href='https://www.pdftron.com/documentation/web/guides/annotations-and-tools/#list-of-tool-names' target='_blank'>tool names list</a> or the name you registered your custom tool with.
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.setToolMode('AnnotationEdit');
      });
     */
  setToolMode(toolName: string | Tools.ToolNames): void;
  /**
     * Sets zoom level.
     * @method WebViewerInstance#setZoomLevel
     * @param {(string|number)} zoomLevel Zoom level in either number or percentage.
     * @example
    WebViewer(...)
      .then(function(instance) {
        var docViewer = instance.docViewer;
    
        // you must have a document loaded when calling this api
        docViewer.on('documentLoaded', function() {
          instance.setZoomLevel('150%'); // or setZoomLevel(1.5)
        });
      });
     */
  setZoomLevel(zoomLevel: string | number): void;
  /**
     * Displays the custom error message
     * @method WebViewerInstance#showErrorMessage
     * @param {string} message An error message
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.showErrorMessage('My error message');
      });
     */
  showErrorMessage(message: string): void;
  /**
     * An instance of Popup that can be used to edit items in the text popup component
     * @name WebViewerInstance#textPopup
     * @implements {WebViewerInstance.Popup}
     * @type {WebViewerInstance.Popup}
     * @example
    WebViewer(...)
      .then(function (instance) {
        instance.textPopup.someAPI();
      });
     */
  textPopup: WebViewerInstance.Popup;
  /**
     * Toggles a visibility state of the element to be visible/hidden. Note that toggleElement works only for panel/overlay/popup/modal elements.
     * @method WebViewerInstance#toggleElement
     * @param {string} dataElement data-element attribute value for a DOM element. To find data-element of a DOM element, refer to <a href='https://www.pdftron.com/documentation/web/guides/hiding-elements/#finding-dataelement-attribute-values' target='_blank'>Finding data-element attribute values</a>.
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.toggleElement('leftPanel'); // open LeftPanel if it is closed, or vice versa
      });
     */
  toggleElement(dataElement: string): void;
  /**
     * Toggles full scree mode of the browser.
     * @method WebViewerInstance#toggleFullScreen
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.toggleFullScreen();
      });
     */
  toggleFullScreen(): void;
  /**
     * Unregisters tool in the document viewer tool mode map, and removes the button object.
     * @method WebViewerInstance#unregisterTool
     * @param {string} toolName Name of the tool, either from <a href='https://www.pdftron.com/documentation/web/guides/annotations-and-tools/#list-of-tool-names' target='_blank'>tool names list</a> or the name you registered your custom tool with.
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.unregisterTool('MyTool');
      });
     */
  unregisterTool(toolName: string): void;
  /**
     * Unselect selected thumbnails
     * @method WebViewerInstance#unselelctThumbnailPages
     * @param {Array<number>} pageNumbers array of page numbers to unselect
     * @example // 6.1 and after
    WebViewer(...)
      .then(function(instance) {
        const pageNumbersToUnselect = [1, 2];
        instance.unselelctThumbnailPages(pageNumbersToUnselect);
      });
     */
  unselelctThumbnailPages(pageNumbers: number[]): void;
  /**
     * Update an element in the viewer.
     * @method WebViewerInstance#updateElement
     * @param {string} dataElement the data element of the element that will be updated. Valid values are 'colorPalette', and HTML elements that have 'Button' in the class name.
     * @param {*} props An object or an array that is used to override an existing item's properties.
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.updateElement('thumbnailsPanelButton', {
          img: 'path/to/image',
          title: 'new_tooltip',
        })
    
        instance.updateElement('colorPalette', ['#FFFFFF', 'transparency', '#000000'])
      });
     */
  updateElement(dataElement: string, props: any): void;
  /**
     * Update existing tool's properties.
     * @method WebViewerInstance#updateTool
     * @param {string} toolName Name of the tool, either from <a href='https://www.pdftron.com/documentation/web/guides/annotations-and-tools/#list-of-tool-names' target='_blank'>tool names list</a> or the name you registered your custom tool with.
     * @param {object} [properties] Tool properties
     * @param {string} [properties.buttonImage] Path to an image or base64 data for the tool button
     * @param {string} [properties.buttonName] Name of the tool button that will be used in data-element
     * @param {string} [properties.buttonGroup] Group of the tool button belongs to
     * @param {string} [properties.tooltip] Tooltip of the tool button
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.updateTool('AnnotationCreateSticky', {
          buttonImage: 'https://www.pdftron.com/favicon-32x32.png'
        });
      });
     */
  updateTool(
    toolName: string,
    properties?: {
      buttonImage?: string;
      buttonName?: string;
      buttonGroup?: string;
      tooltip?: string;
    },
  ): void;
  /**
     * Use/not use embedded printing. Only applicable to Chrome.
     * The printing process will be faster and the quality might be higher when using Chrome's native printing.
     * You may not want to use embedded printing if there are custom annotations in your document.
     * @method WebViewerInstance#useEmbeddedPrint
     * @param {boolean} [use=true] Whether or not to use embedded printing
     * @example
    WebViewer(...)
      .then(function(instance) {
        instance.useEmbeddedPrint(false); // disable embedded printing
      });
     */
  useEmbeddedPrint(use?: boolean): void;
  /**
     * Contains string enums for all features for WebViewer UI
     * @name WebViewerInstance#Feature
     * @property {string} Measurement Measurement tools that can create annotations to measure distance, perimeter and area.
     * @property {string} Annotations Render annotations in the document and be able to edit them.
     * @property {string} Download A download button to download the current document.
     * @property {string} FilePicker Ctrl/Cmd + O hotkey and a open file button that can be clicked to load local files.
     * @property {string} LocalStorage Store and retrieve tool styles from window.localStorage.
     * @property {string} NotesPanel A panel that displays information of listable annotations.
     * @property {string} Print Ctrl/Cmd + P hotkey and a print button that can be clicked to print the current document.
     * @property {string} Redaction Redaction tools that can redact text or areas. Need fullAPI to be on to use this feature.
     * @property {string} TextSelection Ability to select text in a document.
     * @property {string} TouchScrollLock Lock document scrolling in one direction in mobile devices.
     * @property {string} Copy Ability to copy text or annotations use Ctrl/Cmd + C hotkeys or the copy button.
     * @property {string} ThumbnailMerging Ability to drag and drop a file into the thumbnail panel to merge
     * @property {string} ThumbnailReordering Ability to reorder pages using the thumbnail panel
     * @property {string} PageNavigation Ability to navigate through pages using mouse wheel, arrow up/down keys and the swipe gesture.
     * @example
    WebViewer(...)
      .then(function(instance) {
        var Feature = instance.Feature;
        instance.enableFeatures([Feature.Measurement]);
        instance.disableFeatures([Feature.Copy]);
      });
     */
  Feature: {
    Measurement: string;
    Annotations: string;
    Download: string;
    FilePicker: string;
    LocalStorage: string;
    NotesPanel: string;
    Print: string;
    Redaction: string;
    TextSelection: string;
    TouchScrollLock: string;
    Copy: string;
    ThumbnailMerging: string;
    ThumbnailReordering: string;
    PageNavigation: string;
  };
  /**
     * Contains all possible modes for fitting/zooming pages to the viewer. The behavior may vary depending on the LayoutMode.
     * @name WebViewerInstance#FitMode
     * @property {string} FitPage A fit mode where the zoom level is fixed to the width or height of the page, whichever is smaller.
     * @property {string} FitWidth A fit mode where the zoom level is fixed to the width of the page.
     * @property {string} Zoom A fit mode where the zoom level is not fixed.
     * @example
    WebViewer(...)
      .then(function(instance) {
        var FitMode = instance.FitMode;
        instance.setFitMode(FitMode.FitWidth);
      });
     */
  FitMode: {
    FitPage: string;
    FitWidth: string;
    Zoom: string;
  };
  /**
     * Contains string enums for all layouts for WebViewer. They are used to dictate how pages are placed within the viewer.
     * @name WebViewerInstance#LayoutMode
     * @property {string} Single Only the current page will be visible.
     * @property {string} Continuous All pages are visible in one column.
     * @property {string} Facing Up to two pages will be visible.
     * @property {string} FacingContinuous All pages visible in two columns.
     * @property {string} FacingCover All pages visible in two columns, with an even numbered page rendered first. (i.e. The first page of the document is rendered by itself on the right side of the viewer to simulate a book cover.)
     * @property {string} FacingCoverContinuous All pages visible, with an even numbered page rendered first. (i.e. The first page of the document is rendered by itself on the right side of the viewer to simulate a book cover.)
     * @example
    WebViewer(...)
      .then(function(instance) {
        var LayoutMode = instance.LayoutMode;
        instance.setLayoutMode(LayoutMode.Single);
      });
     */
  LayoutMode: {
    Single: string;
    Continuous: string;
    Facing: string;
    FacingContinuous: string;
    FacingCover: string;
    FacingCoverContinuous: string;
  };
  /**
   * Cleans up listeners and data from the WebViewer instance. Should be called when removing the WebViewer instance from the DOM.
   * @method WebViewerInstance#dispose
   */
  dispose(): void;
  /**
     * AnnotationManager instance
     * @name WebViewerInstance#annotManager
     * @memberof WebViewerInstance
     * @see CoreControls.AnnotationManager
     * @type {CoreControls.AnnotationManager}
     * @example
    WebViewer(...)
      .then(function(instance) {
        var annotManager = instance.annotManager;
        // annotManager.someAPI();
      });
     */
  annotManager: CoreControls.AnnotationManager;
  /**
     * DocumentViewer instance
     * @name WebViewerInstance#docViewer
     * @see CoreControls.DocumentViewer
     * @type {CoreControls.DocumentViewer}
     * @example
    WebViewer(...)
      .then(function(instance) {
        var docViewer = instance.docViewer;
        // docViewer.someAPI();
      });
     */
  docViewer: CoreControls.DocumentViewer;
  /**
     * WebViewer iframe window object
     * @name WebViewerInstance#iframeWindow
     * @type {Window}
     * @example
    WebViewer(...)
      .then(function(instance) {
        var iframeWindow = instance.iframeWindow;
        // iframeWindow.SomeNamespace
        // iframeWindow.document.querySelector('.some-element');
      });
     */
  iframeWindow: Window;
  /**
   * Actions namespace
   * @name WebViewerInstance#Actions
   * @see Actions
   * @type {Class<Actions>}
   */
  Actions: typeof Actions;
  /**
   * CoreControls namespace
   * @name WebViewerInstance#CoreControls
   * @see CoreControls
   * @type {Class<CoreControls>}
   */
  CoreControls: typeof CoreControls;
  /**
   * Annotations namespace
   * @name WebViewerInstance#Annotations
   * @see Annotations
   * @type {Class<Annotations>}
   */
  Annotations: typeof Annotations;
  /**
   * Tools namespace
   * @name WebViewerInstance#Tools
   * @see Tools
   * @type {Class<Tools>}
   */
  Tools: typeof Tools;
  /**
   * PDFNet namespace
   * @name WebViewerInstance#PDFNet
   * @see PDFNet
   * @type {Class<PDFNet>}
   */
  PDFNet: typeof PDFNet;
}

/**
 * @typedef {Object} WebViewerOptions
 * @property {string} path  Path to the WebViewer lib folder
 * @property {string} [annotationUser=Guest] Name of the user for annotations
 * @property {string} [config] URL path to a custom JavaScript for customizations
 * @property {string} [css] URL path to a custom CSS file for customizations
 * @property {Array<string>} [disabledElements] List of data-elements to be disabled in UI
 * @property {boolean} [accessibleMode=false] Enable accessibility features. E.g tab page selection and page text in the DOM
 * @property {boolean} [enableAnnotations=true] Enable annotations feature
 * @property {boolean} [enableAzureWorkaround=false] Enable workaround of the issue in Azure related to range requests
 * @property {boolean} [enableFilePicker=false] Enable file picker feature
 * @property {boolean} [enableMeasurement=false] Enable measurement tools
 * @property {boolean} [enableRedaction=false] Enable redaction tool
 * @property {string} [extension] Extension of the document to be loaded
 * @property {string} [filename] The name of the file that will be used when downloading the document. The extension in the filename will be used as the document type to be loaded (e.g. myfile.docx will treat the file as docx) if no extension option is passed.
 * @property {boolean} [forceClientSideInit=false] If set to true then when loading a document using WebViewer Server the document will always switch to client only rendering allowing page manipulation and the full API to be used.
 * @property {boolean} [fullAPI=false] Enable PDFNet.js library functions
 * @property {string} [initialDoc] URL path to a document to load on startup
 * @property {boolean} [isAdminUser=false] Set user permission to admin
 * @property {boolean} [isReadOnly=false] Set user permission to read-only
 * @property {string} [licenseKey] License key for viewing documents. If not set then WebViewer will be in demo mode.
 * @property {boolean} [mobileRedirect=true] Whether the mobile viewer should redirect to a new window or not
 * @property {string} [preloadWorker] Type of workers to be preloaded. Accepts `pdf`|`office`|`all`.
 * @property {string} [backendType] A string representing the "backend type" for rendering PDF documents. Pass "ems" to force the use of the ASM.js/WebAssembly worker and "pnacl" for the "PNaCl" worker.
 * @property {boolean} [useDownloader] A boolean indicating whether Downloader should be used on urls (PDF only). https://www.pdftron.com/documentation/web/guides/usedownloader-option/.
 * @property {string} [ui=default] Type of UI to be used
 * @property {object} [workerTransportPromise]
 * @property {function} [workerTransportPromise.pdf] Promise that resolves to a PDF worker
 * @property {function} [workerTransportPromise.office]  Promise that resolves to an office worker
 * @property {string} [pdftronServer] The URL path to the hosted WebViewer Server
 * @property {boolean} [disableLogs=false] Disables console logs coming from WebViewer, including the version and build numbers
 */
declare type WebViewerOptions = {
  path: string;
  annotationUser?: string;
  config?: string;
  css?: string;
  disabledElements?: string[];
  accessibleMode?: boolean;
  enableAnnotations?: boolean;
  enableAzureWorkaround?: boolean;
  enableFilePicker?: boolean;
  enableMeasurement?: boolean;
  enableRedaction?: boolean;
  extension?: string;
  filename?: string;
  forceClientSideInit?: boolean;
  fullAPI?: boolean;
  initialDoc?: string;
  isAdminUser?: boolean;
  isReadOnly?: boolean;
  licenseKey?: string;
  mobileRedirect?: boolean;
  preloadWorker?: string;
  backendType?: string;
  useDownloader?: boolean;
  ui?: string;
  workerTransportPromise?: {
    pdf?: (...params: any[]) => any;
    office?: (...params: any[]) => any;
  };
  pdftronServer?: string;
  disableLogs?: boolean;
};

/**
 * A function that creates an instance of WebViewer, and embeds it on the HTML page
 * @function
 * @global
 * @name WebViewer
 * @param {WebViewerOptions} options
 * @param {HTMLElement} viewerElement
 * @returns {Promise<WebViewerInstance>} A promise resolved with WebViewer instance.
 * @example
 * WebViewer({
      licenseKey: 'Insert commercial license key here after purchase'
    }, document.getElementById('viewer'))
      .then(function(instance) {
        var docViewer = instance.docViewer;
        var annotManager = instance.annotManager;
        // call methods from instance, docViewer and annotManager as needed

        // you can also access major namespaces from the instancs as follows:
        // var Tools = instance.Tools;
        // var Annotations = instance.Annotations;
      });
 */
declare function WebViewer(options: WebViewerOptions, viewerElement: HTMLElement): Promise<WebViewerInstance>;

/**
 * Gets an already existing instance of WebViewer. If only one instance of WebViewer exists on the page,
 * then 'element' is not required, and the function will return the instance of WebViewer.
 * If more than one instance of WebViewer exists, you must pass in the DOM element containing the
 * instance of WebViewer you want to retrieve. This function can be imported directly as a module as well.
 * @function
 * @name getInstance
 * @global
 * @param {HTMLElement} [element] The DOM element containing the instance of WebViewer you want to retrieve
 * @returns {WebViewerInstance} Returns an instance of WebViewer. Returns null if no instances are available.
 * @example
 * import { getInstance } from '@pdftron/webviewer'
 *
 * // After WebViewer has already been constructed
 * const instance = getInstance();
 *
 */
declare function getInstance(element?: HTMLElement): WebViewerInstance;

/**
 * Represents a Video. Constructor is private. Use {@link CoreControls.Document#getVideo} to retrieve the instance.
 * @see CoreControls.Document#getVideo
 * @class
 */
declare class Video {
  constructor();
  /**
   * Returns the underlying HTML5 video element
   * @function
   * @returns {object}
   */
  getElement(): any;
  /**
   * Returns a string representing the curretn seeked to time. Formatted as hh:mm:ss.
   * @function
   * @returns {string} A string representing the curretn seeked to time. Formatted as hh:mm:ss.
   */
  getFormattedCurrentTime(): string;
  /**
   * Returns a string representing the passed in seconds. Formatted as hh:mm:ss.
   * @function
   * @param {number} seconds
   * @returns {string} A string representing the passed in seconds. Formatted as hh:mm:ss.
   */
  getFormattedTime(seconds: number): string;
  /**
   * Renders the saved annotations on the annotation canvas at the passed in time
   * @param {number} newTime A number representing the milliseconds elapsed between 1 January 1970 00:00:00 UTC and the given date.
   */
  updateAnnotationsToTime(newTime: number): void;
  /**
   * Returns all annotations for all frames in the video.
   * @returns {Array} An array of all annotations.
   */
  getAllAnnotations(): any[];
  /**
   * Returns the conversion of a frame number to a time stamp (in milliseconds).
   * @function
   * @param {number} frame The frame number to convert.
   * @returns {number} The resulting time.
   */
  getTimeFromFrame(frame: number): number;
  /**
   * Returns the conversion of a time stamp to a frame number.
   * @function
   * @param {number} time A number representing the milliseconds elapsed between 1 January 1970 00:00:00 UTC and the given date.
   * @returns {number} The resulting frame number.
   */
  getFrameFromTime(time: number): number;
  /**
   * Returns the total number of frames in the video.
   * @function
   * @returns {number} The total number of frames in the video.
   */
  getTotalFrames(): number;
  /**
   * Returns true if the frame number passed in has at least one annotation associated with it. Returns false otherwise.
   * @function
   * @returns {boolean}
   */
  hasAnnotation(): boolean;
  /**
   * Returns the total number of frames in the video.
   * @function
   * @param {Array} frameNumbers An array of all the frame numbers to retrieve canvases for.
   * @returns {Promise<Array>} An array of the canvases for the frames passed in.
   */
  extractFrames(frameNumbers: any[]): Promise<any[]>;
}
